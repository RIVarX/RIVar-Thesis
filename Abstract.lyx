#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\options preprint
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-15
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\myName}[1]{\textcolor{blue}{\textsf{#1}}\index{#1}}
{\mathbf{myName}\{#1\}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\RIVar}{\myName{RIVar}}
{\mathbf{RIVar}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\RIVarX}{\myName{RIVarX}}
{\mathbf{RIVarX}}
\end_inset


\end_layout

\begin_layout Abstract
This thesis is focused on a concept named 
\begin_inset Formula $\RIVar$
\end_inset

.
 
\begin_inset Formula $\RIVar$
\end_inset

 stands for 
\emph on
Reactive Instance Variable
\emph default
, harmonizing a concept named 
\emph on
reactive variable
\emph default
 found in 
\emph on
Functional Reactive Programming
\emph default
 (FRP) with a concept named 
\emph on
instance variable
\emph default
 found in Object Oriented Programming (OOP).
 Focusing on 
\emph on
reactive instance variables
\emph default
 means emphasizes 
\emph on
de-centralization
\emph default
 in reactive variables.
 This achieved by introducing 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP), in contrast to a conventional method in FRP of constructing hierarchi
cal graphs.
 (i.e., acyclic dependency graph, variables are connected to the input elements,
 and subsequently variables depend on other variables) 
\end_layout

\begin_layout Abstract
\begin_inset Note Note
status collapsed

\begin_layout Abstract
————
\end_layout

\begin_layout Abstract
Similar to reactive variable, each 
\begin_inset Formula $\RIVar$
\end_inset

 can be associated with an expression composed of other 
\begin_inset Formula $\RIVar$
\end_inset

s, forming the 
\begin_inset Formula $\RIVar$
\end_inset

 to depend on the other 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In runtime, the 
\begin_inset Formula $\RIVar$
\end_inset

 is automatically recalculated depending on the dependencies.
 Beside deriving the concept from reactive variable, the concept is derived
 also from instance variable, enabling the specification and runtime of
 data dependencies, as objects' internal behavior.
\end_layout

\begin_layout Abstract
The thesis introuces 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP) that stands for changing from a conventional method of constructing
 hierarchical graphs, where variables are connected to the input elements,
 and subsequently variables depend on other variables, forming an acyclic
 dependency graph (DAG).
 
\end_layout

\begin_layout Abstract
—————
\end_layout

\begin_layout Abstract
The concept is motivated by an healthcare application, where fields calculations
 caused user experiance questions on the implementations.
 
\end_layout

\begin_layout Abstract
We introduce 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP), a new variant of FRP that supports that speical settings.
 The variables (
\begin_inset Formula $\RIVar$
\end_inset

s) are formed of observable streams, with the approach that the association
 between variable and an expression is in the form of subscirptions, i.e.,
 it is like that the variable subscribe to the stream of values of the expressio
n.
\end_layout

\begin_layout Abstract
This forms a tool that enable data dependencies even when the data dependencies
 are not hirarchial.
\end_layout

\begin_layout Abstract
This forms an architeture that contrasted with the traditional FRP, in that
 the data dependenicies are not hirarchial
\end_layout

\begin_layout Abstract
\begin_inset Formula $\RIVar$
\end_inset

s are implemented as observable streams that propagate values while preserving
 the separation refined by the objects.
 During propagation, the loops caused by recursions are terminated by identifyin
g and discarding older values.
 The order of the values is determined by timestamps attached to the values,
 which are derived from the input values.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Abstract
This thesis introduces 
\emph on
reactive instance variables 
\emph default
as the datatype 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Abstract
This thesis provides a new semantics for creating data dependencies without
 the need to be aware of transitive dependencies.
 This means that variables forming the data dependencies can be part of
 OOP interfaces.
 Consequently, we have achieved a framework that harmonizes the abstraction
 mechanisms of both OOP and FRP, which is also considered a decentralized
 constraints system, and also a state management solution for front-end
 applications.
\end_layout

\begin_layout Abstract
As 
\emph on
reactive variable
\emph default
 the variables are automaticaly changed according to input provided over
 time FRP and the
\emph on
 instance variable
\emph default
 from OOP
\end_layout

\begin_layout Abstract
The 
\emph on
Functional Reactive Programming (FRP)
\emph default
 paradigm specializes in maintaining derived variables' values.
 However, this task has difficulties in performing predictable behavior
 especially when applications grow with many code duplications and long
 chains of updates.
 While the FRP paradigm contributes to the predictability of variables'
 updates, the Object Oriented Programming (OOP) paradigm contributes to
 the predictability of code changes.
 In this thesis, we combine the two paradigms to promote predictability.
\end_layout

\begin_layout Abstract
We use the combination of 
\emph on
reactive variable
\emph default
 from FRP and the
\emph on
 instance variable
\emph default
 from OOP, calling it 
\begin_inset Formula $\RIVar$
\end_inset

, a shortcut to the full name 
\emph on
Reactive Instance Variable
\emph default
.
 We introduce an approach and method for a single 
\begin_inset Formula $\RIVar$
\end_inset

 assigned with formulas by several clients.
 The assignment semantics adopts the meaning from FRP, to relate the variable
 to be updated according to the specified formula.
 However, in contrast to the traditional FRP, there can be several assignments
 to the same variable.
 Under the hood, 
\begin_inset Formula $\RIVar$
\end_inset

s observe several formulas, and infer values when and according to the latest
 value coming from any of the sources.
 
\end_layout

\begin_layout Abstract
To evaluate the approach, we compare it against traditional approaches,
 in how they handle variables' updates, and what code-reuse options are
 available.
 In addition, we present an implementation attached with a case study.
 The implementation is provided as an extension library, named 
\begin_inset Formula $\RIVarX$
\end_inset

, to C# programming language.
 The case study presents how we separate one domain logic into sub-domains,
 saparating a central calculation procedure.
 In the case study, each object manages its formulas, even when the formulas
 consist of variables belonging to other objects.
\end_layout

\begin_layout Abstract
We expect this approach being implemented as a state management solution
 and ease the development of front end applications.
 In this process, it is expected that we will discover that the method as
 is is too limited to being used in real-life applications.
 Because the model currently provides only one method to the variable to
 infer values from its sources.
 However, with the current method, the model is handled as a decentralized
 solution for Multiway Dataflow Constraint Systems suited for user interfaces.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
