#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\options preprint
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-15
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Abstract

\emph on
RIVar
\emph default
 is a new concept that harmonizes two traditional concepts: 
\emph on
reactive variable
\emph default
 and 
\emph on
instance variable
\emph default
.
 
\emph on
Reactive variable
\emph default
 is a variable abstraction in which the assignment operator establishes
 dependencies, such that an assigned variable becomes dependent on the variables
 within the assigned expression, therefore updated in response to their
 updates.
 For example, given variables A, B, and C, the formula A := B + C means
 that whenever B or C are updated the operation + is executed on the values
 that B and C contain, and update A with the result.
 Instance variable 
\end_layout

\begin_layout Abstract
—
\end_layout

\begin_layout Abstract

\emph on
Reactive variable
\emph default
 is a variable abstraction in which the assignment operator establishes
 dependencies, such that an assigned variable becomes dependent on the variables
 within the assigned expression, therefore updated in response to their
 updates.
 For example, given variables A, B, and C, the formula A := B + C means
 that whenever B or C are updated the operation + is executed on the values
 that B and C contain, and update A with the result.
 This declarative style produces a 
\emph on
single source of truth
\emph default
, rather than repetition calls to update variables in many code locations.
\end_layout

\begin_layout Abstract
In this thesis, we present that there is still room for improving code reusabili
ty.
 For improving code reuse, we harmonize the reactive variable concept with
 the concept 
\emph on
instance variable
\emph default
 from Object Oriented Programming (OOP), resulting a new concept named 
\emph on
reactive instance variable
\emph default
, 
\emph on
RIVar
\emph default
 for short.
 For example, given an object X that contain A, with the given B and C,
 we declare X.A := B + C.
 
\end_layout

\begin_layout Abstract
————————
\end_layout

\begin_layout Abstract
Instance variables are variables associated with objects, typically accessed
 indirectly through the object's methods, often named 
\emph on
setters
\emph default
 and 
\emph on
getters
\emph default
, therefore indirectly exposed in objects' interface.
 Like
\end_layout

\begin_layout Abstract
The new concept are accessed through object's interface.
\end_layout

\begin_layout Abstract
Similary are the RIVars been accessed through object's interface.
 For example, given an object X that contain A, with the given B and C,
 the formula X.A := B + C establish a dependency such that A 
\end_layout

\begin_layout Standard
——-
\end_layout

\begin_layout Abstract
In this thesis, we show that there is still room for code reuse.
 We harmonize the reactive variable concept with the concept 
\emph on
instance variable
\emph default
 from Object Oriented Programming (OOP), resulting a new concept named 
\emph on
reactive instance variable
\emph default
, 
\emph on
RIVar
\emph default
 for short.
 Instance variables are variables associated with objects, typically accessed
 indirectly through the object's methods, often named 
\emph on
setters
\emph default
 and 
\emph on
getters
\emph default
.
 The syntax for the harmonized concept seems quite simple.
 Such like A := B + C, if A is associated to an object X, a formula like
 X.A := B + C would work.
\end_layout

\begin_layout Abstract
—–
\end_layout

\begin_layout Abstract
and we can express X.A:=B+C 
\end_layout

\begin_layout Abstract
given reactive variables A,B and C, where object X contains the A, it is
 correct to express X.A:=B+C, with the mean of continuous association.
\end_layout

\begin_layout Abstract
This thesis explores RIVar for addressing the challenge of code-reuse, providing
 a working implementation and advocating for further research to drive real-worl
d change within the industry.
\end_layout

\begin_layout Abstract
—-
\end_layout

\begin_layout Abstract
We name the new concept RIVar or Reactive Instance Variables.
 The new concept uses concepts from OOP to enable 
\end_layout

\begin_layout Abstract
Other than the traditionals, the assignment 
\end_layout

\begin_layout Abstract
assignment is establishes a continuous association, and also be called similar
 to an operation, without to determine type or internal details.
 For example, given RIVars B and C and also an object X that contains a
 RIVar A, performing X.A:=B+C are performed for various types of X, such
 that assignment is a method that establish the continuous association.
 
\end_layout

\begin_layout Abstract
Reactive variable points on a new approach where variables by a single assignmen
t establishes a continuous association.
 For example, given reactive variables A, B, and C, performing A := B +
 C means that whenever B and C are updated the operation + is executed on
 the values that B and C contain, and update A with the result.
 The advantage of this declarative style can be described as providing a
 code reuse mechanism or reducing code repetition.
 This style promotes a single source of truth, rather than the repetition
 of calling to update variables in many code locations.
\end_layout

\begin_layout Abstract
An older concept for code reuse is object-oriented programming (OOP).
 Here, the mechanisms of inheritance with polymorphism are provided so that
 developers can define logic once, even if it's used for various types.
 For example, given objects A, B, and C, in performing A := B + C, the operation
 + upon the B and C is without determining the type or details on how is
 it implemented.
\end_layout

\begin_layout Abstract
For improving code-reuse, we introduce an harmonized concept named reactive
 instance (or interface) variable (RIVar).
 In the new concept, the assignment is establishes a continuous association,
 and also be called similar to an operation, without to determine type or
 internal details.
 For example, given RIVars B and C and also an object X that contains a
 RIVar A, performing X.A:=B+C are performed for various types of X, such
 that assignment is a method that establish the continuous association.
 
\end_layout

\begin_layout Abstract
—
\end_layout

\begin_layout Abstract
Also the repeatindg on calling to update variables in various code locations
 have 
\end_layout

\begin_layout Abstract
Recently, a paradigm named Reactive Programming provides mechanisms that
 can be suited as another form for code reuse.
\end_layout

\begin_layout Abstract
Functional Reactive Programming can be reffered as another toold for cod-reuse.
 It provides an asbtraction mechanism, such that developers do not need
 to update variables.
 Code that call to caculate and 
\end_layout

\begin_layout Abstract
Functional Reactive Programming providing lifted operations that automaticaly
 perform updates when required, rather than calling to update the various
 code locations (in response to events).
\end_layout

\begin_layout Abstract
—
\end_layout

\begin_layout Abstract
This thesis focus on increasing code reuse.
 Code reuse is an obvious programming principal.
 It is contrasted with code duplications or code redandancy.
 If code is repeated, changes in code should be repeated, otherwize bugs
 are accured, that behavior is incosnsitent.
\end_layout

\begin_layout Abstract
that lead code changes to perform several times to keep on consistncy.
 can lead to bugs, of some locations were not changed.
\end_layout

\begin_layout Abstract
Code reuse is a fundamental principle in software development.
 Inheritance and composition are famous mechanism to perform code reuse.
\end_layout

\begin_layout Abstract
For example, OOP suggests inheritance and composition.
 Recently FRP contributes another code reuse mechanism, by providing lifted
 operations that automaticaly perform updates when required, rather than
 calling to update the various code locations (in response to events).
\end_layout

\begin_layout Abstract
Reducing code duplication is obvious programming principal.
 OOP is a famous paradigm that provides an abstraction mechanism to 
\end_layout

\begin_layout Abstract
—-
\end_layout

\begin_layout Abstract
Dependency graph is a programming model used in Reactive Programming to
 ease software development.
 Despite its benefits, still most applications are still developed using
 lower sbtractions.
 Here, we address the specific limitation named 
\emph on
acyclicity
\emph default
, a common requirement that prevents circular dependencies (cycles).
 These cycles, while needed in some scenarios, can lead to undesirable behavior.
 Our focus is on how this limitation hinders application scalability.
 We propose a solution by introducing semantics for mutual recursion, to
 be a specialized form of feeding data from multiple sources simultaneously.
 The effectiveness of this approach is validated through a case study with
 a real-world implementation.
\end_layout

\begin_layout Abstract
—–
\end_layout

\begin_layout Abstract
Many technologies today offer tools for explicitly declaring dependencies,
 with features named binding reactivety and so on.
 Such technologies have limitations, unless them, we could fire many developers,
 as many of them continue to implement dependencies with the classic programming.
 One limitation, is acyclicity required in most tools, as cycles naturaly
 leads to undesirable loops.
 We focus on this limiations' problem, with presenting that it resists against
 enlarging (get them bigger) the applications.
 We overcome this, by introducing semantics to mutual recursion, as a sub
 case of feeding values from mutiple sources.
 We evaluate the effectiveness of this approach through a case study with
 an actual implementation.
\end_layout

\begin_layout Abstract
a new approach for cycles, and present a case study to evaluate it.
\end_layout

\begin_layout Abstract
Therefore, to overcome that harful limitation, we develop a framework 
\end_layout

\begin_layout Abstract
Many technalogies today, have toolling of explcity declare dependencies.
 Such tecnalogies have limitations, unless them, we could fire many developers.
 A very important question about such models is about using it for large
 and complex domains, in high amount data and dependencies (we do not focus
 on the volume amount that actualy flow through).
 Usualy the answer for high volume of details is code reuse.
 We focus on reuse for dependency graphs.
 A dependency graph is a set of vertexes and edges, that we bound under
 an object, while vertexes represent the object's fields.
 Can it be useful, to 
\emph on
reuse a dependdancy graph
\emph default
 for creation further dependancy graphs? The resue is like objects composition,
 that the nested oject can access fields from the object that contained
 it.
\end_layout

\begin_layout Abstract
Can such model hold for growing applications? 
\end_layout

\begin_layout Abstract
applications that contain a huge amount details in the forms of data and
 dependencies? (we do not focus on data in high volume, but on amount of
 logic lying in applications.
\end_layout

\begin_layout Abstract
, that untill writing this lines, still not resolved.
 For this reason, we still need to 
\end_layout

\begin_layout Abstract
Paradimgs like of FRP, of explcity declaring dependencies seems a promised
 direction.
 This logic expersivene seems much more better that the traditional programming,
 where deveopers need to debug the application and reason about values.
\end_layout

\begin_layout Abstract
Paradimgs like of FRP, of explcity declaring dependencies seems a promised
 direction, compared to the traditional way of programming, that developers
 need to debug the application detemining reasons about values.
 However, in using this paradigm, two 
\end_layout

\begin_layout Abstract
–
\end_layout

\begin_layout Abstract
Functional Reactive Programming (FRP) is a paradigm of an abstractions to
 declare data dependencies excplicitly and directly.
 In this thesis
\end_layout

\begin_layout Abstract
—-
\end_layout

\begin_layout Abstract
According to many, excplicitly and directly declaring dependencies, improves
 compernhasive and maintanability of programs, compared to the imperative
 programming experience, in analyzing reactive behavior in terms of exeuted
 lines of code.
 This thesis' goal is to imrpove the ability of devide and qonqer approach
 against large graphs of dependencies that will be probbaly created in implement
ing large and complex applications.
 The research focus is to provide smeantics to loops in the dependencies
 that accidently created in using the devide and qonqer approach.
\end_layout

\begin_layout Abstract
The goal is to improve software deisng, according to 
\end_layout

\begin_layout Abstract
Using such paradigms, developers sometimes wonder, on how to handle loops
 in dependencies, and how to devide and queqer
\end_layout

\begin_layout Abstract
face a challenge, that some applications need to support loops in their
 dependencies
\end_layout

\begin_layout Abstract
—
\end_layout

\begin_layout Abstract
Functional Reactive Programming (FRP) is a paradigm suggested to replace
 Events Driven Programming (EDP).
 While EDP uses the imperative paradigm, FRP uses a programming model of
 a dependency graph or a dataflow graph.
 This thesis adress an improved model of a composite graph, by associate
\end_layout

\begin_layout Abstract
where a graph can be composed of smaller subgraphs
\end_layout

\begin_layout Itemize
separation of concerns principle
\end_layout

\begin_layout Abstract
that is a graph composed of simpler graphs or sub-graphs
\end_layout

\begin_layout Abstract
—
\end_layout

\begin_layout Abstract
This thesis address an issue named 
\emph on
cycles
\emph default
, that a change in one variable (or any data store) causes transitively,
 through a chain of changes, this same variable to again change its value.
 Changes caused by cycles might be unpredictable and unexpected.
 Changes might lead for further iterations, In the worst case, they will
 continue endlessly, breaking programs unexpectedly.
 We address cycles by a new conceptual framework where data dependencies
 form a composite dependency graph, that composed of sub-graphs, in order
 that each sub-graph will handle a separate application domain or concern.
 We implement the framework as a programming language extension, using a
 new concept: 
\begin_inset Formula $\RIVar$
\end_inset

, that stands for 
\emph on
Reactive Instance Variable
\emph default
.
 As its name, 
\begin_inset Formula $\RIVar$
\end_inset

 harmonizes a concept named 
\emph on
reactive variable
\emph default
 found in Functional Reactive Programming (FRP) with a concept named 
\emph on
instance variable
\emph default
 found in Object Oriented Programming (OOP).
\end_layout

\begin_layout Abstract
—-
\end_layout

\begin_layout Abstract
This thesis address an issue named 
\emph on
cycles
\emph default
, that a change in one variable (or any data store) causes transitively,
 through a chain of changes, this same variable to again change its value.
 Changes caused by cycles might be unpredictable and unexpected.
 Changes might lead for further iterations, In the worst case, they will
 continue endlessly, breaking programs unexpectedly.
 
\end_layout

\begin_layout Abstract
Upon addressing cycles, we introduce a model that variables and dependencies
 form a 
\emph on
composite graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 In each of the sub-graphs, it is free to add edges without worrying about
 accidentally creating a cycle.
 This implies the separation of concerns principle, referring each sub-graph
 to represent a distinct concern.
\end_layout

\begin_layout Abstract
We implement the model by a noval framework that combines Object Oriented
 Programming (OOP) with Functional Reactive Programming (FRP), such that
 objects from OOP will contain variables and dependencies of FRP.
 This forms a new concept: 
\begin_inset Formula $\RIVar$
\end_inset

, that stands for 
\emph on
Reactive Instance Variable
\emph default
.
 Similar to 
\emph on
Reactive Variable
\emph default
 of FRP, it is initiated with dependencies.
 Similar to 
\emph on
Instance Variable
\emph default
 of OOP, it is assoicated to objects, such that each object represents a
 sub-graph.
\end_layout

\begin_layout Abstract
As a proof of concept, we introduce programming language extensions.
 in the extensions, 
\begin_inset Formula $\RIVar$
\end_inset

 is provided as a data type, by which objects can contain variables of FRP.
 Additionaly, the extensions expose 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 function for creating functions that establish dependencies of FRP.
\end_layout

\begin_layout Abstract
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis is focused on a concept named 
\begin_inset Formula $\RIVar$
\end_inset

.
 
\begin_inset Formula $\RIVar$
\end_inset

 stands for 
\emph on
Reactive Instance Variable
\emph default
, harmonizing a concept named 
\emph on
reactive variable
\emph default
 found in 
\emph on
Functional Reactive Programming
\emph default
 (FRP) with a concept named 
\emph on
instance variable
\emph default
 found in Object Oriented Programming (OOP).
 Focusing on 
\emph on
reactive instance variables
\emph default
 means emphasizes 
\emph on
de-centralization
\emph default
 in reactive variables.
 This achieved by introducing 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP), in contrast to a conventional method in FRP of constructing hierarchi
cal graphs.
 (i.e., acyclic dependency graph, variables are connected to the input elements,
 and subsequently variables depend on other variables) 
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Note Note
status collapsed

\begin_layout Abstract
————
\end_layout

\begin_layout Abstract
Similar to reactive variable, each 
\begin_inset Formula $\RIVar$
\end_inset

 can be associated with an expression composed of other 
\begin_inset Formula $\RIVar$
\end_inset

s, forming the 
\begin_inset Formula $\RIVar$
\end_inset

 to depend on the other 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In runtime, the 
\begin_inset Formula $\RIVar$
\end_inset

 is automatically recalculated depending on the dependencies.
 Beside deriving the concept from reactive variable, the concept is derived
 also from instance variable, enabling the specification and runtime of
 data dependencies, as objects' internal behavior.
\end_layout

\begin_layout Abstract
The thesis introuces 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP) that stands for changing from a conventional method of constructing
 hierarchical graphs, where variables are connected to the input elements,
 and subsequently variables depend on other variables, forming an acyclic
 dependency graph (DAG).
 
\end_layout

\begin_layout Abstract
—————
\end_layout

\begin_layout Abstract
The concept is motivated by an healthcare application, where fields calculations
 caused user experiance questions on the implementations.
 
\end_layout

\begin_layout Abstract
We introduce 
\emph on
Non-Hierarchical FRP
\emph default
 (NH-FRP), a new variant of FRP that supports that speical settings.
 The variables (
\begin_inset Formula $\RIVar$
\end_inset

s) are formed of observable streams, with the approach that the association
 between variable and an expression is in the form of subscirptions, i.e.,
 it is like that the variable subscribe to the stream of values of the expressio
n.
\end_layout

\begin_layout Abstract
This forms a tool that enable data dependencies even when the data dependencies
 are not hirarchial.
\end_layout

\begin_layout Abstract
This forms an architeture that contrasted with the traditional FRP, in that
 the data dependenicies are not hirarchial
\end_layout

\begin_layout Abstract
\begin_inset Formula $\RIVar$
\end_inset

s are implemented as observable streams that propagate values while preserving
 the separation refined by the objects.
 During propagation, the loops caused by recursions are terminated by identifyin
g and discarding older values.
 The order of the values is determined by timestamps attached to the values,
 which are derived from the input values.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Abstract
This thesis introduces 
\emph on
reactive instance variables 
\emph default
as the datatype 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Abstract
This thesis provides a new semantics for creating data dependencies without
 the need to be aware of transitive dependencies.
 This means that variables forming the data dependencies can be part of
 OOP interfaces.
 Consequently, we have achieved a framework that harmonizes the abstraction
 mechanisms of both OOP and FRP, which is also considered a decentralized
 constraints system, and also a state management solution for front-end
 applications.
\end_layout

\begin_layout Abstract
As 
\emph on
reactive variable
\emph default
 the variables are automaticaly changed according to input provided over
 time FRP and the
\emph on
 instance variable
\emph default
 from OOP
\end_layout

\begin_layout Abstract
The 
\emph on
Functional Reactive Programming (FRP)
\emph default
 paradigm specializes in maintaining derived variables' values.
 However, this task has difficulties in performing predictable behavior
 especially when applications grow with many code duplications and long
 chains of updates.
 While the FRP paradigm contributes to the predictability of variables'
 updates, the Object Oriented Programming (OOP) paradigm contributes to
 the predictability of code changes.
 In this thesis, we combine the two paradigms to promote predictability.
\end_layout

\begin_layout Abstract
We use the combination of 
\emph on
reactive variable
\emph default
 from FRP and the
\emph on
 instance variable
\emph default
 from OOP, calling it 
\begin_inset Formula $\RIVar$
\end_inset

, a shortcut to the full name 
\emph on
Reactive Instance Variable
\emph default
.
 We introduce an approach and method for a single 
\begin_inset Formula $\RIVar$
\end_inset

 assigned with formulas by several clients.
 The assignment semantics adopts the meaning from FRP, to relate the variable
 to be updated according to the specified formula.
 However, in contrast to the traditional FRP, there can be several assignments
 to the same variable.
 Under the hood, 
\begin_inset Formula $\RIVar$
\end_inset

s observe several formulas, and infer values when and according to the latest
 value coming from any of the sources.
 
\end_layout

\begin_layout Abstract
To evaluate the approach, we compare it against traditional approaches,
 in how they handle variables' updates, and what code-reuse options are
 available.
 In addition, we present an implementation attached with a case study.
 The implementation is provided as an extension library, named 
\begin_inset Formula $\RIVarX$
\end_inset

, to C# programming language.
 The case study presents how we separate one domain logic into sub-domains,
 saparating a central calculation procedure.
 In the case study, each object manages its formulas, even when the formulas
 consist of variables belonging to other objects.
\end_layout

\begin_layout Abstract
We expect this approach being implemented as a state management solution
 and ease the development of front end applications.
 In this process, it is expected that we will discover that the method as
 is is too limited to being used in real-life applications.
 Because the model currently provides only one method to the variable to
 infer values from its sources.
 However, with the current method, the model is handled as a decentralized
 solution for Multiway Dataflow Constraint Systems suited for user interfaces.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
