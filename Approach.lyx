#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Approach
\end_layout

\begin_layout Standard
Consider a framework, that objects (specicifed by classes) simulate real
 world objects, and their fields simulate the real variable of the real
 world objects.
 For example, consider the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
In our framework, phenomena from the real world, causes updates to fields
 that represent them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly causing a
 chain of updates to make the whole values be consistent and simluate the
 variables they represent.
 The behavior of an object 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For any given pair of objects 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 This means that the updates of 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are free of updates fron unexpected feedback loop.
\end_layout

\begin_layout Standard
However, sometimes the behavior become complex because interactions between
 objects cause unintended feedback loops, or at least unintended updates.
 Consider that an update of Drug of a Bag (instances, but we skip saying
 that for fast reading), that causes Pump to update Dose, then Rate, then
 Volume, then Concentration, and then it comes back to 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 This is an unitended feedback loop.
 even in case that the interaction did not started with 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, there might be an unidented update of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 though an update of another field that causes 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 it updated with a rounded value 0.33 that is computed from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\begin_layout Standard
Consider that each class' behavior is modeled by initating data dependencies
 as in FRP.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), class 
\begin_inset Formula $\NAME{Bag}$
\end_inset

 contains 
\begin_inset Formula $\LSTINLINE{Volume:=Concentration*Drug}$
\end_inset

.
 The associations defined in the classes create data dependency graphs.
 These dependancy graphs from the objects initiated from the classes are
 then combined to form the overall dependancy graph.
 The graph might contains cycles.
 For instance, in the Order Entry, the graph exhibits a cycle involving
 the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 In case that cycles in data dependencies causes unintended feedback loops,
 this is like complex systems.
 As metioned, in complex systems the behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 This means that the behavior is not predictable by looking at a class individua
lly, causing the framework to be unsuccessful in the de-centralization.
 
\end_layout

\begin_layout Standard
————
\end_layout

\begin_layout Standard
A GUI application is like a 
\emph on
complex system
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://uwaterloo.ca/complexity-innovation/about/what-are-complex-systems
\end_layout

\end_inset

 if the behavior of the application as a whole is not predictable by looking
 at each of its individual stateful component separately.
 This thesis aims to stop GUI applications from being complex by handling
 efficiently 
\emph on
feedback loops
\emph default
, where during components interaction, a change in one variable leads to
 a subsequent change that feeds back and affects the original variable itself.
 
\end_layout

\begin_layout Standard
Inspired from the complex system research field, we adapt the 
\emph on
superposition
\emph default
 property, achievable through handling feedback loops.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
The actual process is that phenomena from the real world resulted by user
 interactions that fill values into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly causing a
 chain of updates to make the whole values be consistent and simulate the
 variables they represent.
 During the chain of updates, an update with obsolete value is stopped from
 continuing the propagation.
\end_layout

\begin_layout Subsection
Applications as Complex Systems
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—————-
\end_layout

\begin_layout Plain Layout
Consider an example, that classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 compose a drug administration front end application, with the relationships
 ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Each object contains 
\emph on
calculations
\emph default
 that involve variables it directly holds, as well as variables from other
 objects it contains or variables from its parent object.
 In the example, 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 contain calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contain calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
 The variables need to recalculate according to changes in other variables.
 
\end_layout

\begin_layout Plain Layout
We define this by formulas, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Therefore, the defined behavior of objects, creates data dependency graphs.
 The dependency graphs from the objects are then combined to form the overall
 dependency graph.
 The problem is how to satisfy the 
\emph on
superposition
\emph default
 property, which ensures that the behaviors produced by smaller objects
 are preserved when constructing larger composite objects.
 Formally, the behavior of a class is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 represents an instance of the class.
 We expect that this behavior satisfies the property 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 However, in the context of calculations, redundant updates pose a challenge
 to achieving this property.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  IBag TheBag|
\backslash
label{line:TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:RIVars}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Pseudo Code.
\end_layout

\end_inset

Drug Administration Pseudo Code.
 Illustrating the code of the classes to specify the behavior of objects.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:formula,line:formula2,line:formula3}
\end_layout

\end_inset

 represent the needed calculations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration }
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Class Diagram.
\end_layout

\end_inset

Drug Administration Class Diagram.
 Illustrating the access relationships between the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can perform calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 variables.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 can perform calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The issue is how to avoid redundant updates from an 
\emph on
unexpected feedback loop
\emph default
, where a change in one variable leads to a subsequent change that feeds
 back and affects the original variable itself.
 In the provided example, the graph exhibits a cycle involving the nodes
 duration, volume, and drug (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "true"
noprefix "false"

\end_inset

), which can potentially result in an infinite loop due to such an unexpected
 feedback loop.
 Even a single redundant update can be undesirable.
 If the feedback loop causes a variable to be updated, it can potentially
 override previous valid values, as the example illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}      
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{VolumeOfFluid=300}{Bag}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Concentration=0.33}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Drug=99}{Bag}{}  
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Rate=30}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}        
\end_layout

\begin_layout Plain Layout


\backslash
end{call}   
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Unpredictable-Calculation"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Unexpected Feedback Loop: Unintended Override of User Input
\end_layout

\end_inset

Sequence diagram illustrating the interactions between the User Interface
 (UI), 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 objects.
 Initially, the UI sets the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 to 100.
 However, due to the complex interactions and dependencies between the objects,
 the
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Drug}
\end_layout

\end_inset

 value undergoes modifications and eventually gets updated to 99.
 This unintended alteration exemplifies the challenge posed by feedback
 loops, which can result unintended override of user input.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Mutual recursion created in runtime from created dependency graphs within
 independent components.
\end_layout

\end_inset

Mutual recursion created in runtime from created dependency graphs within
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
 The nodes 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 that are interconnected through the edges represent the mutual recursion.
 The solid edges denote dependencies initiated within the 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instance, while dotted edges indicate dependencies initiated within the
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Outside of software development, 
\emph on
complex systems
\emph default
 refer to specific systems that composed of many components.(, where 
\begin_inset Quotes eld
\end_inset

wholes that are more than the sum of their parts
\begin_inset Quotes erd
\end_inset

.
 This is similar to component-based applications, in cases when behavior
 is not predictable by looking at each of its individual component separately.)
\end_layout

\begin_layout Subsubsection
Superposition Property
\end_layout

\begin_layout Standard
The superposition property means lineraity, i.e., for a set of components
 the sum of behaviors from each of the components seperatedly are equal
 to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Feedback Loops
\end_layout

\begin_layout Standard
In complex systems, the behavior is not linear because components affects
 each other producing sometimes 
\emph on
feedback loops
\emph default
.
 Feedback loop means that an effect in one component, produces a chain of
 effects through several components, which again produce affect on the first
 component (therefore the name, feed back), which sometimes lead to continue
 the chain, sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Subsubsection
Complexity in programming
\end_layout

\begin_layout Standard
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In essence, as specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "true"
noprefix "false"

\end_inset

, adding a single formula, might lead to a cycle in the dependencies which
 causes unexpected feedback loop, which means that the application becomes
 like complex systems.
\end_layout

\begin_layout Subsection
Reactive Instance (or Interface) Variables
\end_layout

\begin_layout Standard

\emph on
Reactive Instance
\emph default
 (or 
\emph on
Interface
\emph default
)
\emph on
 Variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short, is a concept that harmonizes 
\emph on
reactive
\emph default
 variables with 
\emph on
instance
\emph default
 variables (i.e., fields associated with objects).
 The name 
\family typewriter
reactive
\family default
 identify the nature from FRP to automate changes, while the name 
\family typewriter
instance
\family default
 identify nature from OOP including:
\end_layout

\begin_layout Itemize
Variables are associated with objects.
\end_layout

\begin_layout Itemize
Data dependencies (expressed by the variables) are associated with the objects
 as well.
\end_layout

\begin_layout Itemize
The change propagation is handled through sending and receiving messages.
\end_layout

\begin_layout Standard
Beside the first presentation in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present the concept by an example application named Drug Administration.
\end_layout

\begin_layout Standard
Consider an example named Drug Administration.
 In the example, class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
\end_layout

\begin_layout Standard
It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
The point is the full decoupling.
 The data dependencies are managed as internal behavior.
\end_layout

\begin_layout Standard
formulas are specified in classes, and behave as calling to methods.
 the operators, including the := calls a method similar to subscribe, which
 then later produce function calls to update about new values.
 Togather, this conform comunication channel to conform updates.
 For example, Pump contains TheBag.Drug:=Dose*Duration, which makes updates
 from Dose and Duration towards Drug.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In terms of OOP, the problem is that objects update their instance variables
 in response
\end_layout

\begin_layout Standard
With the OOP abstraction, each object is a responsibility to update its
 internal fields according to other fields, by registering their code in
 the coresponding objects.
\end_layout

\begin_layout Standard
Real world systems can be abstracted using OOP.
 Each variable of an object in the real-world is mapped to an instance variable
 of a coresponding object.
 Each object has a responsibility that is bounded within the object.
 
\end_layout

\begin_layout Standard
OOP is another platform by which the problem will be abstracted.
\end_layout

\begin_layout Standard
Each component can be represented by an object of OOP.
 Using class-based OOP, each class defines behavior of a group of objects.
 In the class, there are variables that will be in runtime the instance
 variables, that represent variables of objects from the real world.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration |
\backslash
label{line:PumpCode_RIVars1}|
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:PumpCode_formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable TheBag|
\backslash
label{line:PumpCode_TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:PumpCode_RIVars2}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:PumpCode_formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:PumpCode_formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode-2-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset


\end_layout

\end_inset

Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
Cref{line:PumpCode_formula,line:PumpCode_formula2,line:PumpCode_formula3}
\end_layout

\end_inset

 represent the needed calculations.
 The calculations involves the instance variables declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_RIVars1,line:PumpCode_RIVars2}
\end_layout

\end_inset

.
 In 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, the calculations involve variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, which is declared in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_TheBag}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
—-
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
Instead of declaring for each set of fields a full calculation process,
 there is another option, to declare rules like 
\begin_inset Quotes eld
\end_inset

in case that Amount has changed, then recompute other fields
\begin_inset Quotes erd
\end_inset

.
 Using this method, we declare each calculation once.
 
\end_layout

\begin_layout Standard
We reconstruct the 
\family typewriter
Drug Administration
\family default
 into two stateful components named 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 
\end_layout

\begin_layout Standard
At this design, we should implement rules like 
\begin_inset Quotes eld
\end_inset

in case that Amount has changed, then recompute other fields
\begin_inset Quotes erd
\end_inset

.
 The problem is that it might not distingwished, who changed Amount.
 
\end_layout

\begin_layout Standard
, as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 The reference is typed as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that do not have the field Concentration, making it clear that .
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 need access to only Drug, Volume.
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes stateful components that interact
 through directed and indirected messages is Object Oriented Programming
 (OOP).
 
\end_layout

\begin_layout Subsection
Reusable Dependency Graphs
\end_layout

\begin_layout Standard
We replace the acyclicity model, focusing on creating reusable dependency
 graphs.
 Each dependency graph model calculations to be done accross a set of fields.
 In the same time, fields are referred by a set of dependency graphs.
 We will perform this model further, inspiring from OOP with the encapsulation,
 inheritance and composition mechanisms.
 
\end_layout

\begin_layout Standard
We will present this by reconstructing the 
\family typewriter
Drug Administration
\family default
 with 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 classes, as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 The reference is typed as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that do not have the field Concentration, making it clear that .
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 need access to only Drug, Volume.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Volume}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Pump}{-10,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration }
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Class Diagram.
\end_layout

\end_inset

Drug Administration Class Diagram.
 Illustrating the access relationships between the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can perform calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 variables.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 can perform calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Encapsulation and Composition
\end_layout

\begin_layout Standard
We bundle as 
\emph on
object
\emph default
 a set of vertices and directed edges that inherently a smallest dependency
 graph.
 The vertices of a dependency graph represent the object's fields or variables.
 The edges represent the object's behavior with syntax and meaning similar
 to some traditional RP conceptual frameworks.
 
\end_layout

\begin_layout Standard
For example, 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 contains Drug, Volume and Concentration and an edge Concentration := Drug/Volum
e, signifies that Concentration depends on Drug and Volume.
 This means that the Concentration value needs to be recalculated whenever
 either the Drug or Volume value changes.
\end_layout

\begin_layout Standard
In order to perform further dependency graphs, it is enabled to perform
 compositions.
 As objects composition, an object can contain references of other objects.
 In such objects, the edges in the object can connect between the vertixes
 of this object with vertxes of the referenced objects.
 A full example is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Beside the presented Bag, Pump contains a reference to an instance of Bag,
 named as TheBag.
 It contains vertxes Duration, Dose, Rate and have the declararion of TheBag.Drug
:=Dose*Duration.
 In this way, a dependency graph can be composed of sub-graphs, such that
 each sub-graph is independently implemented.
 
\end_layout

\begin_layout Subsubsection
Cycles/Undesirable Behavior
\end_layout

\begin_layout Standard
In this setting, it is disallowed to keep the graphs to be acylcity.
 For example, as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the graphs of Pump and Bag are composed into graph that exhibits a cycle
 involving the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 The inability to keep graphs to be acylcic is due our form of encapsulation.
 According to it, declaring an object's dependency graph can involve other
 objects' vertxeses, without to be aware of their dependency graphs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
\end_layout

\end_inset

Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
 The solid edges denote dependencies initiated within the 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instance, while dotted edges indicate dependencies initiated within the
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
 In the graph created, the nodes 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 are interconnected through the edges, representing the mutual recursion.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this framework, phenomena from the real world, causes updates to fields
 that represent them.
 The phenomena is produced by user interactions that fill values into input
 controls of a GUI.
 Once a field is updated, other fields are updated accordingly causing a
 chain of updates to make the whole values be consistent and simluate the
 variables they represent.
 The behavior of an object 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For any given pair of objects 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 This means that the updates of 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are free of updates fron unexpected feedback loop.
\end_layout

\begin_layout Standard
However, sometimes the behavior become complex because interactions between
 objects cause unintended feedback loops, or at least unintended updates.
 Consider that an update of Drug of a Bag (instances, but we skip saying
 that for fast reading), that causes Pump to update Dose, then Rate, then
 Volume, then Concentration, and then it comes back to 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 This is an unitended feedback loop.
 even in case that the interaction did not started with 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, there might be an unidented update of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 though an update of another field that causes 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 it updated with a rounded value 0.33 that is computed from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
 (The information lost through proagation chage appears also in the following
 example of an auto-complete textbox.
 In the auto-complete textbox, selected text relies on the available options
 because the default selection is determined when the available options
 are established (utilizing the default text feature).
 Simultaneously, the available options depend on the selected text, as it
 serves as a query to search for options starting with this text.
 The flow of data has information lost by defintion, as the first selected
 text which leads to a set of options did change the selected text.
 )
\end_layout

\begin_layout Standard
Consider that each class' behavior is modeled by initating data dependencies
 as in FRP.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), class 
\begin_inset Formula $\NAME{Bag}$
\end_inset

 contains 
\begin_inset Formula $\LSTINLINE{Volume:=Concentration*Drug}$
\end_inset

.
 The associations defined in the classes create data dependency graphs.
 These dependancy graphs from the objects initiated from the classes are
 then combined to form the overall dependancy graph.
 The graph might contains cycles.
 For instance, in the Order Entry, the graph exhibits a cycle involving
 the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 In case that cycles in data dependencies causes unintended feedback loops,
 this is like complex systems.
 As metioned, in complex systems the behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 This means that the behavior is not predictable by looking at a class individua
lly, causing the framework to be unsuccessful in the de-centralization.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}      
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{VolumeOfFluid=300}{Bag}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Concentration=0.33}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Drug=99}{Bag}{}  
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Rate=30}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}        
\end_layout

\begin_layout Plain Layout


\backslash
end{call}   
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Unpredictable-Calculation-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Unexpected Feedback Loop: Unintended Override of User Input
\end_layout

\end_inset

Sequence diagram illustrating the interactions between the User Interface
\begin_inset space ~
\end_inset

(UI), 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 objects.
 Initially, the UI sets the value of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to 100.
 However, due to the complex interactions and dependencies between the objects,
 the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 value undergoes modifications and eventually gets updated to 99.
 This unintended alteration exemplifies the challenge posed by feedback
 loops, which can result unintended override of user input.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
In this section, we present a case study
\end_layout

\begin_layout Standard
In this section, we present the acylicity problem within a case study and
 the leverage to our noval framework.
\end_layout

\begin_layout Standard
we present a case study, in which cycles prevents from scaling application
\end_layout

\begin_layout Standard
Our motivation is a new technalogy of dependency graphs reuse.
 We introduce depedancy graph as objects that their fields are vertexes,
 and that they contain edges that form depedencies.
 As in objects composition, that the nested oject can access fields from
 the object that contained it, can nested depedancy graph be connected to
 vertexes of the object contains it.
 
\end_layout

\begin_layout Standard
, that adopt the popular best practieing of components reuse.
 The idea is to reuse dependency graphs, similar to the way that objects
 are reused in OOP.
 We declare a dependancy graph as a set of vertex and a set of edges bounded
 together in one unit.
 This unit, beside the vertes and edges, can contain a reference to other
 such units.
\end_layout

\begin_layout Standard
We declare the dependency graph as a new form of objects, that contain vertexes
 and edges, such that vertexes represent the object's fields.
\end_layout

\begin_layout Standard
a set of vertexes and edges, that we bound under an object, while vertexes
 represent the object's fields.
\end_layout

\begin_layout Standard
A dependency graph is a set of vertexes and edges, that we bound under an
 object, while vertexes represent the object's fields.
 The new technalogy will enable to reuse dependency graph similar to objects
 composition and of an inheritance.
 As in objects composition, that objects can contain refernces of other
 objects, can 
\end_layout

\begin_layout Standard
As in objects composition, that the nested oject can access fields from
 the object that contained it, is a nested depedancy graph 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
Code reuse of dependency graphs has a meaning like of creating further dependanc
y graphs relying on previous like objects inheritance or objects compositions.
\end_layout

\begin_layout Standard
Code reuse of dependency graphs means creation further dependancy graphs
 based on the previous.
\end_layout

\begin_layout Standard
The resue is like objects composition, that the nested oject can access
 fields from the object that contained it.
\end_layout

\begin_layout Standard
, of high amount data and dependencies (we do not focus on the volume amount
 that actualy flow through).
 Usualy the answer for high volume of details is code reuse.
 Reuse for 
\end_layout

\begin_layout Standard
We focus on reuse for dependency graphs.
 A dependency graph is a set of vertexes and edges, that we bound under
 an object, while vertexes represent the object's fields.
 Can it be useful, to 
\emph on
reuse a dependdancy graph
\emph default
 for creation further dependancy graphs? The resue is like objects composition,
 that the nested oject can access fields from the object that contained
 it.
\end_layout

\begin_layout Standard
–
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
There are two famous strategies in this context: 
\emph on
push
\emph default
 and 
\emph on
pull
\emph default
 model.
 In the pull model, consumer need to 
\emph on
pull
\emph default
 data, by actions like a function call or a service request.
 In order to compute the data, the called functions or services need again
 to pull data from which to compute.
 This process is recursive untill reaching the sources of the data.
 In the push model, the model is dara data driven, because whenever there
 are changes in data, the new data flows forward.
 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
This thesis' focus is about managing efficiently fields computations.
 Before delving into the motivation, we define the meaning of fields calculation
 and efficienty, as their meaning in this thesis.
 
\end_layout

\begin_layout Standard
Applications frequently include fields that display (or contain) data that
 is derived from other data.
 There are two famous strategies in this context: 
\emph on
push
\emph default
 and 
\emph on
pull
\emph default
 model.
 In the pull model, consumer need to 
\emph on
pull
\emph default
 data, by actions like a function call or a service request.
 In order to compute the data, the called functions or services need again
 to pull data from which to compute.
 This process is recursive untill reaching the sources of the data.
 In the push model, the model is dara data driven, because whenever there
 are changes in data, the new data flows forward.
 
\end_layout

\begin_layout Standard
Efficiently, in this context consists of the push model, but not just it.
 Calling push model as more effcient is because we assume fast processing.
 Fast means for when data to derive from is already available.
 The focus on efficiently is on speed of development.
\end_layout

\begin_layout Standard
The reason for slowing down developments is complexity, for which there
 are two prespectives.
 First, software developers face complexity as 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Second, with software that consists of many components.
 Generaly, according to the famous principal seperation of concerns, there
 is more potentsial in such software to be more simple.
 complex systems' terminology provide an insight However, it sometimes does
 not yield simplicity.
\end_layout

\begin_layout Subsection
Order Relation
\end_layout

\begin_layout Subsection
??????
\end_layout

\begin_layout Subparagraph
DFS
\end_layout

\begin_layout Subparagraph
Expression Tree
\end_layout

\begin_layout Subparagraph
Composite Function in Functional Programming
\end_layout

\begin_layout Standard
This is related to expression tree
\end_layout

\begin_layout Subparagraph
Composite Function by chaining functions
\end_layout

\begin_layout Subparagraph
Conclusion
\end_layout

\begin_layout Standard
evaluation of expressions are in DFS order
\end_layout

\begin_layout Standard
————————
\end_layout

\begin_layout Standard
RIVar framework is built by layering one data model on top of another.
 
\end_layout

\begin_layout Itemize
The input are from the environment produced as events, such as an input
 control change event.
\end_layout

\begin_layout Itemize
Observable streams from the change events, represents varying value over
 time.
\end_layout

\begin_layout Itemize
Objects, variables and functions.
\end_layout

\begin_layout Itemize
Objects (classes) that contain variables and also formula formed as one-way
 dataflow constraint.
 Deriving from OOP, we can do X.A=B+C, that means that we 
\series bold
add
\series default
 an assignment.
 Each objects contain a subgraph, the whole objects become a composite graph.
\end_layout

\begin_layout Itemize
Variables and their expression are varying values over time formed as observable
 streams.
 The assignment make the left hand variable to subscribe to the observable
 of the left side expression.
 The multi assignment makes the variable to be subscribed to several observable
 streams.
 As a result, the obserable stream produced from ths variable is merged.
\end_layout

\begin_layout Itemize
The input are from the environment produced as events, such as a an input
 control change event.
\end_layout

\begin_layout Standard
1.
 As an application developer, you look at the real world (in which there
 are people, organizations, goods, actions, money flows, sensors, etc.) and
 model it in terms of objects or data structures, and APIs that manipulate
 those data structures.
 Those structures are often specific to your application
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
The way in how we harmonize objectability with reactivity is by introducing
 a new assignment operation for RIVar.
 The new assignment operator subscribes for receiving values with a use
 and an online decentralized propagation algorithm.
\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Standard
For when variables receive values and forward values in reponse, we embed
 an online decentralized propagation algorithm.
 
\end_layout

\begin_layout Standard
when variables receive values to make decision regrading the forwaring
\end_layout

\begin_layout Standard
The need for an online decentralized propagation algorithmis due 
\end_layout

\begin_layout Standard
In our setting, each variable when receives values makes its own decision
 regrading the forwaring
\end_layout

\begin_layout Standard
In our setting, we use a decentralized propagation algorithm, such that
 each variable when receives values makes its own decision regrading the
 forwaring.
 The final behavior or the algorithm as a whole is the aggregate of the
 decisions from the whole.
\end_layout

\begin_layout Standard
Other than in traditionl 
\end_layout

\begin_layout Standard
Other than in traditional algorithms, that 
\end_layout

\begin_layout Standard
In settings like us, that each variable si 
\end_layout

\begin_layout Standard
Each variable recive values and forward values
\end_layout

\begin_layout Standard
Even without introducing the new assignment operator, there is a room for
 researching decentralized propagation algorithms.
\end_layout

\begin_layout Standard
The room for a decentralized propagation algorithm is open even before our
 new semantics.
\end_layout

\begin_layout Standard
In this settings, we have a room for just a decentralized propagation algorithm.
 Each variable recive values and makes its own decision regrading the forwaring.
\end_layout

\begin_layout Standard
In this setting, each variable makes its own decision, while the final behavior
 is the aggregate of the decisions.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Non-Hierarchical FRP (NH-FRP) is a new variant for FRP we introduce.
 In NH-FRP, cycles are supported by enabling defining variables in terms
 of one another (named 
\family typewriter
mutual recursion
\family default
).
 For instance, if 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are included in code, which means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is defined in term of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and vice versa.
 More often, are cycles produce by multiple vertexes and edges, without
 being aware of.
\end_layout

\begin_layout Standard
A cycle's starting point has two incoming edges.
 This is clearly derived from the way we illustrate a cycle (depicted in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We start from an incoming edge into a node, that is the cycle's first node.
 Then, we continue through several nodes untill reaching again the first
 node from another edge.
 From determining the two incoming edges of the data flow, we discover the
 need to a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator over streams of values from the two vertexes.
\end_layout

\begin_layout Subsection
Merge Function
\end_layout

\begin_layout Standard
The meaning given for the phenomenon of a variable are assigned multiple
 times, that it is sampled by various options from the environment.
 The variables are continuously re-evaluated according to the most recent
 value, from any of the assigned expressions or input.
 For example, if the application contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

, executing 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B:=3}$
\end_inset

, causes 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to contain 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

,
\begin_inset Formula $\LSTINLINE 2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE 3$
\end_inset

.
\end_layout

\begin_layout Standard
In addition to the operational semantics we started with, we propose the
 incorporation of a denotational semantics.
 The assigned expression and the target variable are streams, such that
 the items from the stream of the assigned expression, are merged into the
 stream of the variable.
 Hence, the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 means an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
 operator over streams.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 Subsequent statements, such as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, which means 
\begin_inset Formula $\LSTINLINE{A=merge(A,D)}$
\end_inset

 extends the concept to being 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
\end_layout

\begin_layout Standard
In another point of view, finally the outcome of each variable consists
 of a stream that is the result of a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function across the assigned expressions, in addition to its original initial
 stream.
 As in the example, in the application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, with executed 
\begin_inset Formula $\LSTINLINE{D=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B=3}$
\end_inset

, means three streams that are merged into the stream of 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

,
\begin_inset Formula $\LSTINLINE 2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE 3$
\end_inset

.
 Accordingly, observing the stream of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 actually observes the stream of 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
This point of view leads that there are no order over the executions of
 the statements of 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

.
 In executing these statements, the right-hand side of the operator is merged
 with the stream on the left-hand side of the operator, and stores the merged
 result back in the left-hand side variable.
 While in runtime, each value from any of the streams are propagated into
 the variable.
 We formulate it that in an application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Propagation Change 
\end_layout

\begin_layout Standard
We implement the change propagation on top of the default change propogation
 of Rx.
 This propagation consists of synchronously respond to notifications by
 passing them forward.
 This propagation consists of a traversal in the form of depth-first search
 (DFS) algorithm.
 In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Further values are ordered acording to the events by which the have been
 produced.
 Comparing valued produced directly by events is immidiate, as it is determne
 by comaring their timetsamps.
 Further comparesitions are a bit complex.
 We will introduce an implementation that keeps on a consistecy, such that
 following each new event, each variable will contain a value that is produced
 by the latest events.
 
\end_layout

\begin_layout Standard
The comparesitions are taken localy, by the node at hand.
 Therefore, each event need to contain a timestamp (managed by an increment
 number) in addition to its value, according to its location in order.
 For example, X and Y that contain value 8 and 2 contain timestamps 1 and
 2 respectively.
 For simplicity the timetsamps are presented as sets, such that in the exmaple
 X and Y contains {1} and {2} respectively.
 Further values contain a set of timestamps resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 In the example, upon formula Z1 = X*Y, Z will contain a value 16 and timestamps
 {1,2}.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Examples are illustaretd in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
For example, when determimng a value for Z1 according to a formula Z1 =
 X*Y, the set of timestamps are determined from 
\end_layout

\begin_layout Standard
For example, in determimng a value for Z1 according to a formula Z1 = X*Y
 as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
are derived from the events, therefore attached with timestamps of the events
 from which their have been produced.
 
\end_layout

\begin_layout Standard
set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
a global consistency, such that following
\end_layout

\begin_layout Standard
We represent this by mapping a set of timestamps for each.
\end_layout

\begin_layout Standard
For example, a list of three events are mapped into {1,2,3}.
 
\end_layout

\begin_layout Standard
This is abstracted by mapping a set of timestamps for each value.
 For example, 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Each event contains a timestamp (managed by an increment number) according
 to its location in order.
 Further values are derived from the events, therefore attached with timestamps
 of the events from which their have been produced.
 
\end_layout

\begin_layout Standard
set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
ordered events, specified according to their time.
 We assume no simultaneous events
\end_layout

\begin_layout Standard
(, i.e., a change event initiates a sequence of computations in a depth-first
 order.
 (The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1972depth"
literal "false"

\end_inset

 of the vertices reached during the traversal.) )
\end_layout

\begin_layout Standard
The compare action is based on the fact, that each value is derived from
 a set of events.
 A value that is more up-to-date is derived from events that produced later.
 Therefore, events' timestamps are attached to values, to be used in the
 compare action.
\end_layout

\begin_layout Standard
The timestamps are organized such that external events are ordered according
 to their time, producing values that are attached with their timestamp
 (managed by an increment number).
 Based on such values, each derived values is attached with a timestamps
 set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Subsequently, it is possible to compare each value tuple.
 As seen in the examples in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, if the value is derived from newer events, it still can be a stale value.
 A newer value must be one that overrides the effects of a variable's previous
 value.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
——————
\end_layout

\begin_layout Subparagraph
—
\end_layout

\begin_layout Standard
The 
\end_layout

\begin_layout Standard
Using this model, we will determine how to propagate changes, without the
 negative effects of cycles mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We determine a meaning for a variable that depends on several expressions
 simultaneously, that it is sampled by various options from the environment.
 This is similar to a common phenomenon, that multiple sensors might measure
 the same physical variable.
 Similarly, in a GUI, filling a field will affect other fields to calculate
 their values according to the new filled field.
 
\end_layout

\begin_layout Standard
The propagation is built upon simply responding synchronously to notifications,
 passing them forward in a form of depth-first search (DFS).
\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
Upon this investigation, a composite graph can include cycles formed accidentall
y (or not) by its indevedual sub-graphs.
 This can be formed by an harmonization with OOP.
 Declaring data dependencies associated to objects, will create a composite
 graph, in which each object represent of a sub-graph.
\end_layout

\begin_layout Standard
, as will figure out using Drug Administration example.
 Declaring data dependencies associated to objects, will create a composite
 graph, in which each object cosnists of a sub-graph.
\end_layout

\begin_layout Standard
An associate variables and dependencies to objects, 
\end_layout

\begin_layout Standard
Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
 
\end_layout

\begin_layout Standard
For example, 
\end_layout

\begin_layout Standard
we introduce a framework of a composite graph mentioned 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Each sub-graph is formed by an object of OOP that contain variables and
 dependencies.
\end_layout

\begin_layout Standard
For example, consider the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
Such applications are complex, since during the interaction, there might
 be unexpected feedback loops.
 The calculations defined in the objects create data dependency graphs.
 These dependancy graphs from the objects are then combined to form the
 overall dependancy graph.
 The graph might contains cycles which leads to the unexpected feedback
 loops.
 For instance, in the Drug Administration, the graph exhibits a cycle involving
 the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 This can potentially result an unexpected infinite loop, however even a
 single redundant update can be undesirable.
 If the feedback loop causes a variable to be updated, it can potentially
 override previous valid values, as the example illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Volume}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Pump}{-10,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration }
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-1-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Class Diagram.
\end_layout

\end_inset

Drug Administration Class Diagram.
 Illustrating the access relationships between the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can perform calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 variables.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 can perform calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration |
\backslash
label{line:PumpCode_RIVars1}|
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:PumpCode_formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable TheBag|
\backslash
label{line:PumpCode_TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:PumpCode_RIVars2}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:PumpCode_formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:PumpCode_formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode-2-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset


\end_layout

\end_inset

Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
Cref{line:PumpCode_formula,line:PumpCode_formula2,line:PumpCode_formula3}
\end_layout

\end_inset

 represent the needed calculations.
 The calculations involves the instance variables declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_RIVars1,line:PumpCode_RIVars2}
\end_layout

\end_inset

.
 In 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, the calculations involve variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, which is declared in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_TheBag}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents-2-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
\end_layout

\end_inset

Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
 The solid edges denote dependencies initiated within the 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instance, while dotted edges indicate dependencies initiated within the
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
 In the graph created, the nodes 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 are interconnected through the edges, representing the mutual recursion.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
We hold two principles by sub-graphs are 
\emph on
decoupled
\emph default
 from each other, for ma will represent a distinct concern.
 First, developers declare dependencies inside an object's class, without
 being aware of other objects' dependencies.
 This does not prevent from using other objects' variables.
 The second point refers to initiating dependencies and propagating changes
 through sending and receiving.
 This informs decoupling, namely that when calling a objects' method, it
 is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In OOP, when calling a objects' method, it is up to the object, to choose
 what method to execute.
 This forms decoupling between the objects, such that objects call other
 objects' method, wihtou being aware detailed
\end_layout

\begin_layout Standard
As objects interacts through sending and receiving, does the change propagaion.
 According to the OOP principals, when calling a objects' method (sending
 a message), it is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
We harmonize FRP with OOP including the elements: variables, objects and
 dependencies.
 Variables is a simplified name for our discussion, referring to the concept
 of reactive insatnce variable (RIVar).
 Variables are part of the object interface, a bit similar to getters and
 setters.
 The dependencies are closed to those dicsussed in FRP, but with an association
 to (or included in) objects.
 While it is not a must, dependencies may be declared explicity in the langiage
 level.
 For this thesis' scope, we will refer to the depedencies as explcity declared
 as in FRP.
 This results a modeling framework for constructing a composite graph, where
 its constituent sub-graphs are represented by the various objects.
 
\end_layout

\begin_layout Standard
The idea that dependencies are associated to objects hold two principlas.
 First, developers declare depedecnies for an object, without being aware
 of other objects' dependencies.
 This does not prevent from using other objects' variables, even if recursion
 is created.
 The second point is relate to how changes are propagated.
 As objects interacts through sending and receiving, do the change propagaion.
 According to the OOP principals, when calling a objects' method (sending
 a message), it is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
For example, as depicted in ..., class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
\end_layout

\begin_layout Standard
It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
The point is the full decoupling.
 The data dependencies are managed as internal behavior.
\end_layout

\begin_layout Standard
formulas are specified in classes, and behave as calling to methods.
 the operators, including the := calls a method similar to subscribe, which
 then later produce function calls to update about new values.
 Togather, this conform comunication channel to conform updates.
 For example, Pump contains TheBag.Drug:=Dose*Duration, which makes updates
 from Dose and Duration towards Drug.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Using this model, we will determine how to propagate changes, without the
 negative effects of cycles mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We determine a meaning for a variable that depends on several expressions
 simultaneously, that it is sampled by various options from the environment.
 This is similar to a common phenomenon, that multiple sensors might measure
 the same physical variable.
 Similarly, in a GUI, each field is updated by several options, and according
 to the latest 
\end_layout

\begin_layout Standard
contains values according to the latest user interaction.
 will contain a value based on the latest user
\end_layout

\begin_layout Standard
Similarly, in a GUI, filling a field will affect other fields to calculate
 their values according to the new filled field.
 
\end_layout

\begin_layout Standard
The propagation is built upon simply responding synchronously to notifications,
 passing them forward in a form of depth-first search (DFS).
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
 
\end_layout

\begin_layout Standard
This forms a smart 
\emph on
merge
\emph default
 for the whole coming values.
\end_layout

\begin_layout Standard
Beyond the locality function, we should keep on a consistecy.
 We keep on that following each new event, each of the variables will contain
 a value that is produced by the latest events.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Further values are ordered acording to the events by which the have been
 produced.
 Comparing valued produced directly by events is immidiate, as it is determne
 by comaring their timetsamps.
 Further comparesitions are a bit complex.
 We will introduce an implementation that keeps on a consistecy, such that
 following each new event, each variable will contain a value that is produced
 by the latest events.
 
\end_layout

\begin_layout Standard
The comparesitions are taken localy, by the node at hand.
 Therefore, each event need to contain a timestamp (managed by an increment
 number) in addition to its value, according to its location in order.
 For example, X and Y that contain value 8 and 2 contain timestamps 1 and
 2 respectively.
 For simplicity the timetsamps are presented as sets, such that in the exmaple
 X and Y contains {1} and {2} respectively.
 Further values contain a set of timestamps resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 In the example, upon formula Z1 = X*Y, Z will contain a value 16 and timestamps
 {1,2}.
\end_layout

\begin_layout Standard
——————
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Later, we created similar work with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 to make the framework avaiable to more users, and to be able to use it
 online.
 In order to use it, the developer need to add our rivar.umd.js script and
 also rxjs.umd.min.js.
 The Drug Administration then availability online in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation/RIVar/DrugAdministration.html
\end_layout

\end_inset

 from the code in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/Evaluation/blob/main/RIVar/DrugAdministration.html
\end_layout

\end_inset

.
 In order to evaluate against modern applications, we chose to integrate
 also with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
 There 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 is inherently the state management solution.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{React}$
\end_inset

 takes a functional approach creating visual views, which are pure functions.
 We used this approach to create a "visual 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

" , where the view continuously reflects the value.
 For instance, 
\begin_inset Formula $\LSTINLINE{InputField}$
\end_inset

 are bound to 
\begin_inset Formula $\LSTINLINE{var}$
\end_inset

 which is an instance of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 set in the 
\begin_inset Formula $\NAME{props}$
\end_inset

, which are the element attributes.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

 <InputField rivar={var} />
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This can be used to compose a larger component that its view depends on
 a larger object.
 Which then used to compose the larger components similar to micro-frontend
 architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

 as illustrated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:react_micro_frontends"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
———————————
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
This is s a common phenomenon in sensor data acquisition
\end_layout

\begin_layout Standard
This phenomenon is known from sampling by sensors.
 It may be several sensors that sample a single phsicial variable.
\end_layout

\begin_layout Standard
The variables are continuously re-evaluated according to the most recent
 value, from any of the assigned expressions or input.
 For example, if the application contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

, executing 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B:=3}$
\end_inset

, causes 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to contain 
\begin_inset Formula $\LSTINLINE1$
\end_inset

,
\begin_inset Formula $\LSTINLINE2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE3$
\end_inset

.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
it is figured out that one of variables has two incoming edges.
\end_layout

\begin_layout Standard
as a change in one variable (of its contained value) causes transitively,
 through a chain of changes, this same variable to change again
\end_layout

\begin_layout Standard
We absract variables and dependencies as a directed graph, where each node
 represents a variable, and the edges are constructed according to a flow
 of updates.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in a cycle, we start from an incoming edge into a node, that is a cycle's
 first node, then through several nodes untill reaching again the first
 node from another edge.
 Yet, it is discovered, that a cycle's first node has two incoming edges.
 
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Standard
Through this directed graph, named as 
\emph on
dataflow graph
\emph default
, we uncover syntax and semantics.
 First, we make a process similar to reverse-engineering: according to such
 a graph, we name as 
\emph on
dataflow graph
\emph default
, we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=f(B).
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
 From this investigation, we find an idea of a new semantic to cycles as
 belonged to a broader concept, that any variable, including input variables,
 can depend on several expressions simultaneously.
\end_layout

\begin_layout Subsection
Semantics
\end_layout

\begin_layout Standard
A second idea is that two incoming edges represent collecting values from
 observing a single phnomenon by more than one option.
\end_layout

\begin_layout Standard
A second idea is inspired from the concept of 
\emph on
observable streams
\emph default
 and of 
\emph on
merging
\emph default
.
 Each variable and expression abstracts values over time axsis, similar
 to as oservable stream is depicted.
 In case that the two incoming edges produced from two expression, then
 it is very closed to the concept of the merge function.
 As an observable stream, the variable observe two elements (that the souce
 nodes represent), so that whenever
\end_layout

\begin_layout Standard
The variable will behave as an observable
\end_layout

\begin_layout Standard
Even when the first incoming edge is produced from a input, the merge 
\end_layout

\begin_layout Standard
A node with two incoming edges refer to a concept similar to a merge function.
 If the two incoming edges produced from two expression, then it is very
 closed to the concept of the merge function.
 If the first incoming edge is produced from a input, then 
\end_layout

\begin_layout Standard
variable that that its values are 
\end_layout

\begin_layout Subsection
Composite Graphs
\end_layout

\begin_layout Standard
In FRP, reactive variables are used to create a data depedancy graph.
 In large scale applications, it might be with any nodes (variables) and
 edges (depedencies).
 We name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges.
 When observing a sugraph, other subgraphs does exist, with common nodes
 (meaning that a node can be observed in diffrent subgraphs).
 When observing a sugraph, the other graphs are not observed.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Standard
In software development, the ability to zoom in and out on the problem that
 software solves is a concept often discussed in software development and
 design.
 This concept is closely related to the idea of abstraction and granularity.
 In diffrent prespectivs diffrent details are observed, ignoring other details.
 It is related to the seperation of concern principle, that the diffrent
 concern are handled independenctly, without to observe other concrens
\end_layout

\begin_layout Standard
In Functional Reactive Programming (FRP), reactive variables are utilized
 to construct a data dependency graph, which forms the backbone of reactive
 systems.
 As applications scale in complexity, this graph can grow significantly,
 comprising numerous nodes (representing variables) interconnected by edges
 (depicting dependencies).
 The concept of "zooming in" comes into play when we focus our attention
 on a specific subset of this graph, forming what we term a subgraph.
 A subgraph consists of a distinct set of nodes and the corresponding edges
 that link them.
 Notably, while we observe a subgraph, other subgraphs coexist within the
 larger graph, sharing common nodes.
 It's crucial to emphasize that when we zoom in on a particular subgraph,
 we do so at the exclusion of others; thus, we overlook the broader context
 of the entire graph.
 This practice resonates closely with the principle of Separation of Concerns,
 wherein each subgraph represents an independent concern, allowing for focused
 and modular handling of specific aspects of the system's behavior or functional
ity.
\end_layout

\begin_layout Subsection
Non-Hierarchical FRP
\end_layout

\begin_layout Standard
–
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In terms of OOP, the problem is that objects update their instance variables
 in response
\end_layout

\begin_layout Standard
With the OOP abstraction, each object is a responsibility to update its
 internal fields according to other fields, by registering their code in
 the coresponding objects.
\end_layout

\begin_layout Standard
Real world systems can be abstracted using OOP.
 Each variable of an object in the real-world is mapped to an instance variable
 of a coresponding object.
 Each object has a responsibility that is bounded within the object.
 
\end_layout

\begin_layout Standard
OOP is another platform by which the problem will be abstracted.
\end_layout

\begin_layout Standard
Each component can be represented by an object of OOP.
 Using class-based OOP, each class defines behavior of a group of objects.
 In the class, there are variables that will be in runtime the instance
 variables, that represent variables of objects from the real world.
\end_layout

\begin_layout Standard
OOP provides a platform to abstract the problem, as tool OOP is helpful
 for cencepetual modeling, to abstract objects of the real world.
\end_layout

\begin_layout Standard
is a paradigm that ease some aspects of concetual modeling.
\end_layout

\begin_layout Standard
An abstraction to the problem
\end_layout

\begin_layout Standard
OOP, as a paradigm of cencepetual modeling helps in provding an abstraction
 to the problem.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
Our approach for dependencies management and change propogation are described
 by several prespectives.
\end_layout

\begin_layout Section
Complex Systems
\end_layout

\begin_layout Standard
Applications composed of many components are called 
\emph on
complex
\emph default
 if their behavior are not predictable by looking at each of their individual
 component separately.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Indpisred from research field named 
\emph on
complex systems.
\end_layout

\end_inset

 The complexity is happened due to 
\emph on
feedback loops
\emph default
.
 Feedback loops means an effect in one component, produces a chain of effects
 through several components, which again produce affect on the first component
 (therefore the name, feed back), which sometimes lead to continue the chain,
 sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Standard
We expect
\emph on
 
\emph default
applications
\emph on
 to
\emph default
 satisfy the 
\emph on
superposition
\emph default
 property.
 The superposition property is closed to 
\emph on
lineraity
\emph default
, i.e., for a set of components the sum of behaviors from each of the components
 seperatedly are equal to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Component breakdown, a cornerstone of software development, doesn't always
 equate to overall application simplicity.
\end_layout

\begin_layout Plain Layout
Furthermore, components-based application are sometimes very similar to
 
\emph on
complex systems.

\emph default
 Systems, therefore also applcations, that composed of many components are
 complex if their behavior are not predictable by looking at each of their
 individual component separately.
\end_layout

\begin_layout Plain Layout
non complex applications are those that satisfies the 
\emph on
superposition property
\emph default
.
 The superposition property means lineraity, i.e., for a set of components
 the sum of behaviors from each of the components seperatedly are equal
 to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In the research of compex systems it has been explained that the non linear
 behavior is caused from 
\emph on
feedback loops
\emph default
.
 Feedback loops are very similar to loops existed in programming components-base
d applications.
 Feedback loop means that an effect in one component, produces a chain of
 effects through several components, which again produce affect on the first
 component (therefore the name, feed back), which sometimes lead to continue
 the chain, sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
In this section, we present complexity derived from the cycles problem.
 During this presentation, we use an application named 
\family typewriter
Drug Administration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A small part from Order Entry in 
\family typewriter
MetaVision
\family default
, an healthcare system provided by 
\family typewriter
iMDsoft
\family default
.
\end_layout

\end_inset

 
\family default
illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for clinicians to document medications amounts, consisting six fields:
 Drug, Volume, Concentration, Rate, Dose and Duration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Complex systems is a research field 
\end_layout

\begin_layout Standard
Complexity refers to small details causes failures in surprising ways 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
sometimes refers to small details causes failures in surprising ways 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Applications composed of many components are called complex if their behavior
 are not predictable by looking at each of their individual component separately.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Indpisred from research field named 
\emph on
complex systems.
\end_layout

\end_inset

 Complexity sometimes refers to small details causes failures in surprising
 ways 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 The inpredictability is caused from feedback loops.
\end_layout

\begin_layout Standard
The complexity is happened due to feedback loops.
\end_layout

\begin_layout Standard
Instead, it is desirable to satisfy the 
\emph on
superposition
\emph default
 property.
 The superposition property means 
\emph on
lineraity
\emph default
, i.e., for a set of components the sum of behaviors from each of the components
 seperatedly are equal to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Component breakdown, a cornerstone of software development, doesn't always
 equate to overall application simplicity.
\end_layout

\begin_layout Plain Layout
Furthermore, components-based application are sometimes very similar to
 
\emph on
complex systems.

\emph default
 Systems, therefore also applcations, that composed of many components are
 complex if their behavior are not predictable by looking at each of their
 individual component separately.
\end_layout

\begin_layout Plain Layout
non complex applications are those that satisfies the 
\emph on
superposition property
\emph default
.
 The superposition property means lineraity, i.e., for a set of components
 the sum of behaviors from each of the components seperatedly are equal
 to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In the research of compex systems it has been explained that the non linear
 behavior is caused from 
\emph on
feedback loops
\emph default
.
 Feedback loops are very similar to loops existed in programming components-base
d applications.
 Feedback loop means that an effect in one component, produces a chain of
 effects through several components, which again produce affect on the first
 component (therefore the name, feed back), which sometimes lead to continue
 the chain, sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
In this section, we present complexity derived from the cycles problem.
 During this presentation, we use an application named 
\family typewriter
Drug Administration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A small part from Order Entry in 
\family typewriter
MetaVision
\family default
, an healthcare system provided by 
\family typewriter
iMDsoft
\family default
.
\end_layout

\end_inset

 
\family default
illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for clinicians to document medications amounts, consisting six fields:
 Drug, Volume, Concentration, Rate, Dose and Duration.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Feedback Loops
\end_layout

\begin_layout Standard
Feedback loops might introduce non-linearity.
 Feedback loops means an effect in one component, produces a chain of effects
 through several components, which again produce affect on the first component
 (therefore the name, feed back), which sometimes lead to continue the chain,
 sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\end_body
\end_document
