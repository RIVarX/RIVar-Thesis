#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reactive Instance Variables
\end_layout

\begin_layout Standard
In traditional imperative languages 
\emph on
variable
\emph default
 is a symbolic name associated to memory address which contains value.
 In OOP
\emph on
 instance variable
\emph default
 is a variable associated to an object.
 Objects are used for conceptual modeling, or to simulate real world domain
 objects, then instance variables represent real world variables.
\end_layout

\begin_layout Standard
Simulating the objects over time, need to somehow have the variables values
 consistence with the real outside world, characteristics of interest we
 observe (observable variables 
\begin_inset CommandInset citation
LatexCommand cite
key "dodge2006oxford"
literal "false"

\end_inset

) or inferre from other variables that are observed (latent variables 
\begin_inset CommandInset citation
LatexCommand cite
key "dodge2006oxford"
literal "false"

\end_inset

).
 This reminds the notion of 
\emph on
reactive variable
\emph default
 from FRP.
\end_layout

\begin_layout Standard
The example in the figure below illustrates the way in which instance variables
 may be reactive variables.
 The variables are typed as RIVar, that is an acronym to Reactive Instance
 Variable, parameterized with double.
 Concentration is a latent variable, which is automaticaly calculated whenever
 Drug or Volume is updated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration := Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main(){
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration()
\end_layout

\begin_layout Plain Layout

administration.Drug=50
\end_layout

\begin_layout Plain Layout

administration.Volume=100 // administration.Concentration=0.5
\end_layout

\begin_layout Plain Layout

administration.Drug=25  // administration.Concentration=0.25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RIVars are accessed externaly by being in service interfaces and specialization
 interfaces (subclass access its superclass variables).
 The access is uniform: any accessible RIVar can be assigned (:= operator)
 as a latent variable, and also to get input (= operator) as an observable
 variable.
 This means that (1) RIVars are not distinguished between observable and
 latent variables, and (2) RIVars that have already been assigned, can be
 reassigned.
\end_layout

\begin_layout Standard
Consequently, the dependency graph is not controlled: there might be cycles
 and all other challenged constructions (detailed in the background).
 We will demonstare examples, and then (in the next section) present a possible
 approach to FRP supporting such dependency graphs.
\end_layout

\begin_layout Section
Specialization Interface
\end_layout

\begin_layout Standard
In the figure bellow, subclass ExtendedDrugAdministration defines Drug to
 depend on Concentration, while in the superclass DrugAdministration defines
 Concentration to depend on Drug.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration := Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration:DrugAdministration {
\end_layout

\begin_layout Plain Layout

  Drug := Concentration*VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Service Interface
\end_layout

\begin_layout Standard
Considering the figures bellow, from the Infusion alone, the dependency
 graph has no cycles.
 Infusion uses TheBag as a service, i.e., without to learn about its implementatio
n (Bag class).
 However, an instance of Infusion with TheBag typed as Bag produces a graph
 with cycles.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Infusion}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Infusion}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Infusion {  
\end_layout

\begin_layout Plain Layout

 Duration := TheBag.VolumeOfFluid*Rate
\end_layout

\begin_layout Plain Layout

 TheBag.Drug := Duration*Dose
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

class Bag:IBag{
\end_layout

\begin_layout Plain Layout

  VolumeOfFluid := Drug*Concentration
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Semantics
\end_layout

\begin_layout Standard
We formulate semantics to reactive variables to work also with RIVars.
 RIVars add two constraints to reactive variables: First, no centerlized
 management are alowed, because objects interact directly by messages and
 events.
 Second, as previously presented, reactive variables might have several
 assigment and feed from multiple sources.
\end_layout

\begin_layout Section
Reactive Variables
\end_layout

\begin_layout Standard
A reactive variable, under the hood, is an 
\emph on
events stream
\emph default
, an observable emitting values to subscribers 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, based on the 
\emph on
observer
\emph default
 and 
\emph on
iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 This makes the management decenterlized and defines the reactive variable
 abstraction in the low level.
 In the high level, reactive variables are the typical 
\emph on
continuous
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

; they are used to define variables dependencies in the problem domain,
 independant of time.
\end_layout

\begin_layout Standard
The lower level abstraction does exist, because even when a reactive variable
 represent a real world variable in high level, in computers reactive variable's
 actual values cannot continuously given.
 For example, temperature might be represented by a reactive variable depending
 on an actualy stream of discrete events, being measured by a thermometer.
\end_layout

\begin_layout Standard
Similary in UI applications, the logic may be in terms of continuously update
 fields according to other fields; objects constructed from classes from
 the previous chapter, aim to be the logic layer to certain UI applications.
 Many times, UI application observe fields’ change events, once a value
 is changed, dependant fields are calculated and presented.
 The fields change events should feed reactive variables (as observable
 variables), and the fields updates are from subscribing to reactive variables
 (as latent variables).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration()
\end_layout

\begin_layout Plain Layout

bag.Drug=From Drug Field Change Events
\end_layout

\begin_layout Plain Layout

bag.Volume=From Volume Field Change Events
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(value=> Update Concentration Field by Value)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operators and Assigments
\end_layout

\begin_layout Standard
Operators and assigments are two elements type connecting reactive variables
 between each other.
 For example, in the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

 over the reactive variables A, B and C, + is an operator connecting B and
 C, and := is an assigment connecting 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+C
\end_layout

\end_inset

.
 In runtime, in response to input, values are propogated through the graph;
 the assigments and operators track their input values, 
\begin_inset Quotes eld
\end_inset

deciding
\begin_inset Quotes erd
\end_inset

 what values to notify their subscribers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (1,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (3,7) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=square,draw=black] (Plus) at (2,5) {+}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (2,3) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,1) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Equal) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Operator is a lifted function, such that a function over values are lifted
 to being over reactive variables: the constructed expression continously
 reflects the varying value calculated from the reactive variables.
 Similary, an assigment over reactive variables would be 
\emph on
lifted
\emph default
 assigment, such that an assigned reactive variable should reflect the assigned
 expression continuously.
 
\end_layout

\begin_layout Standard
As mentioned at the beginning of the section, a RIVar can be assigned (and
 also to get input) ignoring already existed assigments.
 Consequently under the hood, an assigment is like operators: they provide
 a 
\emph on
single
\emph default
 stream of values based on 
\emph on
several 
\emph default
streams, they are subscribed to.
 This formulation of having a reactive variable notifying about its values
 from several streams, is similar to having several devices sampling a single
 real-world variable.
\end_layout

\begin_layout Standard
Assigments and operators as parties in the graph, should track their input
 values from the inputs streams 
\begin_inset Quotes eld
\end_inset

deciding
\begin_inset Quotes erd
\end_inset

 what values to notify their subscribers.
 The parties need to be coordinated, therefore a distributed algorithm must
 be designed.
 
\end_layout

\begin_layout Section
old (not to read)
\end_layout

\begin_layout Standard
————————–
\end_layout

\begin_layout Standard
We adopt the approach 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, in which an existing language can be extended with a variation of reactive
 variable as a data type, that is used to declare and automate dependencies.
 Objects then can contain 
\emph on
reactive instance variables
\emph default
, that are reactive variables as instance variables (or objects' data members).
 Also, they can be declared as part of interfaces, such that providers and
 clients will share them while hiding related associations.
\end_layout

\begin_layout Standard
The reactive instance variables can have references because they can be
 shared among several objects.
 Consequently, reactive instance variables can be referenced by several
 formulas, in such that they are associated to several expressions.
 e.g., given the reactive instance variables' references 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

 assemble the formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=X
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=Y
\end_layout

\end_inset

, if 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B
\end_layout

\end_inset

, then a reactive variable with two associations is produced.
 
\end_layout

\end_body
\end_document
