#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Approach
\end_layout

\begin_layout Standard
In traditional imperative languages 
\emph on
variable
\emph default
 is a symbolic name associated to memory address which contain value.
 In OOP there is 
\emph on
 instance variable
\emph default
 that is a variable associated to an object.
 Objects is used for conceptual modeling, or to simulate real world domain
 objects, then instance variables represent real world variables.
\end_layout

\begin_layout Standard
Simulating the objects over time, need to somehow have the variables values
 consistence with the real outside world, characteristics of interest we
 observe (observable variables 
\begin_inset CommandInset citation
LatexCommand cite
key "dodge2006oxford"
literal "false"

\end_inset

) or inferre from other variables that are observed (latent variables 
\begin_inset CommandInset citation
LatexCommand cite
key "dodge2006oxford"
literal "false"

\end_inset

).
 This reminds the notion of 
\emph on
reactive variable
\emph default
 from FRP.
\end_layout

\begin_layout Standard
The example in the figure below illustrates the way in which instance variables
 may be reactive variables.
 The variables are typed as 
\end_layout

\begin_layout Standard
RIVar, that is an acronym to Reactive Instance Variable, and parameterized
 with double.
 Concentration is a latent variable, that should automaticaly be calculated
 whenever Drug or Volume are updated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration := Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main(){
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration()
\end_layout

\begin_layout Plain Layout

administration.Drug=50
\end_layout

\begin_layout Plain Layout

administration.Volume=100 // administration.Concentration=0.5
\end_layout

\begin_layout Plain Layout

administration.Drug=25  // administration.Concentration=0.25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RIVars, in their interface, are not distinguished between observable and
 latent variables.
 In addition, they can be accessed externaly by being in service interfaces
 or specialization interfaces (subclass access its superclass variables).
 Consequently, the dependency graph is not controlled: there might be cycles
 and other challenged constructions (detailed in the background).
 For example (using a specialization interface, but it is similar also to
 a service interface), in the figure bellow, subclass ExtendedDrugAdministration
 defines Drug depends on Concentration, while in the superclass DrugAdministrati
on defines that Concentration depends on Drug.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration := Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration:DrugAdministration {
\end_layout

\begin_layout Plain Layout

  Drug := Concentration*VolumeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
———
\end_layout

\begin_layout Standard
The objects are the logic layer to certain UI applications.
 Many times, UI application observe fields’ change events, once a value
 is changed, dependant fields are calculated and presented.
 With our model, the fields change events feed the observable variables,
 and the fields updates are from subscribing to the latent variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration()
\end_layout

\begin_layout Plain Layout

bag.Drug=From Drug Field Change Events
\end_layout

\begin_layout Plain Layout

bag.Volume=From Volume Field Change Events
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(value=> Update Concentration Field by Value)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Inheritance
\end_layout

\begin_layout Standard
The classes are organized by subclass hierarchies, such that any subclass
 is a subtype of its superclass.
\end_layout

\begin_layout Chapter
Reactive Instance Variables
\end_layout

\begin_layout Standard
We adopt the approach 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, in which an existing language can be extended with a variation of reactive
 variable as a data type, that is used to declare and automate dependencies.
 Objects then can contain 
\emph on
reactive instance variables
\emph default
, that are reactive variables as instance variables (or objects' data members).
 Also, they can be declared as part of interfaces, such that providers and
 clients will share them while hiding related associations.
\end_layout

\begin_layout Standard
The reactive instance variables can have references because they can be
 shared among several objects.
 Consequently, reactive instance variables can be referenced by several
 formulas, in such that they are associated to several expressions.
 e.g., given the reactive instance variables' references 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

 assemble the formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=X
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=Y
\end_layout

\end_inset

, if 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B
\end_layout

\end_inset

, then a reactive variable with two associations is produced.
 
\end_layout

\begin_layout Standard
Reactive variable is 
\emph on
continuous
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, by being used independant of time.
 Associating reactive variable with an expression, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

X:=A+B
\end_layout

\end_inset

, describes continously how varying value depends on other varying values.
\end_layout

\begin_layout Standard
However, in computers, reactive variable's actual values are not continously
 given.
 For example, reactive variable reflecting temperature, is associated to
 stream of events from measuring by a thermometer.
 Conceptualy, the reactive variable reflects the temperature continuously,
 but in runtime, it depends on the actual stream of values.
\end_layout

\begin_layout Standard
Therfore, reactive variable has two abstraction levels.
 The higher level, is continuous, to being used independant of time.
 But in the lower level (
\begin_inset Quotes eld
\end_inset

under the hood
\begin_inset Quotes erd
\end_inset

), the reactive variable is an 
\emph on
events stream
\emph default
, which is an observable emitting values to subscribers 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, based on the 
\emph on
observer
\emph default
 and 
\emph on
iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The two abstraction levels are relevant also in the context of the operators.
 Operators over reactive instance variables, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 in the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

A+B
\end_layout

\end_inset

, means in the high level, continuously reflecting the variables' sum.
 However
\emph on
, 
\emph default
in the low level, 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are streams, and the operator 
\begin_inset ERT
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 is a function over them, producing a stream of values notifications from
 applying + on the values from the notifications of A and B.

\emph on
 
\end_layout

\begin_layout Standard
Accordingly, reactive instance variables can be associated with several
 streams (streams of imperative events, streams of reactive instance variables,
 and streams of an expression of reactive instance variables).
 The reactive instance variables are notified about their values from several
 streams, similar to having several devices sampling a single real-world
 variable in the world.
 Anyway, the reactive variable provides to its subscribers, a single stream
 of values based on the several streams, it is subscribed to.
 
\end_layout

\begin_layout Standard
When propagating values through the operators and associations, each party
 (operator or association), as an observable observer, tracks its input
 values and 
\begin_inset Quotes eld
\end_inset

decides
\begin_inset Quotes erd
\end_inset

 what values to notify its subscribers.
 The parties need to be coordinated, therefore a distributed algorithm must
 be designed.
 
\end_layout

\end_body
\end_document
