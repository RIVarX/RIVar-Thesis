#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Methodology
\end_layout

\begin_layout Standard
Non-Hierarchical FRP (NH-FRP) is a new variant for FRP we introduce.
 In NH-FRP, cycles are supported by enabling defining variables in terms
 of one another (named 
\family typewriter
mutual recursion
\family default
).
 For instance, if 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are included in code, which means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is defined in term of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and vice versa.
 More often, are cycles produce by multiple vertexes and edges, without
 being aware of.
\end_layout

\begin_layout Standard
A cycle's starting point has two incoming edges.
 This is clearly derived from the way we illustrate a cycle (depicted in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We start from an incoming edge into a node, that is the cycle's first node.
 Then, we continue through several nodes untill reaching again the first
 node from another edge.
 From determining the two incoming edges of the data flow, we discover the
 need to a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator over streams of values from the two vertexes.
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
Usually, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B, therefore
 the data flows from B to A.
 This time, we take a reversed process.
 A cycle's starting point has two incoming edges.
 This is clearly derived from the way we illustrate a cycle (depicted in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We start from an incoming edge into a node, that is the cycle's first node.
 Then, we continue through several nodes untill reaching again the first
 node from another edge.
 From determining the two incoming edges of the data flow, it becomes clear
 that this node is one of two options.
 First, that the node represents an input variable which also depends on
 an expression.
 In this case, an incoming value into the variable propagates through several
 nodes untill reaching again the variable through the expression it depends
 on.
 For example, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable and it is declared that 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and also that 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

.
 In the second options, the node represents a variable that depends on two
 expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
we find that this node represent a variable that has been declared with
 a dependancy more that once.
 Specificaly, this informs one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Standard
From investigating data flow from two distinct nodes, we determine a variable
 with 
\emph on
multiple assignment
\emph default
.
\end_layout

\begin_layout Standard
We distingwish between two assignment types.
 
\end_layout

\begin_layout Standard
Since a cycle's starting point has two incoming edges, it must be that one
 variable two dependancies have been declared or that 
\end_layout

\begin_layout Standard
, or that an input variable 
\end_layout

\begin_layout Standard
A cycle starts from the first incoming edge into the cycle starting point,
 then through several nodes untill reaching again the first node from another
 edge.
\end_layout

\begin_layout Standard
Since a cycle's starting point has two incoming edges, it must be that two
 dependancies have been declared (
\end_layout

\begin_layout Standard
it depends on 
\end_layout

\begin_layout Standard
using a process similar to reverse-engineering.
 Usually, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Standard
In this chapter we figure out that cycles are belonged to a broader concept.
 In ilustrating a cycle, such as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start from an incoming edge into a node, that is a cycle's first node,
 then through several nodes untill reaching again the first node from another
 edge.
 The node that we started from, has two incoming edges.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From this investigation, we determine that an existence of cycles means
 that variables depend on several expressions simultaneously.
 We present this using a process similar to reverse-engineering.
 Usualy, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Standard
The employed strategy involves propagating each input through its data dependenc
ies until reaching points where the value from the propagation is no longer
 more up-to-date than the values of the reached variables at that time.
 For instance, when 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 receives an input, it propagates it to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 However, it does not subsequently propagate it back to 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Standard
The use of 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 is traditionally enabled to assign multiple times.
 The novelty is about 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 that the variable is associated to the expression without being able to
 remove this association.
 For instance, in a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present, it is valid to present also 
\begin_inset Formula $\LSTINLINE{A:=1}$
\end_inset

.
 This will propagate the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Similarly, the addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 is valid.
 In this case, including 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

 will result in the propagation of the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, and finally to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 
\end_layout

\begin_layout Section
Merge Function
\end_layout

\begin_layout Standard
The meaning given for the phenomenon of a variable are assigned multiple
 times, that it is sampled by various options from the environment.
 The variables are continuously re-evaluated according to the most recent
 value, from any of the assigned expressions or input.
 For example, if the application contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

, executing 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B:=3}$
\end_inset

, causes 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to contain 
\begin_inset Formula $\LSTINLINE1$
\end_inset

,
\begin_inset Formula $\LSTINLINE2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE3$
\end_inset

.
\end_layout

\begin_layout Standard
In addition to the operational semantics we started with, we propose the
 incorporation of a denotational semantics.
 The assigned expression and the target variable are streams, such that
 the items from the stream of the assigned expression, are merged into the
 stream of the variable.
 Hence, the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 means an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
 operator over streams.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 Subsequent statements, such as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, which means 
\begin_inset Formula $\LSTINLINE{A=merge(A,D)}$
\end_inset

 extends the concept to being 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
\end_layout

\begin_layout Standard
In another point of view, finally the outcome of each variable consists
 of a stream that is the result of a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function across the assigned expressions, in addition to its original initial
 stream.
 As in the example, in the application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, with executed 
\begin_inset Formula $\LSTINLINE{D=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B=3}$
\end_inset

, means three streams that are merged into the stream of 
\begin_inset Formula $\LSTINLINE1$
\end_inset

,
\begin_inset Formula $\LSTINLINE2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE3$
\end_inset

.
 Accordingly, observing the stream of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 actually observes the stream of 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
This point of view leads that there are no order over the executions of
 the statements of 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

.
 In executing these statements, the right-hand side of the operator is merged
 with the stream on the left-hand side of the operator, and stores the merged
 result back in the left-hand side variable.
 While in runtime, each value from any of the streams are propagated into
 the variable.
 We formulate it that in an application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Propagation Change 
\end_layout

\begin_layout Standard
We implement the change propagation on top of the default change propogation
 of Rx.
 This propagation consists of synchronously respond to notifications by
 passing them forward.
 This propagation consists of a traversal in the form of depth-first search
 (DFS) algorithm.
 In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Further values are ordered acording to the events by which the have been
 produced.
 Comparing valued produced directly by events is immidiate, as it is determne
 by comaring their timetsamps.
 Further comparesitions are a bit complex.
 We will introduce an implementation that keeps on a consistecy, such that
 following each new event, each variable will contain a value that is produced
 by the latest events.
 
\end_layout

\begin_layout Standard
The comparesitions are taken localy, by the node at hand.
 Therefore, each event need to contain a timestamp (managed by an increment
 number) in addition to its value, according to its location in order.
 For example, X and Y that contain value 8 and 2 contain timestamps 1 and
 2 respectively.
 For simplicity the timetsamps are presented as sets, such that in the exmaple
 X and Y contains {1} and {2} respectively.
 Further values contain a set of timestamps resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 In the example, upon formula Z1 = X*Y, Z will contain a value 16 and timestamps
 {1,2}.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Examples are illustaretd in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
For example, when determimng a value for Z1 according to a formula Z1 =
 X*Y, the set of timestamps are determined from 
\end_layout

\begin_layout Standard
For example, in determimng a value for Z1 according to a formula Z1 = X*Y
 as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
are derived from the events, therefore attached with timestamps of the events
 from which their have been produced.
 
\end_layout

\begin_layout Standard
set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
a global consistency, such that following
\end_layout

\begin_layout Standard
We represent this by mapping a set of timestamps for each.
\end_layout

\begin_layout Standard
For example, a list of three events are mapped into {1,2,3}.
 
\end_layout

\begin_layout Standard
This is abstracted by mapping a set of timestamps for each value.
 For example, 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Each event contains a timestamp (managed by an increment number) according
 to its location in order.
 Further values are derived from the events, therefore attached with timestamps
 of the events from which their have been produced.
 
\end_layout

\begin_layout Standard
set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
ordered events, specified according to their time.
 We assume no simultaneous events
\end_layout

\begin_layout Standard
(, i.e., a change event initiates a sequence of computations in a depth-first
 order.
 (The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1972depth"
literal "false"

\end_inset

 of the vertices reached during the traversal.) )
\end_layout

\begin_layout Standard
The compare action is based on the fact, that each value is derived from
 a set of events.
 A value that is more up-to-date is derived from events that produced later.
 Therefore, events' timestamps are attached to values, to be used in the
 compare action.
\end_layout

\begin_layout Standard
The timestamps are organized such that external events are ordered according
 to their time, producing values that are attached with their timestamp
 (managed by an increment number).
 Based on such values, each derived values is attached with a timestamps
 set that is resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 For example, as illustrated in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Subsequently, it is possible to compare each value tuple.
 As seen in the examples in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, if the value is derived from newer events, it still can be a stale value.
 A newer value must be one that overrides the effects of a variable's previous
 value.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
——————
\end_layout

\begin_layout Paragraph
—
\end_layout

\begin_layout Standard
The 
\end_layout

\begin_layout Standard
Using this model, we will determine how to propagate changes, without the
 negative effects of cycles mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We determine a meaning for a variable that depends on several expressions
 simultaneously, that it is sampled by various options from the environment.
 This is similar to a common phenomenon, that multiple sensors might measure
 the same physical variable.
 Similarly, in a GUI, filling a field will affect other fields to calculate
 their values according to the new filled field.
 
\end_layout

\begin_layout Standard
The propagation is built upon simply responding synchronously to notifications,
 passing them forward in a form of depth-first search (DFS).
\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
Upon this investigation, a composite graph can include cycles formed accidentall
y (or not) by its indevedual sub-graphs.
 This can be formed by an harmonization with OOP.
 Declaring data dependencies associated to objects, will create a composite
 graph, in which each object represent of a sub-graph.
\end_layout

\begin_layout Standard
, as will figure out using Drug Administration example.
 Declaring data dependencies associated to objects, will create a composite
 graph, in which each object cosnists of a sub-graph.
\end_layout

\begin_layout Standard
An associate variables and dependencies to objects, 
\end_layout

\begin_layout Standard
Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
 
\end_layout

\begin_layout Standard
For example, 
\end_layout

\begin_layout Standard
we introduce a framework of a composite graph mentioned 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Each sub-graph is formed by an object of OOP that contain variables and
 dependencies.
\end_layout

\begin_layout Standard
For example, consider the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
Such applications are complex, since during the interaction, there might
 be unexpected feedback loops.
 The calculations defined in the objects create data dependency graphs.
 These dependancy graphs from the objects are then combined to form the
 overall dependancy graph.
 The graph might contains cycles which leads to the unexpected feedback
 loops.
 For instance, in the Drug Administration, the graph exhibits a cycle involving
 the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 This can potentially result an unexpected infinite loop, however even a
 single redundant update can be undesirable.
 If the feedback loop causes a variable to be updated, it can potentially
 override previous valid values, as the example illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Volume}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Pump}{-10,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration }
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-1-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Class Diagram.
\end_layout

\end_inset

Drug Administration Class Diagram.
 Illustrating the access relationships between the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can perform calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 variables.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 can perform calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration |
\backslash
label{line:PumpCode_RIVars1}|
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:PumpCode_formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable TheBag|
\backslash
label{line:PumpCode_TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:PumpCode_RIVars2}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:PumpCode_formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:PumpCode_formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode-2-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset


\end_layout

\end_inset

Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
Cref{line:PumpCode_formula,line:PumpCode_formula2,line:PumpCode_formula3}
\end_layout

\end_inset

 represent the needed calculations.
 The calculations involves the instance variables declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_RIVars1,line:PumpCode_RIVars2}
\end_layout

\end_inset

.
 In 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, the calculations involve variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, which is declared in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_TheBag}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents-2-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
\end_layout

\end_inset

Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
 The solid edges denote dependencies initiated within the 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instance, while dotted edges indicate dependencies initiated within the
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
 In the graph created, the nodes 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 are interconnected through the edges, representing the mutual recursion.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
We hold two principles by sub-graphs are 
\emph on
decoupled
\emph default
 from each other, for ma will represent a distinct concern.
 First, developers declare dependencies inside an object's class, without
 being aware of other objects' dependencies.
 This does not prevent from using other objects' variables.
 The second point refers to initiating dependencies and propagating changes
 through sending and receiving.
 This informs decoupling, namely that when calling a objects' method, it
 is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In OOP, when calling a objects' method, it is up to the object, to choose
 what method to execute.
 This forms decoupling between the objects, such that objects call other
 objects' method, wihtou being aware detailed
\end_layout

\begin_layout Standard
As objects interacts through sending and receiving, does the change propagaion.
 According to the OOP principals, when calling a objects' method (sending
 a message), it is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
We harmonize FRP with OOP including the elements: variables, objects and
 dependencies.
 Variables is a simplified name for our discussion, referring to the concept
 of reactive insatnce variable (RIVar).
 Variables are part of the object interface, a bit similar to getters and
 setters.
 The dependencies are closed to those dicsussed in FRP, but with an association
 to (or included in) objects.
 While it is not a must, dependencies may be declared explicity in the langiage
 level.
 For this thesis' scope, we will refer to the depedencies as explcity declared
 as in FRP.
 This results a modeling framework for constructing a composite graph, where
 its constituent sub-graphs are represented by the various objects.
 
\end_layout

\begin_layout Standard
The idea that dependencies are associated to objects hold two principlas.
 First, developers declare depedecnies for an object, without being aware
 of other objects' dependencies.
 This does not prevent from using other objects' variables, even if recursion
 is created.
 The second point is relate to how changes are propagated.
 As objects interacts through sending and receiving, do the change propagaion.
 According to the OOP principals, when calling a objects' method (sending
 a message), it is up to the object, to choose what method to execute.
\end_layout

\begin_layout Standard
For example, as depicted in ..., class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
\end_layout

\begin_layout Standard
It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Standard
The point is the full decoupling.
 The data dependencies are managed as internal behavior.
\end_layout

\begin_layout Standard
formulas are specified in classes, and behave as calling to methods.
 the operators, including the := calls a method similar to subscribe, which
 then later produce function calls to update about new values.
 Togather, this conform comunication channel to conform updates.
 For example, Pump contains TheBag.Drug:=Dose*Duration, which makes updates
 from Dose and Duration towards Drug.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Using this model, we will determine how to propagate changes, without the
 negative effects of cycles mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We determine a meaning for a variable that depends on several expressions
 simultaneously, that it is sampled by various options from the environment.
 This is similar to a common phenomenon, that multiple sensors might measure
 the same physical variable.
 Similarly, in a GUI, each field is updated by several options, and according
 to the latest 
\end_layout

\begin_layout Standard
contains values according to the latest user interaction.
 will contain a value based on the latest user
\end_layout

\begin_layout Standard
Similarly, in a GUI, filling a field will affect other fields to calculate
 their values according to the new filled field.
 
\end_layout

\begin_layout Standard
The propagation is built upon simply responding synchronously to notifications,
 passing them forward in a form of depth-first search (DFS).
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
 
\end_layout

\begin_layout Standard
This forms a smart 
\emph on
merge
\emph default
 for the whole coming values.
\end_layout

\begin_layout Standard
Beyond the locality function, we should keep on a consistecy.
 We keep on that following each new event, each of the variables will contain
 a value that is produced by the latest events.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
For allowing the comparsition, we determine an order over the values.
 We start from a stream of events, that are probably ordered, and without
 simultaneous events.
 Further values are ordered acording to the events by which the have been
 produced.
 Comparing valued produced directly by events is immidiate, as it is determne
 by comaring their timetsamps.
 Further comparesitions are a bit complex.
 We will introduce an implementation that keeps on a consistecy, such that
 following each new event, each variable will contain a value that is produced
 by the latest events.
 
\end_layout

\begin_layout Standard
The comparesitions are taken localy, by the node at hand.
 Therefore, each event need to contain a timestamp (managed by an increment
 number) in addition to its value, according to its location in order.
 For example, X and Y that contain value 8 and 2 contain timestamps 1 and
 2 respectively.
 For simplicity the timetsamps are presented as sets, such that in the exmaple
 X and Y contains {1} and {2} respectively.
 Further values contain a set of timestamps resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
 In the example, upon formula Z1 = X*Y, Z will contain a value 16 and timestamps
 {1,2}.
\end_layout

\begin_layout Standard
——————
\end_layout

\begin_layout Section
Programming Language Extensions
\end_layout

\begin_layout Standard
We implemented the concept as extensions to existing programming languages
 on top of Rx.
 Specifically, we implemented the 
\begin_inset Formula $\NAME{nuget}$
\end_inset

 package 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and an 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 (Using observable streams facilitates binding with the UI, when a UI change
 event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.)
\end_layout

\begin_layout Standard
We implement a filtering mechanism, where the variables and the expressions
 over them does not propagate values that are less updated that the existing
 once.
 To do this, we create a wrapper to variables: the 
\begin_inset Formula $\RIVar$
\end_inset

 datatype, which is a shortcut for reactive instance variable.
 We also create a wrapper to the expressions: the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function (
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

) .
 Both pass values while filtering out obsolete values.
 The values are wrapped by objects of the 
\begin_inset Formula $\LSTINLINE{signal}$
\end_inset

 type (or 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) implementing the classic comparable interface (according to 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) by timestamps as mentioned in in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Order-Model"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function is similar to 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 that it creates an observable stream from input observable streams.
 Whenever any of the input stream has a new item, a new item is created
 to the output stream.
 However, in contrast to the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function creates an observable streams that is 
\emph on
strictly increasing sequence
\emph default
: it only passes an item to the output stream if it is greater (i.e., newer)
 than an item that previously passed.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\RIVar$
\end_inset

 type is derived from the 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

), which implements an observable stream.
 The 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) method is the implementation of the operator 
\begin_inset Formula $\LSTINLINE=$
\end_inset

, and for the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

, we implement a new custom method, we call it 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 In the 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 method, there are subscriptions to the two sides, and each item in the
 right side, is compared to the last item in the stream of the variable
 in the left side.
 If it is new, it will publish it by calling on its 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 This is like applying the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the right-hand side of the operator is merged with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
\end_layout

\begin_layout Standard
By using the extension, 
\begin_inset Formula $\LSTINLINE{A.set(Lift(Inc,B))}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, while 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

 represent the function 
\begin_inset Formula $\LSTINLINE{Inc(x)=x+1}$
\end_inset

.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator observes both the 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 operator and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 These established connections are then utilized for change propagation,
 interacting with the connected user interface (UI) fields.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The sequence diagram in creating the subscriptions of the components of
 a formula
\end_layout

\end_inset

The sequence diagram in creating the subscriptions of the components of
 a formula.
 The diagram is for the formula illustrates 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 Each of the components of the formula is an object, which subscribes and/or
 being subscribed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{next(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{next(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{next(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{next(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{next(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the formula, utilizing the 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Integration
\end_layout

\begin_layout Standard
As 
\begin_inset Formula $\RIVar$
\end_inset

s consist of observable streams we facilitate binding with the UI.
 Once a UI change event occurs, it adds an event to the stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 In this way, we created a .NET Windows Forms application, a web application,
 and an HTML page (available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

).
 Similarly, it should be easy to integrate with various development environments.
\end_layout

\begin_layout Standard
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Later, we created similar work with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 to make the framework avaiable to more users, and to be able to use it
 online.
 In order to use it, the developer need to add our rivar.umd.js script and
 also rxjs.umd.min.js.
 The Drug Administration then availability online in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation/RIVar/DrugAdministration.html
\end_layout

\end_inset

 from the code in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/Evaluation/blob/main/RIVar/DrugAdministration.html
\end_layout

\end_inset

.
 In order to evaluate against modern applications, we chose to integrate
 also with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
 There 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 is inherently the state management solution.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{React}$
\end_inset

 takes a functional approach creating visual views, which are pure functions.
 We used this approach to create a "visual 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

" , where the view continuously reflects the value.
 For instance, 
\begin_inset Formula $\LSTINLINE{InputField}$
\end_inset

 are bound to 
\begin_inset Formula $\LSTINLINE{var}$
\end_inset

 which is an instance of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 set in the 
\begin_inset Formula $\NAME{props}$
\end_inset

, which are the element attributes.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

 <InputField rivar={var} />
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This can be used to compose a larger component that its view depends on
 a larger object.
 Which then used to compose the larger components similar to micro-frontend
 architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

 as illustrated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:react_micro_frontends"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
———————————
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
This is s a common phenomenon in sensor data acquisition
\end_layout

\begin_layout Standard
This phenomenon is known from sampling by sensors.
 It may be several sensors that sample a single phsicial variable.
\end_layout

\begin_layout Standard
The variables are continuously re-evaluated according to the most recent
 value, from any of the assigned expressions or input.
 For example, if the application contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

, executing 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B:=3}$
\end_inset

, causes 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to contain 
\begin_inset Formula $\LSTINLINE1$
\end_inset

,
\begin_inset Formula $\LSTINLINE2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE3$
\end_inset

.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
it is figured out that one of variables has two incoming edges.
\end_layout

\begin_layout Standard
as a change in one variable (of its contained value) causes transitively,
 through a chain of changes, this same variable to change again
\end_layout

\begin_layout Standard
We absract variables and dependencies as a directed graph, where each node
 represents a variable, and the edges are constructed according to a flow
 of updates.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in a cycle, we start from an incoming edge into a node, that is a cycle's
 first node, then through several nodes untill reaching again the first
 node from another edge.
 Yet, it is discovered, that a cycle's first node has two incoming edges.
 
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
Through this directed graph, named as 
\emph on
dataflow graph
\emph default
, we uncover syntax and semantics.
 First, we make a process similar to reverse-engineering: according to such
 a graph, we name as 
\emph on
dataflow graph
\emph default
, we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=f(B).
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
 From this investigation, we find an idea of a new semantic to cycles as
 belonged to a broader concept, that any variable, including input variables,
 can depend on several expressions simultaneously.
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
A second idea is that two incoming edges represent collecting values from
 observing a single phnomenon by more than one option.
\end_layout

\begin_layout Standard
A second idea is inspired from the concept of 
\emph on
observable streams
\emph default
 and of 
\emph on
merging
\emph default
.
 Each variable and expression abstracts values over time axsis, similar
 to as oservable stream is depicted.
 In case that the two incoming edges produced from two expression, then
 it is very closed to the concept of the merge function.
 As an observable stream, the variable observe two elements (that the souce
 nodes represent), so that whenever
\end_layout

\begin_layout Standard
The variable will behave as an observable
\end_layout

\begin_layout Standard
Even when the first incoming edge is produced from a input, the merge 
\end_layout

\begin_layout Standard
A node with two incoming edges refer to a concept similar to a merge function.
 If the two incoming edges produced from two expression, then it is very
 closed to the concept of the merge function.
 If the first incoming edge is produced from a input, then 
\end_layout

\begin_layout Standard
variable that that its values are 
\end_layout

\begin_layout Section
Composite Graphs
\end_layout

\begin_layout Standard
In FRP, reactive variables are used to create a data depedancy graph.
 In large scale applications, it might be with any nodes (variables) and
 edges (depedencies).
 We name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges.
 When observing a sugraph, other subgraphs does exist, with common nodes
 (meaning that a node can be observed in diffrent subgraphs).
 When observing a sugraph, the other graphs are not observed.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Standard
In software development, the ability to zoom in and out on the problem that
 software solves is a concept often discussed in software development and
 design.
 This concept is closely related to the idea of abstraction and granularity.
 In diffrent prespectivs diffrent details are observed, ignoring other details.
 It is related to the seperation of concern principle, that the diffrent
 concern are handled independenctly, without to observe other concrens
\end_layout

\begin_layout Standard
In Functional Reactive Programming (FRP), reactive variables are utilized
 to construct a data dependency graph, which forms the backbone of reactive
 systems.
 As applications scale in complexity, this graph can grow significantly,
 comprising numerous nodes (representing variables) interconnected by edges
 (depicting dependencies).
 The concept of "zooming in" comes into play when we focus our attention
 on a specific subset of this graph, forming what we term a subgraph.
 A subgraph consists of a distinct set of nodes and the corresponding edges
 that link them.
 Notably, while we observe a subgraph, other subgraphs coexist within the
 larger graph, sharing common nodes.
 It's crucial to emphasize that when we zoom in on a particular subgraph,
 we do so at the exclusion of others; thus, we overlook the broader context
 of the entire graph.
 This practice resonates closely with the principle of Separation of Concerns,
 wherein each subgraph represents an independent concern, allowing for focused
 and modular handling of specific aspects of the system's behavior or functional
ity.
\end_layout

\begin_layout Section
Non-Hierarchical FRP
\end_layout

\begin_layout Standard
–
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In terms of OOP, the problem is that objects update their instance variables
 in response
\end_layout

\begin_layout Standard
With the OOP abstraction, each object is a responsibility to update its
 internal fields according to other fields, by registering their code in
 the coresponding objects.
\end_layout

\begin_layout Standard
Real world systems can be abstracted using OOP.
 Each variable of an object in the real-world is mapped to an instance variable
 of a coresponding object.
 Each object has a responsibility that is bounded within the object.
 
\end_layout

\begin_layout Standard
OOP is another platform by which the problem will be abstracted.
\end_layout

\begin_layout Standard
Each component can be represented by an object of OOP.
 Using class-based OOP, each class defines behavior of a group of objects.
 In the class, there are variables that will be in runtime the instance
 variables, that represent variables of objects from the real world.
\end_layout

\begin_layout Standard
OOP provides a platform to abstract the problem, as tool OOP is helpful
 for cencepetual modeling, to abstract objects of the real world.
\end_layout

\begin_layout Standard
is a paradigm that ease some aspects of concetual modeling.
\end_layout

\begin_layout Standard
An abstraction to the problem
\end_layout

\begin_layout Standard
OOP, as a paradigm of cencepetual modeling helps in provding an abstraction
 to the problem.
\end_layout

\end_body
\end_document
