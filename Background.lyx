#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

Background and Motivation
\end_layout

\begin_layout Standard
We are studying a subset of front-end applications, focusing on how to divide
 them into small components with non-overlapping logic.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations"
plural "false"
caps "true"
noprefix "false"

\end_inset

 provides an example of interdependent fields in a front-end application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c c c| }    
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Drug & Concentration & VolumeOfFluid 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
framebox(35,15){
\backslash
textit{100}} & 
\backslash
framebox(35,15){
\backslash
textit{0.33}} & 
\backslash
framebox(35,15){300} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline  
\end_layout

\begin_layout Plain Layout

 Dose & Duration & Rate 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

 
\backslash
framebox(35,15){10} & 
\backslash
framebox(35,15){10} & 
\backslash
framebox(35,15){
\backslash
textit{30}} 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-calculations"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
User interface for drug administration.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

This is a user interface for drug administration.
 User-defined values are displayed in regular typeface, while calculated
 values are displayed in italic typeface.
 The field 
\backslash
lstinline{Drug} specifies the amount of medication administered to the patient,
 for example, 100 mg.
 The field 
\backslash
lstinline{VolumeOfFluid} indicates the volume of fluid mixed with the drug,
 for example, 300 ml.
 The field 
\backslash
lstinline{Concentration} represents the amount of the drug per unit volume
 of fluid, for example, 0.33 mg/ml.
 The field 
\backslash
lstinline{Rate} specifies the flow rate of the fluid into the patient's
 body per unit of time, for example, 30 ml per hour.
 The field 
\backslash
lstinline{Dose} represents the dosage, which is the amount of drug administered
 to the patient's body per unit of time, for example, 10 mg per hour.
 The field 
\backslash
lstinline{Duration} indicates the duration of the injection, from the start
 to the end.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

If edited triple is of Dose,  Duration, and VolumeOfFluid
\end_layout

\begin_layout Plain Layout

  Drug = Dose*Duration
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

  Rate = VolumeOfFluid/Duration
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Drug, Dose, and Rate
\end_layout

\begin_layout Plain Layout

  Duration = Drug/Dose
\end_layout

\begin_layout Plain Layout

  VolumeOfFluid = Duration*Rate 
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Concentration,  Volume, and Duration
\end_layout

\begin_layout Plain Layout

  Drug = Volume*Concentration
\end_layout

\begin_layout Plain Layout

  Rate = VolumeOfFluid/Duration 
\end_layout

\begin_layout Plain Layout

  Dose = Drug/Duration
\end_layout

\begin_layout Plain Layout

End If
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Centerlized-Calculation"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug administration calculation.
\end_layout

\end_inset

Example calculation logic for interdependent fields in a drug administration
 front-end application.
 The code shows how to calculate the values of the fields Drug, Concentration,
 VolumeOfFluid, Dose, Duration, and Rate based on different combinations
 of three input fields.
 When fields are interdependent like this, updating one field requires modifying
 all the locations where the other fields are updated, creating a centralized
 maintenance model.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Events
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The OOP paradigm provides an alernative by the observer pattern.
 Objects can provide observers to register, to later execute tehri code,
 whenever variables are updated.
 Similary, objects can expose an OnChange event, that will be used to eceute
 code that update dependant variables.
 Cross systems, there are sometimes hooks, to call external code in response
 to a change in the data.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(I wrote this, and asked the gpt generate )The Observer pattern in Object-Orient
ed Programming (OOP) can adress the issue of interdependent fields in for
 front-end applications.
 Objects can contain variables that are equivalent to the fields in UI applicati
ons.
 By using the Observer pattern or events, it is possible to register code
 to be executed when a field or a variable is changed.
 Otherwise, code that update a variable (or a field) might be changed, to
 update other depedant variables.
 Instead, by t the observer pattern, we have the ability to hide logic,
 which can help to separate concerns and make code easier to manage.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Objects can use the observer pattern, or expose events to execute code when
 fields are updated, to enable other fields to be updated accordingly.
 If the code that updates one field needs to directly update additional
 fields, modifying the code to update one field might require changing the
 locations in the code where the other fields are updated.
 This leads to a centralized maintenance model, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where all the calculation logic is centralized and tightly coupled, making
 it difficult to isolate the code for each field.
 As an alternative, each field or variable has an onchange event, and multiple
 event handlers are registered, that update depedant fields.
\end_layout

\begin_layout Standard
In reality, the onchange events did not effectively address the issue.
 It has been observed that relying solely on onchange events based on object
 contracts can lead to unexpected updates and values, as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 To address this issue, developers often add logic to determine when to
 update variables.
 Many modern applications use tools like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
XState
\end_layout

\end_inset

 (https://xstate.js.org) or 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Redux
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 to model events as state transitions between logical states 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 derived from variable values.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools allow specifying updates not only when an event occurs but
 also based on the exact state of the application, which is derived from
 previous interactions.
 However, this approach still relies on centralized management of the applicatio
n's state, making it a monolithic approach.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The provided strategy enables many patterns.
 One such strategy is to develop a single calculation procedure that can
 be implemented and called in response to field change events.
 However, this approach has the disadvantage of recomputing fields even
 when they do not need to be recomputed, which can lead to performance issues
 and unnecessary re-rendering of field values that have not been updated.
 Furthermore, a single calculation procedure can become overly complex and
 difficult to maintain as the application grows.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}      
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{VolumeOfFluid=300}{Bag}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Concentration=0.33}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Drug=99}{Bag}{}  
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Rate=30}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}        
\end_layout

\begin_layout Plain Layout


\backslash
end{call}   
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Calculation-spread-over-objects-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A sequence diagram for the drug administration behavior.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

The drug administration behavior is represented by a sequence diagram, which
 is divided into two objects or microfrontends.
 The task of performing calculations is shared between the 
\backslash
lstinline{Pump} and 
\backslash
lstinline{Bag}.
 Initially, the user specifies a 
\backslash
lstinline{Dose} of 10 and a 
\backslash
lstinline{Duration}.
 In response, the 
\backslash
lstinline{Drug} is calculated to be 100.
 Next, the user sets the 
\backslash
lstinline{VolumeOfFluid} to 300, which causes the 
\backslash
lstinline{Concentration} to be calculated as 0.33.
 However, the subsequent calculation of 
\backslash
lstinline{Drug} unexpectedly results in 99.
 This unpredictability can be attributed to two factors.
 Firstly, during the update of 
\backslash
lstinline{Concentration}, the value of 100/300 was rounded, leading to the
 loss of information in the process.
 This caused 
\backslash
lstinline{Concentration} to be calculated as 0.33, and consequently, 
\backslash
lstinline{Drug} was calculated to be 99.
 Secondly, there was a cycle in which 
\backslash
lstinline{Concentration} was updated based on 
\backslash
lstinline{Drug}, which was in turn updated based on 
\backslash
lstinline{Concentration}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {S1};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {S2};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {S3};
\end_layout

\begin_layout Plain Layout

   
\backslash
node[rounded corners=1.5mm,minimum width=4cm,inner sep=1mm,above right,draw,align
=center,text width=26mm] (S4) at (1.2,-3) {S4
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont y changed/calculate x
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont z changed/calculate x};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180,in=90] (S1);
\end_layout

\begin_layout Plain Layout

      
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.5] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.5] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.5] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.5] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)] (System) {};
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Statechart.
\end_layout

\end_inset

This statechart models the handling of events to calculate the value of
 x based on changes in the variables y and z.
 The statechart consists of states S1, S2, S3, and S4, with transitions
 triggered by events 'y changed' and 'z changed'.
 Whenever either y or z changes, the calculation of x is triggered.
 This statechart serves as an illustration of a model where events are not
 used to separate concerns in objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
DataFlow
\end_layout

\begin_layout Standard
Frameworks based on the dataflow paradigm allow for the explicit specification
 of data dependencies, which were previously implicit.
 In FRP, data dependencies are constructed using pure functions, like the
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Signals
\end_layout

\end_inset

 in 
\begin_inset Formula $\REScala$
\end_inset

.
 Alternatively, frameworks for event streams, like 
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The dataflow paradigm provide frameworks to explicity specify the data dependenc
ies, that previously specified implicity.
 In the FRP paradigm data dependencies are composed as pure functions.
 Alternatively, events streams frameworks, such as ReactiveX, enable to
 function over the streams, such that each each stream produces its values
 depending on the values of the input streams.
 It is often claimed that, in order to provde 
\emph on
predictability,
\emph default
 the graph should be acyclic.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The observer pattern can be used with the iterator pattern to provide observable
 stream.
 Observables streams push values notifications to their subsribers.
 On top of it, operators over observable stream, produce values to subseuent
 subscribers, based on the input observable streams.
\end_layout

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, some applications, including the example we provided, inherently
 have cycles in their data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, ensuring that the dependency graph is acyclic becomes a challenge,
 and it limits the ability to separate the code.
 Developers need to be aware of data dependencies and detect existing paths
 before adding new formulas that involve existing variables to prevent cycles.
 For example, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 Consequently, it is not possible to establish boundaries that prevent access
 to the formulas, which can lead to a monolithic codebase.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
However, many applications, as our example, have cycles by their nature
 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, in order to ensure that the graph is acyclic, the ability
 to seperate the code is reduced.
 Because, in order to ensure that the graph is acyclic, developers must
 ensure that no node has a path leading back to itself.
 This requires the developer to have knowledge of data dependencies and
 to detect existing paths before adding new formulas that involve existing
 variables.
 If a cycle is detected, the developer should avoid adding the new formula
 to the graph to prevent the creation of a cycle.
 For instance, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 If a calculation is linked to a variable, but the variable has dependencies
 that fall under a separate concern, it is linked without considering those
 dependencies.
 This means that the graph may not necessarily be acyclic.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
While in the events paradigm, developers 
\emph on
implicitly
\emph default
 create a 
\emph on
data dependency graph
\emph default
, frameworks such the ones of FRP provides this explicity.
\end_layout

\begin_layout Plain Layout
The FRP paradigm, enable to express reactive variables as pure functions,
 so that the data dependemcy management can be predictable composed, depending
 on the 
\emph on
referential transparency
\emph default
 property.
\end_layout

\begin_layout Plain Layout
In the FRP paradigm reactive variables are defined as functions over other
 reactive variables, while the runtime maintains the variables' values.
 The runtime uses a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 to manage the updates.
\end_layout

\begin_layout Plain Layout
accordingly, using a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In REScala, also instance variables can be reactive variables (i.e., objects
 can have reactive variables as part of their interface) having such runtime
 to maintain them 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 For example, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

 defines the reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 to be a function of reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 The runtime uses a graph ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Directed-acyclic-graph"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to automaticaly maintain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

.
 Consequently, there is no need to repeat registering to events to re-calculate
 variables like the ilustration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The FRP paradigm has the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 from being based on pure functions, with the meaning that the same input
 will produce consistently the same output.
 Consequently, the FRP paradigm provides predictability in scaling the applicati
on.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y) at (2,5) {Y};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Z) at (4,5) {Z};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (X) at (3,3) {X};
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Z) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(X) + (0,1)$)    {X:=Y+Z};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Directed-acyclic-graph"

\end_inset

Directed acyclic graph data structure representing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (C);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (D);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,1)$)    {B:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,1)$)    {C:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(D) + (0,1)$)    {D:=B+C};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch"

\end_inset

A data dependency graph, that in push-based evaluation, might have glitches.
 The nodes represent variables that should be updated either by input or
 by updating according to the specified function in the label.
 Each variable's update leads to update the depedencies.
 Updating A leads to updating B and C, each leads to updating D.
 In the first update, the value is incorrect (a glitch), because B or C
 has not been updated yet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Cycles"

\end_inset

Cycles
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, where FRP runtimes are developed, There are two opposing
 methods about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
FRP runtimes that support cycles uses various techniques to stop arisen
 loops.
 Terminating when it closes a cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, adding to the language a special operator to inform the runtime when to
 break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

, stop after a number of iterations, stop if the value has not changed,
 or changed only less than a threshold (available in 
\emph on
Microsoft Excel
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

).
 The various methods caused from the unknown, that a repeating update is
 either needed because previous update was a glitch, or that it is unneeded
 because the repeating update is caused from a cycle.
\end_layout

\begin_layout Plain Layout
Our model provides the semantics described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Any-Formula"
plural "false"
caps "true"
noprefix "false"

\end_inset

: cycles are resulted from variables with more than one source.
 Those variables are updated whenever there is a newer value from any of
 the sources.
 Technically, loops are terminated, because values caused from cycles are
 not newer.
 However, we are not the first to handle cycles, as said in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, constraints systems that handle two-way constraints handle cycles by their
 nature 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Nevertheless, the model treats the meaning issue about cycles more explicity.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
duplication
\end_layout

\begin_layout Plain Layout
Comparing to the traditional pure frp, we increased the ability to extend
 applications.
 Because that variables as pure functions can be extended by only deriving
 variables.
 This limitation in FRP, to not link calculations to existing variables
 causes variables duplications.
 Becasue, if we cannot target to exsting variable, we create a new one.
 (excel examples)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Standard
FRP shares with the paradigm of constraint systems the idea, that developers
 declare equations, and the runtime automates variable updates according
 to the equations and input.
 However, they are different: FRP is about defining variables as functions
 of other variables, while constraint systems are about to satisfy constraints.
\end_layout

\begin_layout Standard
There are constraint systems similar to FRP that handle one-way constraints
\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Other constraint systems like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 handle two-way constraints
\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

.
 Constraint systems that handle two-way constraints, by their nature, handle
 cycles, and allows defining multiple constraints that output to the same
 variable
\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Actually, the developers declaring two-way constraints need to declare
 also the one-way constraints, e.g., in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 is attached with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=A-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C:=A-B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The FRP runtime uses 
\emph on
constraints solver
\emph default
 to maintain the variables
\emph on
.
 
\emph default
The constraints solvers are algorithms developed for constraint systems
 to satisfy the constraints.
 In order to solve a set of two-way constraints, the constraints solver
 uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 There are cases that the algorithm cannot satisfy all the constraints,
 then it satisfies only those that are specified to be in a higher hierarchy.
 For example, having the following constraints hierarchy in the descending
 order 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=2}
\end_layout

\end_inset

, the constraints solver will satisfy only the first two constraints, by
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=1}
\end_layout

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints derived from the variables.
 For each variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 containing a value 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x}
\end_layout

\end_inset

, the runtime maintains a constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X=x}
\end_layout

\end_inset

, with hierarchy according to the order of the input.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1"

\end_inset

two-way constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 implemented by 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy"

\end_inset

Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
title(observable streams)....Although the high level abstraction, the events
 concept still exist in the paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional,proencca2017quality"
literal "false"

\end_inset

.
 In the approach used by ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, functions over 
\emph on
events streams
\emph default
 are declared, preserving the referential transparency property.
 Actualy reactive variables can be represented by events streams representing
 the varying value over time, similar to a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 However, there is a big difference between the original reactive variable
 to this representation.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1"

\end_inset

An events stream representing a varying value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In addition to the more verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 achieved by events streams, the mechanism is very different.
 Functions over events streams are typicaly not handled by a special runtime
 with the graph data structure.
 Instead, the events streams are 
\emph on
observables
\emph default
, with 
\emph on
operators
\emph default
 over them, that subscribe and produce events streams.
 Accordingly objects can have reactive variables as part of their interface,
 while the values are propagated according to the events mechanism.
 Generally speaking, reactive variables as events streams does no depend
 on the madiator exists in the original FRP, because they interact directly.
\end_layout

\begin_layout Plain Layout
The madiator has access to all the variables and formulas, so it can provide
 more predictable behavior.
 For example, if one variable has several updates caused by a single update,
 such as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

.
 In case that the variables interact directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will have an incorrect update named 
\emph on
glitch.
 
\emph default
In contrast, a madiator has the knowledge of the special construction to
 handle the updates correctly.
 So 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will be updated only when both 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

 has been updated.
 Even though the madiator can provide more predictable behavior, there are
 sometimes requirements that prefer directed interaction over a madiator.
 For example, typical distributed applications prefer directed interacton
 to reduce perfomance.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In front-end applications, developers may create a data dependency graph
 either explicitly or implicitly to populate fields based on other fields.
 However, in certain scenarios where the application's data dependencies
 are complex, a centralized or monolithic graph might be required.
 This means that the data dependency definitions are located in a single
 code base that cannot be separated, or the runtime relies on an intermediary
 for variable updates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, where fields are automatically filled based on
 other fields, the developers explicity or implicitly create one centeral
 
\emph on
data dependency graph
\emph default
 in which updates to variables recursively trigger updates to dependent
 variables.
 This graph
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The existing frameworks suggest seperating between declating dependencies
 to maintaining them, between diffrent acyclic graphs only if ther are unconnect
ed or that they produced acyclic graph,
\end_layout

\begin_layout Plain Layout
There are FRP runtimes that are based on the traditional simple methods
 calls, and are unpredictable.
 Others more predictable solutions use a madiator with the added complexity
 of having another layer needed to the application.
 There are FRP runtimes for distributed applications that do not use a madiator,
 but as the FRP paradigm, they support only the sets of formulas producing
 directed acyclic graphs.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
