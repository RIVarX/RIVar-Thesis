#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
The concepts for RIvar
\end_layout

\begin_layout Standard
Harmonizing several concepts with the name 
\emph on
variable
\emph default
 required some background.
 In programming, a mere variable refers to symbolic name associated to memory
 address which contains value, reactive variables refers to handling consistency
, instance variable refers to 
\emph on
identity
\emph default
, i.e.
 real worlds object's variable.
\end_layout

\begin_layout Subsection
Identity
\end_layout

\begin_layout Standard
In a general study, variable (or attribute) represents quality of an object.
 Objects refers to things in our world such as persons, cars and so on.
 Variables examples can be person's age, car's price and so on.
 Even tough in software, variable is only symbolic name associated to memory
 address which contains value, it may represent real world variable.
\end_layout

\begin_layout Subsubsection
OOP
\end_layout

\begin_layout Standard
OOP is the paradigm promoting refering objects to real world objects.
 Therfore the instance variables should refer to real world objects variables.
 Similar to how we understand the world, there is a formal seperation between
 exposed instance variables accessors, the 
\end_layout

\begin_layout Standard
Instance variables can be exposed by accessors, and handle massages containing
 values settings.
\end_layout

\begin_layout Standard
Variable may represent real world variable, even if it is a plain symbolic
 name associated to memory address, it may contain value represents the
 real world variable's value.
 Accordingly, variable may be referred by different names, depending on
 the context.
 This concept remind what is called 
\emph on
identity
\emph default
.
 
\end_layout

\begin_layout Standard
In OOP, objects represent the identity of real world objects, therefore
 their instance variables should represent the real world variable.
 Accordingly, objects can inherit other objects, with the 
\begin_inset Quotes eld
\end_inset

is-a
\begin_inset Quotes erd
\end_inset

 relationships, associated to each other with 
\begin_inset Quotes eld
\end_inset

has-a
\begin_inset Quotes erd
\end_inset

 relationships, and has a formal distinction between objects interface and
 its implementation, to be referred to callers depending on the context.
 
\end_layout

\begin_layout Standard
Specificaly, The formal distinction applies between messages sending values
 to a setter, the variable itself, and other messages calling that setter.
\end_layout

\begin_layout Subsection
Consistency
\end_layout

\begin_layout Standard
Functions are implemented to get how a varying variable's value depends
 on another variable's value.
 Handle consistency means executing the functions, in response to observing
 new values, to update dependant variables with the change.
 Traditionaly we can observe change events and call the calculate function
 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue.changed += { (e) -> powerDierence = f(e) }
\end_layout

\end_inset

, while this is automatic in frameworks facilitate directly representing
 the functional dependency by declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence = f(sensorValue)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Referential Transparency
\end_layout

\begin_layout Standard
In FRP, Reactive Variables are declared similar to pure functions, and the
 framework automaticaly calculates the values in response to new values
 provided.
 For example declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout

Age := CurrentDate-BirthDate
\end_layout

\end_inset

, produce 
\begin_inset ERT
status open

\begin_layout Plain Layout

Age
\end_layout

\end_inset

 to be refreshed automaticaly according to the varying values of 
\begin_inset ERT
status open

\begin_layout Plain Layout

BirthDate
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

CurrentDate
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Declaring variables as calculation tree, leads to very 
\emph on
predictable
\emph default
 programs: the same input produces the same output every time we execute
 it.
 This is similar to invoking pure function, without side effect, so produces
 consistent result, attributed as 
\emph on
referential transparency
\emph default
.
 In such programs, substituting variable by its expression, does not affect
 the program.
 Consequently, changing the code have predictable effect, so programs become
 rubust against changes.
\end_layout

\begin_layout Subsubsection
Constraints
\end_layout

\begin_layout Standard
There are libraries which automaticaly handle variables consistency, according
 to a set of constraints.
 Take for example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

, there are three methods to satisfy the constraint: 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = Total - Tip
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip = Total - Price
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

.
 In response to any new input, the library choose what method to execute
 to satisfy the constraint.
\end_layout

\begin_layout Standard
When more constraints are specified and against varying input options, choosing
 the methods to execute, become not trivial.
 Therefore, various algorithms have been developed named 
\emph on
constraints solvers
\emph default
.
 The principal is to prioritize the constraints, and iterate them, choosing
 methods which does not override variables that already satisfied by previous
 chosen methods.
 The inputs are considered as contraints, for example if user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip
\end_layout

\end_inset

 with the input 
\begin_inset ERT
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, then the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip=10
\end_layout

\end_inset

 is added to the set.
 Accordingly, constraints are prioritized according to the order of the
 inputs.
\end_layout

\begin_layout Standard
Constraints solvers are actualy choose a consistent way to handle conflicts.
 If we add to the above example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = OriginalPrice - Discount
\end_layout

\end_inset

, then it might be wandered from where 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price
\end_layout

\end_inset

 should be calculated.
 Popular libraries usually take weaker approaches to handle consistency,
 they populate changes in one-way (as reactive variables), until an arbitrary
 condition, with the cost of sometimes having non-predictable results.
\end_layout

\begin_layout Section
Tools for implementing RIvar
\end_layout

\begin_layout Subsection
Observable Streams
\end_layout

\begin_layout Standard
Stream is somethimes thought as a complex concept to understand and use.
 However under certain circumstances, it produces functional and predictable
 code even for complex reactive applications.
 
\end_layout

\begin_layout Standard
Form's textbox's content can be changed over time, most libraries today
 handle this as events.
 When handling events we executing functions without controling its time.
 For our textbox, it can be calculate another textbox according to the change.
 Forms textboxs' contents can be composed to streams and produce functional
 code.
\end_layout

\begin_layout Section
Reactive Programming - Do not read 
\end_layout

\begin_layout Standard
Reactive Programming (RP) harmonizes concepts from traditional paradigms
 for programming reactive systems: Events, Unidirectional Dataflow and Constrain
ts.
 Each of the paradigms addresses has a unique abstraction mechanism to manage
 inconsistencies, which might exist in the runtime data and static data.
 Inconsistency in runtime data refers to non-valid states, of which variables'
 values have not been calculated in accordance to other variables' values.
 Inconsistency in static data refers to those bugs causing by an error-prone
 process, handling code-changes several times.
 Reducing inconsistency in static data is handled by reducing code repetition
 by paradigms' independent reusable units.
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
Events (or observer pattern) are used for reusable objects, so that objects
 will not depend on specific callers, but the callers would subscribe/listen
 to their relevant events.
 We can implement events that would execute in response to variables' changes,
 triggering event handlers which would trigger other variables to calculate
 considering the new values.
\end_layout

\begin_layout Subsection
Unidirectional Dataflow
\end_layout

\begin_layout Standard
Reactive systems may be abstracted as composed mathematical functions, using
 reactive variables or streams (by managing effects).
 In this manner, we can specify reusable code of how to calculate data by
 other data.
 In runtime, while an input device produces an input, the system will produce
 a changes chain according to the program, until triggering the output devices
 to produce the effects.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
There are reactive systems which can be abstracted as multidirectional constrain
ts (One-way dataflow constraint is similar to unidirectional dataflow as
 in 2.2).
 Constraints solvers (algorithms) manage the runtime, to handle any input
 and update variables to satisfy the constraints.
\end_layout

\begin_layout Section
Object-Oriented Programming - do not read
\end_layout

\begin_layout Standard
Objects refers to real-world objects (e.g.
 Persons), described by the property named 
\emph on
identity
\emph default
.
 The real-world objects' variables (or attributes) (e.g.
 Persons' weight) are represented by objects' instance variables.
 Specifically, an instance variable may be an association to another object's
 identity.
 The real-world objects' variables' values 
\emph on
vary
\emph default
 during their life-cycle, simulated by 
\emph on
updating
\emph default
 the instance variables content.
 
\end_layout

\begin_layout Standard
(Originaly objects are like components, used to save time by using ready-to-use
 components instead of develop again and again.
 Accordingly, doing a new feature or a bug fix, can be performed once.
 However, we should be carful about components' changes, to prevent from
 unexpected changes.
 
\end_layout

\begin_layout Standard
We recognize two mechanizms to prevent from unexpected changes.
 First, components have 
\emph on
interfaces
\emph default
 as contracts, seperating the specification from the implementation details.
 Second, instance variables are encapsulated, each object manage its instance
 variables seperatly.
\end_layout

\begin_layout Standard
There are several related technical issue preventing from being that elegant
 paradigm.)
\end_layout

\begin_layout Subsection
Vary the Variables Responsibility
\end_layout

\begin_layout Standard
By definition, objects maintain their internal state (data), resulting limitatio
n in abstracting objects' variables' changes: to be included only in the
 code of the object containing the variables.
 To rid of the limitation, objects implement accessors methods to manipulting
 their instance variables.
 However, the data is stopped from being controlled by its containing object.
\end_layout

\begin_layout Standard
This is in contrast to keep controlling the objects , from the real-world
 aspect (or the modeller point of view), certain variable changes should
 be part of another object.
 In addition, deriving a class, by the mean of object reuse.
\end_layout

\begin_layout Subsection
Reentrance
\end_layout

\begin_layout Standard
The indirect nature of objects leads to recursive invoke methods, in which
 object sending a message is unaware of the receiver identity and whether
 this message is not a re-entrance.
 When receiving a message, one should be aware of the caller, thus it cannot
 distinguish between initial calls, or recursive calls.
\end_layout

\end_body
\end_document
