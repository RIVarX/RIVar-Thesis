#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
Variables
\end_layout

\begin_layout Standard
Variable may refer to symbolic name associated to memory address which contains
 value.
 However, variable can be extended to more advanced terms.
\end_layout

\begin_layout Subsection
Instance Variable
\end_layout

\begin_layout Standard
In OOP, objects represent the identity of real world objects, therefore
 their instance variables should represent real world variables.
 Generaly, variable may represent real world variable, even if it is a plain
 symbolic name associated to memory address, it may contain value representing
 real world variable's value.
\end_layout

\begin_layout Standard
In general research, variable is related to attribute, that is quality of
 an object, e.g.
 person's weight.
 Variables' values 
\emph on
vary
\emph default
 over time.
 In software, it is very common to simulate the real world variables' values
 by assigning the variables values whenever the software determines a change.
\end_layout

\begin_layout Standard
OOP is a perfect platform to simulate the real world variables.
 By implementing 
\begin_inset Quotes eld
\end_inset

is-a
\begin_inset Quotes erd
\end_inset

 (inheritance) and 
\begin_inset Quotes eld
\end_inset

has-a
\begin_inset Quotes erd
\end_inset

 relationships, variables can be referenced with different terms depending
 on the context.
 This involves a formal distinction between messages sending values to a
 setters, the variables , and other messages calling that setters.
\end_layout

\begin_layout Subsection
Reactive Variable
\end_layout

\begin_layout Standard
In contrast to traditional variables, reactive variables is automatically
 consistent according to defined formulas.
 In such frameworks, reactive variable 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 assigned by an expression is populated in response to changes in the value
 of any of the variables existing in the expression.
 For example, the meaning of the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 is that variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, so that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Variables' Values' Consistency
\end_layout

\begin_layout Standard
Functions are implemented to get how a varying variable's value depends
 on another variable's value.
 Handle consistency means executing the functions, in response to observing
 new values, to update dependant variables with the change.
 
\end_layout

\begin_layout Standard
Traditionaly we can observe change events and call the calculate function
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{sensorValue.changed += { (e) -> powerDierence = f(e) }}
\end_layout

\end_inset

, while this is automatic in frameworks facilitate directly representing
 the functional dependency (
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence
\end_layout

\end_inset

 depending on 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue
\end_layout

\end_inset

) by declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{powerDierence = f(sensorValue)}
\end_layout

\end_inset

.
 The variables and dependencies form a 
\emph on
dependencies graph
\emph default
.
\end_layout

\begin_layout Subsection
Referential Transparency
\end_layout

\begin_layout Standard
In FRP, Reactive Variables are declared similar to pure functions, and the
 framework automaticaly calculates the values in response to new values
 provided.
 For example declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Age := CurrentDate-BirthDate}
\end_layout

\end_inset

, produce 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Age}
\end_layout

\end_inset

 to be refreshed automaticaly according to the varying values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{BirthDate}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{CurrentDate}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Declaring variables as calculation tree, leads to very 
\emph on
predictable
\emph default
 programs: the same input produces the same output every time we execute
 it.
 This is similar to invoking pure function, without side effect, so produces
 consistent result, attributed as 
\emph on
referential transparency
\emph default
.
 In such programs, substituting variable by its expression, does not affect
 the program.
 Consequently, changing the code have predictable effect, so programs become
 rubust against changes.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
There are libraries which automaticaly handle variables consistency, according
 to a set of constraints.
 Take for example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

, there are three methods to satisfy the constraint: 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = Total - Tip
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip = Total - Price
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

.
 In response to any new input, the library choose what method to execute
 to satisfy the constraint.
\end_layout

\begin_layout Standard
When more constraints are specified and against varying input options, choosing
 the methods to execute, become not trivial.
 Therefore, various algorithms have been developed named 
\emph on
constraints solvers
\emph default
.
 The principal is to prioritize the constraints, and iterate them, choosing
 methods which does not override variables that already satisfied by previous
 chosen methods.
 The inputs are considered as contraints, for example if user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip
\end_layout

\end_inset

 with the input 
\begin_inset ERT
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, then the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip=10
\end_layout

\end_inset

 is added to the set.
 Accordingly, constraints are prioritized according to the order of the
 inputs.
\end_layout

\begin_layout Standard
Constraints solvers are actualy choose a consistent way to handle conflicts.
 If we add to the above example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = OriginalPrice - Discount
\end_layout

\end_inset

, then it might be wandered from where 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price
\end_layout

\end_inset

 should be calculated.
 
\end_layout

\begin_layout Subsection
Weak Approaches 
\end_layout

\begin_layout Standard
There are non FRP libraries, which handle declared functional dependencies
 by automatically calculating values in response to new values provided.
 In contrast to FRP, the calculations might be inpredictable.
\end_layout

\begin_layout Standard
The inpredictable is because, there can be cycles in the graph, even in
 declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout

A := B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B := A
\end_layout

\end_inset

.
 Furthermore, when applications use seperation tools provided in OOP, we
 cannot prevent from cycles.
 For example, declaring to calculate values for 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in response to new values provided to 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, does not require full control over of the two variables.
 So there might be another declaration referring to 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 which calculates values for 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 in response to new values provided to 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
When cycles exist, libraries use an arbitrary condition to stop the changes,
 to not enter an infinite loop.
 
\end_layout

\begin_layout Section
Events Stream
\end_layout

\begin_layout Standard
When handling applications over time, updating variables using the assigment
 operator, we identified time variation in the real world with time variation
 in the computer.
 Stream is an alternative to model phenomena over time, such as varying
 variable's value, without refering explicity the time.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{ReactiveX}
\end_layout

\end_inset

 is a popular library for the stream programming model.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{ReactiveX}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Observable}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Observer}
\end_layout

\end_inset

 implement the observer pattern for a sequence.
 Observers subscribe to Observables, and the Observables calls the observers'
 methods' 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{OnNext}
\end_layout

\end_inset

 for each item in the sequence.
 
\end_layout

\begin_layout Standard
Based on that observable sequence, there are operators to produce streams
 from observing other streams.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B.Select(b=>b+1)
\end_layout

\end_inset

, observe the items of a stream 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{B}
\end_layout

\end_inset

, whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{B}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

 is called, then the lambda expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{b=>b+1}
\end_layout

\end_inset

 is executed, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{b}
\end_layout

\end_inset

 containing the new value, then the result is used as parameter in calling
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The use of the operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Select}
\end_layout

\end_inset

, produces pure function over streams, and can compose other pure functions.
 For example: adding 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{C=A.Select(a=>a+1})
\end_layout

\end_inset

 to the program, is equivalent to writing only 
\begin_inset ERT
status open

\begin_layout Plain Layout

C=B.Select(b=>b+2)
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

Select
\end_layout

\end_inset

 is an example to the powerful operators provided, that reserves the functional
 purity, and calculate not only the values, but also 
\emph on
when
\emph default
 to get the values.
\end_layout

\begin_layout Standard
The values in the input stream, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}
\end_layout

\end_inset

 in the example, are triggered (by calling the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{OnNext}
\end_layout

\end_inset

), by an external execution, such as an input control, that calls 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

 whenever there is a change event.
 The items if the output stream is produced according to the time of the
 inputs stream's items.
 The values in the output stream is used to an external execution, such
 as updating an input control, by subscribing to the output stream (which
 is an observable).
\end_layout

\begin_layout Standard
Marble diagrams are useful to understand how operators operate the streams,
 as in figure 2.1, the input and output items are ilustrated over the time-axis.
 In the example (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Select}
\end_layout

\end_inset

 operator), whenever value is produced in the input stream, value in the
 output is provided.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure} 
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x0) at (1,0) {1};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4,0) {8};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x0) at (6,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x0) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=7cm] (op) {Select
\backslash
{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[baseline=-1mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,minimum height=6mm] (x) {x};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,minimum height=6mm,right=5mm of x] (y) {x+1};
\end_layout

\begin_layout Plain Layout

    
\backslash
draw [fdash] (x) -- (y);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

  
\backslash
}};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x2) at (1,0) {2};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x2) at (3,0) {4};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x2) at (4,0) {9};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x2) at (6,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x2) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x0) -- (0x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (5x0) -- (5x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (6x0) -- (6x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (0x2) -- (0x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x2) -- (2x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x2) -- (3x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x2) -- (5x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x2) -- (6x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Marble Diagram for an execution example for A=B.Select(b=>b+1) }
 
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
