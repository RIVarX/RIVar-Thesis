#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

Background
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The functionality, that fields are recalculated based on other fields, is
 familiar from 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Spreadsheets
\end_layout

\end_inset

.
 There, cells, representing the fields, can contain formulas to determine
 their values based on other cells.
 In application development, this functionality can typically handled using
 variables that are connected to the visual elements of the application.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We find several existing approaches that harmonize components-based applications
 with the functionality to calculate fields based on other fields.
 The functionality to calculate fields based on other fields is familar
 from spreadsheets where cells, that represent the fields, can contain formulas
 to determine the value based on other cells.
 Before delving into haronizing with components, we will present the familiar
 models used for fields calculation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The components-based applications 
\end_layout

\begin_layout Plain Layout
The functionality to calculate fields based on other fields can be achived
 by various approaches.
\end_layout

\begin_layout Plain Layout
The most popular application is spreadsheets, where cells, that represent
 the fields, can contain formulas to determine the value based on other
 cells.
 Among developers, the functionality 
\end_layout

\begin_layout Plain Layout
Alternatively, visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields.
\end_layout

\begin_layout Plain Layout
???
\end_layout

\begin_layout Plain Layout
provide it is hard to implement fields that are calculated according to
 other fields.
\end_layout

\begin_layout Plain Layout
This section should present the exsiting solutions for reactive variables,
 provdiing the understaning about the drawbacks existing in them, in the
 context of components-based applications.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This way, it aims to provide an alternatve to dealing with the mutate variables.
 The problem about the the variables is, that it is hard to reason about
 the values that variables contains.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Programming Models
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
In programming frameworks, such as in web development, code that update
 fields based on other fields, can be registered to be executed when a fields
 are changed.
 For example, in 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
JavaScript
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{input.addEventListener('input', calculate)}
\end_layout

\end_inset

 means to execute 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{calculate}
\end_layout

\end_inset

, when the user interacts with the input element by changing its value.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Observable-Streams"

\end_inset

Observable Streams
\end_layout

\begin_layout Standard
\begin_inset Formula $\ReactiveX$
\end_inset

, available in languages such as 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 through frameworks like 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

, offers 
\emph on
observable streams
\emph default
, which can be thought of as event streams or lists that generate events.
 This model can be used for field calculations.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, field change events can be treated as observable streams.
 The operators 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of other
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, visual fields can
 be updated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
observable stream.
\end_layout

\end_inset

Illustrating an event stream that represents the changes in the values of
 variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 over time.
 Based on the illustration, it can be observed that variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changed to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{5}
\end_layout

\end_inset

 initially, then to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{3}
\end_layout

\end_inset

, and after a longer period, it changed to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{2}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default change propogation, is that the observables syncrounsly respond
 to notifications by passing them forward.
 This traversal can be likened to a depth-first search (DFS) algorithm,
 where a change event initiates a sequence of computations in a depth-first
 order.
 By this traversal order, certain nodes may be visited multiple times, while
 some of these visits involving outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the tree, resulting from a change event, contains nodes with more than
 one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values, which
 are referred to as 
\emph on
glitches
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 The multiple incoming edges of a node represent 
\emph on
simultaneous events
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, indicating that they are related to the same time as they are resulted
 from a single event.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{next(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{next(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D=B+C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Illustrating an example for the glitch issue with the default behavior with
 observable streams.
 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents a sequence diagram of observable streams
 used for fields calculations, started from a change event to 
\backslash
lstinline{A}.
 The calls order in the sequence diagram is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}) (
\backslash
subref{fig:graph}) presentes the tree resulted from the  traversal order,
 leading that the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ReactiveX, available in languages like C# and JavaScript through frameworks
 like RxJS, provides observable streams.
 Observable streams are like a list, that produce the items.
 Field change events can be used to iniate an observable streams.
 and in the other hand, an observable can be subscriebd by visual elements
 to update values.
 The operators Select and CombineLatest creates observables, that their
 items are creatd in response to items in other observables, and based on
 their values.
 For exmaple, B=D.Select(x=>x+1), each value in D is executed by the function
 x=>x+1, and produe the result in D.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
FRP adopts this concept, so A:=B+C signifies that the reactive variable
 A depends on both B and C.
 During runtime, A continuously contains the value derived from the values
 contained in B and C, respectively.
\end_layout

\begin_layout Plain Layout
The composition can be visualized as a tree or graph, where each variable
 represents a node, and the dependencies between them are represented by
 edges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This works nice for hirarchial data.
 Inherently FRP does not support cycles.
 neverthless , frameworks provide special constructs to introduce cycles
 directly.
 This is less elegance, because it should be specified to the framework
 
\emph on
how
\emph default
 to not come into an infinite loop 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 (algorithm to handle cycles, keeping on the abstraction?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reactive-Variables"

\end_inset

Reactive Variables
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We call 
\emph on
reactive variables
\emph default
 (like in 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

) to the variables in FRP.
 FRP is inspired from the 
\emph on
functional paradigm
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+C}$
\end_inset

, so that each value returned by 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the values returned by 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
functional transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
They are automaticaly recalculateed as reaction to the UI change events.
 Input variables are those connected to the input fields.
 Based on these variables, other variables can be created.
 
\end_layout

\begin_layout Plain Layout
This implies that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 continuously contains the value derived from the values contained in 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, by initiating a dependency that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
———
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We call 
\emph on
reactive variables
\emph default
 (like in 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

) to the variables in FRP.
 They are automaticaly recalculateed as reaction to the UI change events.
 Input variables are those connected to the input fields.
 Based on these variables, other variables can be created.
 
\end_layout

\begin_layout Standard
This is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+C}$
\end_inset

, so that each value returned by 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the values returned by 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
functional transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
This implies that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 continuously contains the value derived from the values contained in 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, by initiating a dependency that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard

\emph on
Constraint systems
\emph default
 shares a common idea with FRP: developers declare equations, and the runtime
 automates variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

, which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the constraints 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The systems utilize 
\emph on
constraints solvers
\emph default
 to maintain consistency in variable values
\emph on
.
 
\emph default
The constraints solvers are algorithms developed for constraint systems
 to satisfy constraints.
 As in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints derived from the variables.
 For each variable 
\begin_inset Formula $X$
\end_inset

 containing a value 
\begin_inset Formula $x$
\end_inset

 , the runtime maintains a constraint 
\begin_inset Formula $X=x$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, constraints created
 by new input are set to the top priority.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Two-way constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 implemented by 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset

.
\end_layout

\end_inset

The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{constraint}
\end_layout

\end_inset

 method is used to create the constraint by specifying the variables as
 arguments and chaining the necessary methods.
 Each method has two parameters: the data flow direction and the function
 to execute when that method is chosen to satisfy the constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset

Maintaining 
\begin_inset Formula $\NAME A$
\end_inset

 and 
\begin_inset Formula $\NAME B$
\end_inset

 according to the constraint 
\begin_inset Formula $\NAME{A=B}$
\end_inset

, using constraint hierarchies.
 Each row represents a step in the interaction.
 The first column mentions the input provided.
 The second column mentions the exiting constraints following the input
 provided.
 The third column displays the values of the variables, as determined by
 the constraint solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
title(observable streams)....Although the high level abstraction, the events
 concept still exist in the paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional,proencca2017quality"
literal "false"

\end_inset

.
 In the approach used by ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, functions over 
\emph on
events streams
\emph default
 are declared, preserving the referential transparency property.
 Actualy reactive variables can be represented by events streams representing
 the varying value over time, similar to a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 However, there is a big difference between the original reactive variable
 to this representation.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1"

\end_inset

An events stream representing a varying value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In addition to the more verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 achieved by events streams, the mechanism is very different.
 Functions over events streams are typicaly not handled by a special runtime
 with the graph data structure.
 Instead, the events streams are 
\emph on
observables
\emph default
, with 
\emph on
operators
\emph default
 over them, that subscribe and produce events streams.
 Accordingly objects can have reactive variables as part of their interface,
 while the values are propagated according to the events mechanism.
 Generally speaking, reactive variables as events streams does no depend
 on the madiator exists in the original FRP, because they interact directly.
\end_layout

\begin_layout Plain Layout
The madiator has access to all the variables and formulas, so it can provide
 more predictable behavior.
 For example, if one variable has several updates caused by a single update,
 such as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

.
 In case that the variables interact directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will have an incorrect update named 
\emph on
glitch.
 
\emph default
In contrast, a madiator has the knowledge of the special construction to
 handle the updates correctly.
 So 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will be updated only when both 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

 has been updated.
 Even though the madiator can provide more predictable behavior, there are
 sometimes requirements that prefer directed interaction over a madiator.
 For example, typical distributed applications prefer directed interacton
 to reduce perfomance.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In libraries like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset

, we only need to specify the constraints, and the library automaticaly
 update the fields during the user interaction.
 For example, for cpecifying 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, each edited tuple, the third variable will be updated automaticaly.
 The library need to get as input, not only the constraints, but also methods
 to execute to update the fields .
 For this example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=B-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C=A-B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Components
\end_layout

\begin_layout Standard
The complexity of field calculations can be divided into several components,
 allowing larger and more complex components to be constructed from smaller
 and simpler ones.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multiple-Components"

\end_inset

Multiple Components
\end_layout

\begin_layout Standard
In systems like 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, it is enabled to register components, named 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 The components can contain code to execute in response to field updates,
 that contains code that calculates and updates fields.
 
\end_layout

\begin_layout Standard
Beside the interface provided to the clients, that consists of signature
 methods that the clients can call, there is an 
\emph on
informal contract 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset


\emph on
.

\emph default
 This consists of instructions to help the developers to manage the plugins
 correctly.
 For example, to take care of infinite loop, in case that one component
 recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, while the second reclculates field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The informal contract can contain the instruction, that code that the client
 registers, to be executed when an object's variables changed, should not
 update this object's variables 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The clients need to carefuly design their plugins, so tha the system will
 not 
\end_layout

\begin_layout Plain Layout
The registered components might be non-coordinated.
 For example, if the first component recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, and the second component reclculated field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
 
\end_layout

\begin_layout Plain Layout
Similary, an object provided as a service, beside its interface to the clients,
 that consists of signature methods that the clients can call, has an 
\emph on
informal contract
\emph default
 with the clients, usually attached as documentation.
 For example,
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sequential Connections
\end_layout

\begin_layout Standard
In the distributed setting in the FRP paradigm, components can be connected
 in sequential, so each component can give its output to the next component
 variable as its input 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Two Components
\end_layout

\begin_layout Standard
In frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 and 
\begin_inset Formula $\NAME{Flutter}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

, the layout on the screen is declared as function of the application's
 variables, named the application 
\emph on
state
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev/data-and-backend/state-mgmt/declarative
\end_layout

\end_inset

.
 While the state should be handled seperatedly.
\end_layout

\begin_layout Standard
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Redux
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 is a very popular state management solution.
 Events are modeled as state transitions between logical states, which are
 derived from variable values.
 As described in 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 and shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools not only allow for updates to occur when an event happens
 but also enable updates based on the exact state of the application, derived
 from previous interactions.
 In its centralization approach, this solution helps to develop a predictable
 behavior.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {S1};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {S2};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {S3};
\end_layout

\begin_layout Plain Layout

   
\backslash
node[rounded corners=1.5mm,minimum width=4cm,inner sep=1mm,above right,draw,align
=center,text width=26mm] (S4) at (1.2,-3) {S4
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont y changed/calculate x
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont z changed/calculate x};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180,in=90] (S1);
\end_layout

\begin_layout Plain Layout

      
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.5] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.5] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.5] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.5] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)] (System) {};
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Statechart.
\end_layout

\end_inset

This statechart models the handling of events to calculate the value of
 x based on changes in the variables y and z.
 The statechart consists of states S1, S2, S3, and S4, with transitions
 triggered by events 'y changed' and 'z changed'.
 Whenever either y or z changes, the calculation of x is triggered.
 This statechart serves as an illustration of a model where events are not
 used to separate concerns in objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The centralization approach is used also in designing algorithms to satisfy
 applications variables according to constraints.
 Also in the runtime of FRP, we find that usually the propagation change
 is central 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The fact that there are multiple approaches to the fields calculations indicates
 the complexity, while also indicating its relevance and significance.
 To separate field calculations among multiple components, we can either
 rely on the error prone events programming or leverage hierarchical data,
 where each component provides input to the subsequent one.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Example, react component can be reactive variable, the view is calculated
 according to the state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
\end_layout

\begin_layout Plain Layout
The OOP paradigm 
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 Objects and cmponents use the information hiding principle and introducing
 contracts to how they interacts, without that they need to be aware of
 implementation details.
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 In components based applications, organizations can deploy components that
 would extend an exsting application.
 For example, in the plugin architeture, code components named plugins,
 can be registered in the system to be executed in certain events.
 
\end_layout

\begin_layout Plain Layout
The main concept of the OOP paradigm, is the information hiding.
 It has been introduced to solve the problem of variables calculations.
 In software development has the problem about the the variables is, that
 it is hard to reason about the values that variables contains.
 To solve this problem, in the OOP paradigm,programs are modeled according
 to objects, so that each object will hide its variables.
 The objects have methods, by which they are used.
 fields can be updated only by those methods.
 The implementation details of the methods and the variables need to be
 hidden.
 
\end_layout

\begin_layout Plain Layout
The objects or components methods signitures are used to be a contract,
 and the implementain details are hidden.
 The idea of OOP, is code that consists of method calls to objects, depending
 on the contract.
 building larger components from smaller ones while preserving their individual
 behaviors.
\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
 the developer need to be aware of more information, consisdered as the
 informal contract.
\end_layout

\begin_layout Subsection
Separation between the fields calculation specification and the runtime
\end_layout

\begin_layout Plain Layout
By using constrains system, we have two components: the constraints specificatio
n, and the system.
 This seperation helps the developers, so he or she does not need to specify
 how to calculate fields, but only what calculations to apply.
 Also in the FRP paradigm, langugages like REScala (that is not in the distribut
ed settings), the langague has the runtime, that update the variables.
\end_layout

\begin_layout Subsection
OOP
\end_layout

\begin_layout Plain Layout
As an alternative, the components are stateless, and the whole state is
 used by a dedicate solution.
 for example, in react, there is redux, that helps to build a dedicated
 components to handle the state, to the specific needed logic (varuable
 to state?).
 Another example, Hotdrink, handle the variables according to specified
 constraints.
\end_layout

\begin_layout Plain Layout
A third option depends on informal contracts between components.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In react application, the state can be managed like a state machine
\end_layout

\begin_layout Plain Layout
reasons when no hirarciala data: plugins, DDD, granularity.
\end_layout

\begin_layout Plain Layout
in order to extend applicaion by plugin
\end_layout

\begin_layout Plain Layout
contemporary frameworks, like react, provides a building blocks for composing
 components.
 The component consists of the html that is the view.
\end_layout

\begin_layout Plain Layout
Component in react is a view given as function.
\end_layout

\begin_layout Plain Layout
.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
The problem about variables that it is hard to reason about the values that
 variables contains.
\end_layout

\begin_layout Plain Layout
We find two opposing approaches.
 First, OOP, objectes that interacts, plugins to extend the application,
 conceptual modeling.
 Second, a special component to handle the state.
 OOP is usefull to provide widgets.
 a centeral state management is usefull to improve reasoning.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Front end components, we find the concept of reactive variables usefull,
 to develop fields that compute values depending on the values in other
 fields.
 The most popular tool is spreadsheets, a cell represents a field and can
 contain a formula that defines its dependency on other cells.
 Alternatively, by frameworks like REScala are used to declare the data
 dependencies, which is then connected to events.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
(reactive variable's change produes an even and vise verca.
 MobX provides a framework to implement (like) reactive variables as a state
 management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
 This enables to only specify the data dependencies, and the runtime does
 the updates.
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
Reactve variablres are
\end_layout

\begin_layout Plain Layout
A langaguse with an abstraction like reactive variables depends on coming
 changes, and it preserve on the assignments, by reassigning whenener there
 is a change.
\end_layout

\begin_layout Plain Layout
In our focus is on front end applications, we find the concept of reactive
 variables usefull, in the common functionality to customize fields that
 are aytomaticaly filled based on other fields.
 One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement (like) reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
\end_layout

\begin_layout Plain Layout
Alternatvely, reactive variables can implicity implemented by the events
 driven programming 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 It invovlves iniating a mutable variables, and change events, for whom
 code can be registered to update other variables.
 Another alternative suggests to function over streams.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, data dependencies are constructed using pure functions, like the
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Signals
\end_layout

\end_inset

 in 
\begin_inset Formula $\REScala$
\end_inset

.
 Alternatively, frameworks for event streams, like 
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The FRP paradigm is derived from the functional paradigm to ensure explicit
 depedencies.
 Concretely, the code composed of pure functions, without to deal with the
 mutate variables.
 The problem about the variables, that it is hard to reason about the values
 that the variables contains.
 Therfore, in FRP, the code are composed of functions.
 The paradigm aims to rpovide the high level langage with a predictale behavior.
\end_layout

\begin_layout Plain Layout
As a result, the FRP paradigm helps to simplify front ends applications,
 specificaly when fields need to contously contain values depending on the
 values in other fields.
 The reactive variables are categorized into input and output variables.
 The input variables are typicaly connected to recive events from a visual
 elements, and the output variables are connected to update visual elements.
 This most popular use for this concept is in spreadsheets applications.
 Each cell of a spreadsheet, represented a field, can contain a formula
 to contiuously update dependong on the values of the cells used in the
 formula.
 In other libraries, like REScala, the variables are connected by an API
 built for this purpose.
 In countermporary frameowkrs like react , the developer declare the view
 as a function of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
In our context, the composed reactive variables need to not
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Implementing reactive variables for a front end is suited as state management.
\end_layout

\begin_layout Plain Layout
There are two opposing methods,
\end_layout

\begin_layout Plain Layout
Most reactive variables solutions consists of a centerlized mechanizm in
 their reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Therfore, in the context of components-based applications, it coupled the
 application to a madiaotr, that have access to
\end_layout

\end_inset


\end_layout

\begin_layout Section
Building Blocks
\end_layout

\begin_layout Plain Layout
In the context of developing systems, reactive variables, streams, and events
 can be considered as building blocks or units that you can utilize to construct
 or implement reactive and event-driven functionality.
 They serve as fundamental concepts or tools that enable you to handle and
 propagate changes within your system.
 Here's a breakdown of their roles:
\end_layout

\begin_layout Paragraph*
Reactive Variables
\end_layout

\begin_layout Plain Layout
Reactive variables provide a way to represent and manage data that automatically
 updates when dependent data changes.
 They are building blocks that allow you to define dependencies and establish
 reactive behavior within your system.
 Reactive variables enable you to express how data should react to changes
 and facilitate automatic propagation of updates.
\end_layout

\begin_layout Paragraph*
Streams
\end_layout

\begin_layout Plain Layout
Streams represent a sequence of data that can be processed incrementally
 or asynchronously.
 They serve as building blocks for modeling and transforming data flows
 within your system.
 Streams allow you to express the continuous flow of data and enable you
 to apply operations or transformations to the data as it moves through
 the stream pipeline.
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Plain Layout
Events are mechanisms that allow components or entities within a system
 to communicate and react to specific occurrences or triggers.
 They serve as building blocks for handling and propagating notifications
 or signals about important system events or changes.
 Events facilitate loose coupling and decoupled communication between components
, enabling them to react to relevant events without having direct knowledge
 of each other.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
By utilizing reactive variables, streams, and events as building blocks,
 you can develop systems that are responsive, flexible, and can effectively
 handle and propagate changes.
 These concepts provide the necessary foundations to build reactive, event-drive
n, or data-driven systems, depending on your specific requirements and use
 cases.
\end_layout

\begin_layout Section
Complexity Graphs
\end_layout

\begin_layout Section
Change Propagation
\end_layout

\begin_layout Plain Layout
There are mechanism that make a graph data structure in the memory 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Section
Events
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The OOP paradigm provides an alernative by the observer pattern.
 Objects can provide observers to register, to later execute tehri code,
 whenever variables are updated.
 Similary, objects can expose an OnChange event, that will be used to eceute
 code that update dependant variables.
 Cross systems, there are sometimes hooks, to call external code in response
 to a change in the data.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(I wrote this, and asked the gpt generate )The Observer pattern in Object-Orient
ed Programming (OOP) can adress the issue of interdependent fields in for
 front-end applications.
 Objects can contain variables that are equivalent to the fields in UI applicati
ons.
 By using the Observer pattern or events, it is possible to register code
 to be executed when a field or a variable is changed.
 Otherwise, code that update a variable (or a field) might be changed, to
 update other depedant variables.
 Instead, by t the observer pattern, we have the ability to hide logic,
 which can help to separate concerns and make code easier to manage.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Objects can use the observer pattern, or expose events to execute code when
 fields are updated, to enable other fields to be updated accordingly.
 If the code that updates one field needs to directly update additional
 fields, modifying the code to update one field might require changing the
 locations in the code where the other fields are updated.
 This leads to a centralized maintenance model, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where all the calculation logic is centralized and tightly coupled, making
 it difficult to isolate the code for each field.
 As an alternative, each field or variable has an onchange event, and multiple
 event handlers are registered, that update depedant fields.
\end_layout

\begin_layout Plain Layout
In reality, the onchange events did not effectively address the issue.
 It has been observed that relying solely on onchange events based on object
 contracts can lead to unexpected updates and values, as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 To address this issue, developers often add logic to determine when to
 update variables.
 Many modern applications use tools like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
XState
\end_layout

\end_inset

 (https://xstate.js.org) or 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Redux
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 to model events as state transitions between logical states 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 derived from variable values.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools allow specifying updates not only when an event occurs but
 also based on the exact state of the application, which is derived from
 previous interactions.
 However, this approach still relies on centralized management of the applicatio
n's state, making it a monolithic approach.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The provided strategy enables many patterns.
 One such strategy is to develop a single calculation procedure that can
 be implemented and called in response to field change events.
 However, this approach has the disadvantage of recomputing fields even
 when they do not need to be recomputed, which can lead to performance issues
 and unnecessary re-rendering of field values that have not been updated.
 Furthermore, a single calculation procedure can become overly complex and
 difficult to maintain as the application grows.
\end_layout

\end_inset


\end_layout

\begin_layout Section
DataFlow
\end_layout

\begin_layout Plain Layout
Frameworks based on the dataflow paradigm allow for the explicit specification
 of data dependencies, which were previously implicit.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The dataflow paradigm provide frameworks to explicity specify the data dependenc
ies, that previously specified implicity.
 In the FRP paradigm data dependencies are composed as pure functions.
 Alternatively, events streams frameworks, such as ReactiveX, enable to
 function over the streams, such that each each stream produces its values
 depending on the values of the input streams.
 It is often claimed that, in order to provde 
\emph on
predictability,
\emph default
 the graph should be acyclic.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The observer pattern can be used with the iterator pattern to provide observable
 stream.
 Observables streams push values notifications to their subsribers.
 On top of it, operators over observable stream, produce values to subseuent
 subscribers, based on the input observable streams.
\end_layout

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, some applications, including the example we provided, inherently
 have cycles in their data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, ensuring that the dependency graph is acyclic becomes a challenge,
 and it limits the ability to separate the code.
 Developers need to be aware of data dependencies and detect existing paths
 before adding new formulas that involve existing variables to prevent cycles.
 For example, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 Consequently, it is not possible to establish boundaries that prevent access
 to the formulas, which can lead to a monolithic codebase.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
However, many applications, as our example, have cycles by their nature
 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, in order to ensure that the graph is acyclic, the ability
 to seperate the code is reduced.
 Because, in order to ensure that the graph is acyclic, developers must
 ensure that no node has a path leading back to itself.
 This requires the developer to have knowledge of data dependencies and
 to detect existing paths before adding new formulas that involve existing
 variables.
 If a cycle is detected, the developer should avoid adding the new formula
 to the graph to prevent the creation of a cycle.
 For instance, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 If a calculation is linked to a variable, but the variable has dependencies
 that fall under a separate concern, it is linked without considering those
 dependencies.
 This means that the graph may not necessarily be acyclic.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
While in the events paradigm, developers 
\emph on
implicitly
\emph default
 create a 
\emph on
data dependency graph
\emph default
, frameworks such the ones of FRP provides this explicity.
\end_layout

\begin_layout Plain Layout
The FRP paradigm, enable to express reactive variables as pure functions,
 so that the data dependemcy management can be predictable composed, depending
 on the 
\emph on
referential transparency
\emph default
 property.
\end_layout

\begin_layout Plain Layout
In the FRP paradigm reactive variables are defined as functions over other
 reactive variables, while the runtime maintains the variables' values.
 The runtime uses a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 to manage the updates.
\end_layout

\begin_layout Plain Layout
accordingly, using a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In REScala, also instance variables can be reactive variables (i.e., objects
 can have reactive variables as part of their interface) having such runtime
 to maintain them 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 For example, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

 defines the reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 to be a function of reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 The runtime uses a graph ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Directed-acyclic-graph"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to automaticaly maintain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

.
 Consequently, there is no need to repeat registering to events to re-calculate
 variables like the ilustration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The FRP paradigm has the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 from being based on pure functions, with the meaning that the same input
 will produce consistently the same output.
 Consequently, the FRP paradigm provides predictability in scaling the applicati
on.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y) at (2,5) {Y};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Z) at (4,5) {Z};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (X) at (3,3) {X};
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Z) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(X) + (0,1)$)    {X:=Y+Z};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Directed-acyclic-graph"

\end_inset

Directed acyclic graph data structure representing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (C);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (D);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,1)$)    {B:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,1)$)    {C:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(D) + (0,1)$)    {D:=B+C};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch"

\end_inset

A data dependency graph, that in push-based evaluation, might have glitches.
 The nodes represent variables that should be updated either by input or
 by updating according to the specified function in the label.
 Each variable's update leads to update the depedencies.
 Updating A leads to updating B and C, each leads to updating D.
 In the first update, the value is incorrect (a glitch), because B or C
 has not been updated yet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Cycles"

\end_inset

Cycles
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, where FRP runtimes are developed, There are two opposing
 methods about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
FRP runtimes that support cycles uses various techniques to stop arisen
 loops.
 Terminating when it closes a cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, adding to the language a special operator to inform the runtime when to
 break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

, stop after a number of iterations, stop if the value has not changed,
 or changed only less than a threshold (available in 
\emph on
Microsoft Excel
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

).
 The various methods caused from the unknown, that a repeating update is
 either needed because previous update was a glitch, or that it is unneeded
 because the repeating update is caused from a cycle.
\end_layout

\begin_layout Plain Layout
Our model provides the semantics described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Any-Formula"
plural "false"
caps "true"
noprefix "false"

\end_inset

: cycles are resulted from variables with more than one source.
 Those variables are updated whenever there is a newer value from any of
 the sources.
 Technically, loops are terminated, because values caused from cycles are
 not newer.
 However, we are not the first to handle cycles, as said in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, constraints systems that handle two-way constraints handle cycles by their
 nature 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Nevertheless, the model treats the meaning issue about cycles more explicity.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
duplication
\end_layout

\begin_layout Plain Layout
Comparing to the traditional pure frp, we increased the ability to extend
 applications.
 Because that variables as pure functions can be extended by only deriving
 variables.
 This limitation in FRP, to not link calculations to existing variables
 causes variables duplications.
 Becasue, if we cannot target to exsting variable, we create a new one.
 (excel examples)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
In front-end applications, developers may create a data dependency graph
 either explicitly or implicitly to populate fields based on other fields.
 However, in certain scenarios where the application's data dependencies
 are complex, a centralized or monolithic graph might be required.
 This means that the data dependency definitions are located in a single
 code base that cannot be separated, or the runtime relies on an intermediary
 for variable updates.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, where fields are automatically filled based on
 other fields, the developers explicity or implicitly create one centeral
 
\emph on
data dependency graph
\emph default
 in which updates to variables recursively trigger updates to dependent
 variables.
 This graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The existing frameworks suggest seperating between declating dependencies
 to maintaining them, between diffrent acyclic graphs only if ther are unconnect
ed or that they produced acyclic graph,
\end_layout

\begin_layout Plain Layout
There are FRP runtimes that are based on the traditional simple methods
 calls, and are unpredictable.
 Others more predictable solutions use a madiator with the added complexity
 of having another layer needed to the application.
 There are FRP runtimes for distributed applications that do not use a madiator,
 but as the FRP paradigm, they support only the sets of formulas producing
 directed acyclic graphs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
