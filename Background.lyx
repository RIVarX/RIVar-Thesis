#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
Variables
\end_layout

\begin_layout Standard
Variable may refer to symbolic name associated to memory address which contains
 value.
 However, variable can be extended to more advanced terms.
\end_layout

\begin_layout Subsection
Instance Variable
\end_layout

\begin_layout Standard
In OOP, objects represent the identity of real world objects, therefore
 their instance variables should represent the real world variable.
 Generaly, variable may represent real world variable, even if it is a plain
 symbolic name associated to memory address, it may contain value represents
 the real world variable's value.
\end_layout

\begin_layout Standard
In general research, variables refer to the real-world objects' variables
 (or attributes) such as persons' weight and so on.
 variables have values which vary over the time.
 In software, it is very common to simulate the real world variables values
 by assigning the variables values whenever the software determines a change.
\end_layout

\begin_layout Standard
OOP is a perfect platform to simulate the real world variables.
 By implementing 
\begin_inset Quotes eld
\end_inset

is-a
\begin_inset Quotes erd
\end_inset

 (inheritance) and 
\begin_inset Quotes eld
\end_inset

has-a
\begin_inset Quotes erd
\end_inset

 relationships, variables can be refernced with diffrent terms depending
 on the context.
 This involves a formal distinction between messages sending values to a
 setters, the variables , and other messages calling that setters.
\end_layout

\begin_layout Subsection
Reactive Variable
\end_layout

\begin_layout Standard
In contrast to traditional variables, reactive variables is automatically
 consistent according to the defined formulas.
 In such frameworks, a reactive variable 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 assigned by an expression is populated in response to changes in the value
 of any of the variables existing in the expression.
 For example, the meaning of the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 is that variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, so that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Variables' Values' Consistency
\end_layout

\begin_layout Standard
Functions are implemented to get how a varying variable's value depends
 on another variable's value.
 Handle consistency means executing the functions, in response to observing
 new values, to update dependant variables with the change.
 
\end_layout

\begin_layout Standard
Traditionaly we can observe change events and call the calculate function
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{sensorValue.changed += { (e) -> powerDierence = f(e) }}
\end_layout

\end_inset

, while this is automatic in frameworks facilitate directly representing
 the functional dependency (
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence
\end_layout

\end_inset

 depending on 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue
\end_layout

\end_inset

) by declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{powerDierence = f(sensorValue)}
\end_layout

\end_inset

.
 The variables and dependencies form a 
\emph on
dependencies graph
\emph default
.
\end_layout

\begin_layout Subsection
Referential Transparency
\end_layout

\begin_layout Standard
In FRP, Reactive Variables are declared similar to pure functions, and the
 framework automaticaly calculates the values in response to new values
 provided.
 For example declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Age := CurrentDate-BirthDate}
\end_layout

\end_inset

, produce 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Age}
\end_layout

\end_inset

 to be refreshed automaticaly according to the varying values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{BirthDate}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{CurrentDate}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Declaring variables as calculation tree, leads to very 
\emph on
predictable
\emph default
 programs: the same input produces the same output every time we execute
 it.
 This is similar to invoking pure function, without side effect, so produces
 consistent result, attributed as 
\emph on
referential transparency
\emph default
.
 In such programs, substituting variable by its expression, does not affect
 the program.
 Consequently, changing the code have predictable effect, so programs become
 rubust against changes.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
There are libraries which automaticaly handle variables consistency, according
 to a set of constraints.
 Take for example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

, there are three methods to satisfy the constraint: 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = Total - Tip
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip = Total - Price
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

.
 In response to any new input, the library choose what method to execute
 to satisfy the constraint.
\end_layout

\begin_layout Standard
When more constraints are specified and against varying input options, choosing
 the methods to execute, become not trivial.
 Therefore, various algorithms have been developed named 
\emph on
constraints solvers
\emph default
.
 The principal is to prioritize the constraints, and iterate them, choosing
 methods which does not override variables that already satisfied by previous
 chosen methods.
 The inputs are considered as contraints, for example if user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip
\end_layout

\end_inset

 with the input 
\begin_inset ERT
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, then the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip=10
\end_layout

\end_inset

 is added to the set.
 Accordingly, constraints are prioritized according to the order of the
 inputs.
\end_layout

\begin_layout Standard
Constraints solvers are actualy choose a consistent way to handle conflicts.
 If we add to the above example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = OriginalPrice - Discount
\end_layout

\end_inset

, then it might be wandered from where 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price
\end_layout

\end_inset

 should be calculated.
 
\end_layout

\begin_layout Subsection
Weak Approaches 
\end_layout

\begin_layout Standard
There are non FRP libraries, which handle declared functional dependencies
 by automatically calculating values in response to new values provided.
 In contrast to FRP, the calculations might be inpredictable.
\end_layout

\begin_layout Standard
The inpredictable is because, there can be cycles in the graph, even in
 declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout

A := B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B := A
\end_layout

\end_inset

.
 Furthermore, when applications use seperation tools provided in OOP, we
 cannot prevent from cycles.
 For example, declaring to calculate values for 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in response to new values provided to 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, does not require full control over of the two variables.
 So there might be another declaration referring to 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 which calculates values for 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 in response to new values provided to 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
When cycles exist, libraries use an arbitrary condition to stop the changes,
 to not enter an infinite loop.
 
\end_layout

\begin_layout Section
Stream
\end_layout

\begin_layout Standard
When handling applications over time, updating variables using the assigment
 operator, we identified time variation in the real world with time variation
 in the computer.
 Stream is an alternative to model phenomena over time without refering
 explicity the time.
 With libraries such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

Cycle.js
\end_layout

\end_inset

, program logic consists of one pure function (composed of small other pure
 functions), calculating what sequence of effects to produce according to
 the input sequence of effects.
 
\end_layout

\begin_layout Standard
The effects are like events, in such that they do nothing, when no one is
 registered.
 A stream may be a sequence of events notifications produced by changing
 input control's value, represented real world variable.
 Accordingly, stream may be a sequence of events to notify about a real
 world variables changes, for which an input control should be registered
 and be updated.
 The effects are produced with parameters, and it depends on the consumer
 what function to register and how to use the parameters arrived.
\end_layout

\begin_layout Standard
A set of operators are provided to compose the more advanced calculations
 needed.
 One basic operator is named 
\begin_inset ERT
status open

\begin_layout Plain Layout

select
\end_layout

\end_inset

 (or 
\begin_inset ERT
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

), it produces an effect in the output stream, whenever there is an effect
 in the input stream.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

select
\end_layout

\end_inset

 takes function as parameter, the function is calculated to get the parameter
 of the output effect, from the parameter arrived to the input effect.
 For example, program that updates field 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 according to field 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, such that 
\begin_inset ERT
status open

\begin_layout Plain Layout

B=A+1
\end_layout

\end_inset

, Let's 
\begin_inset ERT
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 be the stream of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

's values
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

a=FromEvents(A)
\end_layout

\begin_layout Plain Layout

b=a.Select(instant=>instant+1)
\end_layout

\begin_layout Plain Layout

b.Subscribe(instant=>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,red] (0x0) at (1,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,yellow] (1x0) at (2,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,green] (2x0) at (3,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,cyan] (3x0) at (4,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,blue] (4x0) at (5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,magenta] (5x0) at (6,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x0) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=7cm] (op) {Select
\backslash
{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[baseline=-1mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,circle] (x) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,diamond,right=5mm of x] (y) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
draw [fdash] (x) -- (y);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

  
\backslash
}};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,red] (0x2) at (1,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,yellow] (1x2) at (2,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,green] (2x2) at (3,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,cyan] (3x2) at (4,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,blue] (4x2) at (5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,magenta] (5x2) at (6,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x2) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x0) -- (0x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (4x0) -- (4x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (5x0) -- (5x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (6x0) -- (6x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (0x2) -- (0x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x2) -- (1x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x2) -- (2x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x2) -- (3x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x2) -- (4x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x2) -- (5x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x2) -- (6x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
