#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

Background
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Variable that is re-assigned over time can be modelled as stream, that in
 each update there is a new item, of the new value representing the updated
 value at that instant.
 reactive variable means that update of that variable raises indirectly
 a continuation action based on the new value.
 Such an update may be called as
\emph on
 update with a push notification
\emph default
.
 In other words, 
\emph on
update with a push notification
\emph default
 means that not only the variable contained the new value instead of the
 previous value, but also that it raises interested parties about the change.
 We refer to variables as an object in the world, that exposes operation
 
\emph on
assign
\emph default
 (with :=) for an update, and 
\emph on
subscribe 
\emph default
for registration for push notifications.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
We provide a brief, comprehensive overview of state management, gradually
 covering its various aspects:
\end_layout

\begin_layout Itemize
Initially, code assigns values to variables, allowing other code to read
 them.
 For instance, A = 1 assigns a value to variable A, and another code segment
 B = A reads from variable A.
\end_layout

\begin_layout Itemize
Next, additional code is introduced to notify potential readers about changes.
 For example, A = 1; OnChangeA(A) notifies other parts of the system about
 changes to variable A.
 Subsequently, another piece of code, RegisterToChangeA(value => ...) registers
 to receive notifications about changes to variable A.
\end_layout

\begin_layout Itemize
Finally, these components are intertwined, enabling writing into a variable
 to automatically trigger other code to read the new values.
 For instance, declaring B := A establishes a continuous relationship between
 variables, so that when the code A = 1 is executed, variable B is updated
 automatically to reflect this new value.
\end_layout

\begin_layout Plain Layout
Each step in the above represent a valid approach.
 In the first approach, there is no mechanism to inform potential readers
 of changes.
 Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 
\end_layout

\begin_layout Plain Layout
The second approach provide reactivity, by informing potential readers of
 changes.
 However, it requires to control when to inform readers, and for readers
 to inform to what changes to subscribe.
 This approach is difficult in high scale applications.
 Because, it is not only clear when to inform readers about changes, or
 for the readers when to subscribe or unsubscribe.
 
\end_layout

\begin_layout Plain Layout
The last approach unifies reading and writing such that writing into variables
 triggers potential readers to read the changes.
 This provides a cleaner specification, except for the problem of cycles,
 where a variable change might indirectly result from itself.
 In such a case, the itended understanding is not clear.
\end_layout

\begin_layout Plain Layout
As a result, the previous approach has a better tools to express requirement
\end_layout

\begin_layout Plain Layout
The previous approach is better 
\end_layout

\begin_layout Plain Layout
In this context, in the previous approach requirements can be expressed
 directly, while here the itended understanding is not clear.
\end_layout

\begin_layout Plain Layout
The strategy, how cycles are controled are not explicit in the code.
\end_layout

\begin_layout Plain Layout
In such cycles,the way how changes are handled loops are stopped without
 to express the explicit strategy in the code.
\end_layout

\begin_layout Plain Layout
It is required to decide how to stop the loop.
 
\end_layout

\begin_layout Plain Layout
The decision how to stop such a loop is not explicit in the code
\end_layout

\begin_layout Plain Layout
In such a case, the second approach, in its full control over the changes
 might convey better in desgning how to stop the loop 
\end_layout

\begin_layout Plain Layout
the decision how to stop the loop is not explicit in the code.
 Therefore, the second approach, in its full control over the changes, 
\end_layout

\begin_layout Plain Layout
the second approach provides a cleaner specification in its full control
 over the changes.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Handling 
\emph on
state
\emph default
 is an important aspect in programming.
 State refers to what software remembers from past used to its future behavior.
 State is represented as changeable data, stored anywere, used to determine
 output.
 Basicly, it is variables that contain values.
 
\end_layout

\begin_layout Plain Layout
Software components that contained variables or any datastore, by which
 its behavior is determined, is named 
\emph on
stateful components
\emph default
.
 Our objective is to redesign an existing application to compose highly
 reusable stateful components.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
In software programming, developers sometimes encounter 
\emph on
cycles 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, 
\emph on
circular dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

 or similar.
 For variables, it means that a change in one variable causes transitively,
 through a chain of changes, this same variable to again change its value.
 Typically, the flow continues, such that the second change produces a third
 change, etc.
 In the worst case, this chain continues endlessly, breaking programs unexpected
ly.
\end_layout

\begin_layout Plain Layout
This might be accidently produced in event driven programming.
 Each event handler can trigger more events, in-awaring of the events from
 which they have been triggered.
 Therefore it is likely that an event handler transitively triggers an event
 from which it was originally triggered.
 If a variable is updated by an event handler, and this event handler triggers
 more events which lead to execute again this event handler, the variable
 is re-updated.
\end_layout

\begin_layout Plain Layout
In Functional Reactive Programming (FRP), it might be even more explicit.
\begin_inset Foot
status open

\begin_layout Plain Layout
Our presentation is based on Tetsuo Kaminaa at al 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
\end_layout

\end_inset

 In FRP, variables can be specified in terms of each other, thus initiating
 dependencies to automatically update each other.
 For instance, A := f(B) indicates that A depends on B, meaning that when
 B’s value changes, A’s value is adjusted accordingly.
 Using this abstraction, B := g(A) establishes a dependency in a reversed
 direction, resulting in a cycle
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis discusse against an argument, that hirarchial data is a nececray
 condition for achiving predictability.
 This argument is inspired from several
\end_layout

\begin_layout Plain Layout
This argument are inferred
\end_layout

\begin_layout Plain Layout
Many couple predictability with the acylciity for graphs that abstract the
 depedancies.
 This represent an argument that hirarchial data is a nececray condition
 for achiving predictability.
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Challenge
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Data Synchronization is a ubiquitous feature across various domains, including
 front-end interfaces, databases and inter-system communication.
 In the various forms, data is transformed or computed to be consistent
 with other data.
 In database management, synchronization involves updating fields.
 Systems such as CRM or e-commerce platforms utilize synchronization to
 align one system with another.
 Similarly, in graphical user interfaces (GUI) or front-end applications,
 it entails updating fields based on changes in other fields.
 In the realm of state management, synchronization involves adjusting variables
 in response to changes in other variables.
 Procedural programming allows developers to write explicit, step-by-step
 procedures for handling data synchronization tasks.
 Each procedure has a set of arguments and update data according to values
 contained by the arguments.
\end_layout

\begin_layout Plain Layout
Procedural programming is an outdated paradigm compared to current modern
 paradigms.
 Procedural programming consists of procedures, that execute a set of instructio
nes for a given set of arguments.
\begin_inset space \space{}
\end_inset


\emph on
 
\end_layout

\begin_layout Plain Layout
In the procedural programming, developers model proceduraes, 
\end_layout

\begin_layout Paragraph
Push Model
\end_layout

\begin_layout Plain Layout
In data synchronization, two prominent strategies are employed: the 
\emph on
pull
\emph default
 and 
\emph on
push
\emph default
 models.
 In the pull mode, data consumers need to proactively request updates by
 executing a procedure or calling for a service.
 In the push model, changes are pushed forward without the consumer proactively
 requesting updates.
 The pull model might lead to redandant requests, if there are no changes
 since the last request.
 This thesis' focus is on the push model, which is apt for scenarios characteriz
ed by: first, a continuous demand for up-to-date data; second, infrequent
 changes; and finally, the absence of prolonged and resource-intensive computati
ons, as new changes may arise before the completion of such processes.
\end_layout

\begin_layout Paragraph
Explicit Data Dependencies
\end_layout

\begin_layout Plain Layout
In Reactive Programming, there is a focus on explicity define the dependencies,
 rather than relying on Event-driven paradigm where developers manually
 manage variable values.
 For example, in the event-driven paradigm, variables 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
 each have a 
\family typewriter
change
\family default
 event to which event handlers are registered.
 Within these event handlers, code calculates the sum of the values contained
 in 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
, and then updates a variable, 
\family typewriter
A
\family default
, with that value.
 From an FRP perspective, this should be declared simply as 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 making the data dependencies explicit directly in the code.
 
\end_layout

\begin_layout Paragraph
Control 
\end_layout

\begin_layout Plain Layout
When relying on third-party control over updates, software developers may
 experience a sense of unpredictability and lack of control.
 This concern has been articulated in the experience of REScala, where developer
s expressed frustration with tracking the flow of code: “I can’t follow
 the Codeflow in RP.
 I want to know, what method is called when
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
Traditional procedural programming remains highly prevalent for Data Synchroniza
tion.
 Our initial focus lies on a specific GUI application in the healthcare
 sector, which utilizes procedural programming.
 Healthcare, an area notorious for low user satisfaction 
\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

, presents an opportunity to enhance the codebase, thereby improving the
 customer feedback loop through rapid releases and innovative programming
 methodologies.
 Surprisingly, procedural-driven programs are not limited to GUI applications
 in the healthcare sector alone.
 REST APIs and command-line interfaces (CLIs) are also often built on procedural
 principles.
 Similarly, any tool that accepts various arguments and must accommodate
 numerous scenarios may suffer from limitations inherent in the outdated
 procedural paradigm.
\end_layout

\begin_layout Plain Layout
————————–
\end_layout

\begin_layout Plain Layout
In this section, we discuss the state of the art of field calculation features.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Events
\end_layout

\begin_layout Standard
Event is an abstraction used in programming that enables 
\emph on
components-based architecture
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 For fields calculations, events facilitate registering code that update
 fields to be executed by a component, when its internal code update other
 fields.
 For example, in web development, code that updates fields based on other
 fields can be registered to be executed when fields are changed.
 For example, in 
\family typewriter
JavaScript
\family default
 programming language, 
\begin_inset Formula $\LSTINLINE{input.addEventListener('input',calculate)}$
\end_inset


\begin_inset space ~
\end_inset

means to execute 
\begin_inset Formula $\LSTINLINE{calculate}$
\end_inset

, when the user interacts with the input element by changing its value.
 Another example is in extending systems, such as in 
\family typewriter
Microsoft Dynamics
\family default
, where it is possible to register components known as 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 These components can include code that executes in response to field updates,
 performing calculations and updating fields accordingly.
 
\end_layout

\begin_layout Standard
In components-based architecture, the components call each other, with the
 caller and callee sharing an interface, hiding implementation details.
 This interface is commonly referred to as a 
\emph on
contract
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 consisting of named operations with corresponding arguments.
 The interface allows parties to be changed without requiring others to
 make modifications.
 
\end_layout

\begin_layout Standard
However, in fields calculations, there is a risk of encountering an infinite
 loop.
 For example, if one plugin in 
\family typewriter
Microsoft Dynamics
\family default
 recalculates field 
\family typewriter
A
\family default
 whenever field 
\family typewriter
B
\family default
 is updated, and the second one recalculates field 
\family typewriter
B
\family default
 whenever field 
\family typewriter
A
\family default
 is updated, this circular dependency can result in an infinite loop of
 recalculations.
 In OOP, the issue is named 
\emph on
object re-entrance
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 that causes problems in objects compositions and inheritance.
 Object re-entrance means that an object indirectly calls another object
 that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 Therefore, frequently there is a knowledge that should be shared in addition
 to the interface.
 It is called sometimes an 
\emph on
informal contract
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset


\emph on
.
\end_layout

\begin_layout Standard

\emph on
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
In components-based architecture, the components call each other, with the
 caller and callee sharing an interface, hiding implementation details.
 This interface is commonly referred to as a 
\emph on
contract
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 consisting of named operations with corresponding arguments.
 The interface allows parties to be changed without requiring others to
 make modifications.
\end_layout

\begin_layout Plain Layout
This enables to register code that update fields to be executed by a component,
 when its internal code update other fields.
 For example, in web development, code that updates fields based on other
 fields can be registered to be executed when fields are changed.
 For example, in 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{input.addEventListener('input',calculate)}$
\end_inset


\begin_inset space ~
\end_inset

means to execute 
\begin_inset Formula $\LSTINLINE{calculate}$
\end_inset

, when the user interacts with the input element by changing its value.
 Another example is in extending systems, such as in 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, where it is possible to register components known as 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 These components can include code that executes in response to field updates,
 performing calculations and updating fields accordingly.
 
\end_layout

\begin_layout Plain Layout
The design principle is that the components can call each other, with the
 caller and callee sharing an interface, hiding implementation details.
 This interface is commonly referred to as a 
\emph on
contract
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 consisting of named operations with corresponding arguments.
 The interface allows parties to be changed without requiring others to
 make modifications.
 This reminds 
\emph on
micro-frontends architecture
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

, wherein UI components are developed and deployed independently to enable
 scalable and flexible application growth.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is also closely related to 
\emph on
component-based applications
\emph default
, where the application is composed of reusable code components, that uses
 concepts from OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, there is a risk of encountering an infinite loop.
 For example, if one plugin in 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

 recalculates field 
\begin_inset Formula $A$
\end_inset

 whenever field 
\begin_inset Formula $B$
\end_inset

 is changed, and the second one recalculates field 
\begin_inset Formula $B$
\end_inset

 whenever field 
\begin_inset Formula $A$
\end_inset

 is changed, this circular dependency can result in an infinite loop of
 recalculations.
 In OOP, the issue is named 
\emph on
object re-entrance
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

, where an object indirectly calls another object that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 This causes problems in objects compositions and inheritance.
 Therefore, frequently there is a knowledge that should be shared in addition
 to the interface.
 It is called sometimes an 
\emph on
informal contract 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset


\emph on
.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Centerlized Providers
\end_layout

\begin_layout Standard
In modern frameworks like 
\family typewriter
React
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\family default
 and also 
\family typewriter
Flutter
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

 applications utilize dedicated state management solutions to handle variables.
 Among these state management solutions, 
\family typewriter
Redux
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 stands out as a highly popular choice.
 It adopts a model inspired by 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, events are modeled as state transitions between logical states, which
 are determined based on variable values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {};
\end_layout

\begin_layout Plain Layout

     
\backslash
node[round] (S4) at (2.5, -3) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180, in=90] (S1);
\end_layout

\begin_layout Plain Layout

    
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.8] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.8] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.8] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.8] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

     
\backslash
draw[-latex] (S4) to [loop below, looseness=8, out=-60, in=-120, min distance=10
mm] node[scale=0.8]  { y changed/calculate x;
\end_layout

\begin_layout Plain Layout

z changed/calculate x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
draw (3.5, -4) coordinate (empty);
\end_layout

\begin_layout Plain Layout

      
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)(empty)] (System) {};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset


\end_layout

\end_inset

Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

.
 The rectangular shapes represent different states or modes of the application.
 The arrows represent transitions between the states, triggered by specific
 events.
 The labels contain the events and also actions, if needed, to perform in
 response to events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The idea to bring the developers user friendly mechanism to fields calculations
 brings also the 
\emph on
constraints systems
\emph default
.
 In constraints systems, developers declare equations, and the runtime automates
 variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 They reminds reactive variables and FRP.
 Many implementations in FRP consists of a centralized manager 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\family typewriter
Hotdrink
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

 which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the methods 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 The systems utilize algorithms, named 
\emph on
constraints solvers
\emph default
, to maintain consistency in variable values.
 As in 
\family typewriter
Hotdrink
\family default
, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints.
 For each variable 
\family typewriter
X
\family default
 containing a value 
\family typewriter
x
\family default
, the runtime maintains a constraint 
\begin_inset Formula $\LSTINLINE{X=x}$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, the more prioritized
 constraints, according to the hirarchy, are satsified.
 As a result, once the user put new input for a field, the fields that relied
 on a previous input, specifically the oldest input, are overwritten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset


\end_layout

\end_inset

Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{constraint}$
\end_inset

 method is used to create the constraint by specifying the variables as
 arguments and chaining the necessary methods.
 Each method has two parameters: the data flow direction and the function
 to execute when that method is chosen to satisfy the constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset

Maintaining 
\begin_inset Formula $\NAME A$
\end_inset

 and 
\begin_inset Formula $\NAME B$
\end_inset

 according to the constraint 
\begin_inset Formula $\NAME{A=B}$
\end_inset

, using constraint hierarchies.
 Each row represents a step in the interaction.
 The first column mentions the input provided.
 The second column mentions the exiting constraints following the input
 provided.
 The third column displays the values of the variables, as determined by
 the constraint solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Actualy, as in the state management solution 
\begin_inset Formula $\NAME{MobX}$
\end_inset

 with the 
\begin_inset Formula $\NAME{React}$
\end_inset

 framework, fields calculations can consist of reactive variables implemented
 by a state management solution connected to the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Unidirectional Data Flow
\end_layout

\begin_layout Standard
Frequently, software developers are often forced to break the cycles by
 creating hierarchical data models.
 A remarkable example is a birth of 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 to replace traditional 
\family typewriter
Model-View-Controller
\family default
 (MVC) libraries.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As described in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.clariontech.com/blog/mvc-vs-flux-vs-redux-the-real-differences
\end_layout

\end_inset


\end_layout

\end_inset

 In MVC, models are updated according to the view and vice versa, sometimes
 mentioned as 
\emph on
multidirectional
\emph default
 dataflow.
 Multidirectional means data flows among components in multiple directions.
 In 
\family typewriter
React
\family default
, each component possesses a 
\begin_inset Formula $\LSTINLINE{render}$
\end_inset

 function, which is responsible for generating and returning the corresponding
 component view.
 This view can consist of nested components, forming a hierarchical structure
 that facilitates the composition of complex user interfaces.
 
\end_layout

\begin_layout Standard
The design choice of avoiding cycles has its cost.
 For example, the lack of a feature named 
\emph on
binding
\emph default
, by which variables are declaratively bound, so that a change in one variable
 update the other variable and vise versa.
 A similar feature is named 
\emph on
multidirectionality
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 (equivalent to multi-way constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

) that means that when necessary, changes in derived values are propagated
 back to the values from which they were derived.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout

\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 provides an alternative approach that proposes a design that data flow
 in one direction, such that data flows from each component to its child
 components.
 This way protects developers from encounter cycles.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Another strategy to ensure predictability in field calculations is the design
 principle that data can only flow in one direction, from the source to
 destination.
 In FRP, this principle is enforced by classifying reactive variables into
 input variables and calculated variables.
 This is the default behavior in spreadsheets like 
\family typewriter
Microsoft Excel
\family default
.
 The input variables have values from the users, while the calculated variables
 cannot be set by the user as it contains the derived values.
\end_layout

\begin_layout Plain Layout
Accordingly components that contains reactive variables may be connected
 in a sequential manner, where each component's output is passed as input
 to the next component 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 A similar approach is adopted by 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 when it comes to rendering.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, each component possesses a 
\begin_inset Formula $\LSTINLINE{render}$
\end_inset

 function, which is responsible for generating and returning the corresponding
 component view.
 This view can consist of nested components, forming a hierarchical structure
 that facilitates the composition of complex user interfaces.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The latter might not follow the unidirectional data flow causing sometimes
 an issue named 
\emph on
accidental recursion
\emph default
s
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 As an example, if the code contains 
\begin_inset Formula $\LSTINLINE{A=D.Select(x=>x+1)}$
\end_inset

 and accidently it is added 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

.
 It is like saying 
\begin_inset Formula $A=D+1$
\end_inset

 and also 
\begin_inset Formula $D=A-1$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The other problems are related to a phenomenon named 
\emph on
simultaneous events
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\emph on
.
 
\emph default
In the default change propogation, observables synchronously respond to
 notifications by passing them forward.
 This traversal can be likened to a depth-first search (DFS) algorithm,
 where a change event initiates a sequence of computations in a depth-first
 order.
 The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1972depth"
literal "false"

\end_inset

 of the vertices reached during the traversal.
 This traversal order has the known issue named 
\emph on
glitch
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset


\emph on
.

\emph default
 Certain nodes may be visited multiple times, while some of these visits
 involving outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the spanning tree, resulting from the DFS traversal, contains nodes with
 more than one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values.
 The multiple incoming edges of a node represent simultaneous events, which
 are related to the same time, that originaly caused by a single event.
\end_layout

\begin_layout Plain Layout
Similary in the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator, the simultaneous events cause an incorrect behavior.
 The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator creates an observable stream, where each item from any of the
 input streams triggers a corresponding item in the output stream.
 If two streams have items from the same time, originating from a single
 event, the resulting stream will contain it twice.
 
\end_layout

\begin_layout Plain Layout
Reactive streams are closely related to FRP.
 As mentioned, reactive variables can be presented as observable streams
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 However, these two issues hinder the abstraction from achieving referential
 transparency, which is a critical requirement for FRP 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reactive-Variables"

\end_inset

Paradigms
\end_layout

\begin_layout Plain Layout
In implementing fields calculations, there are three available paradigms:
 events (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Events"
plural "false"
caps "true"
noprefix "false"

\end_inset

), streams (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and constraints (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Events"

\end_inset

Events
\end_layout

\begin_layout Plain Layout
In programming frameworks, such as in web development, code that updates
 fields based on other fields can be registered to be executed when fields
 are changed.
 For example, in 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{input.addEventListener('input', calculate)}
\end_layout

\end_inset

 means to execute 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{calculate}
\end_layout

\end_inset

, when the user interacts with the input element by changing its value.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A closely related concept is named 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

, where events are modeled as state transitions between logical states,
 which are derived from variable values.
 As described in and shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools not only allow for updates to occur when an event happens
 but also enable updates based on the exact state of the application, derived
 from previous interactions.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Observable-Streams"

\end_inset

Streams
\end_layout

\begin_layout Plain Layout
As an alternative to manipulating fields or variables, there is the strategy
 of modeling programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 due to 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers observable streams, which are objects that abstract collections
 for interested observers, passing their items to them by calling their
 next method (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an alternative to the fields or variables manipulation, there is the
 strategy to model programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 by 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx initialy developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is available now for many programming languages,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The variables are presented as observable streams consists of the values
 or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events generated from UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This programming model has also the problem, that it supports the events
 model.
 For example.
 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

which means that
\end_layout

\begin_layout Plain Layout
Because it allows mutual recusraion there might be an accidental recusrsn,
 that causes an infinite loop.
 For example, if we add to the example 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

, then D and A are mutual recusraion: 
\begin_inset Formula $A=D+1$
\end_inset

 and also 
\begin_inset Formula $D=A-1$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
ReactiveX, available in languages like C# and JavaScript through frameworks
 like RxJS, provides observable streams.
 Observable streams are like a list, that produce the items.
 Field change events can be used to iniate an observable streams.
 and in the other hand, an observable can be subscriebd by visual elements
 to update values.
 The operators Select and CombineLatest creates observables, that their
 items are creatd in response to items in other observables, and based on
 their values.
 For exmaple, B=D.Select(x=>x+1), each value in D is executed by the function
 x=>x+1, and produe the result in D.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
FRP adopts this concept, so A:=B+C signifies that the reactive variable
 A depends on both B and C.
 During runtime, A continuously contains the value derived from the values
 contained in B and C, respectively.
\end_layout

\begin_layout Plain Layout
The composition can be visualized as a tree or graph, where each variable
 represents a node, and the dependencies between them are represented by
 edges.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This works nice for hirarchial data.
 Inherently FRP does not support cycles.
 neverthless , frameworks provide special constructs to introduce cycles
 directly.
 This is less elegance, because it should be specified to the framework
 
\emph on
how
\emph default
 to not come into an infinite loop 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 (algorithm to handle cycles, keeping on the abstraction?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constraints"

\end_inset

Constraints
\end_layout

\begin_layout Plain Layout

\emph on
Constraint systems
\emph default
 shares a common idea with FRP: developers declare equations, and the runtime
 automates variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

 which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the methods 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
The systems utilize algorithms, named 
\emph on
constraints solvers
\emph default
, to maintain consistency in variable values.
 As in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints.
 For each variable 
\begin_inset Formula $X$
\end_inset

 containing a value 
\begin_inset Formula $x$
\end_inset

 , the runtime maintains a constraint 
\begin_inset Formula $X=x$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, the more prioritized
 constraints, according to the hirarchy, are satsified.
 As a result, once the user put new input for a field, the fields that relied
 on a previous input, specifically the oldest input, are overwritten.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
title(observable streams)....Although the high level abstraction, the events
 concept still exist in the paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional,proencca2017quality"
literal "false"

\end_inset

.
 In the approach used by ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, functions over 
\emph on
events streams
\emph default
 are declared, preserving the referential transparency property.
 Actualy reactive variables can be represented by events streams representing
 the varying value over time, similar to a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 However, there is a big difference between the original reactive variable
 to this representation.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1"

\end_inset

An events stream representing a varying value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In addition to the more verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 achieved by events streams, the mechanism is very different.
 Functions over events streams are typicaly not handled by a special runtime
 with the graph data structure.
 Instead, the events streams are 
\emph on
observables
\emph default
, with 
\emph on
operators
\emph default
 over them, that subscribe and produce events streams.
 Accordingly objects can have reactive variables as part of their interface,
 while the values are propagated according to the events mechanism.
 Generally speaking, reactive variables as events streams does no depend
 on the madiator exists in the original FRP, because they interact directly.
\end_layout

\begin_layout Plain Layout
The madiator has access to all the variables and formulas, so it can provide
 more predictable behavior.
 For example, if one variable has several updates caused by a single update,
 such as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

.
 In case that the variables interact directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will have an incorrect update named 
\emph on
glitch.
 
\emph default
In contrast, a madiator has the knowledge of the special construction to
 handle the updates correctly.
 So 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will be updated only when both 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

 has been updated.
 Even though the madiator can provide more predictable behavior, there are
 sometimes requirements that prefer directed interaction over a madiator.
 For example, typical distributed applications prefer directed interacton
 to reduce perfomance.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In libraries like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset

, we only need to specify the constraints, and the library automaticaly
 update the fields during the user interaction.
 For example, for cpecifying 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, each edited tuple, the third variable will be updated automaticaly.
 The library need to get as input, not only the constraints, but also methods
 to execute to update the fields .
 For this example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=B-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C=A-B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Components
\end_layout

\begin_layout Plain Layout
The complexity of field calculations can be divided into several components,
 allowing larger and more complex components to be constructed from smaller
 and simpler ones.
\end_layout

\begin_layout Subsection
Sequential Components
\end_layout

\begin_layout Plain Layout
In the distributed setting of the FRP paradigm, components can be connected
 in a sequential manner, where each component's output is passed as input
 to the next component 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
A similar approach is adopted by 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 when it comes to rendering.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, each component possesses a 
\begin_inset Formula $\LSTINLINE{render}$
\end_inset

 function, which is responsible for generating and returning the corresponding
 component view.
 This view can consist of nested components, forming a hierarchical structure
 that facilitates the composition of complex user interfaces.
\end_layout

\begin_layout Plain Layout
The concept of connecting components sequentially in the FRP paradigm aligns
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

's component rendering approach.
 The hierarchical nature of 
\begin_inset Formula $\NAME{React}$
\end_inset

 components allows for the composition of reusable and encapsulated UI elements.
\end_layout

\begin_layout Subsection
State Management
\end_layout

\begin_layout Plain Layout
In modern frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset

 and also 
\begin_inset Formula $\NAME{Flutter}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

 applications utilize dedicated state management solutions to handle variables.
 These solutions can take the form of FRP-like approaches such as 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 or a straightforward data store.
\end_layout

\begin_layout Plain Layout
Among these state management solutions, 
\begin_inset Formula $\NAME{Redux}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 stands out as a highly popular choice.
 It adopts a model inspired by 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, events are modeled as state transitions between logical states, which
 are determined based on variable values.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 and 
\begin_inset Formula $\NAME{Flutter}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

, the layout on the screen is declared as function of the application's
 variables, named 
\emph on
state
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev/data-and-backend/state-mgmt/declarative
\end_layout

\end_inset

.
 The state is handled seperatedly with a dedicated component.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{Redux}$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 is a very popular state management solution.
 Events are modeled as state transitions between logical states, which are
 derived from variable values.
 As described in 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 and shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools not only allow for updates to occur when an event happens
 but also enable updates based on the exact state of the application, derived
 from previous interactions.
 In its centralization approach, this solution helps to develop a predictable
 behavior.
\end_layout

\begin_layout Plain Layout
However, it leads to repeating on calling to functions in handling the events.
 For instance, in order to implement 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

, we should call ro recalculate 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 in the event that 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 is updated, and also in the events that 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 is updated.
\end_layout

\begin_layout Plain Layout
in order that to ensure that the value of 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 reflects 
\begin_inset Formula $\LSTINLINE{y+z}$
\end_inset

 whenever either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{y}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{z}
\end_layout

\end_inset

 is updated, we must calculate 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x}
\end_layout

\end_inset

 in two event handlers.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multiple-Components"

\end_inset

Multiple Components
\end_layout

\begin_layout Plain Layout
Recently, there has been a trend towards 
\emph on
micro-frontends architecture
\emph default
, wherein UI components are developed and deployed independently to enable
 scalable and flexible application growth 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

.
 This architecture is closely related to 
\emph on
component-based applications
\emph default
, where the application is composed of reusable code components, that uses
 concepts from OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Components can call each other, with the caller and callee sharing an interface,
 hiding implementation details.
 This interface is commonly referred to as a contract and consists of named
 operations with corresponding arguments.
 The interface allows parties to be changed without requiring others to
 make modifications.
\end_layout

\begin_layout Plain Layout
In practice we find challenges in coordinating behavior between components.
 In the context of micro-frontends, this architecture presents challenges
 regarding handling shared state and facilitating communication
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

.
 Similary, in 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, where it is possible to register components known as 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 These components can include code that executes in response to field updates,
 performing calculations and updating fields accordingly.
 However, in the absence of a formal contract, there is a risk of encountering
 an infinite loop.
 For example, if the first component recalculates field 
\begin_inset Formula $A$
\end_inset

 whenever field 
\begin_inset Formula $B$
\end_inset

 is changed, and the second component recalculates field 
\begin_inset Formula $B$
\end_inset

 whenever field 
\begin_inset Formula $A$
\end_inset

 is changed, this circular dependency can result in an infinite loop of
 recalculations.
\end_layout

\begin_layout Plain Layout
In OOP, the issue is named 
\emph on
object re-entrance
\emph default
, where an object indirectly calls another object that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 This causes problems in objects compositions and inheritance.
 Therefore, frequently there is a knowledge that should be shared in addition
 to the interface.
 It is called sometimes an 
\emph on
informal contract.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
The micro-frontends architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "Geers2020,Peltonen2021"
literal "false"

\end_inset

 suggests that UI components are developed and deployed indepedently.
 This concept is derived from the micro-services architecture in the backend,
 and is related also to the traditional OOP paradigm.
 Beside the interface that objects provide, there is an 
\emph on
informal contract 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 , which is intructions or best practices to how to use objects correctly.
\end_layout

\begin_layout Plain Layout
Specificaly, in systems like 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, it is enabled to register components, named 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 The components can contain code to execute in response to field updates,
 that contains code that calculates and updates fields.
 Due to lack of a formal contract, there might be an infinite loop, if the
 first component recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, and the second component reclculated field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the instructions to help the developers to manage the plugins correctly.
 For example, to take care of infinite loop, in case that one component
 recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, while the second reclculates field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The informal contract can contain the instruction, that code that the client
 registers, to be executed when an object's variables changed, should not
 update this object's variables 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The clients need to carefuly design their plugins, so tha the system will
 not
\end_layout

\begin_layout Plain Layout
The registered components might be non-coordinated.
 For example, if the first component recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, and the second component reclculated field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
\end_layout

\begin_layout Plain Layout
Similary, an object provided as a service, beside its interface to the clients,
 that consists of signature methods that the clients can call, has an 
\emph on
informal contract
\emph default
 with the clients, usually attached as documentation.
 For example,
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Observable Streams
\end_layout

\begin_layout Standard

\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx) refers to extensions for programming languages for programming with
 
\emph on
observable streams.
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A complete knowledge and references are available in
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

 https://introtorx.com/
\end_layout

\end_inset

 (in 
\family typewriter
C#
\family default
 programming language) and 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rxjs.dev/
\end_layout

\end_inset

 (in 
\family typewriter
JavaScript
\family default
 programming language)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard

\emph on
Observable stream
\emph default
 (known also as 
\emph on
reactive streams
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://cycle.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

) represents a specific useful pattern.
 Observable stream is an object that delivers items for other objects through
 a method 
\emph on
next
\emph default
.
 An observable stream can be generated from events of UI elements.
 
\emph on
Operators
\emph default
 create observable streams whose items are generated based on the values
 of input observable streams.
 For example, the operator 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

.
 The expression 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

means that each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements are updated.
\end_layout

\begin_layout Standard
An observable stream acts similar to reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Operators act similarly to the concept of 
\emph on
lifting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, because they convert a function to be a 
\emph on
higher order function.
 
\emph default
A unary operator can be lifted by the operator 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 that maps each item according to an argumented function.
 A binary operator can be lifted by an operator 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, that works for two observable streams, mapping based on items from the
 two.
 
\end_layout

\begin_layout Standard
By using these concepts, the propagation change 
\emph on
may
\emph default
 be decentralized, since it is managed by the individual nodes.
 To support this, delivered items can contain meta-data in addition to the
 values 
\begin_inset CommandInset citation
LatexCommand cite
key "proencca2017quality"
literal "false"

\end_inset

.
 However, it may be that coordination is required between nodes.
\end_layout

\begin_layout Standard
Cycles might be created (mentioned by the name
\emph on
 accidental recursion
\emph default
s 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
 For example, if the code contains 
\begin_inset Formula $\LSTINLINE{A=D.Select(x=>x+1)}$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We take the concept of observable streams for presenting variables.
 An observable stream consists of values or changes over time, as illustrated
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

, generated from events of UI elements.
 Furthermore, Each node in a dependancy graph can be represented as an observabl
e stream.
 Each Item represents a visit in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Upon observable streams, 
\emph on
operators 
\emph default
are used for transforming those observable streams.
 The operators act similarly to the concept of 
\emph on
lifting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, because they convert a function to be a 
\emph on
higher order function.
 
\emph default
A unary operator can be lifted by an operator 
\family typewriter
map
\family default
 that maps each item according to an argumented function.
 A binary operator can be lifted by an operator 
\family typewriter
CombineLatest
\family default
 works for two observable streams, mapping based on items from the two.
 The operators create an observable stream, subscribe to the argumented
 observable stream, and deliver items through the created observable stream.
 
\end_layout

\begin_layout Plain Layout
observable streams is a concept popularized by 
\end_layout

\begin_layout Plain Layout
As an alternative to manipulating fields or variables, there is the strategy
 of modeling programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 due to 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers observable streams, which are objects that abstract collections
 for interested observers, passing their items to them by calling their
 next method (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an alternative to the fields or variables manipulation, there is the
 strategy to model programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 by 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx initialy developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is available now for many programming languages,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The variables are presented as observable streams consists of the values
 or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events generated from UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Plain Layout
—————-
\end_layout

\begin_layout Plain Layout
Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
This abstraction can be used to create fields calculations, with a similtary
 to FRP.
 The variables are presented as observable streams consists of the values
 or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events generated from UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Plain Layout
This abstraction has several issue.
 First, in case of 
\emph on
accidental recursion
\emph default
s, the behavior does not behave properly.
 For example, if the code contains 
\begin_inset Formula $\LSTINLINE{A=D.Select(x=>x+1)}$
\end_inset

 and accidently it is added 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

.
 It is like saying 
\begin_inset Formula $A=D+1$
\end_inset

 and also 
\begin_inset Formula $D=A-1$
\end_inset

.
\end_layout

\begin_layout Plain Layout
————–
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Altough that acylicty is immdate by using observable streams and operators,
 an integration with custom code can lead to cycles.
 An observable stream contain a method OnNext For example, A=B.Select(x=>x)
 and B.Subscribe(x=>A.OnNext(x)).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
Three perspectives on handling cycles exist:
\end_layout

\begin_layout Itemize
Event-driven decoupling: This approach focuses on using events to loosely
 couple components, potentially introducing cycles as a side effect.
\end_layout

\begin_layout Itemize
Centralized cycle management: This perspective emphasizes managing cycles
 through a central mechanism, ensuring control and correct behavior.
 
\end_layout

\begin_layout Itemize
Hierarchical models for acyclicity: This approach prioritizes avoiding cycles
 altogether by using strictly hierarchical data models.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The frameworks strike a balance between abstraction and generality.
 Event-driven programming frameworks give developers complete control over
 the propagation order, but this can be error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides a more abstract approach, allowing developers to choose between
 several schedulers to indicate the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset

 Constraints systems like FRP frameworks go even further, abstracting away
 the propagation order altogether and allowing developers to focus on specifying
 the data dependencies.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Over the frameworks, it is challenged to coordinate the field calculation
 behaviors, particularly when establishing dependencies to update fields
 based on changes in other fields.
 This process requires careful consideration of transitive dependencies.
 Otherwise, unintentional recursion can lead to unexpected updates.
 For predictable addition of calculations, it is required that they be in
 the same class or component to ensure that the calculations are correct,
 that there are no cycles, or that cycles are handled correctly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Example, react component can be reactive variable, the view is calculated
 according to the state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
\end_layout

\begin_layout Plain Layout
The OOP paradigm 
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 Objects and cmponents use the information hiding principle and introducing
 contracts to how they interacts, without that they need to be aware of
 implementation details.
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 In components based applications, organizations can deploy components that
 would extend an exsting application.
 For example, in the plugin architeture, code components named plugins,
 can be registered in the system to be executed in certain events.
 
\end_layout

\begin_layout Plain Layout
The main concept of the OOP paradigm, is the information hiding.
 It has been introduced to solve the problem of variables calculations.
 In software development has the problem about the the variables is, that
 it is hard to reason about the values that variables contains.
 To solve this problem, in the OOP paradigm,programs are modeled according
 to objects, so that each object will hide its variables.
 The objects have methods, by which they are used.
 fields can be updated only by those methods.
 The implementation details of the methods and the variables need to be
 hidden.
 
\end_layout

\begin_layout Plain Layout
The objects or components methods signitures are used to be a contract,
 and the implementain details are hidden.
 The idea of OOP, is code that consists of method calls to objects, depending
 on the contract.
 building larger components from smaller ones while preserving their individual
 behaviors.
\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
 the developer need to be aware of more information, consisdered as the
 informal contract.
\end_layout

\begin_layout Subsection
Separation between the fields calculation specification and the runtime
\end_layout

\begin_layout Plain Layout
By using constrains system, we have two components: the constraints specificatio
n, and the system.
 This seperation helps the developers, so he or she does not need to specify
 how to calculate fields, but only what calculations to apply.
 Also in the FRP paradigm, langugages like REScala (that is not in the distribut
ed settings), the langague has the runtime, that update the variables.
\end_layout

\begin_layout Subsection
OOP
\end_layout

\begin_layout Plain Layout
As an alternative, the components are stateless, and the whole state is
 used by a dedicate solution.
 for example, in react, there is redux, that helps to build a dedicated
 components to handle the state, to the specific needed logic (varuable
 to state?).
 Another example, Hotdrink, handle the variables according to specified
 constraints.
\end_layout

\begin_layout Plain Layout
A third option depends on informal contracts between components.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In react application, the state can be managed like a state machine
\end_layout

\begin_layout Plain Layout
reasons when no hirarciala data: plugins, DDD, granularity.
\end_layout

\begin_layout Plain Layout
in order to extend applicaion by plugin
\end_layout

\begin_layout Plain Layout
contemporary frameworks, like react, provides a building blocks for composing
 components.
 The component consists of the html that is the view.
\end_layout

\begin_layout Plain Layout
Component in react is a view given as function.
\end_layout

\begin_layout Plain Layout
.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
The problem about variables that it is hard to reason about the values that
 variables contains.
\end_layout

\begin_layout Plain Layout
We find two opposing approaches.
 First, OOP, objectes that interacts, plugins to extend the application,
 conceptual modeling.
 Second, a special component to handle the state.
 OOP is usefull to provide widgets.
 a centeral state management is usefull to improve reasoning.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Front end components, we find the concept of reactive variables usefull,
 to develop fields that compute values depending on the values in other
 fields.
 The most popular tool is spreadsheets, a cell represents a field and can
 contain a formula that defines its dependency on other cells.
 Alternatively, by frameworks like REScala are used to declare the data
 dependencies, which is then connected to events.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
(reactive variable's change produes an even and vise verca.
 MobX provides a framework to implement (like) reactive variables as a state
 management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
 This enables to only specify the data dependencies, and the runtime does
 the updates.
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
Reactve variablres are
\end_layout

\begin_layout Plain Layout
A langaguse with an abstraction like reactive variables depends on coming
 changes, and it preserve on the assignments, by reassigning whenener there
 is a change.
\end_layout

\begin_layout Plain Layout
In our focus is on front end applications, we find the concept of reactive
 variables usefull, in the common functionality to customize fields that
 are aytomaticaly filled based on other fields.
 One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement (like) reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
\end_layout

\begin_layout Plain Layout
Alternatvely, reactive variables can implicity implemented by the events
 driven programming 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 It invovlves iniating a mutable variables, and change events, for whom
 code can be registered to update other variables.
 Another alternative suggests to function over streams.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, data dependencies are constructed using pure functions, like the
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Signals
\end_layout

\end_inset

 in 
\begin_inset Formula $\REScala$
\end_inset

.
 Alternatively, frameworks for event streams, like 
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The FRP paradigm is derived from the functional paradigm to ensure explicit
 depedencies.
 Concretely, the code composed of pure functions, without to deal with the
 mutate variables.
 The problem about the variables, that it is hard to reason about the values
 that the variables contains.
 Therfore, in FRP, the code are composed of functions.
 The paradigm aims to rpovide the high level langage with a predictale behavior.
\end_layout

\begin_layout Plain Layout
As a result, the FRP paradigm helps to simplify front ends applications,
 specificaly when fields need to contously contain values depending on the
 values in other fields.
 The reactive variables are categorized into input and output variables.
 The input variables are typicaly connected to recive events from a visual
 elements, and the output variables are connected to update visual elements.
 This most popular use for this concept is in spreadsheets applications.
 Each cell of a spreadsheet, represented a field, can contain a formula
 to contiuously update dependong on the values of the cells used in the
 formula.
 In other libraries, like REScala, the variables are connected by an API
 built for this purpose.
 In countermporary frameowkrs like react , the developer declare the view
 as a function of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
In our context, the composed reactive variables need to not
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Implementing reactive variables for a front end is suited as state management.
\end_layout

\begin_layout Plain Layout
There are two opposing methods,
\end_layout

\begin_layout Plain Layout
Most reactive variables solutions consists of a centerlized mechanizm in
 their reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Therfore, in the context of components-based applications, it coupled the
 application to a madiaotr, that have access to
\end_layout

\end_inset


\end_layout

\begin_layout Section
Building Blocks
\end_layout

\begin_layout Plain Layout
In the context of developing systems, reactive variables, streams, and events
 can be considered as building blocks or units that you can utilize to construct
 or implement reactive and event-driven functionality.
 They serve as fundamental concepts or tools that enable you to handle and
 propagate changes within your system.
 Here's a breakdown of their roles:
\end_layout

\begin_layout Paragraph*
Reactive Variables
\end_layout

\begin_layout Plain Layout
Reactive variables provide a way to represent and manage data that automatically
 updates when dependent data changes.
 They are building blocks that allow you to define dependencies and establish
 reactive behavior within your system.
 Reactive variables enable you to express how data should react to changes
 and facilitate automatic propagation of updates.
\end_layout

\begin_layout Paragraph*
Streams
\end_layout

\begin_layout Plain Layout
Streams represent a sequence of data that can be processed incrementally
 or asynchronously.
 They serve as building blocks for modeling and transforming data flows
 within your system.
 Streams allow you to express the continuous flow of data and enable you
 to apply operations or transformations to the data as it moves through
 the stream pipeline.
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Plain Layout
Events are mechanisms that allow components or entities within a system
 to communicate and react to specific occurrences or triggers.
 They serve as building blocks for handling and propagating notifications
 or signals about important system events or changes.
 Events facilitate loose coupling and decoupled communication between components
, enabling them to react to relevant events without having direct knowledge
 of each other.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
By utilizing reactive variables, streams, and events as building blocks,
 you can develop systems that are responsive, flexible, and can effectively
 handle and propagate changes.
 These concepts provide the necessary foundations to build reactive, event-drive
n, or data-driven systems, depending on your specific requirements and use
 cases.
\end_layout

\begin_layout Section
Complexity Graphs
\end_layout

\begin_layout Section
Change Propagation
\end_layout

\begin_layout Plain Layout
There are mechanism that make a graph data structure in the memory 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Section
Events
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The OOP paradigm provides an alernative by the observer pattern.
 Objects can provide observers to register, to later execute tehri code,
 whenever variables are updated.
 Similary, objects can expose an OnChange event, that will be used to eceute
 code that update dependant variables.
 Cross systems, there are sometimes hooks, to call external code in response
 to a change in the data.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(I wrote this, and asked the gpt generate )The Observer pattern in Object-Orient
ed Programming (OOP) can adress the issue of interdependent fields in for
 front-end applications.
 Objects can contain variables that are equivalent to the fields in UI applicati
ons.
 By using the Observer pattern or events, it is possible to register code
 to be executed when a field or a variable is changed.
 Otherwise, code that update a variable (or a field) might be changed, to
 update other depedant variables.
 Instead, by t the observer pattern, we have the ability to hide logic,
 which can help to separate concerns and make code easier to manage.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Objects can use the observer pattern, or expose events to execute code when
 fields are updated, to enable other fields to be updated accordingly.
 If the code that updates one field needs to directly update additional
 fields, modifying the code to update one field might require changing the
 locations in the code where the other fields are updated.
 This leads to a centralized maintenance model, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where all the calculation logic is centralized and tightly coupled, making
 it difficult to isolate the code for each field.
 As an alternative, each field or variable has an onchange event, and multiple
 event handlers are registered, that update depedant fields.
\end_layout

\begin_layout Plain Layout
In reality, the onchange events did not effectively address the issue.
 It has been observed that relying solely on onchange events based on object
 contracts can lead to unexpected updates and values, as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 To address this issue, developers often add logic to determine when to
 update variables.
 Many modern applications use tools like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
XState
\end_layout

\end_inset

 (https://xstate.js.org) or 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Redux
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 to model events as state transitions between logical states 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 derived from variable values.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools allow specifying updates not only when an event occurs but
 also based on the exact state of the application, which is derived from
 previous interactions.
 However, this approach still relies on centralized management of the applicatio
n's state, making it a monolithic approach.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The provided strategy enables many patterns.
 One such strategy is to develop a single calculation procedure that can
 be implemented and called in response to field change events.
 However, this approach has the disadvantage of recomputing fields even
 when they do not need to be recomputed, which can lead to performance issues
 and unnecessary re-rendering of field values that have not been updated.
 Furthermore, a single calculation procedure can become overly complex and
 difficult to maintain as the application grows.
\end_layout

\end_inset


\end_layout

\begin_layout Section
DataFlow
\end_layout

\begin_layout Plain Layout
Frameworks based on the dataflow paradigm allow for the explicit specification
 of data dependencies, which were previously implicit.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The dataflow paradigm provide frameworks to explicity specify the data dependenc
ies, that previously specified implicity.
 In the FRP paradigm data dependencies are composed as pure functions.
 Alternatively, events streams frameworks, such as ReactiveX, enable to
 function over the streams, such that each each stream produces its values
 depending on the values of the input streams.
 It is often claimed that, in order to provde 
\emph on
predictability,
\emph default
 the graph should be acyclic.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The observer pattern can be used with the iterator pattern to provide observable
 stream.
 Observables streams push values notifications to their subsribers.
 On top of it, operators over observable stream, produce values to subseuent
 subscribers, based on the input observable streams.
\end_layout

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, some applications, including the example we provided, inherently
 have cycles in their data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, ensuring that the dependency graph is acyclic becomes a challenge,
 and it limits the ability to separate the code.
 Developers need to be aware of data dependencies and detect existing paths
 before adding new formulas that involve existing variables to prevent cycles.
 For example, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 Consequently, it is not possible to establish boundaries that prevent access
 to the formulas, which can lead to a monolithic codebase.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
However, many applications, as our example, have cycles by their nature
 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, in order to ensure that the graph is acyclic, the ability
 to seperate the code is reduced.
 Because, in order to ensure that the graph is acyclic, developers must
 ensure that no node has a path leading back to itself.
 This requires the developer to have knowledge of data dependencies and
 to detect existing paths before adding new formulas that involve existing
 variables.
 If a cycle is detected, the developer should avoid adding the new formula
 to the graph to prevent the creation of a cycle.
 For instance, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 If a calculation is linked to a variable, but the variable has dependencies
 that fall under a separate concern, it is linked without considering those
 dependencies.
 This means that the graph may not necessarily be acyclic.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
While in the events paradigm, developers 
\emph on
implicitly
\emph default
 create a 
\emph on
data dependency graph
\emph default
, frameworks such the ones of FRP provides this explicity.
\end_layout

\begin_layout Plain Layout
The FRP paradigm, enable to express reactive variables as pure functions,
 so that the data dependemcy management can be predictable composed, depending
 on the 
\emph on
referential transparency
\emph default
 property.
\end_layout

\begin_layout Plain Layout
In the FRP paradigm reactive variables are defined as functions over other
 reactive variables, while the runtime maintains the variables' values.
 The runtime uses a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 to manage the updates.
\end_layout

\begin_layout Plain Layout
accordingly, using a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In REScala, also instance variables can be reactive variables (i.e., objects
 can have reactive variables as part of their interface) having such runtime
 to maintain them 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 For example, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

 defines the reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 to be a function of reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 The runtime uses a graph ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Directed-acyclic-graph"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to automaticaly maintain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

.
 Consequently, there is no need to repeat registering to events to re-calculate
 variables like the ilustration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The FRP paradigm has the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 from being based on pure functions, with the meaning that the same input
 will produce consistently the same output.
 Consequently, the FRP paradigm provides predictability in scaling the applicati
on.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y) at (2,5) {Y};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Z) at (4,5) {Z};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (X) at (3,3) {X};
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Z) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(X) + (0,1)$)    {X:=Y+Z};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Directed-acyclic-graph"

\end_inset

Directed acyclic graph data structure representing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (C);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (D);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,1)$)    {B:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,1)$)    {C:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(D) + (0,1)$)    {D:=B+C};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch"

\end_inset

A data dependency graph, that in push-based evaluation, might have glitches.
 The nodes represent variables that should be updated either by input or
 by updating according to the specified function in the label.
 Each variable's update leads to update the depedencies.
 Updating A leads to updating B and C, each leads to updating D.
 In the first update, the value is incorrect (a glitch), because B or C
 has not been updated yet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection

\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
duplication
\end_layout

\begin_layout Plain Layout
Comparing to the traditional pure frp, we increased the ability to extend
 applications.
 Because that variables as pure functions can be extended by only deriving
 variables.
 This limitation in FRP, to not link calculations to existing variables
 causes variables duplications.
 Becasue, if we cannot target to exsting variable, we create a new one.
 (excel examples)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
In front-end applications, developers may create a data dependency graph
 either explicitly or implicitly to populate fields based on other fields.
 However, in certain scenarios where the application's data dependencies
 are complex, a centralized or monolithic graph might be required.
 This means that the data dependency definitions are located in a single
 code base that cannot be separated, or the runtime relies on an intermediary
 for variable updates.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, where fields are automatically filled based on
 other fields, the developers explicity or implicitly create one centeral
 
\emph on
data dependency graph
\emph default
 in which updates to variables recursively trigger updates to dependent
 variables.
 This graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The existing frameworks suggest seperating between declating dependencies
 to maintaining them, between diffrent acyclic graphs only if ther are unconnect
ed or that they produced acyclic graph,
\end_layout

\begin_layout Plain Layout
There are FRP runtimes that are based on the traditional simple methods
 calls, and are unpredictable.
 Others more predictable solutions use a madiator with the added complexity
 of having another layer needed to the application.
 There are FRP runtimes for distributed applications that do not use a madiator,
 but as the FRP paradigm, they support only the sets of formulas producing
 directed acyclic graphs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
