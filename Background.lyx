#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset


\end_layout

\begin_layout Standard
In software development, state management refers to the process of maintaining
 and updating the variables of an application or system.
 One common requirement is implementing 
\emph on
reactive variables
\emph default
, variables that are recaluclated in response to dependant variables' updates,
 just like cells containing formulas in spreadsheet applications.
 The FRP paradigm provides solutions to implement reactive variables.
 The developers should specify formulas, and the solution uses its runtime
 to enforce them.
 For this discussion, we extend the term 
\emph on
FRP runtime
\emph default
 to any solution that handles the task of updating variables in response
 to other variables’ updates.
\end_layout

\begin_layout Standard
Implementing FRP runtime is challenged, because it might face unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications scale
 with many features and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, that variable
 might be part of a long chains of updates, so it might fall into an endless
 loop.
 Consequently, scaling the application is unpredictable, because any change
 might produce an unpredictable behavior.
\end_layout

\begin_layout Standard
(Solutions achiving predictable are either non-modular or monolithic or
 both.
 Non-modular, that the reactive variables and formulas cannot generaly be
 specified in seperated objects or components.
 Monolithic, that even when the reactive variables and formulas can be seperated
, the reactive variables are not interacting like peer to peer.
 Intsead, there is one centeral algorithm accessing to the entire data.)
\end_layout

\begin_layout Section
OOP
\end_layout

\begin_layout Standard
Originaly, the OOP paradigm provided 
\emph on
objects encapsulation
\emph default
 in order to scale applications without making unpredictable behavior.
 According to the objects encapsulation, objects' variables are protected
 from being updated by external code.
 Instead, objects expose methods, by which an object's consumers ask the
 object to update its variables.
 OOP also provides 
\emph on
indirect control
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "martin2018clean"
literal "false"

\end_inset

, to consumers to call methods only according to the interface.
 Similary, the 
\emph on
inheritance mechanism
\emph default
 provides extending objects without to harm them, by depending on the specializa
tion interface while encapsulating the technical imeplmentation.
 However, objects sometimes provides consumers the option to update their
 variables.
\end_layout

\begin_layout Standard
Objects can provide consumers to register code that update variables, to
 be executed in the events that other variables are updated.
 By this technique, enterprise applications provide customers to extend
 the application according to their business needs, such as 
\emph on
Microsoft Power Apps
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://powerapps.microsoft.com
\end_layout

\end_inset

 do.
 In the enterprise application Microsoft Power Apps, developers can register
 plugins that update fields, to be re-calculated according other fields.
 Registering one custom plugin might lead to infinite loop of updates caused
 from several registered plugins.
 This familiar problem has the ad-hoc solution to stop the loop by the provided
 field named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Depth}
\end_layout

\end_inset


\emph on

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://carldesouza.com/dynamics-365-understanding-plugin-depth
\end_layout

\end_inset


\emph default
, containing how many times the current plugin is executed.
 This situation with Microsoft Power Apps reflects typical situations in
 maintaining applications' state.
\end_layout

\begin_layout Section
FRP
\end_layout

\begin_layout Standard
Originaly, in the FRP paradigm functions over reactive variables are declared,
 in order to have the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 The referential transparency property means that the same input will produce
 consistently the same output.
 Thanks to the referential transparency property, functions can be composed
 and decomposed, producing predictable behavior.
 The functions are represented as trees in the memory, and used by the runtime
 to maintain the values.
 
\emph on
REScala
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014rescala"
literal "false"

\end_inset

 has implemented one such solution integrated with OOP.
 Objects can have reactive variables as part of their interface, and there
 is a propogation system that maintain them 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014rescala"
literal "false"

\end_inset

.
 Consequently, the FRP paradigm provides an alternative to the events paradigm,
 by abstracting away the need to update variables according to other variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (C);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (D);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,1)$)    {B:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,1)$)    {C:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(D) + (0,1)$)    {D:=B+C};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch"

\end_inset

Glitch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, We see in the paradigm the concept of events harmonized in several
 forms 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional,proencca2017quality"
literal "false"

\end_inset

.
 In one popular approach 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, functions over events streams are declared, preserving the referential
 transparency property.
 Actualy a reactive variable can be represented by a stream of events representi
ng the variable's values as a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 However, there is a big difference between the original reactive variable
 to this representation.
\end_layout

\begin_layout Standard
In addition to the more verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 achieved by events streams, the mechanism is typicaly very different.
 Functions over events streams are typicaly not handled by a special runtime
 with the graph data structure.
 Instead, The events streams are observables, and there are operators over
 them, that subscribe and produce events streams.
 
\emph on
ReactiveX
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 has implemented one such solution.
 Objects can have reactive variables as part of their interface, and the
 values are propagated according to the events mechanism.
 Consequently, reactive variables as events streams does no depend on the
 madiator exists in the original FRP, because they interact directly.
\end_layout

\begin_layout Standard
The madiator has access to all the variables and formulas, so it can provide
 more predictable behavior.
 For example, if one variable has several updates caused by a single update,
 such as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "false"
noprefix "false"

\end_inset

, that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 In case that the variables are interacts directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 will have an incorrect update named 
\emph on
glitch.
 
\emph default
In contrast, a madiator has the knowledge of the special construction, and
 handle the updates efficient, so that 
\begin_inset ERT
status open

\begin_layout Plain Layout

\emph on
D
\end_layout

\end_inset

 will e updated only when both 
\begin_inset ERT
status open

\begin_layout Plain Layout

\emph on
B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

\emph on
C
\end_layout

\end_inset

 has been updated.
 Even though the madiator can provide more predictable behavior, there are
 sometimes requirements that prefer directed interaction over a madiator.
 For example, distributed applications prefers directed interacton to reduce
 perfomance.
\end_layout

\begin_layout Standard
In the FRP paradigm with the distributed settings, variables can be located
 in different processes or hosts 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,shibanai2018distributed,drechsler2014distributed"
literal "false"

\end_inset

.
 Using solutions like 
\emph on
XFRP 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "shibanai2018distributed"
literal "false"

\end_inset

, developers declare the level functions over reactive variables, and the
 compiler generates distributed applications, that handle the updates according
 to the specified formulas.
\end_layout

\begin_layout Subsection
Cycles
\end_layout

\begin_layout Standard
There are two opposing opinions how to handle cycles.
 In one approach, cycles should be avoided, because then the referential
 transparency property is broken 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 But in the second approach, forbidding cycles makes FRP unacceptably weak,
 because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 According to this approach, a library named 
\emph on
Hotdrink
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, implements a constraints system for user interfaces.
 The library re-constructs the dependency graph whenever the user edits
 a field.
\end_layout

\begin_layout Standard
Using the approach that cycles exist and supported, the runtime stops arisen
 loops either after an amount of iterations, or that it stops if the value
 has not changed (according to a threshold), or that the language provides
 a special operator to break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 The two first options are available in 
\emph on
Microsoft Excel
\emph default
 by the 
\emph on
calculation options
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Standard
FRP shares with the paradigm of constraints systems the idea, that developers
 declare equations, and the runtime automates variables updates according
 to the equations and input.
 However, they are different: FRP is about defining variables as functions
 over other variables, while constraints systems are about to satisfy constraint
s.
\end_layout

\begin_layout Standard
There are constraints systems similar to FRP that handle one-way constraints.
 There are other constraints systems that handle two-way constraints.
 Constraints systems that handle two-way constraints, by their nature, handle
 cycles correctly, and allows defining multiple constraints that output
 to the same variable 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 This means that we are not the first to discover reassigment as a way to
 solve cycles.
 However, our finding contributes to area of the constraints systems.
\end_layout

\begin_layout Standard
The traditional constraints systems does not have the nature to work with
 components based architecture and distributed systems.
 Because the runtime is handled by constraints solvers, that are algorithms
 developed for constraints systems to satisfy the constraints.
 The solvers are centeral components that need access to all the variables
 and constraints.
 At this point our new model may help, because it does have the nature to
 work with OOP, which may be extended to work with more architectural patterns.
 
\end_layout

\begin_layout Standard
Our new variant of FRP can be refered as a constraints system.
 In the traditional constraints systems, any two-way constraint are declared
 with the methods to satisfy it, e.g., as implemented by Hotdrink in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 is attached with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=A-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C:=A-B}
\end_layout

\end_inset

.
 In order to use our model, only the methods should be specified.
 If one prefers providing the code in terms of two-way constraints, we can
 think about implementing a wrapper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 class as a future work.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1"

\end_inset

two-way constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 implemented by Hotdrink
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
FRP runtimes achiving predictability usualy use a madiator.
 Madiator is another layer needed in the application, with the added complexity
 compared to traditional simple methods calls.
 In order to support any added formula while achiving predictability, we
 are required to use a constraints system, which hardly depends on a madiator.
 Because when supporting any addes formula, we support any graph, also those
 containing cycles.
 Supporting any added formula in the traditional OOP, might produce unpredictabi
lity from the difficulties to recognize the required changes.
\end_layout

\begin_layout Section
???????/
\end_layout

\begin_layout Section
????
\end_layout

\begin_layout Standard
One modeling method 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 present states and events as transition between them, such that in the
 transition, there are actions, that are code to execute during the transition.
 This method is used in front-end applications by the library 
\emph on
Redux
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 and is promoted by 
\emph on
XState
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
https://xstate.js.org
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In software development, state management refers to the process of maintaining
 and updating the variables of an application or system.
 One common requirement is implementing 
\emph on
reactive variables
\emph default
, variables that are recaluclated in response to dependant variables' updates,
 just like cells in spreadsheet applications, that are re-calculated according
 to specified formulas.
 The FRP paradigm provides solutions to implement reactive variables.
 The developers should specify formulas, and the solution uses its runtime
 to enforce them.
 For this discussion, we extend the term 
\emph on
FRP runtime
\emph default
 to any solution that handles the task of updating variables in response
 to other variables’ updates.
\end_layout

\begin_layout Standard
FRP runtime can be implemented by the technique named 
\emph on
inversion of control
\emph default
 (IoC).
 According to IoC, objects provide consumers to register code that update
 variables, to be executed in the events that other variables are updated.
 By this technique, enterprise applications provide customers to extend
 the application according to their business needs, such as 
\emph on
Microsoft Power Apps
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://powerapps.microsoft.com
\end_layout

\end_inset

 do.
 In the enterprise application Microsoft Power Apps, developers can register
 plugins that update fields, to be re-calculated according other fields.
 Registering one custom plugin might lead to infinite loop of updates caused
 from several registered plugins.
 This familiar problem has the ad-hoc solution to stop the loop by the provided
 field named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Depth}
\end_layout

\end_inset


\emph on

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://carldesouza.com/dynamics-365-understanding-plugin-depth
\end_layout

\end_inset


\emph default
, containing how many times the current plugin is executed.
\end_layout

\begin_layout Standard
A second approach provides reactive variables being 
\end_layout

\begin_layout Section
???????
\end_layout

\begin_layout Standard
In software development, state management refers to the process of maintaining
 and updating the variables of an application or system.
 One common requirement is implementing 
\emph on
reactive variables
\emph default
, variables that are recaluclated in response to dependant variables' updates,
 just like cells in spreadsheet applications, that are re-calculated according
 to specified formulas.
 The FRP paradigm provides solutions to implement reactive variables.
 The developers should specify formulas, and the solution uses its runtime
 to enforce them.
 For this discussion, we extend the term 
\emph on
FRP runtime
\emph default
 to any solution that handles the task of updating variables in response
 to other variables’ updates.
\end_layout

\begin_layout Standard
Implementing FRP runtime is challenged, because it might face unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications scale
 with many features and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, that variable
 might be part of a long chains of updates, so it might fall into an endless
 loop.
 Consequently, scaling the application is unpredictable, because any change
 might produce an unpredictable behavior.
\end_layout

\begin_layout Standard
(Solutions achiving predictable are either non-modular or monolithic or
 both.
 Non-modular, that the reactive variables and formulas cannot generaly be
 specified in seperated objects or components.
 Monolithic, that even when the reactive variables and formulas can be seperated
, the reactive variables are not interacting like peer to peer.
 Intsead, there is one centeral algorithm accessing to the entire data.)
\end_layout

\begin_layout Section
Modularity
\end_layout

\begin_layout Section
Non Predictability
\end_layout

\begin_layout Standard
Originaly, the OOP paradigm provided 
\emph on
objects encapsulation
\emph default
 in order to scale applications without making unpredictable behavior.
 According to the objects encapsulation, objects' variables are protected
 from being updated by external code.
 Instead, objects expose methods, by which an object's consumers ask the
 object to update its variables.
 However, the achievable modular FRP runtime is unpredictable.
\end_layout

\begin_layout Standard
By a technique named 
\emph on
inversion of control
\emph default
 (IoC), objects can provide consumers to register code that update variables,
 to be executed in the events that other variables are updated.
 By this technique, enterprise applications provide customers to extend
 the application according to their business needs, such as 
\emph on
Microsoft Power Apps
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://powerapps.microsoft.com
\end_layout

\end_inset

 do.
 In the enterprise application Microsoft Power Apps, developers can register
 plugins that update fields, to be re-calculated according other fields.
 Registering one custom plugin might lead to infinite loop of updates caused
 from several registered plugins.
 This familiar problem has the ad-hoc solution to stop the loop by the provided
 field named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Depth}
\end_layout

\end_inset


\emph on

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://carldesouza.com/dynamics-365-understanding-plugin-depth
\end_layout

\end_inset


\emph default
, containing how many times the current plugin is executed.
\end_layout

\begin_layout Section
Supporting any added formula
\end_layout

\begin_layout Standard
In FRP, the runtime should provide predictable behavior against potential
 loops caused from cycles in the dependency graph.
 There are two opposing opinions.
 In one approach, cycles should be avoided, because then the referential
 transparency property is broken 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 But in the second approach, forbidding cycles makes FRP unacceptably weak,
 because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 According to this approach, a library named 
\emph on
Hotdrink
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, implements a constraints system for user interfaces.
 The library re-constructs the dependency graph whenever the user edits
 a field.
\end_layout

\begin_layout Standard
Using the approach that cycles exist and supported, the runtime stops arisen
 loops either after an amount of iterations, or that it stops if the value
 has not changed (according to a threshold), or that the language provides
 a special operator to break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 The two first options are available in 
\emph on
Microsoft Excel
\emph default
 by the 
\emph on
calculation options
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Non-Modular
\end_layout

\begin_layout Standard
Originaly, FRP is about high level syntax and predictable behavior, not
 about modularity and components.
 FRP solutions usually collects the formulas in its implemented compilation
 or evaluation process.
 Solutions like REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "salvaneschi2014rescala"
literal "false"

\end_inset

 constructs a graph data structure and the runtime uses the graph to maintain
 the variables.
 Solutions like 
\emph on
XFRP 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "shibanai2018distributed"
literal "false"

\end_inset

 generates code that handles the updates according to the specified formulas.
\end_layout

\begin_layout Section
Monolithic
\end_layout

\begin_layout Section
Non-Modular
\end_layout

\begin_layout Standard
The FRP runtime should collect the formulas and continuously reevaluating
 the variables according to the formulas and input.
 FRP solutions usually collects the formulas in its implemented compilation
 or evaluation process.
 Solutions like REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "salvaneschi2014rescala"
literal "false"

\end_inset

 constructs a graph data structure to enforce later.
 Solutions like 
\emph on
XFRP 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "shibanai2018distributed"
literal "false"

\end_inset

 generates code that handles the updates according to the specified formulas.
 In contrast, solutions depending purly on the observer pattern, does not
 need a special mechanism to collect the formulas.
\end_layout

\begin_layout Section
??????
\end_layout

\begin_layout Standard
——-
\end_layout

\begin_layout Standard
Reactive variables by their nature suffer from (1) cycles, (2) glitches
 and (3) reassigments.
 This leads approaches achiving predictable being either non-modular or
 monolithic or both.
 Non-modular, that the reactive variables and formulas cannot generaly be
 specified in seperated objects or components.
 Monolithic, that even when the reactive variables and formulas can be seperated
, the reactive variables are not interacting like peer to peer.
 Intsead, there is one centeral algorithm accessing to all of the reactive
 variables and formulas.
\end_layout

\begin_layout Standard
——–
\end_layout

\begin_layout Standard
In software development, state management refers to the process of maintaining
 and updating the variables of an application or system.
 There are many different approaches and techniques that can be used for
 state management, depending on the specific requirements of the application
 and the programming language or framework being used.
 One common requirement is the 
\emph on
spreadsheet behavior
\emph default
, i.e., to recalculate variables in response to dependant variables' changes,
 just like cells in spreadsheet applications, that are re-calculated according
 to specified formulas.
 
\end_layout

\begin_layout Standard
———-
\end_layout

\begin_layout Standard
In one technique named 
\emph on
inversion of control
\emph default
 (IoC), object's consumer registers code to update variables, to be executed
 in the events that other variables are updated.
 By this technique, enterprise applications provide customers to extend
 the application according to their business needs.
 In the enterprise application 
\emph on
Microsoft Power Apps
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://powerapps.microsoft.com
\end_layout

\end_inset

, developers can register plugins that update fields, to be re-calculated
 according other fields.
\end_layout

\begin_layout Standard
In another approach, 
\end_layout

\begin_layout Standard
The custom plugin might lead to infinite loop of updates caused by several
 registered plugins.
 Therefore, the field 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Depth}
\end_layout

\end_inset


\emph on

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://carldesouza.com/dynamics-365-understanding-plugin-depth
\end_layout

\end_inset


\emph default
 is provided to the developer to stop the loop.
 The field is like the cursion depth, containing how many times the current
 plugin is executed.
\end_layout

\begin_layout Standard
The OOP observable pattern provides a technique to implement the spreadsheet
 behavior
\end_layout

\begin_layout Standard
The used approaches and techniques can be categorized to those who are 
\end_layout

\begin_layout Standard
In order to recalculate variables in response to dependant variables' changes,
 there are diffrent techniques
\end_layout

\begin_layout Section
Adding Formulas
\end_layout

\begin_layout Standard
The FRP paradigm provides solutions to the task of updating variables in
 response to other variables' updates.
 The developers should specify formulas, and the solution uses its runtime
 to enforce them.
 For this discussion, we extend the term 
\emph on
FRP runtime
\emph default
 to any solution that handles the task of updating variables in response
 to other variables' updates.
\end_layout

\begin_layout Standard
The FRP runtime should collect the formulas and continuously reevaluating
 the variables according to the formulas and input.
 FRP solutions usually collects the formulas in its implemented compilation
 or evaluation process.
 Solutions like REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "salvaneschi2014rescala"
literal "false"

\end_inset

 constructs a graph data structure to enforce later.
 Solutions like 
\emph on
XFRP 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "shibanai2018distributed"
literal "false"

\end_inset

 generates code that handles the updates according to the specified formulas.
 In contrast, solutions depending purly on the observer pattern, does not
 need a special mechanism to collect the formulas.
\end_layout

\begin_layout Section
Predictability
\end_layout

\begin_layout Standard
FRP runtimes might cause unpredictable behavior and even infinite loops
 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications scale
 with many features and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, that variable
 might be part of a long chains of updates, so it might fall into an endless
 loop.
 Consequently, scaling the application is unpredictable, because any change
 might produce an unpredictable behavior.
\end_layout

\begin_layout Subsection
OOP
\end_layout

\begin_layout Standard
In order to scale applications without making unpredictable behavior, OOP
 suggests objects encapsulation, by which objects' variables are protected
 from being updated by external code.
 Instead, objects expose methods, by which an object's consumers ask the
 object to update its variables.
 OOP also provides the inheritance mechanism, to reuse software without
 breaking the encapsulation.
\end_layout

\begin_layout Standard
OOP are based on the control-driven imperative paradigm, by which the program
 is executed line by line.
 On top of it, OOP provides 
\emph on
indirect control
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "martin2018clean"
literal "false"

\end_inset

, such that object's consumer calls a method according to its names and
 arguments, but the actual method is known only in runtime.
 This should keep on the object's encapsulation, because the object's consumer
 need to call methods according to the interface and not according to the
 actual implementation.
\end_layout

\begin_layout Standard
There is an option named 
\emph on
inversion of control
\emph default
 (IoC), such that an object's consumer will register code, that will be
 executed by the object in certain events.
 By this option, there is an option to register code that update variables,
 to be executed in the events that other variables are updated.
\end_layout

\begin_layout Standard
Based on OOP and IoC, enterprise applications can provide customers to extend
 the application according to their business needs.
 In the enterprise application 
\emph on
Microsoft Power Apps
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://powerapps.microsoft.com
\end_layout

\end_inset

, developers can register plugins that update fields, to be re-calculated
 according other fields.
 The custom plugin might lead to infinite loop of updates caused by several
 registered plugins.
 Therefore, the field 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Depth}
\end_layout

\end_inset


\emph on

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://carldesouza.com/dynamics-365-understanding-plugin-depth
\end_layout

\end_inset


\emph default
 is provided to the developer to stop the loop.
 The field is like the cursion depth, containing how many times the current
 plugin is executed.
\end_layout

\begin_layout Standard
In OOP, an object's variables are called its 
\emph on
state
\emph default
, because it represents the state of the object 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

, or that its state is derived from the variables.
 There is a modeling method 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 to present states and events as transition between them, such that in the
 transition, there are actions, that are code to execute during the transition.
 This method is used in front-end applications by the library 
\emph on
Redux
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 and is promoted by 
\emph on
XState
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
https://xstate.js.org
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
FRP
\end_layout

\begin_layout Standard
FRP is a paradigm developed to provide predictable calculations and updates.
 In traditional programming, developers have difficulties controlling the
 task of manually maintaining variables, by calling functions to be executed
 in various events.
 In contrast, FRP provides a declerative style to define the data dependencies
 explicit, and a runtime to maintain them.
\end_layout

\begin_layout Standard
In the most elegant style, functions over reactive variables are declared,
 producing the runtime behavior named 
\emph on
one-way data flow contraint
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

 or 
\emph on
spreadsheet behavior
\emph default
.
 Declaration such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 means 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 to be function of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

, with the runtime behavior that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

 triggers updates of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

.
 This elegance is provided automatically instead of manually maintaining
 the formula as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:manually-maintaining-one-way"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

B_changed += { (e) => b=e; a = b+c; A_changed.Invoke(a); }
\end_layout

\begin_layout Plain Layout

C_changed += { (e) => c=e; a = b+c; A_changed.Invoke(a);}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:manually-maintaining-one-way"

\end_inset

Manually maintaining one-way data flow contraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although the notion of using the high-level syntax of reactive variables,
 We see in the paradigm the concept of events harmonized in several forms
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional"
literal "false"

\end_inset

.
 In one form, streams of events are used similar to reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Actualy a reactive variable can be represented by a stream of events representi
ng the variable's values as a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 This produces more a verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Supporting any added formula
\end_layout

\begin_layout Standard
In FRP, the runtime should provide predictable behavior against potential
 loops caused from cycles in the dependency graph.
 There are two opposing opinions.
 In one approach, cycles should be avoided, because then the referential
 transparency property is broken 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 But in the second approach, forbidding cycles makes FRP unacceptably weak,
 because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 According to this approach, a library named 
\emph on
Hotdrink
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, implements a constraints system for user interfaces.
 The library re-constructs the dependency graph whenever the user edits
 a field.
\end_layout

\begin_layout Standard
Using the approach that cycles exist and supported, the runtime stops arisen
 loops either after an amount of iterations, or that it stops if the value
 has not changed (according to a threshold), or that the language provides
 a special operator to break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 The two first options are available in 
\emph on
Microsoft Excel
\emph default
 by the 
\emph on
calculation options
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
??????
\end_layout

\begin_layout Paragraph
Avoiding
\end_layout

\begin_layout Standard
In 
\emph on
true FRP
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 the graph must not have cycles, because the code is constructed similar
 to pure functions.
 The functional style is used in order to achieve the 
\emph on
referential transparency 
\emph default
property, i.e., the same input produces consistenctly the same output.
 
\end_layout

\begin_layout Standard
In addition, in 
\emph on
glitch free
\emph default
 FRP, there are special algoritms to prevent from the incomplete updates
 .
 Indeed, avoiding cycles is a necessary condition to the algorithms 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Cycles are not handled by default also by Microsoft Excel (with the term
\emph on
 circular dependencies
\emph default
).
 Also React provides only one-way dataflow 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

, and so also 
\begin_inset CommandInset citation
LatexCommand cite
key "marum2020unified"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
There is also an approach to avoid the glitches
\begin_inset Foot
status open

\begin_layout Plain Layout
https://staltz.com/rx-glitches-arent-actually-a-problem.html
\end_layout

\end_inset

: variable depends on several variables with a single ancestor will be defined
 directly by that ancestor.
 
\end_layout

\begin_layout Paragraph
Limitation
\end_layout

\begin_layout Paragraph
Iterations
\end_layout

\begin_layout Standard
In contrast, FrTime and other FRP implementations 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

 support cycles such as by providing a keyword 
\emph on
delay
\emph default
 to break an update loop.
 However, the solution is a 
\begin_inset Quotes eld
\end_inset

compromise consistent
\begin_inset Quotes erd
\end_inset

.
 As explained, variables might not complete the calculation by a single
 update (that might be a glitch).
 A more reliable solution is provided by Microsoft Excel, when changing
 the default behavior to avoid cycles by one of the suggested 
\begin_inset Quotes eld
\end_inset

calculation options
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The first option is to terminate the updates after an arbitrary iterations
 amount.
 The second option is to ignore an update if the new value has not been
 changed comparing to the value that the variable contains, or changed only
 less than an arbitrary threshold.
\end_layout

\begin_layout Standard
Terminating the updates after an arbitrary iterations amount, may be a solution.
 However, the developer should find the balance, what constant number to
 choose.
 It might be difficult to find out the minimum number, that is the needed
 amount for applications with many dependencies.
 While, an high amount might perform low perfomance by unnecessary updates.
\end_layout

\begin_layout Standard
In the second method the developers need to find a threshold.
 The threshold is needed due to loose of information though calculations,
 e.g., In an application that contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A/3
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B*3
\end_layout

\end_inset

, if the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 might be calculated and updated with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100/3=0.33
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 should not be updated with the new calculated value 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.33*3=0.99
\end_layout

\end_inset

, consequently the chosen constant threshold should be less than 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.01
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
In order to protect against infinite loop
\end_layout

\begin_layout Standard
Previous approaches provides solutions to cycles but did not provide semantics
 to cycles, but solutions to the phenomenon.
\end_layout

\begin_layout Standard
According to previous approaches, the data-dependencies should be hierarchical.
 
\end_layout

\begin_layout Standard
—–
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (0,5) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (3.5,5) {B};       
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge [bend left] (B);  
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge [bend left] (A);
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(A) + (1.75,-0.75)$)    {A:=B/3};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(A) + (1.75,0.75)$)    {B:=A*3};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Loosing informCycle while loose of information
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
It is likely that infinite loops happens because of 
\emph on
indepedent definitions
\emph default
 to update variable in response to the other variables' updates.
 Nevertheless, The problem will not happen if the new definitions only derive
 existing variables.
\end_layout

\begin_layout Standard
In case of mutual recursions such like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:simple-cycle"
plural "false"
caps "false"
noprefix "false"

\end_inset

 there might be infinite loops, caused from the cycle that A should update
 B, and B should update A.
\end_layout

\begin_layout Standard
is defined by B and B is defined by A.
\end_layout

\begin_layout Standard
Our model supports cycles caused from mutual recursions, where reactive
 variables are defined in terms of each other, e.g., the FRP application in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:simple-cycle"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
, application might contain 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and also 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Cycles need a special treatment, because it might lead to infinite loops.
 As in the example, updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, that might lead again to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Standard
Cycles need a special treatment, because it might lead to infinite loops.
 As in the example, updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, that might lead again to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Standard
Furthermore, in the the 
\emph on
glitch
\emph default
 problem 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, a variable can have several updates caused by a single update.
 Consequently, ignoring repeating updates might lead to incomplete calculations.
 e.g., in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "false"
noprefix "false"

\end_inset

, updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y1
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y2
\end_layout

\end_inset

, each of them might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, therfore 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 with an incomplete calculation, therfore 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 should not ignore a second update.
\end_layout

\begin_layout Paragraph
Avoiding
\end_layout

\begin_layout Standard
In 
\emph on
true FRP
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 the graph must not have cycles, because the code is constructed similar
 to pure functions.
 The functional style is used in order to achieve the 
\emph on
referential transparency 
\emph default
property, i.e., the same input produces consistenctly the same output.
 
\end_layout

\begin_layout Standard
In addition, in 
\emph on
glitch free
\emph default
 FRP, there are special algoritms to prevent from the incomplete updates
 .
 Indeed, avoiding cycles is a necessary condition to the algorithms 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Cycles are not handled by default also by Microsoft Excel (with the term
\emph on
 circular dependencies
\emph default
).
 Also React provides only one-way dataflow 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

, and so also 
\begin_inset CommandInset citation
LatexCommand cite
key "marum2020unified"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
There is also an approach to avoid the glitches
\begin_inset Foot
status open

\begin_layout Plain Layout
https://staltz.com/rx-glitches-arent-actually-a-problem.html
\end_layout

\end_inset

: variable depends on several variables with a single ancestor will be defined
 directly by that ancestor.
 
\end_layout

\begin_layout Paragraph
Limitation
\end_layout

\begin_layout Paragraph
Iterations
\end_layout

\begin_layout Standard
In contrast, FrTime and other FRP implementations 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

 support cycles such as by providing a keyword 
\emph on
delay
\emph default
 to break an update loop.
 However, the solution is a 
\begin_inset Quotes eld
\end_inset

compromise consistent
\begin_inset Quotes erd
\end_inset

.
 As explained, variables might not complete the calculation by a single
 update (that might be a glitch).
 A more reliable solution is provided by Microsoft Excel, when changing
 the default behavior to avoid cycles by one of the suggested 
\begin_inset Quotes eld
\end_inset

calculation options
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The first option is to terminate the updates after an arbitrary iterations
 amount.
 The second option is to ignore an update if the new value has not been
 changed comparing to the value that the variable contains, or changed only
 less than an arbitrary threshold.
\end_layout

\begin_layout Standard
Terminating the updates after an arbitrary iterations amount, may be a solution.
 However, the developer should find the balance, what constant number to
 choose.
 It might be difficult to find out the minimum number, that is the needed
 amount for applications with many dependencies.
 While, an high amount might perform low perfomance by unnecessary updates.
\end_layout

\begin_layout Standard
In the second method the developers need to find a threshold.
 The threshold is needed due to loose of information though calculations,
 e.g., In an application that contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A/3
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B*3
\end_layout

\end_inset

, if the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 might be calculated and updated with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100/3=0.33
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 should not be updated with the new calculated value 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.33*3=0.99
\end_layout

\end_inset

, consequently the chosen constant threshold should be less than 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.01
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Paragraph*
Decenterlized/No-Isolation
\end_layout

\begin_layout Standard
In the core of OOP paradigm, objects should hide their variables.
 So instance variables that need to be updated according to other instance's
 variable, should invovlve direct interaction, without to require a third
 party.
\end_layout

\begin_layout Standard
Hotdrink manages the variables by the constraints solver.
\end_layout

\begin_layout Paragraph*
Any dependency
\end_layout

\begin_layout Standard
Classes or types that contains reactive instance variables in their interface,
 allow to declare any dependency from those instance variables.
 If cycles are avoided such as in Soduium, then there is the limitation
 to avoid from declaring certain dependencies.
\end_layout

\begin_layout Paragraph*
Predictable Propogation
\end_layout

\begin_layout Standard
The core of the FRP paradigm is to provide predictable propogation.
 by the referntial transparcncy property, the same sequence of input produce
 consistenly the same output.
\end_layout

\begin_layout Standard
If there are cycles, if the (Bridging the gui gap with reactive values and
 relations...)
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Safe Propogation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Any dependency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decenterlized
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FrTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReactiveX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sodium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributed REscala
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XState
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
????????
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unsafe Propogation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Centerlized
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FrTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReactiveX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sodium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributed REscala
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XState
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
???????
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
unsupported constructions, unpredictable results or to no-isolation
\end_layout

\end_body
\end_document
