#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

Background
\end_layout

\begin_layout Standard
As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the fields calculations have similarities with reactive variables and
 FRP.
 In FRP the operations are lifted, so that once a variable or a field is
 assigned, it is accosiated to the assigned expression, to continuously
 re-evaluated according to relevant changes.
 
\end_layout

\begin_layout Standard
For example
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables or fields 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 The accosiation establishes data dependencies, so that the left side variable
 depends on the variables in the right side.
 Naivly the left side should be recalculated in response to any change in
 any of the variables it depends on.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // A=2
\end_layout

\begin_layout Plain Layout

B=6 // A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
hspace{3cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 represent reactive variables or fields.
 The code and the graph illustrate the established dependencies.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The noval approach of FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Actualy, as in the state management solution 
\begin_inset Formula $\NAME{MobX}$
\end_inset

 with the 
\begin_inset Formula $\NAME{React}$
\end_inset

 framework, fields calculations can consist of reactive variables implemented
 by a state management solution connected to the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reactive-Variables"

\end_inset

Paradigms
\end_layout

\begin_layout Standard
In implementing fields calculations, there are three available paradigms:
 events (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Events"
plural "false"
caps "true"
noprefix "false"

\end_inset

), streams (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and constraints (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Events"

\end_inset

Events
\end_layout

\begin_layout Standard
In programming frameworks, such as in web development, code that updates
 fields based on other fields can be registered to be executed when fields
 are changed.
 For example, in 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{input.addEventListener('input', calculate)}
\end_layout

\end_inset

 means to execute 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{calculate}
\end_layout

\end_inset

, when the user interacts with the input element by changing its value.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A closely related concept is named 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

, where events are modeled as state transitions between logical states,
 which are derived from variable values.
 As described in and shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools not only allow for updates to occur when an event happens
 but also enable updates based on the exact state of the application, derived
 from previous interactions.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Observable-Streams"

\end_inset

Streams
\end_layout

\begin_layout Standard
As an alternative to manipulating fields or variables, there is the strategy
 of modeling programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 due to 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers observable streams, which are objects that abstract collections
 for interested observers, passing their items to them by calling their
 next method (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an alternative to the fields or variables manipulation, there is the
 strategy to model programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 by 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx initialy developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is available now for many programming languages,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variables are presented as observable streams consists of the values
 or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events generated from UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variable value changes as an observable stream
\end_layout

\end_inset

Variable value changes as an observable stream.
 Variable 
\begin_inset Formula $A$
\end_inset

 changed to 
\begin_inset Formula $5$
\end_inset

 initially, then to 
\begin_inset Formula $3$
\end_inset

, and after a longer period, it changed to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This abstraction has several issue.
 First, in case of 
\emph on
accidental recursion
\emph default
s, the behavior does not behave properly.
 For example, if the code contains 
\begin_inset Formula $\LSTINLINE{A=D.Select(x=>x+1)}$
\end_inset

 and accidently it is added 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

.
 It is like saying 
\begin_inset Formula $A=D+1$
\end_inset

 and also 
\begin_inset Formula $D=A-1$
\end_inset

.
\end_layout

\begin_layout Standard
The other problems are related to a phenomenon named 
\emph on
simultaneous events.
 
\emph default
In the default change propogation, observables synchronously respond to
 notifications by passing them forward.
 This traversal can be likened to a depth-first search (DFS) algorithm,
 where a change event initiates a sequence of computations in a depth-first
 order.
 The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 of the vertices reached during the traversal.
 This traversal order has the known issue named 
\emph on
glitch
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset


\emph on
.

\emph default
 Certain nodes may be visited multiple times, while some of these visits
 involving outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the spanning tree, resulting from the DFS traversal, contains nodes with
 more than one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values.
 The multiple incoming edges of a node represent simultaneous events, which
 are related to the same time, that originaly caused by a single event.
\end_layout

\begin_layout Standard
Similary in the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator, the simultaneous events cause an incorrect behavior.
 The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator creates an observable stream, where each item from any of the
 input streams triggers a corresponding item in the output stream.
 If two streams have items from the same time, originating from a single
 event, the resulting stream will contain it twice.
 
\end_layout

\begin_layout Standard
The issues caused by accidental recursions, as well as simultaneous events,
 prevent the abstraction from being referential transparent.
 For recursions, this merely leads to infinite loops.
 For simultaneous events, it is not explicitly defined in what order the
 items should be generated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{next(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{next(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D=B+C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
An example for the glitch issue with the default behavior with observable
 streams
\end_layout

\end_inset

An example for the glitch issue with the default behavior with observable
 streams.
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents a sequence diagram of observable streams
 used for fields calculations, started from a change event to 
\backslash
lstinline{A}.
 The calls order in the sequence diagram is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}) (
\backslash
subref{fig:graph}) presentes the spanning tree resulted from the  traversal
 order, leading that the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This programming model has also the problem, that it supports the events
 model.
 For example.
 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

which means that 
\end_layout

\begin_layout Plain Layout
Because it allows mutual recusraion there might be an accidental recusrsn,
 that causes an infinite loop.
 For example, if we add to the example 
\begin_inset Formula $\LSTINLINE{D.Subscribe(val=>A.OnNext(val-1))}$
\end_inset

, then D and A are mutual recusraion: 
\begin_inset Formula $A=D+1$
\end_inset

 and also 
\begin_inset Formula $D=A-1$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ReactiveX, available in languages like C# and JavaScript through frameworks
 like RxJS, provides observable streams.
 Observable streams are like a list, that produce the items.
 Field change events can be used to iniate an observable streams.
 and in the other hand, an observable can be subscriebd by visual elements
 to update values.
 The operators Select and CombineLatest creates observables, that their
 items are creatd in response to items in other observables, and based on
 their values.
 For exmaple, B=D.Select(x=>x+1), each value in D is executed by the function
 x=>x+1, and produe the result in D.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FRP adopts this concept, so A:=B+C signifies that the reactive variable
 A depends on both B and C.
 During runtime, A continuously contains the value derived from the values
 contained in B and C, respectively.
\end_layout

\begin_layout Plain Layout
The composition can be visualized as a tree or graph, where each variable
 represents a node, and the dependencies between them are represented by
 edges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This works nice for hirarchial data.
 Inherently FRP does not support cycles.
 neverthless , frameworks provide special constructs to introduce cycles
 directly.
 This is less elegance, because it should be specified to the framework
 
\emph on
how
\emph default
 to not come into an infinite loop 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 (algorithm to handle cycles, keeping on the abstraction?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constraints"

\end_inset

Constraints
\end_layout

\begin_layout Standard

\emph on
Constraint systems
\emph default
 shares a common idea with FRP: developers declare equations, and the runtime
 automates variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

 which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the methods 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The systems utilize algorithms, named 
\emph on
constraints solvers
\emph default
, to maintain consistency in variable values.
 As in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints.
 For each variable 
\begin_inset Formula $X$
\end_inset

 containing a value 
\begin_inset Formula $x$
\end_inset

 , the runtime maintains a constraint 
\begin_inset Formula $X=x$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, the more prioritized
 constraints, according to the hirarchy, are satsified.
 As a result, once the user put new input for a field, the fields that relied
 on a previous input, specifically the oldest input, are overwritten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset


\end_layout

\end_inset

Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{constraint}$
\end_inset

 method is used to create the constraint by specifying the variables as
 arguments and chaining the necessary methods.
 Each method has two parameters: the data flow direction and the function
 to execute when that method is chosen to satisfy the constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset

Maintaining 
\begin_inset Formula $\NAME A$
\end_inset

 and 
\begin_inset Formula $\NAME B$
\end_inset

 according to the constraint 
\begin_inset Formula $\NAME{A=B}$
\end_inset

, using constraint hierarchies.
 Each row represents a step in the interaction.
 The first column mentions the input provided.
 The second column mentions the exiting constraints following the input
 provided.
 The third column displays the values of the variables, as determined by
 the constraint solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
title(observable streams)....Although the high level abstraction, the events
 concept still exist in the paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018,blackheath2016functional,proencca2017quality"
literal "false"

\end_inset

.
 In the approach used by ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, functions over 
\emph on
events streams
\emph default
 are declared, preserving the referential transparency property.
 Actualy reactive variables can be represented by events streams representing
 the varying value over time, similar to a list 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,schuster2016reactive"
literal "false"

\end_inset

.
 However, there is a big difference between the original reactive variable
 to this representation.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1"

\end_inset

An events stream representing a varying value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In addition to the more verbose syntax 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 achieved by events streams, the mechanism is very different.
 Functions over events streams are typicaly not handled by a special runtime
 with the graph data structure.
 Instead, the events streams are 
\emph on
observables
\emph default
, with 
\emph on
operators
\emph default
 over them, that subscribe and produce events streams.
 Accordingly objects can have reactive variables as part of their interface,
 while the values are propagated according to the events mechanism.
 Generally speaking, reactive variables as events streams does no depend
 on the madiator exists in the original FRP, because they interact directly.
\end_layout

\begin_layout Plain Layout
The madiator has access to all the variables and formulas, so it can provide
 more predictable behavior.
 For example, if one variable has several updates caused by a single update,
 such as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that updating 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

.
 In case that the variables interact directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will have an incorrect update named 
\emph on
glitch.
 
\emph default
In contrast, a madiator has the knowledge of the special construction to
 handle the updates correctly.
 So 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{D}
\end_layout

\end_inset

 will be updated only when both 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C}
\end_layout

\end_inset

 has been updated.
 Even though the madiator can provide more predictable behavior, there are
 sometimes requirements that prefer directed interaction over a madiator.
 For example, typical distributed applications prefer directed interacton
 to reduce perfomance.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In libraries like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset

, we only need to specify the constraints, and the library automaticaly
 update the fields during the user interaction.
 For example, for cpecifying 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, each edited tuple, the third variable will be updated automaticaly.
 The library need to get as input, not only the constraints, but also methods
 to execute to update the fields .
 For this example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=B-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C=A-B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Components
\end_layout

\begin_layout Standard
The complexity of field calculations can be divided into several components,
 allowing larger and more complex components to be constructed from smaller
 and simpler ones.
\end_layout

\begin_layout Subsection
Sequential Components
\end_layout

\begin_layout Standard
In the distributed setting of the FRP paradigm, components can be connected
 in a sequential manner, where each component's output is passed as input
 to the next component 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
A similar approach is adopted by 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 when it comes to rendering.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, each component possesses a 
\begin_inset Formula $\LSTINLINE{render}$
\end_inset

 function, which is responsible for generating and returning the corresponding
 component view.
 This view can consist of nested components, forming a hierarchical structure
 that facilitates the composition of complex user interfaces.
\end_layout

\begin_layout Standard
The concept of connecting components sequentially in the FRP paradigm aligns
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

's component rendering approach.
 The hierarchical nature of 
\begin_inset Formula $\NAME{React}$
\end_inset

 components allows for the composition of reusable and encapsulated UI elements.
\end_layout

\begin_layout Subsection
State Management
\end_layout

\begin_layout Standard
In modern frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset

 and also 
\begin_inset Formula $\NAME{Flutter}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

 applications utilize dedicated state management solutions to handle variables.
 These solutions can take the form of FRP-like approaches such as 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 or a straightforward data store.
\end_layout

\begin_layout Standard
Among these state management solutions, 
\begin_inset Formula $\NAME{Redux}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 stands out as a highly popular choice.
 It adopts a model inspired by 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, events are modeled as state transitions between logical states, which
 are determined based on variable values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {};
\end_layout

\begin_layout Plain Layout

     
\backslash
node[round] (S4) at (2.5, -3) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180, in=90] (S1);
\end_layout

\begin_layout Plain Layout

    
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.8] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.8] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.8] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.8] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

     
\backslash
draw[-latex] (S4) to [loop below, looseness=8, out=-60, in=-120, min distance=10
mm] node[scale=0.8]  { y changed/calculate x;
\end_layout

\begin_layout Plain Layout

z changed/calculate x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
draw (3.5, -4) coordinate (empty);
\end_layout

\begin_layout Plain Layout

      
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)(empty)] (System) {};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset


\end_layout

\end_inset

Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

.
 The rectangular shapes represent different states or modes of the application.
 The arrows represent transitions between the states, triggered by specific
 events.
 The labels contain the events and also actions, if needed, to perform in
 response to events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://legacy.reactjs.org/
\end_layout

\end_inset

 and 
\begin_inset Formula $\NAME{Flutter}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

, the layout on the screen is declared as function of the application's
 variables, named 
\emph on
state
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev/data-and-backend/state-mgmt/declarative
\end_layout

\end_inset

.
 The state is handled seperatedly with a dedicated component.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{Redux}$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 is a very popular state management solution.
 Events are modeled as state transitions between logical states, which are
 derived from variable values.
 As described in 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 and shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools not only allow for updates to occur when an event happens
 but also enable updates based on the exact state of the application, derived
 from previous interactions.
 In its centralization approach, this solution helps to develop a predictable
 behavior.
\end_layout

\begin_layout Plain Layout
However, it leads to repeating on calling to functions in handling the events.
 For instance, in order to implement 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

, we should call ro recalculate 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 in the event that 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 is updated, and also in the events that 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 is updated.
\end_layout

\begin_layout Plain Layout
in order that to ensure that the value of 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 reflects 
\begin_inset Formula $\LSTINLINE{y+z}$
\end_inset

 whenever either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{y}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{z}
\end_layout

\end_inset

 is updated, we must calculate 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x}
\end_layout

\end_inset

 in two event handlers.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multiple-Components"

\end_inset

Multiple Components
\end_layout

\begin_layout Standard
Recently, there has been a trend towards 
\emph on
micro-frontends architecture
\emph default
, wherein UI components are developed and deployed independently to enable
 scalable and flexible application growth 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

.
 This architecture is closely related to 
\emph on
component-based applications
\emph default
, where the application is composed of reusable code components, that uses
 concepts from OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Components can call each other, with the caller and callee sharing an interface,
 hiding implementation details.
 This interface is commonly referred to as a contract and consists of named
 operations with corresponding arguments.
 The interface allows parties to be changed without requiring others to
 make modifications.
\end_layout

\begin_layout Standard
In practice we find challenges in coordinating behavior between components.
 In the context of micro-frontends, this architecture presents challenges
 regarding handling shared state and facilitating communication
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

.
 Similary, in 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, where it is possible to register components known as 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 These components can include code that executes in response to field updates,
 performing calculations and updating fields accordingly.
 However, in the absence of a formal contract, there is a risk of encountering
 an infinite loop.
 For example, if the first component recalculates field 
\begin_inset Formula $A$
\end_inset

 whenever field 
\begin_inset Formula $B$
\end_inset

 is changed, and the second component recalculates field 
\begin_inset Formula $B$
\end_inset

 whenever field 
\begin_inset Formula $A$
\end_inset

 is changed, this circular dependency can result in an infinite loop of
 recalculations.
\end_layout

\begin_layout Standard
In OOP, the issue is named 
\emph on
object re-entrance
\emph default
, where an object indirectly calls another object that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 This causes problems in objects compositions and inheritance.
 Therefore, frequently there is a knowledge that should be shared in addition
 to the interface.
 It is called sometimes an 
\emph on
informal contract.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
The micro-frontends architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "Geers2020,Peltonen2021"
literal "false"

\end_inset

 suggests that UI components are developed and deployed indepedently.
 This concept is derived from the micro-services architecture in the backend,
 and is related also to the traditional OOP paradigm.
 Beside the interface that objects provide, there is an 
\emph on
informal contract 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 , which is intructions or best practices to how to use objects correctly.
 
\end_layout

\begin_layout Plain Layout
Specificaly, in systems like 
\begin_inset Formula $\NAME{Microsoft}$
\end_inset

 
\begin_inset Formula $\NAME{Dynamics}$
\end_inset

, it is enabled to register components, named 
\emph on
plugins
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 The components can contain code to execute in response to field updates,
 that contains code that calculates and updates fields.
 Due to lack of a formal contract, there might be an infinite loop, if the
 first component recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, and the second component reclculated field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the instructions to help the developers to manage the plugins correctly.
 For example, to take care of infinite loop, in case that one component
 recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, while the second reclculates field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The informal contract can contain the instruction, that code that the client
 registers, to be executed when an object's variables changed, should not
 update this object's variables 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The clients need to carefuly design their plugins, so tha the system will
 not 
\end_layout

\begin_layout Plain Layout
The registered components might be non-coordinated.
 For example, if the first component recalculates a field 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed, and the second component reclculated field 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 whenever 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is changed.
 
\end_layout

\begin_layout Plain Layout
Similary, an object provided as a service, beside its interface to the clients,
 that consists of signature methods that the clients can call, has an 
\emph on
informal contract
\emph default
 with the clients, usually attached as documentation.
 For example,
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The frameworks strike a balance between abstraction and generality.
 Event-driven programming frameworks give developers complete control over
 the propagation order, but this can be error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides a more abstract approach, allowing developers to choose between
 several schedulers to indicate the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset

 Constraints systems like FRP frameworks go even further, abstracting away
 the propagation order altogether and allowing developers to focus on specifying
 the data dependencies.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over the frameworks, it is challenged to coordinate the field calculation
 behaviors, particularly when establishing dependencies to update fields
 based on changes in other fields.
 This process requires careful consideration of transitive dependencies.
 Otherwise, unintentional recursion can lead to unexpected updates.
 For predictable addition of calculations, it is required that they be in
 the same class or component to ensure that the calculations are correct,
 that there are no cycles, or that cycles are handled correctly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Example, react component can be reactive variable, the view is calculated
 according to the state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
\end_layout

\begin_layout Plain Layout
The OOP paradigm 
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 Objects and cmponents use the information hiding principle and introducing
 contracts to how they interacts, without that they need to be aware of
 implementation details.
\end_layout

\begin_layout Plain Layout
The OOP paradigm helps to build components-based applications, because the
 components contain objects and use the principles of the OOP paradigm.
 In components based applications, organizations can deploy components that
 would extend an exsting application.
 For example, in the plugin architeture, code components named plugins,
 can be registered in the system to be executed in certain events.
 
\end_layout

\begin_layout Plain Layout
The main concept of the OOP paradigm, is the information hiding.
 It has been introduced to solve the problem of variables calculations.
 In software development has the problem about the the variables is, that
 it is hard to reason about the values that variables contains.
 To solve this problem, in the OOP paradigm,programs are modeled according
 to objects, so that each object will hide its variables.
 The objects have methods, by which they are used.
 fields can be updated only by those methods.
 The implementation details of the methods and the variables need to be
 hidden.
 
\end_layout

\begin_layout Plain Layout
The objects or components methods signitures are used to be a contract,
 and the implementain details are hidden.
 The idea of OOP, is code that consists of method calls to objects, depending
 on the contract.
 building larger components from smaller ones while preserving their individual
 behaviors.
\end_layout

\begin_layout Plain Layout
The system executes code of a registered plugin in response to fields updates.
 This code can contain code that update fields according to other fields.
 the developer need to be aware of more information, consisdered as the
 informal contract.
\end_layout

\begin_layout Subsection
Separation between the fields calculation specification and the runtime
\end_layout

\begin_layout Plain Layout
By using constrains system, we have two components: the constraints specificatio
n, and the system.
 This seperation helps the developers, so he or she does not need to specify
 how to calculate fields, but only what calculations to apply.
 Also in the FRP paradigm, langugages like REScala (that is not in the distribut
ed settings), the langague has the runtime, that update the variables.
\end_layout

\begin_layout Subsection
OOP
\end_layout

\begin_layout Plain Layout
As an alternative, the components are stateless, and the whole state is
 used by a dedicate solution.
 for example, in react, there is redux, that helps to build a dedicated
 components to handle the state, to the specific needed logic (varuable
 to state?).
 Another example, Hotdrink, handle the variables according to specified
 constraints.
\end_layout

\begin_layout Plain Layout
A third option depends on informal contracts between components.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In react application, the state can be managed like a state machine
\end_layout

\begin_layout Plain Layout
reasons when no hirarciala data: plugins, DDD, granularity.
\end_layout

\begin_layout Plain Layout
in order to extend applicaion by plugin
\end_layout

\begin_layout Plain Layout
contemporary frameworks, like react, provides a building blocks for composing
 components.
 The component consists of the html that is the view.
\end_layout

\begin_layout Plain Layout
Component in react is a view given as function.
\end_layout

\begin_layout Plain Layout
.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
The problem about variables that it is hard to reason about the values that
 variables contains.
\end_layout

\begin_layout Plain Layout
We find two opposing approaches.
 First, OOP, objectes that interacts, plugins to extend the application,
 conceptual modeling.
 Second, a special component to handle the state.
 OOP is usefull to provide widgets.
 a centeral state management is usefull to improve reasoning.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Front end components, we find the concept of reactive variables usefull,
 to develop fields that compute values depending on the values in other
 fields.
 The most popular tool is spreadsheets, a cell represents a field and can
 contain a formula that defines its dependency on other cells.
 Alternatively, by frameworks like REScala are used to declare the data
 dependencies, which is then connected to events.
 In frameowkrs like react, the developer declare the view as a function
 of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
(reactive variable's change produes an even and vise verca.
 MobX provides a framework to implement (like) reactive variables as a state
 management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
 This enables to only specify the data dependencies, and the runtime does
 the updates.
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
Reactve variablres are
\end_layout

\begin_layout Plain Layout
A langaguse with an abstraction like reactive variables depends on coming
 changes, and it preserve on the assignments, by reassigning whenener there
 is a change.
\end_layout

\begin_layout Plain Layout
In our focus is on front end applications, we find the concept of reactive
 variables usefull, in the common functionality to customize fields that
 are aytomaticaly filled based on other fields.
 One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement (like) reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields (the view is reactive variable by declaring it by function
 of the application's variables).
\end_layout

\begin_layout Plain Layout
Alternatvely, reactive variables can implicity implemented by the events
 driven programming 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 It invovlves iniating a mutable variables, and change events, for whom
 code can be registered to update other variables.
 Another alternative suggests to function over streams.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, data dependencies are constructed using pure functions, like the
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Signals
\end_layout

\end_inset

 in 
\begin_inset Formula $\REScala$
\end_inset

.
 Alternatively, frameworks for event streams, like 
\begin_inset Formula $\ReactiveX$
\end_inset

, enable the application of functions to streams, where each stream produces
 its values based on the values of the input streams.
 It is commonly suggested that in order to ensure predictability, the graph
 should not contain cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The FRP paradigm is derived from the functional paradigm to ensure explicit
 depedencies.
 Concretely, the code composed of pure functions, without to deal with the
 mutate variables.
 The problem about the variables, that it is hard to reason about the values
 that the variables contains.
 Therfore, in FRP, the code are composed of functions.
 The paradigm aims to rpovide the high level langage with a predictale behavior.
\end_layout

\begin_layout Plain Layout
As a result, the FRP paradigm helps to simplify front ends applications,
 specificaly when fields need to contously contain values depending on the
 values in other fields.
 The reactive variables are categorized into input and output variables.
 The input variables are typicaly connected to recive events from a visual
 elements, and the output variables are connected to update visual elements.
 This most popular use for this concept is in spreadsheets applications.
 Each cell of a spreadsheet, represented a field, can contain a formula
 to contiuously update dependong on the values of the cells used in the
 formula.
 In other libraries, like REScala, the variables are connected by an API
 built for this purpose.
 In countermporary frameowkrs like react , the developer declare the view
 as a function of the variables of the applicatiom, called state.
 the framework continuously present the view according to the appliation's
 state.
 this method connects betwee MobX provides a framework to implement (like)
 reactive variables as a state management solution to integrate with React.
\end_layout

\begin_layout Plain Layout
In our context, the composed reactive variables need to not
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Implementing reactive variables for a front end is suited as state management.
\end_layout

\begin_layout Plain Layout
There are two opposing methods,
\end_layout

\begin_layout Plain Layout
Most reactive variables solutions consists of a centerlized mechanizm in
 their reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Therfore, in the context of components-based applications, it coupled the
 application to a madiaotr, that have access to
\end_layout

\end_inset


\end_layout

\begin_layout Section
Building Blocks
\end_layout

\begin_layout Plain Layout
In the context of developing systems, reactive variables, streams, and events
 can be considered as building blocks or units that you can utilize to construct
 or implement reactive and event-driven functionality.
 They serve as fundamental concepts or tools that enable you to handle and
 propagate changes within your system.
 Here's a breakdown of their roles:
\end_layout

\begin_layout Paragraph*
Reactive Variables
\end_layout

\begin_layout Plain Layout
Reactive variables provide a way to represent and manage data that automatically
 updates when dependent data changes.
 They are building blocks that allow you to define dependencies and establish
 reactive behavior within your system.
 Reactive variables enable you to express how data should react to changes
 and facilitate automatic propagation of updates.
\end_layout

\begin_layout Paragraph*
Streams
\end_layout

\begin_layout Plain Layout
Streams represent a sequence of data that can be processed incrementally
 or asynchronously.
 They serve as building blocks for modeling and transforming data flows
 within your system.
 Streams allow you to express the continuous flow of data and enable you
 to apply operations or transformations to the data as it moves through
 the stream pipeline.
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Plain Layout
Events are mechanisms that allow components or entities within a system
 to communicate and react to specific occurrences or triggers.
 They serve as building blocks for handling and propagating notifications
 or signals about important system events or changes.
 Events facilitate loose coupling and decoupled communication between components
, enabling them to react to relevant events without having direct knowledge
 of each other.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
By utilizing reactive variables, streams, and events as building blocks,
 you can develop systems that are responsive, flexible, and can effectively
 handle and propagate changes.
 These concepts provide the necessary foundations to build reactive, event-drive
n, or data-driven systems, depending on your specific requirements and use
 cases.
\end_layout

\begin_layout Section
Complexity Graphs
\end_layout

\begin_layout Section
Change Propagation
\end_layout

\begin_layout Plain Layout
There are mechanism that make a graph data structure in the memory 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Section
Events
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The OOP paradigm provides an alernative by the observer pattern.
 Objects can provide observers to register, to later execute tehri code,
 whenever variables are updated.
 Similary, objects can expose an OnChange event, that will be used to eceute
 code that update dependant variables.
 Cross systems, there are sometimes hooks, to call external code in response
 to a change in the data.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(I wrote this, and asked the gpt generate )The Observer pattern in Object-Orient
ed Programming (OOP) can adress the issue of interdependent fields in for
 front-end applications.
 Objects can contain variables that are equivalent to the fields in UI applicati
ons.
 By using the Observer pattern or events, it is possible to register code
 to be executed when a field or a variable is changed.
 Otherwise, code that update a variable (or a field) might be changed, to
 update other depedant variables.
 Instead, by t the observer pattern, we have the ability to hide logic,
 which can help to separate concerns and make code easier to manage.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Objects can use the observer pattern, or expose events to execute code when
 fields are updated, to enable other fields to be updated accordingly.
 If the code that updates one field needs to directly update additional
 fields, modifying the code to update one field might require changing the
 locations in the code where the other fields are updated.
 This leads to a centralized maintenance model, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where all the calculation logic is centralized and tightly coupled, making
 it difficult to isolate the code for each field.
 As an alternative, each field or variable has an onchange event, and multiple
 event handlers are registered, that update depedant fields.
\end_layout

\begin_layout Plain Layout
In reality, the onchange events did not effectively address the issue.
 It has been observed that relying solely on onchange events based on object
 contracts can lead to unexpected updates and values, as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 To address this issue, developers often add logic to determine when to
 update variables.
 Many modern applications use tools like 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
XState
\end_layout

\end_inset

 (https://xstate.js.org) or 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Redux
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 to model events as state transitions between logical states 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 derived from variable values.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, these tools allow specifying updates not only when an event occurs but
 also based on the exact state of the application, which is derived from
 previous interactions.
 However, this approach still relies on centralized management of the applicatio
n's state, making it a monolithic approach.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The provided strategy enables many patterns.
 One such strategy is to develop a single calculation procedure that can
 be implemented and called in response to field change events.
 However, this approach has the disadvantage of recomputing fields even
 when they do not need to be recomputed, which can lead to performance issues
 and unnecessary re-rendering of field values that have not been updated.
 Furthermore, a single calculation procedure can become overly complex and
 difficult to maintain as the application grows.
\end_layout

\end_inset


\end_layout

\begin_layout Section
DataFlow
\end_layout

\begin_layout Plain Layout
Frameworks based on the dataflow paradigm allow for the explicit specification
 of data dependencies, which were previously implicit.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The dataflow paradigm provide frameworks to explicity specify the data dependenc
ies, that previously specified implicity.
 In the FRP paradigm data dependencies are composed as pure functions.
 Alternatively, events streams frameworks, such as ReactiveX, enable to
 function over the streams, such that each each stream produces its values
 depending on the values of the input streams.
 It is often claimed that, in order to provde 
\emph on
predictability,
\emph default
 the graph should be acyclic.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The observer pattern can be used with the iterator pattern to provide observable
 stream.
 Observables streams push values notifications to their subsribers.
 On top of it, operators over observable stream, produce values to subseuent
 subscribers, based on the input observable streams.
\end_layout

\begin_layout Plain Layout
For example, in ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val+1))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, some applications, including the example we provided, inherently
 have cycles in their data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, ensuring that the dependency graph is acyclic becomes a challenge,
 and it limits the ability to separate the code.
 Developers need to be aware of data dependencies and detect existing paths
 before adding new formulas that involve existing variables to prevent cycles.
 For example, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 Consequently, it is not possible to establish boundaries that prevent access
 to the formulas, which can lead to a monolithic codebase.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
However, many applications, as our example, have cycles by their nature
 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Furthermore, in order to ensure that the graph is acyclic, the ability
 to seperate the code is reduced.
 Because, in order to ensure that the graph is acyclic, developers must
 ensure that no node has a path leading back to itself.
 This requires the developer to have knowledge of data dependencies and
 to detect existing paths before adding new formulas that involve existing
 variables.
 If a cycle is detected, the developer should avoid adding the new formula
 to the graph to prevent the creation of a cycle.
 For instance, if there are already two formulas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset

, and the developer wants to add a third formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset

, they must have access to all three formulas and detect the existing cycle
 among nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 If a calculation is linked to a variable, but the variable has dependencies
 that fall under a separate concern, it is linked without considering those
 dependencies.
 This means that the graph may not necessarily be acyclic.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
old
\end_layout

\begin_layout Plain Layout
While in the events paradigm, developers 
\emph on
implicitly
\emph default
 create a 
\emph on
data dependency graph
\emph default
, frameworks such the ones of FRP provides this explicity.
\end_layout

\begin_layout Plain Layout
The FRP paradigm, enable to express reactive variables as pure functions,
 so that the data dependemcy management can be predictable composed, depending
 on the 
\emph on
referential transparency
\emph default
 property.
\end_layout

\begin_layout Plain Layout
In the FRP paradigm reactive variables are defined as functions over other
 reactive variables, while the runtime maintains the variables' values.
 The runtime uses a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 to manage the updates.
\end_layout

\begin_layout Plain Layout
accordingly, using a directed acyclic graph data structure 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In REScala, also instance variables can be reactive variables (i.e., objects
 can have reactive variables as part of their interface) having such runtime
 to maintain them 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 For example, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

 defines the reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 to be a function of reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

.
 The runtime uses a graph ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Directed-acyclic-graph"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to automaticaly maintain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

.
 Consequently, there is no need to repeat registering to events to re-calculate
 variables like the ilustration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The FRP paradigm has the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 from being based on pure functions, with the meaning that the same input
 will produce consistently the same output.
 Consequently, the FRP paradigm provides predictability in scaling the applicati
on.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y) at (2,5) {Y};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Z) at (4,5) {Z};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (X) at (3,3) {X};
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Z) edge  (X);
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(X) + (0,1)$)    {X:=Y+Z};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Directed-acyclic-graph"

\end_inset

Directed acyclic graph data structure representing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (C);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (D);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,1)$)    {B:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,1)$)    {C:=A+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(D) + (0,1)$)    {D:=B+C};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch"

\end_inset

A data dependency graph, that in push-based evaluation, might have glitches.
 The nodes represent variables that should be updated either by input or
 by updating according to the specified function in the label.
 Each variable's update leads to update the depedencies.
 Updating A leads to updating B and C, each leads to updating D.
 In the first update, the value is incorrect (a glitch), because B or C
 has not been updated yet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection

\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
duplication
\end_layout

\begin_layout Plain Layout
Comparing to the traditional pure frp, we increased the ability to extend
 applications.
 Because that variables as pure functions can be extended by only deriving
 variables.
 This limitation in FRP, to not link calculations to existing variables
 causes variables duplications.
 Becasue, if we cannot target to exsting variable, we create a new one.
 (excel examples)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
In front-end applications, developers may create a data dependency graph
 either explicitly or implicitly to populate fields based on other fields.
 However, in certain scenarios where the application's data dependencies
 are complex, a centralized or monolithic graph might be required.
 This means that the data dependency definitions are located in a single
 code base that cannot be separated, or the runtime relies on an intermediary
 for variable updates.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, where fields are automatically filled based on
 other fields, the developers explicity or implicitly create one centeral
 
\emph on
data dependency graph
\emph default
 in which updates to variables recursively trigger updates to dependent
 variables.
 This graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The existing frameworks suggest seperating between declating dependencies
 to maintaining them, between diffrent acyclic graphs only if ther are unconnect
ed or that they produced acyclic graph,
\end_layout

\begin_layout Plain Layout
There are FRP runtimes that are based on the traditional simple methods
 calls, and are unpredictable.
 Others more predictable solutions use a madiator with the added complexity
 of having another layer needed to the application.
 There are FRP runtimes for distributed applications that do not use a madiator,
 but as the FRP paradigm, they support only the sets of formulas producing
 directed acyclic graphs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
