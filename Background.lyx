#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
Reactive Programming
\end_layout

\begin_layout Standard
Reactive Programming (RP) harmonizes concepts from traditional paradigms
 for programming reactive systems: Events, Unidirectional Dataflow and Constrain
ts.
 Each of the paradigms addresses has a unique abstraction mechanism to manage
 inconsistencies, which might exist in the runtime data and static data.
 Inconsistency in runtime data refers to non-valid states, of which variables'
 values have not been calculated in accordance to other variables' values.
 Inconsistency in static data refers to those bugs causing by an error-prone
 process, handling code-changes several times.
 Reducing inconsistency in static data is handled by reducing code repetition
 by paradigms' independent reusable units.
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
Events (or observer pattern) are used for reusable objects, so that objects
 will not depend on specific callers, but the callers would subscribe/listen
 to their relevant events.
 We can implement events that would execute in response to variables' changes,
 triggering event handlers which would trigger other variables to calculate
 considering the new values.
\end_layout

\begin_layout Subsection
Unidirectional Dataflow
\end_layout

\begin_layout Standard
Reactive systems may be abstracted as composed mathematical functions, using
 reactive variables or streams (by managing effects).
 In this manner, we can specify reusable code of how to calculate data by
 other data.
 In runtime, while an input device produces an input, the system will produce
 a changes chain according to the program, until triggering the output devices
 to produce the effects.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
There are reactive systems which can be abstracted as multidirectional constrain
ts (One-way dataflow constraint is similar to unidirectional dataflow as
 in 2.2).
 Constraints solvers (algorithms) manage the runtime, to handle any input
 and update variables to satisfy the constraints.
\end_layout

\begin_layout Section
Object-Oriented Programming
\end_layout

\begin_layout Standard
Objects refers to real-world objects (e.g.
 Persons), described by the property named 
\emph on
identity
\emph default
.
 The real-world objects' variables (or attributes) (e.g.
 Persons' weight) are represented by objects' instance variables.
 Specifically, an instance variable may be an association to another object's
 identity.
 The real-world objects' variables' values 
\emph on
vary
\emph default
 during their life-cycle, simulated by 
\emph on
updating
\emph default
 the instance variables content.
 
\end_layout

\begin_layout Standard
(Originaly objects are like components, used to save time by using ready-to-use
 components instead of develop again and again.
 Accordingly, doing a new feature or a bug fix, can be performed once.
 However, we should be carful about components' changes, to prevent from
 unexpected changes.
 
\end_layout

\begin_layout Standard
We recognize two mechanizms to prevent from unexpected changes.
 First, components have 
\emph on
interfaces
\emph default
 as contracts, seperating the specification from the implementation details.
 Second, instance variables are encapsulated, each object manage its instance
 variables seperatly.
\end_layout

\begin_layout Standard
There are several related technical issue preventing from being that elegant
 paradigm.)
\end_layout

\begin_layout Subsection
Vary the Variables
\end_layout

\begin_layout Standard
By definition, objects maintain their internal state (data), resulting limitatio
n in abstracting objects' variables' changes: to be included only in the
 code of the object containing the variables.
 To rid of the limitation, objects implement accessors methods to manipulting
 their instance variables.
 However, the data is stopped from being controlled by its containing object.
\end_layout

\begin_layout Standard
This is in contrast to keep controlling the objects , from the real-world
 aspect (or the modeller point of view), certain variable changes should
 be part of another object.
 In addition, deriving a class, by the mean of object reuse.
\end_layout

\begin_layout Subsection
Observation
\end_layout

\begin_layout Standard
When instance variables accessors are used (operations to setting and getting
 the instance variables' values), then instance variables can be used as
 part of interfaces.
 However, pulling the values is time and resource consuming, user interfaces
 must invoke the accessors, even when there has not been changes.
 
\end_layout

\begin_layout Standard
Objects need to implement observation features, events abstraction, for
 which user interfaces subscribe to be notified only when changes happen.
 Consequently, the real-worlds entities representation become less simple,
 they involve not only its variables as instance variables, but also the
 concept of 
\emph on
change events
\emph default
, for which consumers should subscribe to get the variables values.
\end_layout

\begin_layout Subsection
Reentrance
\end_layout

\begin_layout Standard
The indirect nature of objects leads to recursive invoke methods, in which
 object sending a message is unaware of the receiver identity and whether
 this message is not a re-entrance.
 When receiving a message, one should be aware of the caller, thus it cannot
 distinguish between initial calls, or recursive calls.
\end_layout

\end_body
\end_document
