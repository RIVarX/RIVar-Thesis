#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard
In the development of user interface applications, the task of updating
 variables in response to other variables' updates, might cause unpredictable
 behavior such as infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

, e.g., variable A might update variable B in response to its update and vice
 versa.
 Unpredictable behavior might exist especially when an application commences
 scaling and have long chains of updates.
\end_layout

\begin_layout Standard
This section provides an overview, for how FRP and OOP have contributed
 to this task of updating variables in response to other variables' updates.
\end_layout

\begin_layout Section
OOP
\end_layout

\begin_layout Standard
OOP suggests objects encapsulation, by which objects' variables are protected
 from being updated by external code.
 Instead, objects expose methods, by which an object's consumers ask the
 object to update its variables.
 OOP also provides the inheritance mechanism, to reuse software without
 breaking the encapsulation.
\end_layout

\begin_layout Standard
OOP are based on the control-driven imperative paradigm, by which the program
 is executed line by line.
 On top of it, OOP provides 
\emph on
indirect control
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "martin2018clean"
literal "false"

\end_inset

, such that object's consumer calls a method according to its names and
 arguments, but the actual method is known only in runtime.
 This should keep on the object's encapsulation, because the object's consumer
 need to call methods according to the interface and not according to the
 actual implementation.
\end_layout

\begin_layout Standard
There is an option named 
\emph on
inversion of control
\emph default
 (IoC), such that an object's consumer will register code, that will be
 executed by the object in certain events.
 By this option, there is an option to register code that update variables,
 to be executed in the events that other variables are updated.
\end_layout

\begin_layout Standard
Based on OOP and IoC, enterprise applications can provide customers to extend
 the application according to their business needs.
 In the enterprise application 
\emph on
Microsoft Dynamics
\emph default
 developers can extend the web forms with code that are executed in response
 to events.
 In addition users can extend the forms without code, but by a user friendly
 customization form.
 The user customize 
\emph on
business rules
\emph default
 by drug and drop and easy selection elements.
 By those two options the application can be customized to calculate fields
 in response to other fields changes.
 Similary in the server side, developers can register plugins that update
 fields, to be re-calculated according other fields.
\end_layout

\begin_layout Subsection
??????????
\end_layout

\begin_layout Standard
The key concept behind Objects Oriented Programming (OOP) is that, classes
 evolve without interfering other classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 Classes use 
\emph on
contracts
\emph default
, and encapsulate the internal implementation.
 In the simplified form, the contract is the 
\emph on
interface
\emph default
, which defines variables and methods that are accessible to the consumers
 or subclasses.
 However, in the presence of events an interface is not enough to define
 a contract.
 
\end_layout

\begin_layout Standard
There are various approaches how to define contracts in such cases, but
 they are usually informal and hard to enforce.
 In implementation inheritance in 
\emph on
the fragile base class problem
\emph default
, the contract between the super class and subclass is broken, such as when
 a change in the super class breaks the sub class.
 And in contracts between providers and consumers, there is a significant
 number of design and implementation errors, often hard to define and correct.
\end_layout

\begin_layout Standard
The reason is that events might lead to 
\emph on
unexpected recursive re-entracnce of objects.
 
\emph default
Re-entracnce of objects is when an object's method calls a method that belongs
 to the same object: If a method update several of its instance variables,
 they of course should be consistent (i.e, calculated or updated according
 to each other), so the object's methods 
\emph on
should not
\emph default
 be called until finishing the execution.
 Furthermore, the method 
\emph on
should not
\emph default
 be called again until finishing its execution (but if there is special
 treatment).
\end_layout

\begin_layout Subsection
statechart
\end_layout

\begin_layout Paragraph
Ad Hoc / Specific
\end_layout

\begin_layout Standard
XState
\begin_inset Foot
status open

\begin_layout Plain Layout
https://xstate.js.org/
\end_layout

\end_inset

 and Redux 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 reminds the statechart 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1990statemate"
literal "false"

\end_inset

 or just the simple state-machine.
 The updates are still controlled by state and conditions, but they are
 centerlized and not encapsulated in various objects.
 As a result the variables change become more predictable 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
FRP
\end_layout

\begin_layout Standard
FRP provide the option to define the declerative style to define functions
 over reactive variables, with the behavior named one-way data flow contraint.
 Declaration such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

 means 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to be function of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, with the runtime behavior that updates of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 will trigger updates in 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Although the notion of using the high-level syntax of reactive variables,
 FRP still provides the concept of events that is harmonized in several
 forms 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push,Kamina2018"
literal "false"

\end_inset

 into the paradigm.
 In one form, FRP uses the concept 
\emph on
stream
\emph default
, that represent variable's values as a list.
\end_layout

\begin_layout Itemize
unindirectional dataflow (acyclic)
\end_layout

\begin_layout Itemize
glitch
\end_layout

\begin_layout Itemize
conflicts
\end_layout

\begin_layout Itemize
centeral management / distributed settings
\end_layout

\begin_layout Itemize
one way constraint
\end_layout

\begin_layout Itemize
one way dataflow constraint
\end_layout

\begin_layout Section
Integration between OOP and FRP
\end_layout

\begin_layout Subsection
What is assigment?
\end_layout

\begin_layout Standard
in frp what is assigment? like in FP?
\end_layout

\begin_layout Standard
in javascript we can write f=function(){} same as function f(){}
\end_layout

\begin_layout Standard
in imperative, this is an operator going with the machine clock
\end_layout

\begin_layout Standard
there is a confision in mutiple assigment/ reassigment, what is this assigment
 (in FRP+OOP article)
\end_layout

\begin_layout Subsection
?????
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 as an 
\emph on
event stream
\emph default
, which is an observable emitting values to subscribers, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Subsection
??????
\end_layout

\begin_layout Standard
In integration of functional-reactive code with imperative code might contain
 circular dependencies causing infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in case recursive definitions are presented.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 contain circular dependencies: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
In the integration with FRP there might contain circular dependencies causing
 infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (named also ).
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 
\end_layout

\begin_layout Standard
Unfortunately, the integration and option to implement calculation externaly
 leads to the problem named cycles accidental recursion 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
FRP Integration????
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming langauge 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable as an 
\emph on
event stream
\emph default
, which is an observable emitting values to subscribers, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Standard
integration of functional-reactive code with imperative code might contain
 circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in case recursive definitions are presented.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 contain circular dependencies: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
???????
\end_layout

\begin_layout Standard
In the approach to extend OOP with FRP, an existing language is extended
 with a variation of reactive variables as a data type [42].
 Accordingly, libraries such as ReactiveX
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

 and REscala
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://www.rescala-lang.com}
\end_layout

\end_inset

, support having a variation of reactive variables as objects’ data members
 (named also 
\emph on
instance variables
\emph default
).
\end_layout

\begin_layout Standard
Therefrom, objects' classes can contain
\emph on
 reactive instance variables
\emph default
, that are instance variables of type reactive variables.
 Also, objects' classes can contain formulas based on the reactive instance
 variables they contain.
 The formulas are activated once the objects are created.
 e.g., class 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 contains two reactive instance variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, and contains also the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

.
 Consequently, in each instance of C, 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 that is associated to the instance will continuously re-evaluated in response
 to changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 that is associated to the same instance.
\end_layout

\begin_layout Standard
Similar to the problems causes by unexpected recursive re-entracnce of objects,
 the problems in reactive instance variables.
 Reactive instance variables might have cycles when classes encapsulate
 their formulas, e.g., base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Similary for glitches: base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

 , while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In addition, there is an open question whether to support reassignment 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Declaring class variables being reactive variables, arises that conflict,
 whether to enable reassignment e.g.
 declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 and then 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=C+1
\end_layout

\end_inset

.
 In FRP, reassignment should not be enabled, since in FRP we “describe things
 that exist, rather than actions that have happened or are to happen (i.e.,
 what is, not what does)” 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
 In contrast, in OOP reassignment should be enabled for assigning independently
 e.g., 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 in a base class, and 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=C+1
\end_layout

\end_inset

 in the derived class.
\end_layout

\begin_layout Section
Conclusion?????????
\end_layout

\begin_layout Standard
It is likely that infinite loops happens because of 
\emph on
indepedent definitions
\emph default
 to update variable in response to the other variables' updates, such as
 when extending an application with various features.
 Nevertheless, The problem will not happen if the new definitions only derive
 existing variables.
\end_layout

\end_body
\end_document
