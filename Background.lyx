#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard
Traditionaly, variables that need to be consistent with (i.e., re-calculated
 according to) other variables, either pull the values or use observation
 features .
 Pulling consumes time and resources, because the application must invoke
 the variables, even in cases when no changes have occurred.
 implementing observation features means 
\emph on
events 
\emph default
abstraction, for which user interfaces subscribe to be notified only when
 changes occur.
 For instance, 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue
\end_layout

\end_inset

 should be consistent with 
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence
\end_layout

\end_inset

, and associated according to the formula 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

powerDierence = f(sensorValue)
\end_layout

\end_inset

.
 This should be implemented by subscribing to 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue
\end_layout

\end_inset

 change events to re-evaluate the 
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sensorValue.changed += { (e) -> powerDierence = f(e) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variables that need to be consistent with other variables, 
\emph on
depend
\emph default
 on them.
 Consequently, the variables have 
\emph on
dependencies
\emph default
 that can be modeled by a 
\emph on
dependency graph
\emph default
: variables are respresented by nodes, and for each dependency, there is
 an edge connecting the nodes in the direction of the dependency.
 e.g., the following graph model 
\begin_inset ERT
status open

\begin_layout Plain Layout

sensorValue
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout

powerDierence
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black, label={sensorValue}] (A) at (0,5) {};    
 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black ,label={powerDierence}] (B) at (3.5,5) {}; 
    
\end_layout

\begin_layout Plain Layout


\backslash
draw[-{Triangle[scale=1]}] (A) -- (B);       
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Graphes that contain 
\emph on
cycles
\emph default
 need a special treatment, because it might lead to infinite loops.
 For instance, if an application contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and also 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 (as in the following figure), then updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, that might again lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure} 
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (0,5) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (3.5,5) {B};       
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge [bend left] (B);  
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge [bend left] (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout


\backslash
caption{A simple dependency graph with cycles (by A:=B and B:=A)} 
\end_layout

\begin_layout Plain Layout


\backslash
end{figure} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Furthermore, in the the 
\emph on
glitch
\emph default
 problem 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, a variable can have several updates caused by a single update.
 Consequently, ignoring repeating updates might lead to incomplete calculations.
 e.g., in the application bellow, updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y1
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Y2
\end_layout

\end_inset

, each of them might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, therfore 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 might lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 with an incomplete calculation, therfore 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 should not ignore a second update.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

Y1:=f1(X)
\end_layout

\begin_layout Plain Layout

Y2:=f2(X)
\end_layout

\begin_layout Plain Layout

A:=f3(Y1,Y2)
\end_layout

\begin_layout Plain Layout

B:=f4(A)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (X) at (2,9) {X};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y1) at (1,7) {Y1};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Y2) at (3,7) {Y2};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,5) {A}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,3) {B};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y1) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Y2) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (X) edge  (Y1);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (X) edge  (Y2);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The used cycles ( i.e., cycles in which values are actualy propogated in runtime)
 must have a variable
\end_layout

\begin_layout Standard
with 
\emph on
reassigment
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "salvaneschi2014towards"
literal "false"

\end_inset

, i.e., a variable that, during the application execution, is updated according
 to several formulas, therfore it has several 
\emph on
associations
\emph default
.
 Assume, for the sake of contradiction, that there exists a cycle dependency
 graph, such that each variables has a single association.
 So there is a list of reactive variables, each variable has a single associatio
n, with a formula consisting of the next variable, except the last variable
 that is associated with a formula consisting the first variable.
 In runtime, the variables must have values from external input, therefore
 one of the variables must have an association consisting input, that will
 propogate through the cycle.
 This is a contradiction, since it means that it has an additional association.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (5,5) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bottom line is that variables can be updated in response to more than
 one event 
\begin_inset CommandInset citation
LatexCommand citep
key "caspers2017react"
literal "false"

\end_inset

.
 So it is complex to track the dependencies and implementing them, especially
 that the order of the events is not fully predictable, i.e., for a certain
 application and input events, the events execution order might be inconsistent
 
\begin_inset CommandInset citation
LatexCommand citep
key "abelson1996structure"
literal "false"

\end_inset

.
 Many efforts have been made to abstract away the complexity, provide simpler
 abstractions or hide the concept of 
\emph on
change events
\emph default
 under the wood.
 The cycles are handled diffrently depending on the implementation, and
 affect on the limitations, predictability and modularity.
\end_layout

\begin_layout Section
Abstractions
\end_layout

\begin_layout Subsection
Reactive Variables
\end_layout

\begin_layout Standard
Today, many frameworks support to declare the dependancies and enforcing
 them under the wood.
 The developer then declares the needed dependencies leaving the frameworks
 to handle the perfomance optimization.
 It is desirable that 
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
There are libraries which automaticaly handle variables 
\emph on
consistency
\emph default
 according to a set of constraints.
 While functions are implemented to get 
\emph on
how
\emph default
 a varying variable's value depends on another variable's value.
 Handling consistency means executing the functions, in response to observing
 new values, to update dependant variables with the change.
 
\end_layout

\begin_layout Standard
Take for example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

, there are three methods to satisfy the constraint: 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = Total - Tip
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip = Total - Price
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Total = Price + Tip
\end_layout

\end_inset

.
 In response to any new input, the library choose what method to execute
 to satisfy the constraint.
\end_layout

\begin_layout Standard
When more constraints are specified and against varying input options, choosing
 the methods to execute, become not trivial.
 Therefore, various algorithms have been developed named 
\emph on
constraints solvers
\emph default
.
 The principal is to prioritize the constraints, and iterate them, choosing
 methods which does not override variables that already satisfied by previous
 chosen methods.
 The inputs are considered as contraints, for example if user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip
\end_layout

\end_inset

 with the input 
\begin_inset ERT
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, then the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout

Tip=10
\end_layout

\end_inset

 is added to the set.
 Accordingly, constraints are prioritized according to the order of the
 inputs.
\end_layout

\begin_layout Standard
Constraints solvers are actualy choose a consistent way to handle conflicts.
 If we add to the above example 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price = OriginalPrice - Discount
\end_layout

\end_inset

, then it might be wandered from where 
\begin_inset ERT
status open

\begin_layout Plain Layout

Price
\end_layout

\end_inset

 should be calculated.
 
\end_layout

\begin_layout Subsection
Observable Streams
\end_layout

\begin_layout Standard
When handling applications over time, updating variables using the assigment
 operator, we identified time variation in the real world with time variation
 in the computer.
 Stream is an alternative to model phenomena over time, such as varying
 variable's value, without refering explicity the time.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{ReactiveX}
\end_layout

\end_inset

 is a popular library for the stream programming model.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{ReactiveX}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Observable}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Observer}
\end_layout

\end_inset

 implement the observer pattern for a sequence.
 Observers subscribe to Observables, and the Observables calls the observers'
 methods' 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{OnNext}
\end_layout

\end_inset

 for each item in the sequence.
 
\end_layout

\begin_layout Standard
Based on that observable sequence, there are operators to produce streams
 from observing other streams.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B.Select(b=>b+1)
\end_layout

\end_inset

, observe the items of a stream 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{B}
\end_layout

\end_inset

, whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{B}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

 is called, then the lambda expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{b=>b+1}
\end_layout

\end_inset

 is executed, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{b}
\end_layout

\end_inset

 containing the new value, then the result is used as parameter in calling
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The use of the operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Select}
\end_layout

\end_inset

, produces pure function over streams, and can compose other pure functions.
 For example: adding 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{C=A.Select(a=>a+1})
\end_layout

\end_inset

 to the program, is equivalent to writing only 
\begin_inset ERT
status open

\begin_layout Plain Layout

C=B.Select(b=>b+2)
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

Select
\end_layout

\end_inset

 is an example to the powerful operators provided, that reserves the functional
 purity, and calculate not only the values, but also 
\emph on
when
\emph default
 to get the values.
\end_layout

\begin_layout Standard
The values in the input stream, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}
\end_layout

\end_inset

 in the example, are triggered (by calling the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{OnNext}
\end_layout

\end_inset

), by an external execution, such as an input control, that calls 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{A}'s 
\backslash
textit{OnNext}
\end_layout

\end_inset

 whenever there is a change event.
 The items if the output stream is produced according to the time of the
 inputs stream's items.
 The values in the output stream is used to an external execution, such
 as updating an input control, by subscribing to the output stream (which
 is an observable).
\end_layout

\begin_layout Standard
Marble diagrams are useful to understand how operators operate the streams,
 as in figure 2.1, the input and output items are ilustrated over the time-axis.
 In the example (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Select}
\end_layout

\end_inset

 operator), whenever value is produced in the input stream, value in the
 output is provided.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure} 
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x0) at (1,0) {1};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4,0) {8};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x0) at (6,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x0) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=7cm] (op) {Select
\backslash
{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[baseline=-1mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,minimum height=6mm] (x) {x};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,minimum height=6mm,right=5mm of x] (y) {x+1};
\end_layout

\begin_layout Plain Layout

    
\backslash
draw [fdash] (x) -- (y);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

  
\backslash
}};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x2) at (1,0) {2};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x2) at (3,0) {4};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x2) at (4,0) {9};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x2) at (6,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x2) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x0) -- (0x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (5x0) -- (5x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (6x0) -- (6x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (0x2) -- (0x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x2) -- (2x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x2) -- (3x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x2) -- (5x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x2) -- (6x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Marble Diagram for an execution example for A=B.Select(b=>b+1) }
 
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Handling Cycles
\end_layout

\begin_layout Standard
In 
\emph on
true FRP
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 the graph must not have cycles, because the code is constructed similar
 to pure functions.
 The functional style is used in order to achieve the 
\emph on
referential transparency 
\emph default
property, i.e., the same input produces consistenctly the same output.
 
\end_layout

\begin_layout Standard
In addition, in 
\emph on
glitch free
\emph default
 FRP, there are special algoritms to prevent from the incomplete updates
 .
 Indeed, avoiding cycles is a necessary condition to the algorithms 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Cycles are not handled by default also by Microsoft Excel (with the term
\emph on
 circular dependencies
\emph default
).
 Also React provides only one-way dataflow 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

, and so also 
\begin_inset CommandInset citation
LatexCommand cite
key "marum2020unified"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
It is interesting to see the effect of preventing cycles, on the user friendly
 application 
\emph on
Microsoft Dynamics
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "somani2018dynamics"
literal "false"

\end_inset

.
 In Microsoft Dynamics, users can customize the application by user friendly
 elements such as drug and drop and auto selection (without writing code).
 The user can then customize 
\emph on
business rules
\emph default
 such as calculating fields in response to a change events.
 In addition, developers can write code to execute in response to change
 events.
 However, there is a limitation, that the code is executed only in resonse
 to change that happens directly by the user, and changes happened by business
 rules are ignored.
 Of course, the limitation is to break the cycles in the dependencies.
\end_layout

\begin_layout Standard
In contrast, FrTime and other FRP implementations 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

 support cycles such as by providing a keyword 
\emph on
delay
\emph default
 to break an update loop.
 However, the solution is a 
\begin_inset Quotes eld
\end_inset

compromise consistent
\begin_inset Quotes erd
\end_inset

.
 As explained, variables might not complete the calculation by a single
 update (that might be a glitch).
 A more reliable solution is provided by Microsoft Excel, when changing
 the default behavior to avoid cycles by one of the suggested 
\begin_inset Quotes eld
\end_inset

calculation options
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The first option is to terminate the updates after an arbitrary iterations
 amount.
 The second option is to ignore an update if the new value has not been
 changed comparing to the value that the variable contains, or changed only
 less than an arbitrary threshold.
\end_layout

\begin_layout Standard
Terminating the updates after an arbitrary iterations amount, may be a solution.
 However, the developer should find the balance, what constant number to
 choose.
 It might be difficult to find out the minimum number, that is the needed
 amount for applications with many dependencies.
 While, an high amount might perform low perfomance by unnecessary updates.
\end_layout

\begin_layout Standard
In the second method the developers need to find a threshold.
 The threshold is needed due to loose of information though calculations,
 e.g., In an application that contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A/3
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B*3
\end_layout

\end_inset

, if the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 might be calculated and updated with 
\begin_inset ERT
status open

\begin_layout Plain Layout

100/3=0.33
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 should not be updated with the new calculated value 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.33*3=0.99
\end_layout

\end_inset

, consequently the chosen constant threshold should be less than 
\begin_inset ERT
status open

\begin_layout Plain Layout

0.01
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In the traditional programming, the developers uses state to recognize when
 to update or not to update, and when to trigger an event or to not trigger
 an event.
 Consequently, it might be difficult to comprehend the variables and dependencie
s of the functional requirements (required application logic).
 because the code is tangled with non-functional requirements consisting
 of the internal variables (state) and conditions to technically implement
 (as described, to recognize when to update or not to update) the functional
 requirements.
\end_layout

\begin_layout Standard
XState
\begin_inset Foot
status open

\begin_layout Plain Layout
https://xstate.js.org/
\end_layout

\end_inset

 and Redux 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 reminds the statechart 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1990statemate"
literal "false"

\end_inset

 or just the simple state-machine.
 The updates are still controlled by state and conditions, but they are
 centerlized and not encapsulated in various objects.
 As a result the variables change become more predictable 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Hotdrink 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 maintains priority, when a user updates a variable, its priority becomes
 the highest.
 The values of the variables with the old priority is overridden by calculating
 according to the variables with the higher priority.
 The variables and dependencies are managed by a centralized algorithm named
 
\emph on
constraints solver
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unsafe Propogation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Centerlized
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FrTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReactiveX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sodium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributed REscala
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XState
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hotdrink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
unsupported constructions, unpredictable results or to no-isolation
\end_layout

\end_body
\end_document
