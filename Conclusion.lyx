#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Conclusion"

\end_inset

Conclusion
\end_layout

\begin_layout Standard
Classes with 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

s form like objects with writable fields, such that the fields are continuously
 consistent.
 Previously, in the various models, adding calculations required that they
 be in the same class or component to ensure that the calculations are correct,
 that there are no cycles, or that cycles are handled correctly.
\end_layout

\begin_layout Standard
With this new option to separate into components, there are more options
 to place the boundaries in the applications code.
 One criterion to seperate code to components, is whether it is required
 that changing the code of one component will not affect the other.
 This depends on the organization needs, where each field or calculation
 is best located.
\end_layout

\begin_layout Standard
This may be used to scale up the creation of fields calculations, to improve
 front-end usability.
 It can be said that we provide a new mechanism to handle the redundancy.
 For redundancy in fields or variables, the runtime automatically updates
 the values to make them consistent.
 For redundancy in code, the new model provides a new option to reuse code,
 instead of to duplicate components (to avoid harming existing usages).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Similary, it can be said that the provided mechanism addresses the challenge
 of managing both the 
\emph on
data dependencies
\emph default
 and the 
\emph on
source code dependencies
\emph default
.
 The latter points that if applications that are composed of several components,
 there might be that changing the source code of one component lead to subsequen
t changes in the source code of other components, meaning that the code
 of the component depends on the code of the other coomponents 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 The new mechanism should be used to specify SSOT, thus to 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

 can be managed
\end_layout

\begin_layout Plain Layout
This addresses the challenge of managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

 of the code that manages the data dependencies.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.
 By the OOP features,
\end_layout

\begin_layout Plain Layout
This model provides more boundery options 
\end_layout

\begin_layout Plain Layout
By the use of 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 or other similar extensions for others programming languages, we provide
 a new model of extensibility.
 Classes with RIVars form like objects with writable fields, such that the
 fields are continously consistent.
 Previously in any model, adding calculations required to being in the same
 class or component.
 to make sure that the calculations are correct, that there is no cycles
 or that the cycles are handled correctly.
\end_layout

\begin_layout Plain Layout
By the use of 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 or other similar extensions for others programming languages, we achive
 predictability while enabling to decouple formulas from the used reactive
 variables, so that expressions can be associated to reactive variables
 from outside of objects, and that variables are updated directly by their
 dependencies, without a central madiator.
\end_layout

\begin_layout Plain Layout
This lets a new model of extensibility.
 Classes with RIVars form like objects with writable fields, such that the
 fields are continously consistent.
 Previously in any model, adding calculations required to being in the same
 class or component.
 to make sure that the calculations are correct, that there is no cycles
 or that the cycles are handled correctly.
 This model forms a new type of contract, that 
\end_layout

\begin_layout Plain Layout
This not only helps in managing the data dependencies on runtime but also
 the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Source code dependencies are the dependencies derived from the direction
 of changes in the source code of the applications.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other components.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

, leaving the challenge of managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, this consists of the changes required in the application code.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.
\end_layout

\begin_layout Plain Layout
We have developed a new semantics for creating data dependencies without
 the need to be aware of transitive dependencies.
 This means that variables forming the data dependencies can be part of
 OOP interfaces.
 Consequently, we have achieved a framework that harmonizes the abstraction
 mechanisms of both OOP and FRP, which is also considered a decentralized
 constraints system, and also a state management solution for front-end
 applications
\end_layout

\end_inset


\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
We hope to evaluate the approach of this thesis in improving front-end usability.
 We have considered several options for moving forward.
 One option is to refactor parts of an existing complex healthcare system
 and analyze the time that it takes to fix bugs or to develop new features
 be fore and after the change.
 However, this approach would require the cooperation of the private organizatio
n that owns the system, as we would need to publish internal information.
 Therefore we think about alternative directions.
\end_layout

\begin_layout Standard
We will provide a state management solution to development communities.
 As 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 we hope to create more extensions for the other programming languages.
 In addition we will expand the integration to UI components, as a state
 management solution for frameworks like 
\begin_inset Formula $\NAME{React}$
\end_inset

 and 
\begin_inset Formula $\NAME{Flutter}$
\end_inset

, another alternative to 
\begin_inset Formula $\NAME{Redux}$
\end_inset

.
 They should be checked against real-life applications, or general patterns,
 such as cascading combo boxes, where selecting a value in one combo box
 filters the options available in another combo box.
\end_layout

\begin_layout Standard
Another interesting direction is to develop CLIs or IDEs for programming
 languages such as 
\begin_inset Formula $\NAME{pop-pl}$
\end_inset

, a patient-oriented prescription programming language
\begin_inset CommandInset citation
LatexCommand cite
key "florence2015pop"
literal "false"

\end_inset

.
 Inspired from programming environments and extensions like 
\begin_inset Formula $\NAME{Visual}$
\end_inset

 
\begin_inset Formula $\NAME{Studio}$
\end_inset

 and 
\begin_inset Formula $\NAME{Resharper}$
\end_inset

, the UX can be improved in the form of simple writing.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, creating front-ends with a large number of fields can cause cognitive
 overload, while redundancy improves usability.
 Therefore, to enable redundancy without overwhelming users, front-ends
 might switch to IDEs or smart CLIs.
 In the future model, fields will appear on the screen as if information
 is being typed into a notepad, so that we can freely add redundancy to
 the language.
\end_layout

\begin_layout Standard
We can also research this direction in domains other than healthcare, specifical
ly 
\begin_inset Formula $\NAME{DevOps}$
\end_inset

 tools.
 As in 
\begin_inset Formula $\NAME{Azure}$
\end_inset


\begin_inset Formula $\NAME{Devops}$
\end_inset

, there is interchangeability of front-ends and text editors.
 When specifying pipelines, there are the classic pipelines, which are being
 migrated to 
\begin_inset Formula $\NAME{YAML}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/azure/devops/pipelines/migrate/from-classic-pipe
lines?view=azure-devops
\end_layout

\end_inset


\end_layout

\end_inset

.
 We also think about tasks done by CLIs that we can improve for a user-friendly
 front-end, specifically conflict resolution.
 As an alternative to the 
\begin_inset Formula $\NAME{npm}$
\end_inset

 CLI, we think about drop-down lists that the user can select the package
 version from, while other lists are filtered accordingly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The approach can be expanded.
 The consistency of front-end variable values is similar to the consistency
 needed in the backend or data store.
 For example, systems that handle different aspects might hold records for
 the same entities, with the need to synchronize the data.
\end_layout

\begin_layout Plain Layout
We believe that more options for inferring values, in addition to the presented
 merge operation, will be discovered, while maintaining the consistency
 of the values of the variables.
 We chose the direction to update the variable in response to each change
 in any of the sources.
 However, it might be the case that changes to the value under certain condition
s should be rejected.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
One possible approach is employing 
\emph on
equality tests
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

, where values that remain unchanged are disregarded.
 Additionally, dealing with conflicting values from different sources may
 require extending the abstraction Furthermore, further investigation should
 be conducted on the integration of multiple semantic options.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
performance considerations (non functional requirements) may require changing
 the order of the updates, such as reducing consistency levels for heavy
 calculations.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We expect this approach to be implemented as a state management solution
 to ease the development of front-end applications.
 In front-end development, state management is separated from other parts
 of the development process.
 There are various solutions to handle this role
\begin_inset Foot
status open

\begin_layout Plain Layout
https://docs.flutter.dev/development/data-and-backend/state-mgmt/options
\end_layout

\end_inset

, each with its own maintenance and behavior limitations.
 Our model should be easy to maintain, but its behavior is limited to inferring
 values based on the latest value received from any of the sources.
\end_layout

\begin_layout Plain Layout
There are additional options to be researched for reactive variables to
 infer their values.
 One such option is the use of 
\emph on
equality tests
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

, in which values that have not changed are ignored.
 Additionally, values that conflict with another source may need to be rejected,
 requiring an extension of the abstraction.
 We should also explore integrating several semantic options.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
databases? implement in distributed settings
\end_layout

\end_inset


\end_layout

\end_body
\end_document
