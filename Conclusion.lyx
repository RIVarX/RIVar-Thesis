#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Conclusion"

\end_inset

Conclusion
\end_layout

\begin_layout Standard
Classes with 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

s form like objects with writable fields, such that the fields are continuously
 consistent.
 Previously, in the various models, adding calculations required that they
 be in the same class or component to ensure that the calculations are correct,
 that there are no cycles, or that cycles are handled correctly.
\end_layout

\begin_layout Standard
With the new option to separate into components, there are more options
 to place the boundaries in the applications code.
 One criterion to seperate code to components, is whether it is required
 that changing the code of one component will not affect the other.
 This depends on the organization needs, where each field or calculation
 is best located.
\end_layout

\begin_layout Standard
This may be an efficient mechanism to develop fields calculations with a
 potenstial to improve front ends usability.
 Against redandancy there are two mechanisms.
 For redundancy in fields or variables, the runtime automatically updates
 the values to make them consistent.
 This improve the usability because it promotes the use of redundancies
 in the user interfaces.
 For redundancy in code, the new model provides a new option to reuse code.
 Previously, instead of reusing code, we had to duplicate it and make the
 required changes to avoid harming existing usages.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

 can be managed
\end_layout

\begin_layout Plain Layout
This addresses the challenge of managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

 of the code that manages the data dependencies.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.
 By the OOP features,
\end_layout

\begin_layout Plain Layout
This model provides more boundery options 
\end_layout

\begin_layout Plain Layout
By the use of 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 or other similar extensions for others programming languages, we provide
 a new model of extensibility.
 Classes with RIVars form like objects with writable fields, such that the
 fields are continously consistent.
 Previously in any model, adding calculations required to being in the same
 class or component.
 to make sure that the calculations are correct, that there is no cycles
 or that the cycles are handled correctly.
\end_layout

\begin_layout Plain Layout
By the use of 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 or other similar extensions for others programming languages, we achive
 predictability while enabling to decouple formulas from the used reactive
 variables, so that expressions can be associated to reactive variables
 from outside of objects, and that variables are updated directly by their
 dependencies, without a central madiator.
\end_layout

\begin_layout Plain Layout
This lets a new model of extensibility.
 Classes with RIVars form like objects with writable fields, such that the
 fields are continously consistent.
 Previously in any model, adding calculations required to being in the same
 class or component.
 to make sure that the calculations are correct, that there is no cycles
 or that the cycles are handled correctly.
 This model forms a new type of contract, that 
\end_layout

\begin_layout Plain Layout
This not only helps in managing the data dependencies on runtime but also
 the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Source code dependencies are the dependencies derived from the direction
 of changes in the source code of the applications.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other components.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

, leaving the challenge of managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, this consists of the changes required in the application code.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.
\end_layout

\begin_layout Plain Layout
We have developed a new semantics for creating data dependencies without
 the need to be aware of transitive dependencies.
 This means that variables forming the data dependencies can be part of
 OOP interfaces.
 Consequently, we have achieved a framework that harmonizes the abstraction
 mechanisms of both OOP and FRP, which is also considered a decentralized
 constraints system, and also a state management solution for front-end
 applications
\end_layout

\end_inset


\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
As 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 we hope to create more extensions for the other programming languages.
 They should be checked against real-life applications.
 We believe also that it is crucial to explore additional options for inferring
 values in addition to the presented 
\begin_inset Formula $\NAME{merge}$
\end_inset

 operation.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
One possible approach is employing 
\emph on
equality tests
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

, where values that remain unchanged are disregarded.
 Additionally, dealing with conflicting values from different sources may
 require extending the abstraction Furthermore, further investigation should
 be conducted on the integration of multiple semantic options.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
performance considerations (non functional requirements) may require changing
 the order of the updates, such as reducing consistency levels for heavy
 calculations.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We expect this approach to be implemented as a state management solution
 to ease the development of front-end applications.
 In front-end development, state management is separated from other parts
 of the development process.
 There are various solutions to handle this role
\begin_inset Foot
status open

\begin_layout Plain Layout
https://docs.flutter.dev/development/data-and-backend/state-mgmt/options
\end_layout

\end_inset

, each with its own maintenance and behavior limitations.
 Our model should be easy to maintain, but its behavior is limited to inferring
 values based on the latest value received from any of the sources.
\end_layout

\begin_layout Plain Layout
There are additional options to be researched for reactive variables to
 infer their values.
 One such option is the use of 
\emph on
equality tests
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

, in which values that have not changed are ignored.
 Additionally, values that conflict with another source may need to be rejected,
 requiring an extension of the abstraction.
 We should also explore integrating several semantic options.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
databases? implement in distributed settings
\end_layout

\end_inset


\end_layout

\end_body
\end_document
