#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Evaluation"

\end_inset

Evaluation
\end_layout

\begin_layout Standard
This work presents an approach of management separation of reactive variables
 through the use of objects from the OOP paradigm.
 The goal is to reduce cognitive overload in the developer experience, by
 decreasing code size, and in the user experience, as a result of the improved
 development experience.
 To evaluate the thesis work, we performed several processes:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The observer design pattern is employed, so that state management is not
 centralized.
 As a result, this aligns with the inheritance mechanism.
 The use of the inheritance mechanism is intended to reduce cognitive overload,
 as inheritance is an abstraction mechanism for reusing code, and thus should
 reduce code repetition that creates cognitive overload.
 The goal of the evaluation is to assess whether this approach indeed contribute
s to reducing cognitive overload.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Drug Administration Implementation
\series default
: Development of 
\family typewriter
Drug Administr
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

ation
\family default
 implementations using the thesis approach, comparison between these implementat
ions and the original implementation, analysis of the results.
\end_layout

\begin_layout Itemize

\series bold
Comparative Analysis
\series default
: Definition of a metric to assess cognitive overload.
 Measurement and calculation for several different implementations of 
\family typewriter
Drug Admini
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

stration
\family default
: implementation according to the thesis approach, implementation using
 event-driven programming, and implementation using 
\family typewriter
Excel
\family default
 (representing implementation using reactive variables).
 Presentation of results and explanation of the results.
\end_layout

\begin_layout Itemize

\series bold
Application Evolution Process
\series default
: Comparison between using reactive variables versus using reactive instance
 variables (without referring to objects that contain them).
 A case study of an application evolution process and discussion, showing
 the benefits of using reactive instance variables.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Note Note
status collapsed

\begin_layout Itemize

\series bold
Drug Administration Implementation
\series default
: We developed several implementations of a specific application.
 Some of the implementations use the thesis approach, while others do not.
 Additionaly, we conducted some qualitative comparisons regarding user and
 developer experience between the implementations.
\end_layout

\begin_layout Itemize

\series bold
Comparative Analysis
\series default
: we defined metrics to assess cognitive overload, conducted the measurements,
 and presented the results.
\end_layout

\begin_layout Itemize

\series bold
An Application Evolution Process
\series default
: A comparison of the case using reactive variables versus the use of reactive
 instance variables (without referring to objects).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This work introduces the concept of reactive instance variables, which are
 high-level abstraction variables.
 These variables possess a characteristic similar to reactive variables,
 in that they continuously update automatically with relevant changes according
 to (reactive) assignment statements.
 However, they also have additional properties related to their unique definitio
n as "instance variables" in OOP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Principles for Evaluating the Approach
\end_layout

\begin_layout Plain Layout
This work addresses challenges that arise when developing automatic computation
 features for fields in user interfaces.
 These challenges stem from cognitive overload in user and developer experience.
\end_layout

\begin_layout Paragraph
cognitive overload for Users
\end_layout

\begin_layout Plain Layout
For end-users as well, cognitive overload can negatively impact their experience
 with an interface.
 Here are some factors that can contribute to this load:
\end_layout

\begin_layout Itemize

\series bold
Excessive Fields
\series default
: Too many fields, or irrelevant fields, confuse the user and make it difficult
 to locate those that are actually relevant.
\end_layout

\begin_layout Itemize

\series bold
Irrelevant Elements
\series default
: An overabundance of visual elements or the presence of irrelevant ones
 distracts the user and makes it harder to focus on the task at hand.
 
\end_layout

\begin_layout Itemize

\series bold
Lengthy Processes
\series default
: Long processes require the user to remember a lot of information and follow
 many steps, increasing cognitive overload.
 
\end_layout

\begin_layout Itemize

\series bold
Lack of Clarity
\series default
: Long user manual reflects instructions, as well as errors or a lack of
 feedback, confuse the user and make it difficult to understand the interface.
\end_layout

\begin_layout Paragraph
cognitive overload for Programmers
\end_layout

\begin_layout Plain Layout
cognitive overload is a significant factor in the user interface development
 process and can stem from several sources:
\end_layout

\begin_layout Itemize

\series bold
Code Volume
\series default
: A large amount of code hinders system comprehension, navigation, and maintenan
ce.
 Programmers are required to invest more time in understanding the code
 and locating errors.
\end_layout

\begin_layout Itemize

\series bold
Logical Complexity
\series default
: Complex calculation logic and dependencies between fields require programmers
 to invest more effort in design and implementation.
 As the logic becomes more intricate, the likelihood of errors increases.
\end_layout

\begin_layout Itemize

\series bold
Abundance of Details in Code Building Blocks
\series default
: A large number of items and concepts that constitute the building blocks
 of programming overload memory and hinder code comprehension.
 Programmers are required to learn and retain extensive knowledge to be
 proficient application developers.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Drug Administration 
\series bold
Implementation
\end_layout

\begin_layout Standard
We implemented the 
\family typewriter
Drug Administration
\family default
 application using the approach of the thesis as a desktop application in
 
\family typewriter
C#
\family default
 in 
\family typewriter
JavaScript
\family default
 as a static 
\family typewriter
HTML
\family default
 page, and in 
\family typewriter
React
\family default
.
 For 
\family typewriter
C#
\family default
, we used 
\family typewriter
RIVarX
\family default
, and for 
\family typewriter
JavaScript
\family default
, we used 
\family typewriter
rivarjs
\family default
.
 
\end_layout

\begin_layout Standard
The core design remains consistent across all implementations, but each
 serves a different purpose.
 The first implementation, in 
\family typewriter
C#
\family default
, was used for empirical validation by analyzing change propagation through
 logging.
 The second implementation, the static 
\family typewriter
HTML
\family default
 page, is straightforward to execute because it does not require a compilation
 step.
 The third and final implementation, in 
\family typewriter
React
\family default
, features the most elegant end-to-end code structure (in our view) and
 is the version presented in this thesis.
\end_layout

\begin_layout Subsection
Core Design
\end_layout

\begin_layout Standard
By the use of reactive instance variables we created 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes with a focus on separation according to the business domain:
\end_layout

\begin_layout Itemize

\series bold
During code writing
\series default
: The 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 class defines reactive assignments (in its constructor) that affect variables
 in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 ( 
\begin_inset Formula $\LSTINLINE{Amount}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

) without being aware of other variables in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

, namely the 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

.
 Similary, the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 class defines reactive assignments without being aware of that an instance
 of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 will be used within an instance of a 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
 In other words, each class is defined independently, regardless of the
 structure or context in which it will be used.
\end_layout

\begin_layout Itemize

\series bold
At runtime:
\series default
 The propagation of changes occurs in a decentralized manner, where each
 variable is responsible for sending messages to other variables (without
 knowing them) and updating itself based on the messages it receives from
 other variables.
\end_layout

\begin_layout Standard
But there are still centralized elements:
\end_layout

\begin_layout Itemize

\series bold
Policy
\series default
: While the propagation mechanism is decentralized, the propagation policy
 is centralized.
\end_layout

\begin_layout Itemize

\series bold
Logical Clock
\series default
: Reliance on a central static 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 variable.
\end_layout

\begin_layout Subsection

\family typewriter
React
\family default
 Application
\end_layout

\begin_layout Standard
We created a 
\family typewriter
React
\family default
 application that includes components called 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 .
 Recalling the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 objects, each component receives its corresponding object as input.
 This design is motivated by the goal of creating 
\emph on
micro-frontends
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Peltonen2021"
literal "false"

\end_inset

, which are small, independent applications that can be developed, deployed,
 and maintained separately.
\end_layout

\begin_layout Standard
The components 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 are designed for increased independence.
 They communicate indirectly.
 This interaction occurs through the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 objects.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

 illustrates this communication.
 A user input in a component raises an event that makes a value assignment
 to the corresponding reactive instance variable.
 The value assignment raises a propagation change process through the reactive
 instance variables according to the reactive assignments defined in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
 Each reactive instance variable that has a value assignment causes its
 corresponding field to be updated with the corresponding value.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To increase independence between the components, the communication between
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 is indirect, as it occurs through the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 objects as illistrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
raises value assignment messages to other reactive instance variables 
\end_layout

\begin_layout Plain Layout
We created a 
\family typewriter
React
\family default
 application consists of components 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

.
 As React components, they are functions, each of them has an argument for
 the corresponding object Bag and Pump.
\end_layout

\begin_layout Plain Layout
that can be used as 
\emph on
micro-frontends
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Peltonen2021"
literal "false"

\end_inset

 such that each component can be developed, built, and deployed independently
 as a standalone mini-application.
 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 contains the fields according to 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 contains the fields according to 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-3"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the 
\family typewriter
Drug Administration
\family default
 application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents code in 
\family typewriter
React
\family default
 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents corresponding runtime elements.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the 
\family typewriter
Bag UI
\family default
 and 
\family typewriter
Pump UI
\family default
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 accordingly.
 The dotted lines represent interactions between objects within the components,
 including method calls and event handling.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contain reactive instance variables that send value assignment messages
 .
 In addition, 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 calls reactive instance variables of each otehr to the Set methods.
 The dotted lineds between BagComponent and PumpComponent to their corresonsing
 object (Bag and Pump) means taht UI change event makes a value assignment
 messages to reactive instance variable.
 Conversely, reactive instance variable trigger changes in corresponding
 UI.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
Empirical Validation
\end_layout

\begin_layout Standard
In this subsection, we present a scenario demonstrating the use of the 
\family typewriter
Drug Administ
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

ration
\family default
 application, utilizing a logging capability added in the
\family typewriter
 C# 
\family default
implementation.
 The log for this scenario is shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In the example, there are three steps: setting 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to 10, then 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 to 100, and finally 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

 to 5.
 Each step includes a timestamp for the events and a propagation to update
 other fields with the attached timestamp.
 In the first step, line 1 presents the setting, and then in line 2, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 has an event with the value 10 and timestamp 1.
 The second step, line 3, presents the input, but only line 6 presents the
 event that 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 has the value 100 with timestamp 2.
 In between, there is line 5, which presents the event for concentration
 with value 0.1 and timestamps 1 and 2, as it is computed from the values
 of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 , whose timestamps are now 1 and 2.
 This causes a redundant change event (that is ignored) presented in line
 4, where 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

's timestamp is also 1 and 2, because there is a dependency - 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 on 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 .
 The order of the log is not entirely logical.
 The logging action is an event handler triggered according to the order
 of registrations.
 Therefore, the event in line 4 is caused by (and therefore occurs after)
 line 5.
 
\end_layout

\begin_layout Standard
The order of the log might not seem entirely reasonable at first glance.
 The event in line 4 is logged before the event in line 5, even though it
 is caused by (and therefore occurs after) line 5.
 This discrepancy occurs because the log action is an event handler triggered
 according to the order of registrations.
 The order of the log follows a post-order traversal on top of a traversal
 similar to DFS.
 In the second step, the traversal sequence is 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 (first visit) 
\begin_inset Formula $\Mapsto$
\end_inset

 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 
\begin_inset Formula $\Mapsto$
\end_inset

 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 (second visit), while the log sequence is 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 (second visit) 
\begin_inset Formula $\Mapsto$
\end_inset

 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 
\begin_inset Formula $\Mapsto$
\end_inset

 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 (first visit).
\end_layout

\begin_layout Standard
The final step confirms the previous principles.
 In the next step, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

 has a timestamp of 3 with a value of 5.
 However, the log presents the post-order traversal caused by this.
 The change propagation is as follows: 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

 (value 5, timestamp 3), 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 (value 20, timestamps 2 and 3 computed from 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

/
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

 , 100/5), 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

 (0.5 timestamp 1, 2, and 3 computed based on 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 (from it, there are timestamps 2 and 3) and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (from it, timestamp 1)), 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 (second visit, caused by 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

 , ignored).
 The order of the log in post-order: 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 (value 20, timestamps 1, 2, and 3, second visit), 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

 (value 0.5, timestamps 1, 2, and 3), 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 ( 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 20, timestamps 2 and 3, first visit), 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

 (value 5, timestamp 3).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
1.
 Drug_Control:10
\end_layout

\begin_layout Plain Layout
2.
 Drug_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
3.
 Volume_Control:100
\end_layout

\begin_layout Plain Layout
4.
 Volume_Control: 100 <1,2>
\end_layout

\begin_layout Plain Layout
5.
 Concentration_Control: 0.1 <1,2>
\end_layout

\begin_layout Plain Layout
6.
 Volume_Control: 100 <2>
\end_layout

\begin_layout Plain Layout
7.
 Rate_Control:5
\end_layout

\begin_layout Plain Layout
8.
 Duration_Control: 20 <1,2,3>
\end_layout

\begin_layout Plain Layout
9.
 Dose_Control: 0.5 <1,2,3>
\end_layout

\begin_layout Plain Layout
10.
 Duration_Control: 20 <2,3>
\end_layout

\begin_layout Plain Layout
11.
 Rate_Control: 5 <3>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Log result for an execution of the Drug Administration application.
\end_layout

\end_inset

Log result for an execution of the Drug Administration application.
 The lines that does not end with angle brackets, inform change events directly
 set by the user.
 The angle bracket contains the timestamps, that are the order of the events
 that the value depends on.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename DFS_Validation.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DFS_Validation-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Visualizing Change Propagation for a Scenario in 
\family typewriter
Drug Administration
\family default
 Application.
\end_layout

\end_inset

Visualizing Change Propagation for a Scenario in 
\family typewriter
Drug Administration
\family default
 Application.
 The graph illustrates the propagation of changes after setting the 
\family typewriter
Rate
\family default
 variable to 5, where 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
 have already been set to 10 and 100, respectively.
 The circles represent variables, squares represent expressions assigned
 to them.
 Edges represent the propagation of values, with each edge labeled by the
 value and its corresponding timestamps.
 The primary propagation path is highlighted in bold, while redundant propagatio
n is indicated by dotted lines.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The fill of each of those fields raises events that trigger transitions
 between states.
 The 
\end_layout

\begin_layout Plain Layout
According to the current statechart, the user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
.
 
\family typewriter
Concentration
\family default
 is calculated in response to the filling operations and according to their
 values.
\end_layout

\begin_layout Plain Layout
The current implementation includes only the fields: 
\family typewriter
Drug
\family default
, 
\family typewriter
Concentration
\family default
 and 
\family typewriter
Volume
\family default
.
 
\end_layout

\begin_layout Plain Layout
Statechart presents the different states that the application can be in
 and the events that trigger transitions between those states.
 In each transition an action may be executed.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a 
\emph on
statechart
\emph default
 is used for a visual representation of an implementation of a 
\family typewriter
Drug Administration
\family default
 application using events.
 The statechart presents the different states that the application can be
 in and the events that trigger transitions between those states.
 In each transition an action may be executed.
\end_layout

\begin_layout Plain Layout
As presented in the statechart, the implementation consists of only the
 fields 
\family typewriter
Drug
\family default
, 
\family typewriter
Concentration
\family default
 and 
\family typewriter
Volume
\family default
.
 A user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
.
 Filling a value raises a transition between states, while in 
\end_layout

\begin_layout Plain Layout
When a user fill a field, an event is raised such that there is a move to
 another state 
\end_layout

\begin_layout Plain Layout
As presented in the statechart, the implementation consists of only the
 fields Drug, Concentration and Volume.
 The user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
.
 
\family typewriter
Concentration
\family default
 is calculated in response to the filling operations and according to their
 values.
\end_layout

\begin_layout Plain Layout
According to the current statechart, the user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
.
 
\family typewriter
Concentration
\family default
 is calculated in response to the filling operations and according to their
 values.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a 
\emph on
statechart
\emph default
 is presented.
 Statecharts 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 are used for the visual representation of the behavior of event-driven
 systems.
 They show the different states a system can be in and the events that trigger
 transitions between those states.
 According to the current statechart, the user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
.
 
\family typewriter
Concentration
\family default
 is calculated in response to the filling operations and according to their
 values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In modern frameworks like 
\family typewriter
React
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\family default
 and also 
\family typewriter
Flutter
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

 applications utilize dedicated state management solutions to handle variables.
 Among these state management solutions, 
\family typewriter
Redux
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 stands out as a highly popular choice.
 It adopts a model inspired by 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, events are modeled as state transitions between logical states, which
 are determined based on variable values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Implementation of 
\family typewriter
Drug Administration
\family default
 using 
\family typewriter
Hotdrink
\end_layout

\begin_layout Plain Layout
The Hotdrink library employs a multi-directional constraint programming
 approach, where dependencies between variables and methods for computing
 values are explicitly defined.
 In this system, each "method" not only defines a function for computing
 a variable but also specifies the directions and dependencies between the
 variables involved in the computation.
 For example, in Figure 11, three variables (A, B, C) are defined, and the
 relationships between them are modeled using constraints.
 Each "method" defines how a variable is computed from others: the method
 B, C -> A uses the sum function to compute A from B and C (i.e., A := B +
 C), the method A, C -> B uses the diff function to compute B from A and
 C (i.e., B := A - C), and the method A, B -> C also uses the diff function
 to compute C from A and B (i.e., C := A - B).
\end_layout

\begin_layout Plain Layout
In the Hotdrink system, the constraint solver is based on a model called
 "constraint hierarchies," which allows for prioritizing constraints.
 In addition to the constraints defined in the code, the system adds new
 constraints based on variables that have user input.
 When an input is provided for a variable X, a constraint with maximum priority,
 i.e., X = x, is added.
 Subsequently, the system checks the newly created model.
 When solving the constraints, the system will prioritize the higher-priority
 constraints according to the hierarchy and attempt to satisfy them first.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset


\end_layout

\end_inset

Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{constraint}$
\end_inset

 method is used to create the constraint by specifying the variables as
 arguments and chaining the necessary methods.
 Each method has two parameters: the data flow direction and the function
 to execute when that method is chosen to satisfy the constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset

Maintaining 
\begin_inset Formula $\NAME A$
\end_inset

 and 
\begin_inset Formula $\NAME B$
\end_inset

 according to the constraint 
\begin_inset Formula $\NAME{A=B}$
\end_inset

, using constraint hierarchies.
 Each row represents a step in the interaction.
 The first column mentions the input provided.
 The second column mentions the exiting constraints following the input
 provided.
 The third column displays the values of the variables, as determined by
 the constraint solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Discussion: Transparency of Data Source
\end_layout

\begin_layout Standard
Compared to the old implementation (of 
\family typewriter
Drug Administration
\family default
 presented in the introduction), there is a difficulty in knowing the source
 of each calculated value.
 The old implementation uses a solution where the user is required to make
 choices that define the calculation method, thus the source of each value
 is known.
 Whereas in the new implementation, a field is populated directly or indirectly
 and can therefore receive values from multiple sources.
\end_layout

\begin_layout Standard
This difficulty resembles the known problem, that different methods triggered
 by various events can update shared variables (
\emph on
state management
\emph default
).
 Thus, given a variable containing a certain value, it's hard to know the
 reason for it.
 Below are the advantages of the new implementation over regular state managemen
t.
\end_layout

\begin_layout Itemize
In the new implementation, the source of a value is more constrained and
 therefore more predictable.
 It is more constrained because it is determined by reactive assignments
 and input, whereas regular state management relies on regular code, which
 has many more variations.
\end_layout

\begin_layout Itemize
The user chooses which fields to edit, and can be aware that when they enter
 a value that might conflict with previously entered values, the oldest
 value will be overwritten, as will any values calculated based on that
 old value.
\end_layout

\begin_layout Itemize
It's possible to determine for each value whether it is calculated or a
 user-entered value (this was implemented in all the examples, except for
 the React example).
\end_layout

\begin_layout Itemize
Suggestion for further research: prepare a visualization that shows the
 calculation source for each value.
\end_layout

\begin_layout Itemize
Suggestion for further research: allow more options to whom value would
 override.
 the research could investigate alternative strategies such as:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Prioritization
\series default
: Assigning priorities to different data sources or input methods.
 For example, user input might have higher priority than calculated values,
 or values from a specific source might be preferred over others.
 
\end_layout

\begin_layout Itemize

\series bold
Conflict resolution
\series default
: Implementing mechanisms to detect and resolve conflicts between values,
 such as prompting the user to choose the correct value or using predefined
 rules to determine the appropriate outcome.
 
\end_layout

\begin_layout Itemize

\series bold
Versioning
\series default
: Keeping track of different versions of a value, allowing users to revert
 to previous values or compare changes over time.
 
\end_layout

\begin_layout Itemize

\series bold
Merging
\series default
: Developing strategies to merge conflicting values instead of simply overwritin
g them.
 This could involve averaging values, combining different parts of the data,
 or using other techniques to create a composite value.
\end_layout

\end_deeper
\begin_layout Section
Comparative Analysis
\end_layout

\begin_layout Standard
This work addresses challenges stem from cognitive overload in user and
 developer experience, when developing automatic computation features for
 fields in user interfaces.
 The goal is to assess whether the approach helps reduce cognitive overload.
 
\family typewriter
\series bold

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To this end, the evaluation focuses on a score 
\family typewriter
Efficiency
\family default
 that is calculated from scores 
\family typewriter
Code Quantity
\family default
 and 
\family typewriter
Use Case Coverage
\family default
.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This work addresses challenges stem from cognitive overload in user and
 developer experience, when developing automatic computation features for
 fields in user interfaces.
 Challenges to user experience include, for example:
\end_layout

\begin_layout Itemize

\series bold
Excessive Fields
\series default
: Too many fields, or irrelevant fields, confuse the user and make it difficult
 to locate those that are actually relevant.
\end_layout

\begin_layout Itemize

\series bold
Irrelevant Elements
\series default
: An overabundance of visual elements or the presence of irrelevant ones
 distracts the user and makes it harder to focus on the task at hand.
 
\end_layout

\begin_layout Itemize

\series bold
Lengthy Processes
\series default
: Long processes require the user to remember a lot of information and follow
 many steps, increasing cognitive overload.
 
\end_layout

\begin_layout Itemize

\series bold
Lack of Clarity
\series default
: Long user manual reflects instructions, as well as errors or a lack of
 feedback, confuse the user and make it difficult to understand the interface.
\end_layout

\begin_layout Plain Layout
Challenges to developer experience include, for example:
\end_layout

\begin_layout Itemize

\series bold
Large Code Volume
\series default
: A large amount of code hinders system comprehension, navigation, and maintenan
ce.
 Programmers are required to invest more time in understanding the code
 and locating errors.
\end_layout

\begin_layout Itemize

\series bold
Logical Complexity
\series default
: Complex calculation logic and dependencies between fields require programmers
 to invest more effort in design and implementation.
 As the logic becomes more intricate, the likelihood of errors increases.
\end_layout

\begin_layout Itemize

\series bold
Abundance of Details in Code Building Blocks
\series default
: A large number of items and concepts that constitute the building blocks
 of programming overload memory and hinder code comprehension.
 Programmers are required to learn and retain extensive knowledge to be
 proficient application developers.
\end_layout

\begin_layout Plain Layout
The goal is to assess whether the approach helps reduce cognitive overload.
 To this end, the evaluation focuses on a score 
\family typewriter
Efficiency
\family default
 that is calculated from scores 
\family typewriter
Code Quantity
\family default
 and 
\family typewriter
Use Case Coverage
\family default
.
\family typewriter
\series bold

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\family typewriter
\series bold
\begin_inset Note Note
status collapsed

\begin_layout Itemize

\family typewriter
\series bold
Code Quantity
\family default
\series default
: For any given task, the smaller the amount of code, the greater the efficiency.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
Use Case Coverage
\family default
\series default
: The higher the coverage of use cases, the greater the efficiency.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series bold
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\family typewriter
\series bold
Documentation Length
\family default
\series default
: Shorter documentation length reflects greater efficiency because it implies
 predictable and general behavior, as opposed to lengthy documentation that
 reflects a multitude of cases or the existence of edge cases.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Based on those scores, we calculate 
\family typewriter
Efficiency
\family default
 by 
\begin_inset Formula $Use\ Case\ Coverage/Code\ Quantity$
\end_inset

.
 We do not measure Documentation Length because we use a consistent documentatio
n length across all implementations, with the identical behavior in all
 of them: maintaining the consistency and currency of the fields.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scores
\end_layout

\begin_layout Standard
The evaluation focuses on a score 
\family typewriter
Efficiency
\family default
 that is calculated from scores 
\family typewriter
Code Quantity
\family default
 and 
\family typewriter
Use Case Coverage
\family default
.
 The 
\family typewriter
Use Case Coverage
\family default
 score refers to counting existing distinct ways a user can interact with
 the application.
 It's measured by counting the permutations of field completion: analyzing
 the different sequences in which a user can fill out the fields from the
 start of the application until all fields are completed.
 Each unique order, regardless of the specific values entered, represents
 a distinct use case.
 
\end_layout

\begin_layout Standard
For example, in a 
\family typewriter
Drug Administration
\family default
 application instance that includes three fields: 
\family typewriter
Drug
\family default
, 
\family typewriter
Volume
\family default
, and 
\family typewriter
Concentration
\family default
, there are six possible permutations (use cases) for how a medical professional
 might fill these out:
\end_layout

\begin_layout Enumerate

\family typewriter
Drug -> Volume -> Concentration 
\end_layout

\begin_layout Enumerate

\family typewriter
Drug -> Concentration -> Volume
\end_layout

\begin_layout Enumerate

\family typewriter
Volume -> Drug -> Concentration 
\end_layout

\begin_layout Enumerate

\family typewriter
Volume -> Concentration -> Drug 
\end_layout

\begin_layout Enumerate

\family typewriter
Concentration -> Drug -> Volume 
\end_layout

\begin_layout Enumerate

\family typewriter
Concentration -> Volume -> Drug 
\end_layout

\begin_layout Standard
The more use cases the code generates, the more value it has, and therefore
 it has a positive impact on the 
\family typewriter
Efficiency
\family default
 metric.
\end_layout

\begin_layout Standard
The 
\family typewriter
Code Quantity
\family default
\series bold
 
\series default
score focuses specifically on the code related to managing fields and their
 calculations within the user interface, excluding code related to visual
 design or layout.
 Therefore, we count and sum the scores for 
\series bold
Variables
\series default
 and 
\series bold
Calculations
\series default
:
\end_layout

\begin_layout Itemize

\series bold
Variables
\series default
: This refers to the count of variables used to represent data within the
 user interface, particularly those associated with the fields being evaluated.
\end_layout

\begin_layout Itemize

\series bold
Calculations
\series default
: This refers to instances in the code where values or expressions are assigned
 to variables, or where functions are called that perform such assignments.
 This applies regardless of whether the code is imperative (e.g., direct assignmen
ts), declarative (e.g., reactive programming), or in the form of formulas
 (e.g., in Excel).
 The core idea is that these actions represent assignments, even though
 their implementation may vary across different contexts.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A higher number of possible use case permutations indicates as more adaptable
 to different user workflows and preferences.
 Therefore, the code does more for the users, affects the 
\family typewriter
Efficiency 
\family default
metrics.
\end_layout

\begin_layout Plain Layout
This affects the efficiency metric, because for a specific code size, more
 possible use case permutations, the code is more efficient.
\end_layout

\begin_layout Plain Layout
A user interface that allows for more of these permutations is considered
 more flexible and adaptable to different user approaches.
 This is important because medical professionals may have different preferences
 or workflows when prescribing medication.
 Some might prefer to select the 
\family typewriter
Drug
\family default
 first, while others might start with the 
\family typewriter
Concentration
\family default
 or the 
\family typewriter
Volume
\family default
.
 A flexible interface accommodates these variations and allows for a more
 efficient and user-friendly experience.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Paragraph
Documentation Complexity
\end_layout

\begin_layout Plain Layout
This metric assesses the complexity and clarity of the underlying logic
 by analyzing the documentation required to describe the system's behavior.
 It's measured by the number of rules or special cases documented.
\end_layout

\begin_layout Itemize
Shorter documentation with fewer rules generally reflects a more predictable
 and generalized behavior.
 This suggests a solution that handles a wide range of scenarios with a
 concise set of principles, leading to easier understanding and maintenance.
\end_layout

\begin_layout Itemize
Conversely, longer documentation with a multitude of edge cases and specific
 rules indicates higher complexity.
 This can be a sign of a less robust solution that may be more difficult
 to understand, debug, and extend.
\end_layout

\begin_layout Plain Layout
Why this is important:
\end_layout

\begin_layout Itemize
Captures Underlying Logic: This metric goes beyond simply measuring the
 amount of documentation.
 It aims to capture the inherent complexity of the system's behavior.
 
\end_layout

\begin_layout Itemize
Identifies Potential Issues: A high degree of documentation complexity can
 be a warning sign of potential design flaws or a lack of underlying coherence
 in the solution.
 
\end_layout

\begin_layout Itemize
Prioritizes Elegance and Simplicity: This metric encourages solutions that
 are not only functional but also elegant and easy to understand, promoting
 good design principles.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
Efficiency
\family default
 score is calculated by 
\begin_inset Formula $Use\ Case\ Coverage/Code\ Quantity$
\end_inset

.
 A higher 
\family typewriter
Efficiency
\family default
 score indicates for an implementation that it generates more use cases
 with a smaller amount of code.
 For example, an implementation 
\family typewriter
A
\family default
 has 6 possible use cases and a 
\family typewriter
Code Quantity
\family default
 score 10, its Efficiency would be 
\begin_inset Formula $6/10=0.6$
\end_inset

.
 A second implementation 
\family typewriter
B
\family default
 has 4 use cases and a 
\family typewriter
Efficiency
\family default
 score 20, its 
\family typewriter
Efficiency
\family default
 is 4/20 = 0.2.
 This suggests that implementation 
\family typewriter
A
\family default
 is more efficient, as it provides more use cases per unit of code.
\end_layout

\begin_layout Subsection
Implementations
\end_layout

\begin_layout Standard
There are three implementations used in this evaluation: the Drug Administration
 implementation, which utilizes either 
\family typewriter
rivarjs
\family default
 or 
\family typewriter
RIVarX
\family default
 (both yielding identical scores in the evaluation), an implementation using
 
\family typewriter
Excel
\family default
, and an implementation based on event-driven programming.
\end_layout

\begin_layout Paragraph
Implementation of 
\family typewriter
Drug Administration
\family default
 using 
\family typewriter
Excel
\end_layout

\begin_layout Standard
In the 
\family typewriter
Excel
\family default
 implementation, for each type of calculation, the set of fields should
 be duplicated and redefined.
 Each field is defined as either an input, meaning a field where the user
 enters values, or an output, meaning a field where a formula is entered,
 so it will contain computed values based on the values of other fields.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Scores for this implementation:
\end_layout

\begin_layout Itemize
Variables: 12
\end_layout

\begin_layout Itemize
Calculations: 6
\end_layout

\begin_layout Itemize
Code Quantity: 18
\end_layout

\begin_layout Itemize
Use Cases: 12
\end_layout

\begin_layout Itemize
Efficiency: 0.6
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This implementation is similar to an implementation using only reactive
 variables (i.e., without combining with streams, events, or imperative code).
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Scores for this implementation:
\end_layout

\begin_layout Itemize
variables: 12
\end_layout

\begin_layout Itemize
calculations: 6
\end_layout

\begin_layout Itemize
Code Quantity: 18
\end_layout

\begin_layout Itemize
Use Cases: 12
\end_layout

\end_inset


\begin_inset Graphics
	filename DrugAdministrationInExcel.png
	scale 50

\end_inset


\end_layout

\begin_layout Paragraph
Implementation of 
\family typewriter
Drug Administration
\family default
 using 
\family typewriter
Events
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a 
\emph on
statechart
\begin_inset space ~
\end_inset


\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 is used for a visual representation of an implementation of a 
\family typewriter
Drug Administration
\family default
 application using events.
 Statecharts
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

 are used for a visual representation of the behavior in event-driven programmin
g.
 They show the different states a system can be in, events that trigger
 transitions between those states, and action that may be executed in the
 transitions.
 
\end_layout

\begin_layout Standard
In using the implemented 
\family typewriter
Drug Administration
\family default
, a user can fill in either 
\family typewriter
Drug
\family default
 and then 
\family typewriter
Volume
\family default
, or 
\family typewriter
Volume
\family default
 and then 
\family typewriter
Drug
\family default
, such that from these values the value of 
\family typewriter
Concentration
\family default
 is calculated.
 
\end_layout

\begin_layout Standard
As presented in the statechart, events are raised and trigger transition
 between states, such that a call to calculate and update 
\family typewriter
Concentration
\family default
 is repeated three times.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {};
\end_layout

\begin_layout Plain Layout

     
\backslash
node[round] (S4) at (2.5, -3) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180, in=90] (S1);
\end_layout

\begin_layout Plain Layout

    
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.8] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.8] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.8] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.8] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

     
\backslash
draw[-latex] (S4) to [loop below, looseness=8, out=-60, in=-120, min distance=10
mm] node[scale=0.8]  { y changed/calculate x;
\end_layout

\begin_layout Plain Layout

z changed/calculate x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
draw (3.5, -4) coordinate (empty);
\end_layout

\begin_layout Plain Layout

      
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)(empty)] (System) {};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Modeling a statechart for a formula 
\begin_inset Formula $\LSTINLINE{Concentration:=Drug/Volume}$
\end_inset


\end_layout

\end_inset

Modeling a statechart for a formula 
\begin_inset Formula $\LSTINLINE{Concentration:=Drug/Volume}$
\end_inset

.
 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 represents 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 represents 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 represents 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

.
 The rectangular shapes represent the states or modes of the application.
 The arrows represent transitions between the states, triggered by specific
 events.
 The labels contain the events and also actions, if needed, to perform in
 response to events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Scores for this implementation:
\end_layout

\begin_layout Itemize
Variables: 3
\end_layout

\begin_layout Itemize
Calculations: 3
\end_layout

\begin_layout Itemize
Code Quantity: 6
\end_layout

\begin_layout Itemize
Use Cases: 2
\end_layout

\begin_layout Itemize
Efficiency: 0.4
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Results and Discussion
\end_layout

\begin_layout Standard
The goal of the tests was to compare different approaches to developing
 
\family typewriter
Drug Admini
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

stration
\family default
 and to examine which approach leads to the highest value in the score 
\family typewriter
Efficiency
\family default
.
 The implementations using 
\family typewriter
rivarjs
\family default
 and 
\family typewriter
RIVarX
\family default
 show significant efficiency compared to the other implementations.
 As can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparison-of-Implementations."
plural "false"
caps "true"
noprefix "false"

\end_inset

, the highest efficiency score was achieved for the implementation of the
 thesis approach.
 The thesis approach achieved an efficiency score of 8, while the other
 implementations achieved scores of 0.6 and 0.4.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Calculations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Code Quantity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Use-Cases
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Efficiency
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
rivarjs
\family default
/
\family typewriter
RIVarX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Events
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparison-of-Implementations."

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation Scores.
\end_layout

\end_inset

Implementation Scores.
 Comparison of 
\family typewriter
Drug Administration
\family default
 implementations scores.
 Each row represents a different implementation, with corresponding scores
 in each column.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Fields (the number of fields in the user interface), Assignments (the number
 of explicit field value assignments in the code), Use Cases (the number
 of possible use case permutations), and 
\family typewriter
Efficiency
\family default
 (a combined metric that balances functionality with code size, where code
 size is represented by the combined number of Fields and Assignments).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The explanation for these results is that in older programming approaches,
 any type of repetition in code is addressed by utilizing either the OOP
 or FRP paradigm, but not by combining them, each relying on its own abstraction
 mechanisms.
 In contrast, the programming approach presented in this work integrates
 both FRP and OOP, including the integration of their abstraction mechanisms,
 thus addressing all types of repetition.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The explanation for these results is related to three elements of repetition
 included in the code: 
\emph on
calls to update variables, variables
\emph default
 and 
\emph on
objects.

\emph default
 In older programming approaches, any type of repetition in code is addressed
 by utilizing either the OOP or FRP paradigm, but not by combining them,
 each relying on its own abstraction mechanisms.
 In contrast, the programming approach presented in this work integrates
 both FRP and OOP, including the integration of their abstraction mechanisms,
 thus addressing all types of repetition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
OOP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
FRP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Combined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objects
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Reuse Analysis.
\end_layout

\end_inset

Code Reuse Analysis.
 The columns represent OOP, FRP and the combination approach we presented.
 Across the rows, we categorize types of code duplication types, with X
 denoting the presence of code reuse mechanism for the particular duplication
 type.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Calls to Update Variables
\end_layout

\begin_layout Standard
The declerative approach of FRP saves code amount.
 The amount of code saved is of that calls to update variables in the needed
 event handlers.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

), an events based implementation for FRP based declration 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

, the recalculation of 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 needs to be triggered both when 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 is updated and when 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 is updated.
 The calls to recalculate 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 are repeated within the two handlers of the change events for 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE z$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Standard
In using reactive variables, the right-hand expression is part of the identity
 of a reactive variable, without the possibility to add more sources of
 values.
 Therefore, in case of a new source, a new reactive variable is added, causing
 variable duplication.
\end_layout

\begin_layout Paragraph
Objects
\end_layout

\begin_layout Standard
When it is needed to create a code component based on an an existing one
 without modifying impacting the existing clients, it is needed to clone
 the existing codebase and then making the necessary changes.
 For this reason, identifying 
\emph on
objects
\emph default
 and 
\emph on
inheritance
\emph default
 (and 
\emph on
composition
\emph default
) is a method to reduce code duplications.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Plain Layout
In using reactive variables, the right hand expression is part of the identity
 of a reactive variable, without the posibility to add more sources of values.
 Therfore, in case of a new source, a new reactive varible is added, cuasing
 variables duplication.
\end_layout

\begin_layout Plain Layout
cenario, new reactive variables are added even though their values reflect
 
\end_layout

\begin_layout Plain Layout
In OOP, each object may represent real world entity and each object's variable
 may represent a real world object's variable.
 (Nevertheless, in real life applcations, when new code update existing
 variables, it might affect existing clients unexpectedly.
 Therefore, it is more safe to add new variables, which causes repetetive
 variables.) In contrast, in using reactive variables, the right hand expression
 is part of the identity of a reactive variable, without the posibility
 to add 
\end_layout

\begin_layout Plain Layout
In modeling objects like the real world, each object and variable should
 represent real world entity.
 However, in using reactive variables, it is not allowed to 
\end_layout

\begin_layout Plain Layout
In modeling objects like the real world, each object and variable should
 represent real world entity.
 However, in real life applcations, when new code update existing variables,
 it might affect existing clients unexpectedly.
 Therefore, it is more safe to add new variables, which causes repetetive
 variables.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
We examine the implementations of 
\family typewriter
Drug Administration
\family default
 against metrics to investigate their level regrading cognitive overload
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Paragraph
Implementation of Drug Administration using rivarjs/rivarx
\end_layout

\begin_layout Plain Layout
This implementation utilizes two separate applications to showcase the capabilit
ies of rivarjs in handling varying levels of complexity:
\end_layout

\begin_layout Itemize

\series bold
Simplified Application
\series default
: Includes only the fields related to the 
\family typewriter
Bag
\family default
 component.
\end_layout

\begin_layout Itemize

\series bold
Extended Application
\series default
: Includes fields for both 
\family typewriter
Bag
\family default
 and 
\family typewriter
Pump
\family default
 components.
 
\end_layout

\begin_layout Plain Layout
Here's a breakdown of the measurements:
\end_layout

\begin_layout Itemize
Variables: 6 
\end_layout

\begin_layout Itemize
Calculations: 9 
\end_layout

\begin_layout Itemize
Total Code Size: 15 (Variables + Calculations) 
\end_layout

\begin_layout Itemize
Use Cases (Simplified App): 6 
\end_layout

\begin_layout Itemize
Use Cases (Extended App): 120 
\end_layout

\begin_layout Itemize
Total Use Cases: 126 
\end_layout

\begin_layout Itemize
Documentation: A single, consistent rule: the value of each field is calculated
 based on the most recently entered values.
 
\end_layout

\begin_layout Subparagraph
Use Case Efficiency
\end_layout

\begin_layout Plain Layout
To calculate the Use Case Efficiency, we'll divide the total number of use
 cases by the total code size: Use Case Efficiency: (6 Use Cases + 120 Use
 Cases) / 15 = 8.4
\end_layout

\begin_layout Subparagraph
Interpretation
\end_layout

\begin_layout Plain Layout
The rivarjs implementation demonstrates a high Use Case Efficiency, indicating
 its effectiveness in handling a large number of use cases (126 different
 field entry sequences) with a relatively small code size (15).
 This efficiency is further emphasized by the consistent rule for calculating
 field values, as reflected in the documentation, suggesting that rivarjs
 promotes a clear and predictable approach to managing computed fields.
\end_layout

\begin_layout Plain Layout
This result provides positive evidence for the effectiveness of rivarjs
 in achieving both flexibility and code efficiency in the Drug Administration
 application.
\end_layout

\begin_layout Paragraph
Implementation of Drug Administration using Excel
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation of Drug Administration using statechart
\end_layout

\begin_layout Plain Layout
measurements:
\end_layout

\begin_layout Itemize
variables: 3
\end_layout

\begin_layout Itemize
calculations: 3 or 4
\end_layout

\begin_layout Itemize
Total Code Size: 6 or 7 (Variables + Calculations) 
\end_layout

\begin_layout Itemize
Use Cases: 2
\end_layout

\end_inset


\end_layout

\begin_layout Section

\series bold
Application Evolution Process
\end_layout

\begin_layout Standard
This section presents a comparison between utilizing reactive variables
 and reactive instance variables (without referring to objects that contain
 them) within the context of application evolution.
 To illustrate the distinctions and benefits of reactive instance variables,
 a case study is presented, focusing on the evolution of an application
 example involving the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 represents medication dosage administered to a patient, while 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 indicates whether the application should trigger an alert for abnormal
 medication amounts.
 A formula is employed to establish a relationship between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

, enabling the automatic determination of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 based on the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code needs to be modified (indicated using bold font style) when the
 doctor administers the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 in order to calculate the resulting amount.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput()
\end_layout

\begin_layout Plain Layout

__AmountByConcentrationAndVolume=Concentration*Volume__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),__IsAbnormal(AmountByConcentration AndVolume)
__)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the doctor administers the medication by setting the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, the medication amount can be calculated using the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 In this scenario, it is necessary to update the code accordingly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput() 
\end_layout

\begin_layout Plain Layout

AmountByConcentrationAndVolume=Concentration*Volume __AmountByDoseAndDuration=Do
se*Duration__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),
\end_layout

\begin_layout Plain Layout

IsAbnormal(AmountByConcentrationAndVolume),
\end_layout

\begin_layout Plain Layout

__IsAbnormal(AmountByDoseAndDuration)__) 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example presents:
\end_layout

\begin_layout Itemize
Several variables to represent 
\family typewriter
Amount
\family default
.
\end_layout

\begin_layout Itemize
A variable 
\family typewriter
Alert
\family default
 that should be updated.
\end_layout

\begin_layout Standard
At this stage, we begin the process again with the new semantics of multiple
 assignments.
\end_layout

\begin_layout Standard
Again, an initial step, alert if the amount is abnormal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the doctor administers the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

, the resulting amount can be calculated by taking their product.
 In order to incorporate this functionality, it is sufficient to add the
 following code snippet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=Concentration*Volume
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the doctor administers the medication by setting the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, the medication amount can be calculated using the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 To implement this calculation, it is sufficient to add the following code
 snippet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

Amount=Dose*Duration
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example with the new semantics presents:
\end_layout

\begin_layout Standard
• A single variable to represent 
\family typewriter
Amount
\family default
.
 
\end_layout

\begin_layout Standard
• No need to update code for 
\family typewriter
Alert
\family default
.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
Traditionally, the reactive variables concept is similar to a feature for
 creating computed fields easily.
 For example, a formula 
\begin_inset Formula $\LSTINLINE{Amount=Dose}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{*Duration}$
\end_inset

 such that 
\family typewriter
Amount
\family default
 is automatically computed according to 
\family typewriter
Dose
\family default
 and 
\family typewriter
Rate
\family default
.
\end_layout

\begin_layout Standard
However, the reactive instance variable concept has an extended meaning.
 The meaning of creating computed fields is reserved but limited to cases
 where the formula declares 
\family typewriter
Amount
\family default
 firstly.
 The extended meaning is
\emph on
 
\emph default
adding a 
\emph on
filling option
\emph default
 or adding an 
\emph on
indirect input option
\emph default
.
 For example, the formula a 
\begin_inset Formula $\LSTINLINE{Amount=Dose}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{*Duration}$
\end_inset

 means that filling 
\family typewriter
Dose
\family default
 and 
\family typewriter
Duration
\family default
 is an option added to fill 
\family typewriter
Amount
\family default
.
\end_layout

\begin_layout Standard
The new feature can be presented also as adding a filling option as a set
 of fields.
 This would be presented by the following example.
 Among fields 
\family typewriter
Drug
\family default
,
\family typewriter
 Volume
\family default
 and 
\family typewriter
Concentration
\family default
, only two of them are required for documenting drugs' amount.
 Users can, for example, define quantities by setting only 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
.
 In such a case, the value of 
\family typewriter
Concentration
\family default
 is computed.
 Additionaly, users can define quantities by setting only the 
\family typewriter
Concentration
\family default
 and 
\family typewriter
Volume
\family default
.
 In such a case, the value of 
\family typewriter
Drug
\family default
 is computed.
\end_layout

\begin_layout Standard
If only one filling option is available, users are stricted: users must
 define values in the terms used in the application.
 For example, in 
\family typewriter
Drug Administration
\family default
 define quantities by setting 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
 for drugs that it is easier to set by 
\family typewriter
Volume
\family default
 and
\family typewriter
 Concentration
\family default
.
 In the strict mode, users are forced to convert the values.
 For example, a case that available fields are 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
, and an amount is 
\begin_inset Formula $0.5$
\end_inset

 and 
\begin_inset Formula $100$
\end_inset

 for 
\family typewriter
Concentration
\family default
 and 
\family typewriter
Volume
\family default
.
 For filling 
\family typewriter
Drug
\family default
 it is required to calculate 
\begin_inset Formula $\LSTINLINE{Concentration*Volume}$
\end_inset

.
\end_layout

\begin_layout Section
Threats to Validity
\end_layout

\begin_layout Standard
The comparisons we made are based on the 
\family typewriter
Drug Administration
\family default
 application, which is a small-scale simulation.
 It is important to note that the results we obtained apply to this type
 of system, and therefore should be interpreted with caution when considering
 larger and more complex applications.
 However, 
\family typewriter
Drug Administration
\family default
 serves as a good example since its dependency graph includes the three
 main issues: 
\series bold
glitch
\series default
, 
\series bold
cycle
\series default
, and 
\series bold
multiple Assignments
\series default
.
 Additionally, the example represents the three core principles of OOP:
 
\series bold
encapsulation
\series default
, 
\series bold
inheritance
\series default
, and 
\series bold
polymorphism
\series default
, which provide a foundation for building more complex solutions.
\end_layout

\begin_layout Standard
However, there are several technical limitations to consider:
\end_layout

\begin_layout Itemize
One limitation is the dependency on a central 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 variable, which progresses with each external event.
 This could lead to issues in larger applications that require parallelism
 or distributed change propagation.
 
\end_layout

\begin_layout Itemize
The implementation does not include elements of parallelism, and thus lacks
 handling of concurrent processes, which could be essential in distributed
 systems or high-load scenarios.
 
\end_layout

\begin_layout Standard
In conclusion, the impact of these limitations on the validity of the results
 may be significant in larger systems, but the 
\family typewriter
Drug Administration
\family default
 application provides a solid basis for an initial understanding of design
 principles.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The researcher is a software developer with 15 years of experience in developing
 complex software systems, 10 of which were spent at iMDsoft, working on
 the MetaVision system, which served as the basis for the Drug Administration
 example.
 This information strengthens the credibility of the results and the connection
 between the example and the research.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To demonstrate the correctness of the change propagation algorithm, we compare
 its output to that of 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, showing that they yield identical results.
 Indeed, 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 is a constraints system of two-way constraints.
 However, each two-way constraint can be decomposed into several one-way
 constraints as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We created the 
\family typewriter
Drug Administration
\family default
 with 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 to compare with the implementation with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 The two algorithms provide identical results in the propagation change.
 Both of the algorithms makes new input to override effects (input and computed
 values) of oldest input at the time of the input.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
The example illustrates a variable reuse mechanism introduced from this
 thesis.
 As in the example, lack of a well defined variable reuse mechanism might
 lead to confused duplications in variables.
 The traditional approach, especially within the imperative paradigm, often
 involves duplicating variables.
 This practice arises due to the inherent complexity in managing variables
 across multiple code locations, making it error-prone to update them consistent
ly.
 Therefore, when dealing with existing components, a safer approach is to
 introduce new variables rather than modifying existing ones.
 This strategy not only reduces the risk of unintended side effects but
 also aligns with methodologies employed in frameworks that facilitate the
 addition of computed fields.
 By utilizing the new variable reuse mechanism, it becomes easier to model
 programs according to the real world, such that applications' variables
 reflect real-world variables, facilitating a one-to-one correspondence.
\end_layout

\begin_layout Plain Layout
Additionally, two mechanisms are derived from OOP and FRP.
 The OOP paradigm consists of inheritance and composition.
 Without inheritance and composition, code is duplicated, leading to potential
 unexpected changes for existing customers.
 The FRP paradigm, in its declarative approach, facilitates code reuse compared
 to event-driven programming.
 In the event-driven paradigm, if a certain field depends on several other
 fields, this field should be updated whenever any of them is updated.
 Therefore, a call to compute and update the field is registered in the
 events of all fields it depends on.
 Prior to this thesis, these two mechanisms were considered mutually exclusive.
 OOP, as an imperative paradigm, struggled to achieve the level of code
 reuse inherent in declarative programming.
 Consequently, inheritance and composition were often combined with the
 event-driven paradigm, resulting in tangled code and duplications when
 calling to compute and update fields.
\end_layout

\begin_layout Plain Layout
It turns out that this thesis introduces three code reuse mechanisms to
 be used together.
 An analysis is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:analysis-2"
plural "true"
caps "false"
noprefix "false"

\end_inset

.
 First, reuse for 
\emph on
components
\emph default
 by the inheritance and composition from the OOP paradigm.
 Second, reuse for 
\emph on
computations
\emph default
, meaning to specify a computation once without the need to manage state.
 The declerative style provides this reuse mechanism like FRP and constraints
 systems.
 Finaly, the presented reuse for variables.
 A variables reuse mechanism has been partially provided in constraints
 systems.
 In constraints systems, several constraints can mention a single variable,
 enabling to add computations without adding variables.
 However the constraints are managed in a centralized mannar 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

, rather than object oriented.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An improveness in code reuse may affect delivery speed to be faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
Replacing the strict mode by a fast adding filling option may improve usability.
 In addition, the improveness in code reuse aims to affect delivery speed
 to be faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
The new feature present another prespective of the improveness code reuse.
 In lack of a mechanism for adding filling options, this has been done manually
 with code duplications.
 The user experience is affected
\end_layout

\begin_layout Plain Layout
This thesis should produce a positive impact on the user experience according
 to the following.
 First, the improveness in code reuse aims to affect delivery speed to be
 faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
The new feature as well as the
\end_layout

\begin_layout Plain Layout
This thesis should produce a positive impact on the user experience according
 to the following.
 First, the improveness in code reuse aims to affect delivery speed to be
 faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
 Secondly, our novel variables reuse mechanism leads into a new feature
 we name 
\emph on
add filling option
\emph default
 in addition to an ordinary feature 
\emph on
add computed field
\emph default
.
 In a formula 
\begin_inset Formula $\LSTINLINE{Amount=Dose*Duration}$
\end_inset

, in case that 
\family typewriter
Amount
\family default
 is firsly declared, it is the ordinary computed field, otherwise it adds
 a new filling option.
 The idea is that filling 
\family typewriter
Dose
\family default
 and 
\family typewriter
Duration 
\family default
is one option to fill Amount, an alternative to other such filling options.
\end_layout

\begin_layout Plain Layout
The new feature can be presented also as adding a filling option as a set
 of fields, as in the followng example.
 Among fields 
\begin_inset Formula $\NAME{Drug}$
\end_inset

, 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

, only two of them are required for documenting drugs' amount.
 Users can, for example, define quantities by setting only 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is computed.
 Additionaly, users can define quantities by setting only the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is computed.
\end_layout

\begin_layout Plain Layout
If only one filling option is available, users are stricted: users must
 define values in the terms used in the application.
 For example, in Drug Administration define quantities by setting 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 for drugs that it is easier to set by 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

.
 In the strict mode, users are forced to convert the values.
 For example, a case that available fields are 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, and an amount is 
\begin_inset Formula $0.5$
\end_inset

 and 
\begin_inset Formula $100$
\end_inset

 for 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 For filling 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 it is required to calculate 
\begin_inset Formula $\LSTINLINE{Concentration\times Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Harmonized Paradigm
\end_layout

\begin_layout Plain Layout
The provided framework comperhasive traditional paradigms nicely.
 The framework harmonizes features from FRP and OOP.
 FRP gives predictability from the functional nature and the declerative
 approach that remove code repetition of registering events to computations.
 OOP gives encapsulation, inheritance and polymorphism.
 Our custom assignment suite the inheritance mehcanism, that it adds dependencie
s rather than change them.
\end_layout

\begin_layout Plain Layout
Additionaly, the framework accompass the abstractions of events streams
 and events.
 The events streams represent the lower level of a variable, represeting
 th vaying value over time.
 The events as side effects is already mentioned in the framework.
 This produces a framework woth three levels of abstraction.
 Consequently, any future demands can be adressed on its level.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 outperforms 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, because in 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

, two distinct styles are used to distinguish between input values and computed
 values.
 
\end_layout

\begin_layout Plain Layout
(i.e., what fields to compute, wh).
 in decisions when and what fields to compute.
\end_layout

\begin_layout Plain Layout
) are the same, except that we change the style to values that are computed
 distingusinh between values that are set and values that are computed.
\end_layout

\begin_layout Plain Layout
We used Hotdrink to create an alternative to the Drug Administration.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 Hotdrink is a library that are based on constraints programming.
 Suprisingly, it provide a very closed solution in code and behavior.
 The behavior of the updates (decisions when and what fields to compute)
 are the same, except that we change the style to values that are computed
 distingusinh between values that are set and values that are computed.
 In code, altough that Hotdrink support two-way constraints while our formulas
 are like one-way constraint, our code is not more difficult.
 The reason is mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

: the constraints are attached with methods that are according to the formulas.
\end_layout

\begin_layout Plain Layout
The significant diffrence between the implementations is in support for
 reusable components.
 In Hotdrink (and others) if we need to create another application based
 on an this one without modifying impacting the existing clients, we need
 to clone the existing codebase and then making the necessary changes to
 the new application.
\end_layout

\begin_layout Plain Layout
However, the library currently lacks support for reusable components 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 Therefore, if we need to create another application based on an this one
 without modifying impacting the existing clients, we need to clone the
 existing codebase and then making the necessary changes to the new application.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
The implementation of the thesis approach is different.
 In the new implemention, users can edit any of the fields, while in the
 same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes (reduced cognitive
 loads).
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Additionaly, in the new implementation , two distinct styles are used to
 distinguish between input values and computed values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Abstraction
\end_layout

\begin_layout Plain Layout
reactive instance variable is similar to reactive variable, that it is more
 declerative than events and streams.
 Furthermore, reactive instance variable outperforms previous implementation
 of reactive variables.
 
\family typewriter
Sodium
\family default
 the transaction was invented to handle cycles.
 In FrTime, there is a delay keywork used to let the developers to sign
 to the runtime, when to stop propagation because of cycles.
\end_layout

\begin_layout Plain Layout
Beside, reactive instance variables is based on events and streams has their
 role, to abstract environmental phnomenon.
 reactive instance variables satisfy this need as well, as it is consists
 of stream of events.
\end_layout

\begin_layout Plain Layout
Comparing to constraints, 
\end_layout

\begin_layout Plain Layout
In the highest level, we provide farmework
\end_layout

\begin_layout Plain Layout
Reactive Instance Variables harmonizes previous concepts seamlessly, sometimes
 ease the abstraction.
 
\end_layout

\begin_layout Plain Layout
in the Highest level, it is similar to reactive variables and one-way dataflow
 constraints
\end_layout

\begin_layout Plain Layout
Comparing to reactive variables implemented in Sodium, 
\end_layout

\begin_layout Paragraph*
events
\end_layout

\begin_layout Plain Layout
events produce repeat in calling to methods in the events.
\end_layout

\begin_layout Paragraph*
streams
\end_layout

\begin_layout Plain Layout
streams that exists in an application, it cannot be reused, by adding more
 values fron another source.
\end_layout

\begin_layout Paragraph
constraints
\end_layout

\begin_layout Plain Layout
constraints are managed as external DSL or ceneralizaed mechanism
\end_layout

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
in contrsints there is a centerlized mechanism to read the 
\end_layout

\begin_layout Plain Layout
This thesis harmomizes FRP with OOP, in a way that the abstraction mechainsm
 is harmonzed as well.
 
\end_layout

\begin_layout Subsection
Stream
\end_layout

\begin_layout Plain Layout
In the example, we created new Amount variables.
 There is an alternative to represent Amount as a stream
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Events/Redux
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Streams/Cycle.js
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints/Hotdrink
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
components
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Repetition Analysis.
\end_layout

\end_inset

Code Repetition Analysis.
 The columns represent distinct libraries, each reflecting a specific architectu
ral design aspect.
 Across the rows, we categorize types of code repetitions, with X denoting
 the presence of a particular repetition type in correlation with the respective
 library or architectural approach.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
pettern
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
react/redux (State)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
cycle.js (Unidirectional Dataflow)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
hotdrink (Constraints)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
components
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Repetition Analysis.
\end_layout

\end_inset

Code Repetition Analysis.
 The rows represent repetitions types and the columns represent an architutal
 appraoch.
 X represents that the repetitions type of the current row might apear in
 using the a architutal appraoch of the column.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 The application is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
with 6 fields, depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, named Drug Administration.
\end_layout

\begin_layout Plain Layout
This thesis is driven by the need to enhance calculations in GUI, in order
 to improve the user experiences.
 Specifically in healthcare, it is desirable to solve usability problems
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

.
 Some concepts will be simplified by the following Drug Administration applicati
on (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), used along this thesis.
 In the Drug Administration, there are several options to define the quantities:
 either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis is driven by the need to enhance user experiences in UI (User
 Interface) and front-end applications.
 A fundamental aspect of this enhancement lies in the realm of field calculation
s.
 Fields calculations means maintaining consistency in field values.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
This thesis aims to establish an effective mechanism for field calculations,
 enhancing user experience in User Interfaces and frond-end applications.
 Field calculations refer to the process of maintaining consistency in field
 values.
 When users input data into one field, it is essential to recalculate the
 values of other related fields.
\end_layout

\begin_layout Plain Layout
This thesis is focused on creating an effective mechanism in fields calculations
 to achive a better user experience in UI or drone ends applications.
 Fields calculations means Maintaining consistency in field values.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Maintaining consistency in field values might be crucial in front ends applicati
ons.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Repeating on code resists against the code changes for two reasons: First,
 because efforts need to be keep on the rules consistency.
 Second, it adds more lines of code to the application.
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the timeconsuming process of implementing changes.
 One contributing factor is the limited cognitive capacity of developers
 when it comes to analyzing the extensive details within the application
 source code, dealing with large code bases and code repetition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Exploring the Useability
\end_layout

\begin_layout Plain Layout
An efficient mechanism to develop fields calculations has a potenstial to
 improve front ends usability.
 Specificaly, in applications for healthcare, it is desirable to solve usability
 problems 
\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Using The new Approach
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
locker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:180:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
openedlocker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:130:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c c c| }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{ordering style }  
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{
\backslash
framebox(130,15){set Dose and Rate {$
\backslash
nabla$}}}
\end_layout

\begin_layout Plain Layout

 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Drug & Concentration & Volume 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

 Dose & Duration & Rate 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

 
\backslash
framebox(35,15){ } 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
openedlocker{0.25}} 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Order-Entry"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration - Full Version.
\end_layout

\end_inset

 At the top, there is the Ordering Style field, represented by a combobox,
 where users can select from the available options.
 Below this, each field consists of a label above its name, an area to display
 its value, and a lock icon on its right.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——————————
\end_layout

\begin_layout Plain Layout
This thesis approach, frame
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, user experience may be affected by code size, because it enhances fast
 customer feedback loops.
 Therefore, we compare code size along with application behavior (user experienc
e = the application behavior from users point of view).
 We use the Order Entry application mentioned throughout this thesis, over
 several implementation approaches.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, calling it Drug Administration
\end_layout

\end_inset

.
 We compare behavior and code size over several approaches for creating
 the application.
 User experience may be affected by code size, since (as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) it enhances fast customer feedback loops.
\end_layout

\begin_layout Section
Approaches
\end_layout

\begin_layout Plain Layout
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Section
Behavior
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
We created several variants for the Drug Administration application with
 diffrences in the code and the behavior.
\end_layout

\begin_layout Plain Layout
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
We compare code size, because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, large code resists against code changes, that is needed for enhance user
 experience with a fast customer feedback loops.
 Beside the code, we compare resulted behavior 
\end_layout

\begin_layout Plain Layout
We compare code repettion over the implementations and approaches for creating
 the Drug Administration.
 We also mention the amount of elements in the screen and compare the applicatio
ns behavior as the cost.
\end_layout

\begin_layout Plain Layout
—————–
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 We compare the code size because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it affects user experience, because it enhances fast customer feedback
 loops.
 Beside the code size, we present its cost or outcome regrading the behavior
 experienced in the application.
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis.
 We created it with the name Drug Administration according to this thesis'
 approach.
 We also created a similar application as an excel file (spreadsheet) to
 ilustrate the application code as reactive variables.
 In addition, we created the Drug Administration as a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Our focus is on reducing the code size to enhance fast customer feedback
 loops.
\end_layout

\begin_layout Plain Layout
because as the reason for poor user experience lies in the inability of
 a fast customer feedback loops.
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 Our focus is in reducing code size.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, code size affects the user experience, because it affect the ability of
 a fast customer feedback loops.
 As mentioned, code size is affected from GUI elements amount and code repetitio
ns.
 Before delving into it, let's present several implementation/approaches
 fo implementing of the Drug Adminstration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
 Beside the original application and the Drug Administration, there are
 various implementations enabled.
 For example, we implemented in Hotdrink an application just like the Drug
 Administration (except the indicator between input values and computed
 values).
 
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
\end_layout

\begin_layout Plain Layout
However, we asume that the centeral outcome of this thesis is in reducing
 code repetitions.
 We identify several architetual deisgns, and find common patterns of code
 repetions that is reduced in the Drug Administration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are three types of repetition elements.
 First, when multiple events handlers need to call the same executation
 call consists of computations and updates.
 Second, when variables reflect the same real world variable.
 Third, components that are unable to reuse, causing to create similar other
 components.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This chapter focuses on evaluating effectiveness of our de-centralization
 approach for improving user experience.
 We evaluate by the Order Entry example.
 We created several implementations of Order Entry of our approach consisting
 the six numeric fields presented in the beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In those applications, users can in any stage edit any of the fields, while
 in the same time, any of them can be updated with computed values by the
 system.
 This is applied based on the rule described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that new input overrides effects (input and computed values) of oldest
 input at the time of the input.
\end_layout

\begin_layout Plain Layout
This is diffrent than in the original application.
 There, users need to start with choosing an orderyng style and sometimes
 to toggle lockers buttons to manage what fields will the user fill.
 At this point the new implementations are more simple and easy to use.
 This is the one hand.
 But in the other hand, the beavior in the original application is might
 be better because behavior is refertial trsnaparent to the user, because
 the user can manage what fields are input and what are computed.
 Therefore, the new implemnetations are imroved with graphical indiator
 of what values are input and what are computed.
 The compyted values have diffrent style than the input values, so it is
 clear to ther user.
\end_layout

\begin_layout Plain Layout
In order to imIn the new implementations, we 
\end_layout

\begin_layout Plain Layout
but in the other hand, it contains 
\end_layout

\begin_layout Plain Layout
Comparing such an implementation to the original presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the new one has reduced conginite loads.
 In the original impleentation, there are locker elements an ordering style
 to choose.
 In the current implementations there is no more than the six numeric fields.
 
\end_layout

\begin_layout Plain Layout
In order that it will be clear what values are input and what are computed,
 there is a graphicaly indicator, when the value is computed, and when the
 values is the one that the use fill.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
We recognize in the exploration three patterns of code duplication.
 First, calling to update variables in various locations, such as in response
 to events.
 Second, multiple variables to represent a single real-world variable.
 Finaly, cloning code to not affect existing clients.
 Since we could not prevent code repretition, we cannot provide a
\emph on
 single source of truth
\emph default
 for the organization's business logic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

import { useState } from 'react';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

export function VisualRIVar({ rivar, render }) {
\end_layout

\begin_layout Plain Layout

  const [value, setValue] = useState(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  rivar.subscribe((signal) => {
\end_layout

\begin_layout Plain Layout

    if (signal.value && value !== signal.value.toString()) {
\end_layout

\begin_layout Plain Layout

      setValue(signal.value.toString());
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  const change = (value) => {
\end_layout

\begin_layout Plain Layout

    rivar.next(new Signal(value));
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return render({ value, change });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

const App = () => {
\end_layout

\begin_layout Plain Layout

  const rivar = new Rivar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return (
\end_layout

\begin_layout Plain Layout

    <RIVarView rivar={rivar} render={({ value, change }) => (
\end_layout

\begin_layout Plain Layout

      <input
\end_layout

\begin_layout Plain Layout

        type="number"
\end_layout

\begin_layout Plain Layout

        value={value}
\end_layout

\begin_layout Plain Layout

        onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

      />
\end_layout

\begin_layout Plain Layout

    )}>
\end_layout

\begin_layout Plain Layout

    </VisualRIVar>
\end_layout

\begin_layout Plain Layout

  );
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:VisualRIVar"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset

The code snippest generates 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

, a react component that takes two props: 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 and a render prop function.
 The render prop function is used to render the child component.
 The render prop function is passed an object with two properties: value
 and change.
 The value property is the current value of the Rivar variable.
 The change function can be used to update the 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 variable.
 In the sample app, the code will render an input field that is connected
 to the rivar variable.
 When the user changes the value of the input field, the rivar variable
 will be updated.
 The rivar variable will then update the value prop of the input field.
 This will cause the input field to be re-rendered with the updated value.
 This pattern can be used to render any type of component inline and nested
 in the 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

 component.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Section
propagation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propagation algorithm,
 to provide the developers to sepcify clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propagation algorithm.
 The technaogy that enables completely custom propagation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propagation strategy.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propagation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, the languages provide also the stream abstraction ( 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, 
\begin_inset Formula $\NAME{REScala}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
have the ability to declare the data dependencies, but also have stream
 abstraction.
\end_layout

\begin_layout Plain Layout
However, we find various exceptions.
 In 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, in addition to the high level langauge.
 there is the concept of transaction to customize the way of how to handle
 cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In 
\begin_inset Formula $\NAME{FrTime}$
\end_inset

, there is the reserved word 
\begin_inset Formula $\NAME{\LSTINLINE{delay}}$
\end_inset

 to customize the way to how to handle cycles.
 Generaly, the languges does not only have the ability to declare the data
 dependencies, but also have stream abstraction.
\end_layout

\begin_layout Plain Layout
because it is not in addition to the lifted variables.
\end_layout

\begin_layout Plain Layout
The FRP paradigm promotes the concept that the developers need only to specify
 the data dependencies, and the runtime maintains the updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
\end_layout

\begin_layout Plain Layout
However, as the data dependencies might contain cycles, the 
\end_layout

\begin_layout Plain Layout
the langagues in order to handle cycles, the langiges are force to break
 the neat abstraction
\end_layout

\begin_layout Plain Layout
In our framework, like previous works, we had to face the balancing between
 the abstraction level and the generalism of the propagation algorithm.
 In the events driven programming, the framework completely enables completely
 custom propagation.
 In 
\begin_inset Formula $\ReactiveX$
\end_inset

, the developers can choose between several scueduler, to indicate the order
 of the updates.
 In contrast, the FRP paradigm promotes the concept that the developers
 need only to specify the data dependencies, and the runtime maintains the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 
\end_layout

\begin_layout Section
propagation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propagation algorithm,
 to provide the developers to sepcify the logic clearly clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
In the events driven programming, that the framework that completely enables
 completely custom propagation, it is error prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, so that it hard to realy customize the propagation according to the needs.
 In frameworks that use streams it used to be also the case, because it
 has the difficulty similar to the evemts paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propagation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
This consists of the use of inheritance and composition abstraction mechanisms
 used in OOP to not clone components.
 
\end_layout

\begin_layout Plain Layout
It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
This 
\end_layout

\begin_layout Plain Layout
We implemented the Bag and Pump classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The Pump class extends the Bag class and adds field calculations to the
 existing fields in the Bag class.
 We added also the UI as React components, so that Bag is a ready to use
 component, and Pump is an extension over it.
\end_layout

\begin_layout Plain Layout
We also created Bag React component and a Pump React component, that are
 components that include the UI with the interaction with the user.
 This means that if Bag component is used, and there is a need to extend
 it with the Pump, it is done.
\end_layout

\begin_layout Plain Layout
, each 
\end_layout

\begin_layout Plain Layout
This represents the novelity of our approach to add field calculations without
 disrupting existing clients.
\end_layout

\begin_layout Plain Layout
We also created a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application, keeping on the indepedance, such that a Bag UI component and
 a Pump UI component are indepedant from each other.
 The Bag UI component depends on the Bag class, and the Pump UI component
 depends on the Pump class.
 This present the new ability, that each class can contain fields calculation
 s independantly 
\end_layout

\begin_layout Plain Layout
We implemented 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 extends 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 while adding fields calculations to existing fields that are in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 This represent the advantage of our approach, to enable adding fields calculati
on withiut to disturb existing clients.
 We created also Bag UI component and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 UI component with reserved chrachstic.
\end_layout

\begin_layout Plain Layout
This charechstic in classes is reserved also in UI components.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 is a composition class, that contain 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and adds fields and calculations to calculate fields from 
\end_layout

\begin_layout Plain Layout
, the differences are mostly in the binding to the UI.
 
\end_layout

\begin_layout Plain Layout
Basicly, as 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 consists of an observable stream, when a UI change event occurs, it adds
 an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 However in 
\begin_inset Formula $\NAME{React}$
\end_inset

, we used other strategy.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, the developer should define the visual view as function of changeable
 state or props.
 Therefore, we created a base element, a react component, that defines the
 visual view as function of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that is passed to it by props.
\end_layout

\begin_layout Plain Layout
One of the samples is a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application (a library discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Multiple-Components"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We created class 
\begin_inset Formula $\LSTINLINE{RIVarComponent}$
\end_inset

 that can be 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This enables to create classes with fields and calculations, and then 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This helps to reduce code repetition, becuse without this ability, the
 need to not disturb exisintg clients leads to clone the code to the new
 clients with the added fields calcualtions.
 Another alternative is to not add calculations to existing fields, but
 to add new fields to the new needs, causes repetition in the fields.
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might lead
 to cycles.
 Consequently, we need to take care of the any location taht have access
 to the field, which make the code locations coupled, in contrast to the
 strategy of independent components to increase code reuse, to decrease
 code repetition.
 This is addition to the code repetition in mutiple calls fro the various
 events as explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
without being able to reuse existing 
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might dsiturb
 existing clients, if this closes a cycle in the dependencies.
 If code locations from other components update that field,
\end_layout

\begin_layout Plain Layout
has problems that it requires to consider 
\end_layout

\begin_layout Plain Layout
all the code that might update the field, 
\end_layout

\begin_layout Plain Layout
we can be inaware if a cycle been created, or that 
\end_layout

\begin_layout Plain Layout
, the developers need to handle cases of infinite loops
\end_layout

\begin_layout Plain Layout
with caring about the potentisal of infinite loops
\end_layout

\begin_layout Plain Layout
We evaluate the suggested framework by the Drug Administration example as
 an emparical evaluation.
 Our approach consists of adding fields calculation withiut to disturb existing
 clients and without to repeate code.
 The principal is that enabling to add fields calculations 
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
 The reason is that changes might disturb existing clients.
 Consequently, if there is a need to change, it leads to clone the codebase.
 Cloning or code repretiion is expensnise.
 
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
In the designing the classes for the Drug Administration in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, our approach does the most in the three aspects.
 The novality in our approach, in that fields calculation can be added without
 to disturb existing clients and without to repeate code.
 Previously, we could either add another variables to not disturb the clients,
 or add the functionality to update the exiting fields with the risk of
 an accidetal recursion, that will harm exisitng clients.
 In order to ot harm the clients, we could duplicate the component, and
 adjust the new component to the need.
\end_layout

\begin_layout Plain Layout
As in the Spreadsheet example, in FRP
\end_layout

\begin_layout Plain Layout
Consequently, we reduce code repetition.
 Comparing the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our approach, fields calculation can be added withiut to disturb existing
 clients and without to repeate code.
 Previously, we could add another variables to not disturb the clients,
 or to add the functionality to update the exiting fields with the risk
 that in runtime
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
However, if there is a component and a field that it contains, if we need
 to add a calculation, to update this field according to some other fields,
 there might be an accidental recursion.
\end_layout

\begin_layout Plain Layout
Our approach allows adding 
\end_layout

\begin_layout Plain Layout
In using the approach for Drug Administration, fields calculations are added
 
\end_layout

\begin_layout Plain Layout
Our framework allow, a good seperation where it is allowed to add fields
 calculations, without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
It has been recognized that in each design there is code duplication.
 We recognize several patterns.
 First code reptition to call to update variables in various locations,
 such as in response to events.
 Second, defining several variables to one real world variable.
 and the third and most known cloning code to not affect existing clients.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 In the Spreadsheet, there were variables repetitions.
 In the Hotdrink example, we explained the need to clone components.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 This repetion type is resolved in our framework, like FRP and constraints.
 In using our approach, there is no need to register code to update variables.
\end_layout

\begin_layout Plain Layout
In spreadsheets, that represent the high level abstraction of FRP, there
 is no need to repeat calling to the updates, however, it causes to repeat
 var
\end_layout

\begin_layout Plain Layout
Our discussion is in terms of code repition.
\end_layout

\begin_layout Plain Layout
We focus on the code repretition element.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP languages, that lifts the variables and the expressions (without
 streams), each variable is either an 
\emph on
input
\emph default
 variable or 
\emph on
calculated
\emph default
 variable.
 The input variable is like 
\end_layout

\begin_layout Plain Layout
basicly where each variable is either an input variable or calculated variable
 
\end_layout

\begin_layout Plain Layout
In the presented spreadsheet for implementing the Drug Administration in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there were duplications in the variables.
 Similary, in using the FRP paradign, with creating DAG, such that each
 variable is either an input variable or calculated variable
\end_layout

\begin_layout Plain Layout
We find that the FRP paradigm that created DAG, causes to create variables
 duplication.
\end_layout

\begin_layout Plain Layout
The FRP paradigm is basicly like spreadsheets, which require each variable
 to be either an input 
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
We recognize several code repretition types.
 First, the reptition calls to execute code in the various events.
 This has been 
\end_layout

\begin_layout Plain Layout
Second, the 
\end_layout

\begin_layout Plain Layout
We have explored several architutal designs to implement the Drug Administration
 application, and presented a new approach to design such applications.
 In this section we docu
\end_layout

\begin_layout Plain Layout
We compare the code duplications based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to our approach
\end_layout

\begin_layout Plain Layout
We evaluate the approach empirically: we compare the code duplications based
 on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 in the Drug Administration by our approach, as presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, to other approaches based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Repeating Calls
\end_layout

\begin_layout Plain Layout
In the imperative paradigm, the developer need to call to functions to calculate
 variables in case that their dependant variables changed.
 This might be several locations, in case that there are several variables
 that variable depends on.
\end_layout

\begin_layout Plain Layout
Declerative paradigm has the meaning that the developer need only to decalre,
 and there is runtime that will do it.
 both Spreadsheet and contraints are categorized to this declerative paradigm.
 In addition, the FRP paradigm aims also to helps the developers from the
 need to reminds to call to update the variables.
 it is said that this leads to a hges anount of bugs.
\end_layout

\begin_layout Plain Layout
The repeating calls are usualy related to mutating variables.
 This drawback is known, that in mutithreading applications, there might
 be deadlok.
 and even when it is a single thread, it is hard to determine the logic
 of mutiple events handlers and callbacks that are called by the events
 and update the variables.
 or it is hard to understand haw the data flows from the flow of the control.
 
\end_layout

\begin_layout Plain Layout
It should be noted, that also when using imutable stream.
 there might be the same problem.
 pushing a value notification to a centeral stream, seems similar ro updating
 a centeral variable.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Repeating Components
\end_layout

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 This absence of redundancy is upheld until the point at which the requirement
 arises to replicate the entire application.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our context, a good seperation should support adding fields calculations,
 without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The model of constraints, there is neither repeating calls nor repeating
 variables.
 The zero repeating is until reaching the need to clone the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This leads to the referential transparency property, which is a characteristic
 of FRP.
 It has been determined that the output streams are calculated from pure
 functions, thus maintaining referential transparency.
 It can also be observed that the principles that block the observable streams
 model from achieving referential transparency (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

) have been addressed.
 The merge operator and accidental recursion are addressed through the assignmen
t operator, while glitches, simultaneous events, and recursions are addressed
 through modeling an order and implementing a filter mechanism.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As a result, the new variant of FRP support multiple assignments.
 A variable with multiple assignments is interpreted as a merge operator
 over the variable and assigned expressions in the various statements.
 This is like a methodology that involves the variable inferring its value
 over time from various streams of samples.
 This leads also to the functional transparency
\emph on
 
\emph default
property, characterized by FRP.
 Because it has been determined, that the output streams are calculated
 from pure functions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propagation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The propagation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our implementation includes a general propagation algorithm that enables
 developers to define clear logic.
 In the drug administration example, the business logic is well-defined,
 including the objects, variables, and how they are calculated.
 However, our implementation follows a strict order of updates, which may
 not meet specific requirements for other domains.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Itemize
Benefits of this metric:
\end_layout

\begin_layout Itemize
Captures the trade-off: It explicitly quantifies the balance between functionali
ty (use cases) and code complexity.
\end_layout

\begin_layout Itemize
Provides a comparative measure: It allows you to directly compare different
 implementations in terms of their efficiency in achieving functionality.
\end_layout

\begin_layout Itemize
Highlights design choices: It can reveal how different design decisions
 impact the relationship between functionality and code complexity.
\end_layout

\begin_layout Plain Layout
The 
\family typewriter
Efficiency
\family default
 metric is calculated by 
\begin_inset Formula $Use\ Case\ Coverage/Code\ Quantity$
\end_inset

.
 A higher 
\family typewriter
Efficiency
\family default
 score indicates for an implementation that it generates more achieves a
 greater degree of flexibility and functionality with a smaller amount of
 code, suggesting a more efficient and potentially more maintainable solution.
\end_layout

\begin_layout Itemize
To further assess the relationship between functionality and code complexity,
 a "Use Case Efficiency" metric is calculated.
 This metric is determined by dividing the number of possible use case permutati
ons (representing Use Case Coverage) by the Code Efficiency score.
\end_layout

\begin_layout Itemize
Formula: Efficiency = Use Case Coverage / Code Efficiency
\end_layout

\begin_layout Itemize
Interpretation: A higher Use Case Efficiency score indicates that the implementa
tion achieves a greater degree of flexibility and functionality with a smaller
 amount of code, suggesting a more efficient and potentially more maintainable
 solution.
\end_layout

\begin_layout Subparagraph
Example:
\end_layout

\begin_layout Itemize
If implementation A has 6 possible use cases and a Code Efficiency score
 of 10, its Use Case Efficiency would be 6/10 = 0.6.
 If implementation B has 4 use cases and a Code Efficiency score of 20,
 its Use Case Efficiency would be 4/20 = 0.2.
 This suggests that implementation A is more efficient, as it provides more
 use cases per unit of code.
\end_layout

\begin_layout Itemize
Benefits of this metric:
\end_layout

\begin_layout Itemize
Captures the trade-off: It explicitly quantifies the balance between functionali
ty (use cases) and code complexity.
\end_layout

\begin_layout Itemize
Provides a comparative measure: It allows you to directly compare different
 implementations in terms of their efficiency in achieving functionality.
\end_layout

\begin_layout Itemize
Highlights design choices: It can reveal how different design decisions
 impact the relationship between functionality and code complexity.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Evaluation Methodology
\end_layout

\begin_layout Plain Layout
The evaluation is conducted through implementations of 
\family typewriter
Drug Administration
\family default
, each employing a distinct approach to managing computed fields and ensuring
 data consistency.
 These implementations utilize the following frameworks or tools:
\end_layout

\begin_layout Itemize

\series bold
rivarjs
\series default
: A 
\family typewriter
JavaScript
\family default
 library designed for reactive programming, facilitating the management
 of dependencies between fields and automatic updates of calculated values.
\end_layout

\begin_layout Itemize

\series bold
RIVarX
\series default
: A C# counterpart to rivarjs, offering similar reactive programming capabilitie
s but tailored for the .NET framework.
\end_layout

\begin_layout Itemize

\series bold
Hotdrink
\series default
: A constraint programming library that allows developers to define relationship
s between variables and have the system automatically maintain consistency
 based on those constraints.
\end_layout

\begin_layout Itemize

\series bold
Excel
\series default
: A spreadsheet software used as a baseline to compare the efficiency and
 flexibility of the reactive programming and constraint programming approaches
 with a traditional method of managing computed fields.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
