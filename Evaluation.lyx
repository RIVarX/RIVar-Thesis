#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Evaluation"

\end_inset

Evaluation
\end_layout

\begin_layout Standard
In order to empirically evaluate our approach and the created libraries
 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we also created several basic unit tests and also sample applications
 of the Drug Administration that has been presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Some source code is available in public in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/Evaluation
\end_layout

\end_inset

.
 A few samples are published in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This implementation of the Drug Administration does not have the patterns
 of code duplication presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Each real wolrd variable exists only once, there is no need to repeat the
 code of events registerations and the classes can be reused (TBD two versions
 in hotdrink and rivarjs)
\end_layout

\begin_layout Standard
In the unit tests, we subscribe to the variables and performed checks on
 the values and on the amount of updates.
 One of the unit tests has the shape of a diamond that has the potential
 of a glitch as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the test, following two updates in the root, it is checked that there
 exactly two updates in the final node.
 We created also unit tests to the Drug Administration, performing such
 checks against the fields and the amout of updates, verifing that the behavior
 is not changed when extending the components.
\end_layout

\begin_layout Standard
We created a windows forms application, with two user controls to the Bag
 and to the Pump.
 We bound the 
\begin_inset Formula $\RIVar$
\end_inset

 to the UI, so that when a UI change event occurs, it adds an event to the
 variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 Here we protect from infinite loops by passing only changes.
\end_layout

\begin_layout Standard
In the sample of the windows forms application, we added the functionality
 to write to the log whenever a change is triggered.
 For updating the UI, we verified that threre is a change in the value,
 but in the log, we always write.
 an example to the log output is present in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 This helps to track the exact updates in the various cenarios.
 During our observations we found redandant updates.
 The reason is that the order of the propogation is post-order DFS.
 Such updates are ignored by the variables and are not passed forward.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
new session 26/09/2023 23:44:02
\end_layout

\begin_layout Plain Layout
Drug_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Volume_Control:100
\end_layout

\begin_layout Plain Layout
Volume_Control: 100 <1,2>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.1 <1,2>
\end_layout

\begin_layout Plain Layout
Volume_Control: 100 <2>
\end_layout

\begin_layout Plain Layout
Rate_Control:5
\end_layout

\begin_layout Plain Layout
Duration_Control: 20 <1,2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 0.5 <1,2,3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 20 <2,3>
\end_layout

\begin_layout Plain Layout
Rate_Control: 5 <3>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Log result for an execution of the Drug Administration application.
\end_layout

\end_inset

 The lines that does not end with angle brackets, inform change events directly
 set by the user.
 The angle bracket contains the timestamps, that are the order of the events
 that the value depends on.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Later, we created similar work with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 to make the framework avaiable to more users, and to be able to use it
 online.
 In order to use it, the developer need to add our rivar.umd.js script and
 also rxjs.umd.min.js.
 The Drug Administration then availability online in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation/RIVar/DrugAdministration.html
\end_layout

\end_inset

 from the code in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/Evaluation/blob/main/RIVar/DrugAdministration.html
\end_layout

\end_inset

.
 In order to evaluate against modern applications, we chose to integrate
 also with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
 There 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 is inherently the state management solution.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\NAME{React}$
\end_inset

 takes a functional approach creating visual views, which are pure functions.
 We used this approach to create a "visual 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

" , where the view continuously reflects the value.
 For instance, 
\begin_inset Formula $\LSTINLINE{InputField}$
\end_inset

 are bound to 
\begin_inset Formula $\LSTINLINE{var}$
\end_inset

 which is an instance of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 set in the 
\begin_inset Formula $\NAME{props}$
\end_inset

, which are the element attributes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

 <InputField rivar={var} />
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can be used to compose a larger component that its view depends on
 a larger object.
 Which then used to compose the larger components similar to micro-frontend
 architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

 as illustrated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:react_micro_frontends"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset Formula $\NAME{React}$
\end_inset

, the visual view of a component can be defined as function of its state.
 In runtime each change in the state, leads the view to re-render.
 We used this concept to create a base class named 
\begin_inset Formula $\LSTINLINE{RIVarComponent}$
\end_inset

 which abstract like a visual 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

.
 Its view is defined as a function of a 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

, so that it is re-render in response to new values in the stream.
\end_layout

\begin_layout Plain Layout
We implemented the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes with the fields and calculations as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 class extends the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 class by composition, adding field calculations to the existing fields
 in the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 class.
 We added also the UI as 
\begin_inset Formula $\NAME{React}$
\end_inset

 components, creating a concept similar to micro-frontend architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

.
 The components are
\emph on
 loosly coupled
\emph default
: the UI components interact with their backend objects (instances of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes), which interacts in the calculations processes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, the languages provide also the stream abstraction ( 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, 
\begin_inset Formula $\NAME{REScala}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
have the ability to declare the data dependencies, but also have stream
 abstraction.
\end_layout

\begin_layout Plain Layout
However, we find various exceptions.
 In 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, in addition to the high level langauge.
 there is the concept of transaction to customize the way of how to handle
 cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In 
\begin_inset Formula $\NAME{FrTime}$
\end_inset

, there is the reserved word 
\begin_inset Formula $\NAME{\LSTINLINE{delay}}$
\end_inset

 to customize the way to how to handle cycles.
 Generaly, the languges does not only have the ability to declare the data
 dependencies, but also have stream abstraction.
\end_layout

\begin_layout Plain Layout
because it is not in addition to the lifted variables.
\end_layout

\begin_layout Plain Layout
The FRP paradigm promotes the concept that the developers need only to specify
 the data dependencies, and the runtime maintains the updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
\end_layout

\begin_layout Plain Layout
However, as the data dependencies might contain cycles, the 
\end_layout

\begin_layout Plain Layout
the langagues in order to handle cycles, the langiges are force to break
 the neat abstraction
\end_layout

\begin_layout Plain Layout
In our framework, like previous works, we had to face the balancing between
 the abstraction level and the generalism of the propogation algorithm.
 In the events driven programming, the framework completely enables completely
 custom propogation.
 In 
\begin_inset Formula $\ReactiveX$
\end_inset

, the developers can choose between several scueduler, to indicate the order
 of the updates.
 In contrast, the FRP paradigm promotes the concept that the developers
 need only to specify the data dependencies, and the runtime maintains the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 
\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify the logic clearly clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
In the events driven programming, that the framework that completely enables
 completely custom propogation, it is error prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, so that it hard to realy customize the propogation according to the needs.
 In frameworks that use streams it used to be also the case, because it
 has the difficulty similar to the evemts paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
This consists of the use of inheritance and composition abstraction mechanisms
 used in OOP to not clone components.
 
\end_layout

\begin_layout Plain Layout
It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
This 
\end_layout

\begin_layout Plain Layout
We implemented the Bag and Pump classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The Pump class extends the Bag class and adds field calculations to the
 existing fields in the Bag class.
 We added also the UI as React components, so that Bag is a ready to use
 component, and Pump is an extension over it.
\end_layout

\begin_layout Plain Layout
We also created Bag React component and a Pump React component, that are
 components that include the UI with the interaction with the user.
 This means that if Bag component is used, and there is a need to extend
 it with the Pump, it is done.
\end_layout

\begin_layout Plain Layout
, each 
\end_layout

\begin_layout Plain Layout
This represents the novelity of our approach to add field calculations without
 disrupting existing clients.
\end_layout

\begin_layout Plain Layout
We also created a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application, keeping on the indepedance, such that a Bag UI component and
 a Pump UI component are indepedant from each other.
 The Bag UI component depends on the Bag class, and the Pump UI component
 depends on the Pump class.
 This present the new ability, that each class can contain fields calculation
 s independantly 
\end_layout

\begin_layout Plain Layout
We implemented 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 extends 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 while adding fields calculations to existing fields that are in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 This represent the advantage of our approach, to enable adding fields calculati
on withiut to disturb existing clients.
 We created also Bag UI component and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 UI component with reserved chrachstic.
\end_layout

\begin_layout Plain Layout
This charechstic in classes is reserved also in UI components.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 is a composition class, that contain 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and adds fields and calculations to calculate fields from 
\end_layout

\begin_layout Plain Layout
, the differences are mostly in the binding to the UI.
 
\end_layout

\begin_layout Plain Layout
Basicly, as 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 consists of an observable stream, when a UI change event occurs, it adds
 an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 However in 
\begin_inset Formula $\NAME{React}$
\end_inset

, we used other strategy.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, the developer should define the visual view as function of changeable
 state or props.
 Therefore, we created a base element, a react component, that defines the
 visual view as function of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that is passed to it by props.
\end_layout

\begin_layout Plain Layout
One of the samples is a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application (a library discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Multiple-Components"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We created class 
\begin_inset Formula $\LSTINLINE{RIVarComponent}$
\end_inset

 that can be 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This enables to create classes with fields and calculations, and then 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This helps to reduce code repetition, becuse without this ability, the
 need to not disturb exisintg clients leads to clone the code to the new
 clients with the added fields calcualtions.
 Another alternative is to not add calculations to existing fields, but
 to add new fields to the new needs, causes repetition in the fields.
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might lead
 to cycles.
 Consequently, we need to take care of the any location taht have access
 to the field, which make the code locations coupled, in contrast to the
 strategy of independent components to increase code reuse, to decrease
 code repetition.
 This is addition to the code repetition in mutiple calls fro the various
 events as explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
without being able to reuse existing 
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might dsiturb
 existing clients, if this closes a cycle in the dependencies.
 If code locations from other components update that field,
\end_layout

\begin_layout Plain Layout
has problems that it requires to consider 
\end_layout

\begin_layout Plain Layout
all the code that might update the field, 
\end_layout

\begin_layout Plain Layout
we can be inaware if a cycle been created, or that 
\end_layout

\begin_layout Plain Layout
, the developers need to handle cases of infinite loops
\end_layout

\begin_layout Plain Layout
with caring about the potentisal of infinite loops
\end_layout

\begin_layout Plain Layout
We evaluate the suggested framework by the Drug Administration example as
 an emparical evaluation.
 Our approach consists of adding fields calculation withiut to disturb existing
 clients and without to repeate code.
 The principal is that enabling to add fields calculations 
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
 The reason is that changes might disturb existing clients.
 Consequently, if there is a need to change, it leads to clone the codebase.
 Cloning or code repretiion is expensnise.
 
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
In the designing the classes for the Drug Administration in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, our approach does the most in the three aspects.
 The novality in our approach, in that fields calculation can be added without
 to disturb existing clients and without to repeate code.
 Previously, we could either add another variables to not disturb the clients,
 or add the functionality to update the exiting fields with the risk of
 an accidetal recursion, that will harm exisitng clients.
 In order to ot harm the clients, we could duplicate the component, and
 adjust the new component to the need.
\end_layout

\begin_layout Plain Layout
As in the Spreadsheet example, in FRP
\end_layout

\begin_layout Plain Layout
Consequently, we reduce code repetition.
 Comparing the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our approach, fields calculation can be added withiut to disturb existing
 clients and without to repeate code.
 Previously, we could add another variables to not disturb the clients,
 or to add the functionality to update the exiting fields with the risk
 that in runtime
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
However, if there is a component and a field that it contains, if we need
 to add a calculation, to update this field according to some other fields,
 there might be an accidental recursion.
\end_layout

\begin_layout Plain Layout
Our approach allows adding 
\end_layout

\begin_layout Plain Layout
In using the approach for Drug Administration, fields calculations are added
 
\end_layout

\begin_layout Plain Layout
Our framework allow, a good seperation where it is allowed to add fields
 calculations, without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
It has been recognized that in each design there is code duplication.
 We recognize several patterns.
 First code reptition to call to update variables in various locations,
 such as in response to events.
 Second, defining several variables to one real world variable.
 and the third and most known cloning code to not affect existing clients.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 In the Spreadsheet, there were variables repetitions.
 In the Hotdrink example, we explained the need to clone components.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 This repetion type is resolved in our framework, like FRP and constraints.
 In using our approach, there is no need to register code to update variables.
\end_layout

\begin_layout Plain Layout
In spreadsheets, that represent the high level abstraction of FRP, there
 is no need to repeat calling to the updates, however, it causes to repeat
 var
\end_layout

\begin_layout Plain Layout
Our discussion is in terms of code repition.
\end_layout

\begin_layout Plain Layout
We focus on the code repretition element.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP languages, that lifts the variables and the expressions (without
 streams), each variable is either an 
\emph on
input
\emph default
 variable or 
\emph on
calculated
\emph default
 variable.
 The input variable is like 
\end_layout

\begin_layout Plain Layout
basicly where each variable is either an input variable or calculated variable
 
\end_layout

\begin_layout Plain Layout
In the presented spreadsheet for implementing the Drug Administration in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there were duplications in the variables.
 Similary, in using the FRP paradign, with creating DAG, such that each
 variable is either an input variable or calculated variable
\end_layout

\begin_layout Plain Layout
We find that the FRP paradigm that created DAG, causes to create variables
 duplication.
\end_layout

\begin_layout Plain Layout
The FRP paradigm is basicly like spreadsheets, which require each variable
 to be either an input 
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
We recognize several code repretition types.
 First, the reptition calls to execute code in the various events.
 This has been 
\end_layout

\begin_layout Plain Layout
Second, the 
\end_layout

\begin_layout Plain Layout
We have explored several architutal designs to implement the Drug Administration
 application, and presented a new approach to design such applications.
 In this section we docu
\end_layout

\begin_layout Plain Layout
We compare the code duplications based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to our approach
\end_layout

\begin_layout Plain Layout
We evaluate the approach empirically: we compare the code duplications based
 on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 in the Drug Administration by our approach, as presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, to other approaches based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Repeating Calls
\end_layout

\begin_layout Plain Layout
In the imperative paradigm, the developer need to call to functions to calculate
 variables in case that their dependant variables changed.
 This might be several locations, in case that there are several variables
 that variable depends on.
\end_layout

\begin_layout Plain Layout
Declerative paradigm has the meaning that the developer need only to decalre,
 and there is runtime that will do it.
 both Spreadsheet and contraints are categorized to this declerative paradigm.
 In addition, the FRP paradigm aims also to helps the developers from the
 need to reminds to call to update the variables.
 it is said that this leads to a hges anount of bugs.
\end_layout

\begin_layout Plain Layout
The repeating calls are usualy related to mutating variables.
 This drawback is known, that in mutithreading applications, there might
 be deadlok.
 and even when it is a single thread, it is hard to determine the logic
 of mutiple events handlers and callbacks that are called by the events
 and update the variables.
 or it is hard to understand haw the data flows from the flow of the control.
 
\end_layout

\begin_layout Plain Layout
It should be noted, that also when using imutable stream.
 there might be the same problem.
 pushing a value notification to a centeral stream, seems similar ro updating
 a centeral variable.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Repeating Components
\end_layout

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 This absence of redundancy is upheld until the point at which the requirement
 arises to replicate the entire application.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our context, a good seperation should support adding fields calculations,
 without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The model of constraints, there is neither repeating calls nor repeating
 variables.
 The zero repeating is until reaching the need to clone the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This leads to the referential transparency property, which is a characteristic
 of FRP.
 It has been determined that the output streams are calculated from pure
 functions, thus maintaining referential transparency.
 It can also be observed that the principles that block the observable streams
 model from achieving referential transparency (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

) have been addressed.
 The merge operator and accidental recursion are addressed through the assignmen
t operator, while glitches, simultaneous events, and recursions are addressed
 through modeling an order and implementing a filter mechanism.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As a result, the new variant of FRP support multiple assignments.
 A variable with multiple assignments is interpreted as a merge operator
 over the variable and assigned expressions in the various statements.
 This is like a methodology that involves the variable inferring its value
 over time from various streams of samples.
 This leads also to the functional transparency
\emph on
 
\emph default
property, characterized by FRP.
 Because it has been determined, that the output streams are calculated
 from pure functions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our implementation includes a general propagation algorithm that enables
 developers to define clear logic.
 In the drug administration example, the business logic is well-defined,
 including the objects, variables, and how they are calculated.
 However, our implementation follows a strict order of updates, which may
 not meet specific requirements for other domains.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
