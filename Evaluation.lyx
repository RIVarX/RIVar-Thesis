#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Evaluation
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {S1};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {S2};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {S3};
\end_layout

\begin_layout Plain Layout

   
\backslash
node[rounded corners=1.5mm,minimum width=4cm,inner sep=1mm,above right,draw,align
=center,text width=26mm] (S4) at (1.2,-3) {S4
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont y changed/calculate x
\backslash

\backslash

\backslash
fontsize{5pt}{5pt}
\backslash
selectfont z changed/calculate x};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180,in=90] (S1);
\end_layout

\begin_layout Plain Layout

      
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.5] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.5] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.5] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.5] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)] (System) {};
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Comparison to Existing Approaches
\end_layout

\begin_layout Standard
We compare the our approach against OOP, FRP and Constraints Programming.
 The comparisons are not meant to be rigorous, but to give intuitions of
 why the our approach outperforms other solutions.
\end_layout

\begin_layout Section
Constraint Programming
\end_layout

\begin_layout Standard
Hotdrink abstract multi-way constaints, while reactive instanse variables
 abstract one-way dependencies.
 Nevertheless, the code verbosity are very close.
 Both declare the variables, the dependencies and the low level functions
 to enforce the dependencies.
 For example the following is equivilent to the bag class' content.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {Drug: 0, VolumeOfFluid: 0, Concentration: 0 )
\end_layout

\begin_layout Plain Layout

.constraint( Drug, VolumeOfFluid, Concentration' )
\end_layout

\begin_layout Plain Layout

      .method( 'VolumeOfFluid, Concentration -> Drug', mul  )
\end_layout

\begin_layout Plain Layout

      .method( 'Drug, VolumeOfFluid -> Concentration', div  )   
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, reactive instance variables' approach outperforms Hotdrink.
 For a small case study, two applications are required.
 First, containing only the bag from the drug administration.
 Second, containing the whole drug administration.
 As in our design, from the single source of code, bag can be deployed independe
tly in addition to the deployment of the whole.
 While in Hotdrink, two applications should be developed, duplicating the
 code of the bag.
\end_layout

\begin_layout Section
FRP
\end_layout

\begin_layout Standard
This thesis is like FRP, providing consistency between variables with 
\emph on
predictable
\emph default
 programs: the same input produces the same output every time we execute
 it.
 However, in FRP developers need to update the program for new input sources,
 while in the new approach, developers need to only extend the program.
\end_layout

\begin_layout Standard
We use an example of two variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}
\end_layout

\end_inset

.
 The first refers to medication amount administared for a patient, the second
 refers to wether the application should alert about abnormal medication
 amount.
\end_layout

\begin_layout Subsection*
Implemented by FRP
\end_layout

\begin_layout Standard
As mentioned, there should be an alert if the amount is abnormal.
 The following formula related the tuple, so that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}'s
\end_layout

\end_inset

 value be automatically according to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administaer the 
\begin_inset ERT
status open

\begin_layout Plain Layout

Concentration
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Volume
\end_layout

\end_inset

, then the amount will be calculated by as product, thefore the code will
 be changed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput()
\end_layout

\begin_layout Plain Layout

_AmountByConcentrationAndVolume=Concentration*Volume_ Alert=Or(IsAbnormal(Amount
ByInput),
\end_layout

\begin_layout Plain Layout

_IsAbnormal(AmountByConcentration AndVolume)_)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Duration}
\end_layout

\end_inset

, then the medication amount will be calculated by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Dose*Duration}
\end_layout

\end_inset

.
 In such a case, we should again update the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput() 
\end_layout

\begin_layout Plain Layout

AmountByConcentrationAndVolume=Concentration*Volume _AmountByDoseAndDuration=Dos
e*Duration_ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),
\end_layout

\begin_layout Plain Layout

         IsAbnormal(AmountByConcentrationAndVolume),      _IsAbnormal(AmountByDo
seAndDuration)_) 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can be seen, that whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset

 need more values source, then we should update the assigment to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}
\end_layout

\end_inset

.
 If we forget to update (as may happen in large complex applications), there
 become inconsistencies between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Implemented by the our approach
\end_layout

\begin_layout Standard
As mentioned, there should be an alert if the amount is abnormal.
 The following formula related the tuple, so that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}'s
\end_layout

\end_inset

 value be automatically according to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer the 
\begin_inset ERT
status open

\begin_layout Plain Layout

Concentration
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Volume
\end_layout

\end_inset

, then the amount will be calculated by as product.
 It is enough to only add the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=Concentration*Volume
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Duration}
\end_layout

\end_inset

, then the medication amount will be calculated by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Dose*Duration}
\end_layout

\end_inset

.
 It is enough to only add the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

Amount=Dose*Duration
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nothing about variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Alert}
\end_layout

\end_inset

 need updates, therfore there is no chance of consistency problem between
 the variables values.
\end_layout

\begin_layout Subsection*
Summary
\end_layout

\begin_layout Standard
In FRP the predictability is because an assigment takes total control over
 its target variable.
 Consequently developers need to update the assigments' code for new input
 sources.
 The proposed thesis we achieve predictability without the above constraint,
 thefore arisen new variables' sources is provided by only extending programs.
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Standard
This thesis is like constraints systems, providing consistency between variables.
 However in constraints systems, developer are forced to one block of code
 that run on a single machine, while this thesis provides modular architecture.
 
\end_layout

\begin_layout Subsection
Multi-way Constraints
\end_layout

\begin_layout Standard
In constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 With the proposed Rivars, it is implemented by declaring three formulas:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 However, the long verbosity exists also in constraints systems, when developers
 need specifying methods to satisfy the constraints.
 In addition, building blocks can easily built on top of our thesis.
 This means more extensions can be implemented by combining several formulas
 into a single constraint.
\end_layout

\begin_layout Subsection
Handle Consistency
\end_layout

\begin_layout Standard
As mentioned, in constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 However, it is not clear what variable's value should be changed, especially
 when both other variables are not empty.
\end_layout

\begin_layout Standard
The same question is arisen when declaring RIvar' formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 Our merge method produce variable's values according to the total order
 over the propogated values, that is derived from a total order over the
 external input events.
 In other words, values produced from old events are overidden by new ones.
\end_layout

\begin_layout Standard
As in 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, first, constraints systems handle consistency according 
\emph on
hierarchical
\emph default
 consraints, that is to ignore constraints if they belong to the low levels
 of hierarchy.
 Second, they consider external inputs as constraints, for example the constrain
t 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=1
\end_layout

\end_inset

 is added when the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

.
 Third, external inputs' constraints are set in the hierarchy, according
 to the events' order.
\end_layout

\begin_layout Standard
Consequently, the decision what variables to update in the automatic updates
 seems the same.
 
\end_layout

\begin_layout Subsection
Decentralized Calculation
\end_layout

\begin_layout Standard
Constraints systems (and most reactive programming implementations
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) manage the constraints and handle them by a one centralized procedure.
 Similary is the approach in the code, the applications' code are of one
 block, because: 
\begin_inset Quotes eld
\end_inset

If the one-way constraints are defined in separate places, co-ordinating
 these constraints can be a major software engineering problem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Consequently, the market which needs modular solutions, does not adopt
 such centerlized solutions 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Procedural Programming
\end_layout

\begin_layout Standard
Whenever a user sets a new value to any of the fields, a calculation procedure
 is executed.
 The procedure consists of branches according to the user-cases, in each
 branch there are three values being used to calculate the other values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[float,frame=single,caption={Centralized Calculation (pseudocod
e, except handling the states that not all the fields have been set yet)}]
 
\end_layout

\begin_layout Plain Layout

If edited triple is of Dose,  Duration, and VolumeOfFluid
\end_layout

\begin_layout Plain Layout

  Drug = Dose*Duration
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

  Rate = VolumeOfFluid/Duration
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Drug, Dose, and Rate
\end_layout

\begin_layout Plain Layout

  Duration = Drug/Dose
\end_layout

\begin_layout Plain Layout

  VolumeOfFluid = Duration*Rate 
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Concentration,  Volume, and Duration
\end_layout

\begin_layout Plain Layout

  Drug = Volume*Concentration
\end_layout

\begin_layout Plain Layout

  Rate = VolumeOfFluid/Duration 
\end_layout

\begin_layout Plain Layout

  Dose = Drug/Duration
\end_layout

\begin_layout Plain Layout

End If
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
We use the observer pattern, meaning that 
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout

Drug:=Duration*Dose
\end_layout

\end_inset

 
\emph default
performs Concentration subscribing to Drug and VolumeOfFluid.
 And declaring 
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout

TheBag.Drug:=Duration*Dose
\end_layout

\end_inset


\emph default
 in Intravenous object, performs calculation to the bag's Drug's values
 by subscribing to its Duration and Dose.
 As a result, the calculations task is seperated according to the objects'
 design (listing 3.3).
 It can be seen that, the long central calculaton procedure (Listing 3.2),
 are replaced with two smaller object's classes, removing repetition lines
 3 and 8.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[float,frame=single, caption=Seperated Calculation] 
\end_layout

\begin_layout Plain Layout

class Intravenous {    
\end_layout

\begin_layout Plain Layout

  Duration := TheBag.Drug/Dose
\end_layout

\begin_layout Plain Layout

  Rate := TheBag.VolumeOfFluid/Duration
\end_layout

\begin_layout Plain Layout

  Dose = TheBag.Drug/Duration
\end_layout

\begin_layout Plain Layout

  TheBag.Drug := Duration*Dose
\end_layout

\begin_layout Plain Layout

  TheBag.VolumeOfFluid := Duration*Rate
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Bag{
\end_layout

\begin_layout Plain Layout

  Concentration := Drug/VolumeOfFluid
\end_layout

\begin_layout Plain Layout

  Drug = Volume*Concentration
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Section
OOP
\end_layout

\begin_layout Chapter
Evaluation
\end_layout

\begin_layout Standard
Our goal was to improve components-based applications by the FRP paradigm.
 However, it is not clear that RIvar, or RIvar with the proposed propogation
 algorithm, is realy FRP.
 Then evaluating improvement of components-based applications by the new
 model is too complex for this scope.
 In this chapter we will provide only some intuition about the relation
 between the proposed model to FRP.
 Then we will provide small scale comparison to programming components (by
 the OOP paradigm) with and without the new model.
 
\end_layout

\begin_layout Section
The new model as FRP
\end_layout

\begin_layout Section
Improving OOP by the new model
\end_layout

\begin_layout Itemize
———-
\end_layout

\begin_layout Standard
We implement the drug administration case study several times to compare
 
\end_layout

\begin_layout Standard
We developed 
\emph on
RIvarX
\emph default
, a nuget package contains the type RIvar.
\end_layout

\begin_layout Standard
Therfore we attach two variations to the development of the drug administration
 classes, first implemented by the traditional C# programming langauge,
 and the second uses RIvarX.
\end_layout

\begin_layout Standard
Reactive instance variables with the distributed propogation algorithms
 are FRP, because...
\end_layout

\begin_layout Standard
FRP based on the refrential transparent, anyway the defintion is not strict
\end_layout

\begin_layout Standard
predictability - equivilent to Hotdrink
\end_layout

\begin_layout Standard
Do we actually improve components based applications we our promise?
\end_layout

\begin_layout Standard
case study compare to traditional implementation
\end_layout

\begin_layout Standard
——————-
\end_layout

\begin_layout Section
FRP Integration
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming langauge 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable as an 
\emph on
event stream
\emph default
, which is an observable emitting values to subscribers, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Standard
integration of functional-reactive code with imperative code might contain
 circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in case recursive definitions are presented.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 contain circular dependencies: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\end_body
\end_document
