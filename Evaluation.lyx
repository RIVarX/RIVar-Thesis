#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Evaluation"

\end_inset

Evaluation
\end_layout

\begin_layout Standard
In this section, it is presented how easy it to 
\emph on
add filling option
\emph default
 compared to previous approaches.
 
\end_layout

\begin_layout Section
Transition to the new Approach: an Example
\end_layout

\begin_layout Standard
Consider an example, where reactive variables are used with the evolution
 of an application.
 The evaluation revolves around the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 represents the medication dosage administered to a patient, while 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 indicates whether the application should trigger an alert for abnormal
 medication amounts.
 A formula is employed to establish a relationship between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

, enabling the automatic determination of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 based on the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code needs to be modified (indicated using bold font style) when the
 doctor administers the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 in order to calculate the resulting amount.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput()
\end_layout

\begin_layout Plain Layout

__AmountByConcentrationAndVolume=Concentration*Volume__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),__IsAbnormal(AmountByConcentration AndVolume)
__)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the doctor administers the medication by setting the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, the medication amount can be calculated using the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 In this scenario, it is necessary to update the code accordingly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput() 
\end_layout

\begin_layout Plain Layout

AmountByConcentrationAndVolume=Concentration*Volume __AmountByDoseAndDuration=Do
se*Duration__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),
\end_layout

\begin_layout Plain Layout

IsAbnormal(AmountByConcentrationAndVolume),
\end_layout

\begin_layout Plain Layout

__IsAbnormal(AmountByDoseAndDuration)__) 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example presents:
\end_layout

\begin_layout Itemize
Several variables to represent 
\family typewriter
Amount
\family default
.
\end_layout

\begin_layout Itemize
A variable 
\family typewriter
Alert
\family default
 that should be updated.
\end_layout

\begin_layout Standard
At this stage, we begin the process again with the new semantics of multiple
 assignments.
\end_layout

\begin_layout Standard
Again, an initial step, alert if the amount is abnormal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the doctor administers the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

, the resulting amount can be calculated by taking their product.
 In order to incorporate this functionality, it is sufficient to add the
 following code snippet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=Concentration*Volume
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the doctor administers the medication by setting the values of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, the medication amount can be calculated using the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 To implement this calculation, it is sufficient to add the following code
 snippet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

Amount=Dose*Duration
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example with the new semantics presents:
\end_layout

\begin_layout Standard
• A single variable to represent 
\family typewriter
Amount
\family default
.
 
\end_layout

\begin_layout Standard
• No need to update code for 
\family typewriter
Alert
\family default
.
\end_layout

\begin_layout Section
Add Filling Option
\end_layout

\begin_layout Standard
Traditionaly, it is easy to add a computed field.
 For example, a formula 
\begin_inset Formula $\LSTINLINE{Amount=Dose*Duration}$
\end_inset

 such that 
\family typewriter
Amount
\family default
 is automaticaly computed according to 
\family typewriter
Dose
\family default
 and 
\family typewriter
Rate
\family default
.
 This meaning would be reserved, only in case that this formula declares
 
\family typewriter
Amount
\family default
 firstly.
 However, generaly the meaning is, that filling 
\family typewriter
Dose
\family default
 and 
\family typewriter
Duration 
\family default
is an option to fill 
\family typewriter
Amount
\family default
.
\end_layout

\begin_layout Standard
The new feature can be presented also as adding a filling option as a set
 of fields.
 This would be presented by the following example.
 Among fields 
\begin_inset Formula $\NAME{Drug}$
\end_inset

, 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

, only two of them are required for documenting drugs' amount.
 Users can, for example, define quantities by setting only 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is computed.
 Additionaly, users can define quantities by setting only the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is computed.
\end_layout

\begin_layout Standard
If only one filling option is available, users are stricted: users must
 define values in the terms used in the application.
 For example, in 
\family typewriter
Drug Administration
\family default
 define quantities by setting 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 for drugs that it is easier to set by 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

.
 In the strict mode, users are forced to convert the values.
 For example, a case that available fields are 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, and an amount is 
\begin_inset Formula $0.5$
\end_inset

 and 
\begin_inset Formula $100$
\end_inset

 for 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 For filling 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 it is required to calculate 
\begin_inset Formula $\LSTINLINE{Concentration*Volume}$
\end_inset

.
\end_layout

\begin_layout Section
Code Reuse Analysis
\end_layout

\begin_layout Standard
We identify three distinct duplication types: 
\emph on
calls to update variables, variables
\emph default
 and 
\emph on
objects
\emph default
 that are adressed through the presented approach.
 The full analysis is presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:analysis-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Calls to Update Variables
\end_layout

\begin_layout Standard
The declerative approach of FRP saves code amount.
 The amount of code saved is of that calls to update variables in the needed
 event handlers.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

), an events based implementation for FRP based declration 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

, the recalculation of 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 needs to be triggered both when 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 is updated and when 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 is updated.
 The calls to recalculate 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 are repeated within the two handlers of the change events for 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE z$
\end_inset

.
\end_layout

\begin_layout Paragraph
Objects
\end_layout

\begin_layout Standard
When it is needed to create a code component based on an an existing one
 without modifying impacting the existing clients, it is needed to clone
 the existing codebase and then making the necessary changes.
 For this reason, identifying 
\emph on
objects
\emph default
 and 
\emph on
inheritance
\emph default
 (and 
\emph on
composition
\emph default
) is a method to reduce code duplications.
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Standard
In modeling objects like the real world, each object and variable should
 represent real world entity.
 However, in real life applcations, when new code update existing variables,
 it might affect existing clients unexpectedly.
 Therefore, it is more safe to add new variables, which causes repetetive
 variables.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
OOP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
FRP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Combined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objects
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Reuse Analysis.
\end_layout

\end_inset

Code Reuse Analysis.
 The columns represent OOP, FRP and the combination approach we presented.
 Across the rows, we categorize types of code duplication types, with X
 denoting the presence of code reuse mechanism for the particular duplication
 type.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To demonstrate the correctness of the change propagation algorithm, we compare
 its output to that of 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, showing that they yield identical results.
 Indeed, 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 is a constraints system of two-way constraints.
 However, each two-way constraint can be decomposed into several one-way
 constraints as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We created the 
\family typewriter
Drug Administration
\family default
 with 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 to compare with the implementation with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 The two algorithms provide identical results in the propagation change.
 Both of the algorithms makes new input to override effects (input and computed
 values) of oldest input at the time of the input.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
The example illustrates a variable reuse mechanism introduced from this
 thesis.
 As in the example, lack of a well defined variable reuse mechanism might
 lead to confused duplications in variables.
 The traditional approach, especially within the imperative paradigm, often
 involves duplicating variables.
 This practice arises due to the inherent complexity in managing variables
 across multiple code locations, making it error-prone to update them consistent
ly.
 Therefore, when dealing with existing components, a safer approach is to
 introduce new variables rather than modifying existing ones.
 This strategy not only reduces the risk of unintended side effects but
 also aligns with methodologies employed in frameworks that facilitate the
 addition of computed fields.
 By utilizing the new variable reuse mechanism, it becomes easier to model
 programs according to the real world, such that applications' variables
 reflect real-world variables, facilitating a one-to-one correspondence.
\end_layout

\begin_layout Plain Layout
Additionally, two mechanisms are derived from OOP and FRP.
 The OOP paradigm consists of inheritance and composition.
 Without inheritance and composition, code is duplicated, leading to potential
 unexpected changes for existing customers.
 The FRP paradigm, in its declarative approach, facilitates code reuse compared
 to event-driven programming.
 In the event-driven paradigm, if a certain field depends on several other
 fields, this field should be updated whenever any of them is updated.
 Therefore, a call to compute and update the field is registered in the
 events of all fields it depends on.
 Prior to this thesis, these two mechanisms were considered mutually exclusive.
 OOP, as an imperative paradigm, struggled to achieve the level of code
 reuse inherent in declarative programming.
 Consequently, inheritance and composition were often combined with the
 event-driven paradigm, resulting in tangled code and duplications when
 calling to compute and update fields.
\end_layout

\begin_layout Plain Layout
It turns out that this thesis introduces three code reuse mechanisms to
 be used together.
 An analysis is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:analysis-2"
plural "true"
caps "false"
noprefix "false"

\end_inset

.
 First, reuse for 
\emph on
components
\emph default
 by the inheritance and composition from the OOP paradigm.
 Second, reuse for 
\emph on
computations
\emph default
, meaning to specify a computation once without the need to manage state.
 The declerative style provides this reuse mechanism like FRP and constraints
 systems.
 Finaly, the presented reuse for variables.
 A variables reuse mechanism has been partially provided in constraints
 systems.
 In constraints systems, several constraints can mention a single variable,
 enabling to add computations without adding variables.
 However the constraints are managed in a centralized mannar 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

, rather than object oriented.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An improveness in code reuse may affect delivery speed to be faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
Replacing the strict mode by a fast adding filling option may improve usability.
 In addition, the improveness in code reuse aims to affect delivery speed
 to be faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
The new feature present another prespective of the improveness code reuse.
 In lack of a mechanism for adding filling options, this has been done manually
 with code duplications.
 The user experience is affected
\end_layout

\begin_layout Plain Layout
This thesis should produce a positive impact on the user experience according
 to the following.
 First, the improveness in code reuse aims to affect delivery speed to be
 faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
\end_layout

\begin_layout Plain Layout
The new feature as well as the
\end_layout

\begin_layout Plain Layout
This thesis should produce a positive impact on the user experience according
 to the following.
 First, the improveness in code reuse aims to affect delivery speed to be
 faster.
 This is because code duplication leads to duplicate also needed changes,
 which is slower than doing changes without duplication.
 Secondly, our novel variables reuse mechanism leads into a new feature
 we name 
\emph on
add filling option
\emph default
 in addition to an ordinary feature 
\emph on
add computed field
\emph default
.
 In a formula 
\begin_inset Formula $\LSTINLINE{Amount=Dose*Duration}$
\end_inset

, in case that 
\family typewriter
Amount
\family default
 is firsly declared, it is the ordinary computed field, otherwise it adds
 a new filling option.
 The idea is that filling 
\family typewriter
Dose
\family default
 and 
\family typewriter
Duration 
\family default
is one option to fill Amount, an alternative to other such filling options.
\end_layout

\begin_layout Plain Layout
The new feature can be presented also as adding a filling option as a set
 of fields, as in the followng example.
 Among fields 
\begin_inset Formula $\NAME{Drug}$
\end_inset

, 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

, only two of them are required for documenting drugs' amount.
 Users can, for example, define quantities by setting only 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is computed.
 Additionaly, users can define quantities by setting only the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In such a case, the value of 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is computed.
\end_layout

\begin_layout Plain Layout
If only one filling option is available, users are stricted: users must
 define values in the terms used in the application.
 For example, in Drug Administration define quantities by setting 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 for drugs that it is easier to set by 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 and 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

.
 In the strict mode, users are forced to convert the values.
 For example, a case that available fields are 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, and an amount is 
\begin_inset Formula $0.5$
\end_inset

 and 
\begin_inset Formula $100$
\end_inset

 for 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 For filling 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 it is required to calculate 
\begin_inset Formula $\LSTINLINE{Concentration\times Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Harmonized Paradigm
\end_layout

\begin_layout Plain Layout
The provided framework comperhasive traditional paradigms nicely.
 The framework harmonizes features from FRP and OOP.
 FRP gives predictability from the functional nature and the declerative
 approach that remove code repetition of registering events to computations.
 OOP gives encapsulation, inheritance and polymorphism.
 Our custom assignment suite the inheritance mehcanism, that it adds dependencie
s rather than change them.
\end_layout

\begin_layout Plain Layout
Additionaly, the framework accompass the abstractions of events streams
 and events.
 The events streams represent the lower level of a variable, represeting
 th vaying value over time.
 The events as side effects is already mentioned in the framework.
 This produces a framework woth three levels of abstraction.
 Consequently, any future demands can be adressed on its level.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 outperforms 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, because in 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

, two distinct styles are used to distinguish between input values and computed
 values.
 
\end_layout

\begin_layout Plain Layout
(i.e., what fields to compute, wh).
 in decisions when and what fields to compute.
\end_layout

\begin_layout Plain Layout
) are the same, except that we change the style to values that are computed
 distingusinh between values that are set and values that are computed.
\end_layout

\begin_layout Plain Layout
We used Hotdrink to create an alternative to the Drug Administration.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 Hotdrink is a library that are based on constraints programming.
 Suprisingly, it provide a very closed solution in code and behavior.
 The behavior of the updates (decisions when and what fields to compute)
 are the same, except that we change the style to values that are computed
 distingusinh between values that are set and values that are computed.
 In code, altough that Hotdrink support two-way constraints while our formulas
 are like one-way constraint, our code is not more difficult.
 The reason is mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

: the constraints are attached with methods that are according to the formulas.
\end_layout

\begin_layout Plain Layout
The significant diffrence between the implementations is in support for
 reusable components.
 In Hotdrink (and others) if we need to create another application based
 on an this one without modifying impacting the existing clients, we need
 to clone the existing codebase and then making the necessary changes to
 the new application.
\end_layout

\begin_layout Plain Layout
However, the library currently lacks support for reusable components 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 Therefore, if we need to create another application based on an this one
 without modifying impacting the existing clients, we need to clone the
 existing codebase and then making the necessary changes to the new application.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
The implementation of the thesis approach is different.
 In the new implemention, users can edit any of the fields, while in the
 same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes (reduced cognitive
 loads).
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Additionaly, in the new implementation , two distinct styles are used to
 distinguish between input values and computed values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Abstraction
\end_layout

\begin_layout Plain Layout
reactive instance variable is similar to reactive variable, that it is more
 declerative than events and streams.
 Furthermore, reactive instance variable outperforms previous implementation
 of reactive variables.
 
\family typewriter
Sodium
\family default
 the transaction was invented to handle cycles.
 In FrTime, there is a delay keywork used to let the developers to sign
 to the runtime, when to stop propagation because of cycles.
\end_layout

\begin_layout Plain Layout
Beside, reactive instance variables is based on events and streams has their
 role, to abstract environmental phnomenon.
 reactive instance variables satisfy this need as well, as it is consists
 of stream of events.
\end_layout

\begin_layout Plain Layout
Comparing to constraints, 
\end_layout

\begin_layout Plain Layout
In the highest level, we provide farmework
\end_layout

\begin_layout Plain Layout
Reactive Instance Variables harmonizes previous concepts seamlessly, sometimes
 ease the abstraction.
 
\end_layout

\begin_layout Plain Layout
in the Highest level, it is similar to reactive variables and one-way dataflow
 constraints
\end_layout

\begin_layout Plain Layout
Comparing to reactive variables implemented in Sodium, 
\end_layout

\begin_layout Paragraph*
events
\end_layout

\begin_layout Plain Layout
events produce repeat in calling to methods in the events.
\end_layout

\begin_layout Paragraph*
streams
\end_layout

\begin_layout Plain Layout
streams that exists in an application, it cannot be reused, by adding more
 values fron another source.
\end_layout

\begin_layout Paragraph
constraints
\end_layout

\begin_layout Plain Layout
constraints are managed as external DSL or ceneralizaed mechanism
\end_layout

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
in contrsints there is a centerlized mechanism to read the 
\end_layout

\begin_layout Plain Layout
This thesis harmomizes FRP with OOP, in a way that the abstraction mechainsm
 is harmonzed as well.
 
\end_layout

\begin_layout Subsection
Stream
\end_layout

\begin_layout Plain Layout
In the example, we created new Amount variables.
 There is an alternative to represent Amount as a stream
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Events/Redux
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Streams/Cycle.js
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints/Hotdrink
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
components
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Repetition Analysis.
\end_layout

\end_inset

Code Repetition Analysis.
 The columns represent distinct libraries, each reflecting a specific architectu
ral design aspect.
 Across the rows, we categorize types of code repetitions, with X denoting
 the presence of a particular repetition type in correlation with the respective
 library or architectural approach.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
pettern
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
react/redux (State)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
cycle.js (Unidirectional Dataflow)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
hotdrink (Constraints)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
components
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Repetition Analysis.
\end_layout

\end_inset

Code Repetition Analysis.
 The rows represent repetitions types and the columns represent an architutal
 appraoch.
 X represents that the repetitions type of the current row might apear in
 using the a architutal appraoch of the column.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 The application is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
with 6 fields, depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, named Drug Administration.
\end_layout

\begin_layout Plain Layout
This thesis is driven by the need to enhance calculations in GUI, in order
 to improve the user experiences.
 Specifically in healthcare, it is desirable to solve usability problems
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

.
 Some concepts will be simplified by the following Drug Administration applicati
on (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), used along this thesis.
 In the Drug Administration, there are several options to define the quantities:
 either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis is driven by the need to enhance user experiences in UI (User
 Interface) and front-end applications.
 A fundamental aspect of this enhancement lies in the realm of field calculation
s.
 Fields calculations means maintaining consistency in field values.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
This thesis aims to establish an effective mechanism for field calculations,
 enhancing user experience in User Interfaces and frond-end applications.
 Field calculations refer to the process of maintaining consistency in field
 values.
 When users input data into one field, it is essential to recalculate the
 values of other related fields.
\end_layout

\begin_layout Plain Layout
This thesis is focused on creating an effective mechanism in fields calculations
 to achive a better user experience in UI or drone ends applications.
 Fields calculations means Maintaining consistency in field values.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Maintaining consistency in field values might be crucial in front ends applicati
ons.
 When users fill in one field, it is essential to recalculate the values
 of other related fields.
 For example, in Drug Administration (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), there are several options to define the quantities: either by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Repeating on code resists against the code changes for two reasons: First,
 because efforts need to be keep on the rules consistency.
 Second, it adds more lines of code to the application.
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the timeconsuming process of implementing changes.
 One contributing factor is the limited cognitive capacity of developers
 when it comes to analyzing the extensive details within the application
 source code, dealing with large code bases and code repetition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Exploring the Useability
\end_layout

\begin_layout Plain Layout
An efficient mechanism to develop fields calculations has a potenstial to
 improve front ends usability.
 Specificaly, in applications for healthcare, it is desirable to solve usability
 problems 
\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Using The new Approach
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
locker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:180:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
openedlocker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:130:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c c c| }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{ordering style }  
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{
\backslash
framebox(130,15){set Dose and Rate {$
\backslash
nabla$}}}
\end_layout

\begin_layout Plain Layout

 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Drug & Concentration & Volume 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

 Dose & Duration & Rate 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

 
\backslash
framebox(35,15){ } 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
openedlocker{0.25}} 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Order-Entry"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration - Full Version.
\end_layout

\end_inset

 At the top, there is the Ordering Style field, represented by a combobox,
 where users can select from the available options.
 Below this, each field consists of a label above its name, an area to display
 its value, and a lock icon on its right.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——————————
\end_layout

\begin_layout Plain Layout
This thesis approach, frame
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, user experience may be affected by code size, because it enhances fast
 customer feedback loops.
 Therefore, we compare code size along with application behavior (user experienc
e = the application behavior from users point of view).
 We use the Order Entry application mentioned throughout this thesis, over
 several implementation approaches.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, calling it Drug Administration
\end_layout

\end_inset

.
 We compare behavior and code size over several approaches for creating
 the application.
 User experience may be affected by code size, since (as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) it enhances fast customer feedback loops.
\end_layout

\begin_layout Section
Approaches
\end_layout

\begin_layout Plain Layout
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Section
Behavior
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
We created several variants for the Drug Administration application with
 diffrences in the code and the behavior.
\end_layout

\begin_layout Plain Layout
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
We compare code size, because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, large code resists against code changes, that is needed for enhance user
 experience with a fast customer feedback loops.
 Beside the code, we compare resulted behavior 
\end_layout

\begin_layout Plain Layout
We compare code repettion over the implementations and approaches for creating
 the Drug Administration.
 We also mention the amount of elements in the screen and compare the applicatio
ns behavior as the cost.
\end_layout

\begin_layout Plain Layout
—————–
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 We compare the code size because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it affects user experience, because it enhances fast customer feedback
 loops.
 Beside the code size, we present its cost or outcome regrading the behavior
 experienced in the application.
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis.
 We created it with the name Drug Administration according to this thesis'
 approach.
 We also created a similar application as an excel file (spreadsheet) to
 ilustrate the application code as reactive variables.
 In addition, we created the Drug Administration as a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Our focus is on reducing the code size to enhance fast customer feedback
 loops.
\end_layout

\begin_layout Plain Layout
because as the reason for poor user experience lies in the inability of
 a fast customer feedback loops.
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 Our focus is in reducing code size.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, code size affects the user experience, because it affect the ability of
 a fast customer feedback loops.
 As mentioned, code size is affected from GUI elements amount and code repetitio
ns.
 Before delving into it, let's present several implementation/approaches
 fo implementing of the Drug Adminstration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
 Beside the original application and the Drug Administration, there are
 various implementations enabled.
 For example, we implemented in Hotdrink an application just like the Drug
 Administration (except the indicator between input values and computed
 values).
 
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
\end_layout

\begin_layout Plain Layout
However, we asume that the centeral outcome of this thesis is in reducing
 code repetitions.
 We identify several architetual deisgns, and find common patterns of code
 repetions that is reduced in the Drug Administration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are three types of repetition elements.
 First, when multiple events handlers need to call the same executation
 call consists of computations and updates.
 Second, when variables reflect the same real world variable.
 Third, components that are unable to reuse, causing to create similar other
 components.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This chapter focuses on evaluating effectiveness of our de-centralization
 approach for improving user experience.
 We evaluate by the Order Entry example.
 We created several implementations of Order Entry of our approach consisting
 the six numeric fields presented in the beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In those applications, users can in any stage edit any of the fields, while
 in the same time, any of them can be updated with computed values by the
 system.
 This is applied based on the rule described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that new input overrides effects (input and computed values) of oldest
 input at the time of the input.
\end_layout

\begin_layout Plain Layout
This is diffrent than in the original application.
 There, users need to start with choosing an orderyng style and sometimes
 to toggle lockers buttons to manage what fields will the user fill.
 At this point the new implementations are more simple and easy to use.
 This is the one hand.
 But in the other hand, the beavior in the original application is might
 be better because behavior is refertial trsnaparent to the user, because
 the user can manage what fields are input and what are computed.
 Therefore, the new implemnetations are imroved with graphical indiator
 of what values are input and what are computed.
 The compyted values have diffrent style than the input values, so it is
 clear to ther user.
\end_layout

\begin_layout Plain Layout
In order to imIn the new implementations, we 
\end_layout

\begin_layout Plain Layout
but in the other hand, it contains 
\end_layout

\begin_layout Plain Layout
Comparing such an implementation to the original presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the new one has reduced conginite loads.
 In the original impleentation, there are locker elements an ordering style
 to choose.
 In the current implementations there is no more than the six numeric fields.
 
\end_layout

\begin_layout Plain Layout
In order that it will be clear what values are input and what are computed,
 there is a graphicaly indicator, when the value is computed, and when the
 values is the one that the use fill.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
We recognize in the exploration three patterns of code duplication.
 First, calling to update variables in various locations, such as in response
 to events.
 Second, multiple variables to represent a single real-world variable.
 Finaly, cloning code to not affect existing clients.
 Since we could not prevent code repretition, we cannot provide a
\emph on
 single source of truth
\emph default
 for the organization's business logic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

import { useState } from 'react';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

export function VisualRIVar({ rivar, render }) {
\end_layout

\begin_layout Plain Layout

  const [value, setValue] = useState(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  rivar.subscribe((signal) => {
\end_layout

\begin_layout Plain Layout

    if (signal.value && value !== signal.value.toString()) {
\end_layout

\begin_layout Plain Layout

      setValue(signal.value.toString());
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  const change = (value) => {
\end_layout

\begin_layout Plain Layout

    rivar.next(new Signal(value));
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return render({ value, change });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

const App = () => {
\end_layout

\begin_layout Plain Layout

  const rivar = new Rivar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return (
\end_layout

\begin_layout Plain Layout

    <RIVarView rivar={rivar} render={({ value, change }) => (
\end_layout

\begin_layout Plain Layout

      <input
\end_layout

\begin_layout Plain Layout

        type="number"
\end_layout

\begin_layout Plain Layout

        value={value}
\end_layout

\begin_layout Plain Layout

        onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

      />
\end_layout

\begin_layout Plain Layout

    )}>
\end_layout

\begin_layout Plain Layout

    </VisualRIVar>
\end_layout

\begin_layout Plain Layout

  );
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:VisualRIVar"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset

The code snippest generates 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

, a react component that takes two props: 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 and a render prop function.
 The render prop function is used to render the child component.
 The render prop function is passed an object with two properties: value
 and change.
 The value property is the current value of the Rivar variable.
 The change function can be used to update the 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 variable.
 In the sample app, the code will render an input field that is connected
 to the rivar variable.
 When the user changes the value of the input field, the rivar variable
 will be updated.
 The rivar variable will then update the value prop of the input field.
 This will cause the input field to be re-rendered with the updated value.
 This pattern can be used to render any type of component inline and nested
 in the 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

 component.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, the languages provide also the stream abstraction ( 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, 
\begin_inset Formula $\NAME{REScala}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
have the ability to declare the data dependencies, but also have stream
 abstraction.
\end_layout

\begin_layout Plain Layout
However, we find various exceptions.
 In 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, in addition to the high level langauge.
 there is the concept of transaction to customize the way of how to handle
 cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In 
\begin_inset Formula $\NAME{FrTime}$
\end_inset

, there is the reserved word 
\begin_inset Formula $\NAME{\LSTINLINE{delay}}$
\end_inset

 to customize the way to how to handle cycles.
 Generaly, the languges does not only have the ability to declare the data
 dependencies, but also have stream abstraction.
\end_layout

\begin_layout Plain Layout
because it is not in addition to the lifted variables.
\end_layout

\begin_layout Plain Layout
The FRP paradigm promotes the concept that the developers need only to specify
 the data dependencies, and the runtime maintains the updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
\end_layout

\begin_layout Plain Layout
However, as the data dependencies might contain cycles, the 
\end_layout

\begin_layout Plain Layout
the langagues in order to handle cycles, the langiges are force to break
 the neat abstraction
\end_layout

\begin_layout Plain Layout
In our framework, like previous works, we had to face the balancing between
 the abstraction level and the generalism of the propogation algorithm.
 In the events driven programming, the framework completely enables completely
 custom propogation.
 In 
\begin_inset Formula $\ReactiveX$
\end_inset

, the developers can choose between several scueduler, to indicate the order
 of the updates.
 In contrast, the FRP paradigm promotes the concept that the developers
 need only to specify the data dependencies, and the runtime maintains the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 
\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify the logic clearly clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
In the events driven programming, that the framework that completely enables
 completely custom propogation, it is error prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, so that it hard to realy customize the propogation according to the needs.
 In frameworks that use streams it used to be also the case, because it
 has the difficulty similar to the evemts paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
This consists of the use of inheritance and composition abstraction mechanisms
 used in OOP to not clone components.
 
\end_layout

\begin_layout Plain Layout
It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
This 
\end_layout

\begin_layout Plain Layout
We implemented the Bag and Pump classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The Pump class extends the Bag class and adds field calculations to the
 existing fields in the Bag class.
 We added also the UI as React components, so that Bag is a ready to use
 component, and Pump is an extension over it.
\end_layout

\begin_layout Plain Layout
We also created Bag React component and a Pump React component, that are
 components that include the UI with the interaction with the user.
 This means that if Bag component is used, and there is a need to extend
 it with the Pump, it is done.
\end_layout

\begin_layout Plain Layout
, each 
\end_layout

\begin_layout Plain Layout
This represents the novelity of our approach to add field calculations without
 disrupting existing clients.
\end_layout

\begin_layout Plain Layout
We also created a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application, keeping on the indepedance, such that a Bag UI component and
 a Pump UI component are indepedant from each other.
 The Bag UI component depends on the Bag class, and the Pump UI component
 depends on the Pump class.
 This present the new ability, that each class can contain fields calculation
 s independantly 
\end_layout

\begin_layout Plain Layout
We implemented 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 extends 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 while adding fields calculations to existing fields that are in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 This represent the advantage of our approach, to enable adding fields calculati
on withiut to disturb existing clients.
 We created also Bag UI component and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 UI component with reserved chrachstic.
\end_layout

\begin_layout Plain Layout
This charechstic in classes is reserved also in UI components.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 is a composition class, that contain 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and adds fields and calculations to calculate fields from 
\end_layout

\begin_layout Plain Layout
, the differences are mostly in the binding to the UI.
 
\end_layout

\begin_layout Plain Layout
Basicly, as 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 consists of an observable stream, when a UI change event occurs, it adds
 an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 However in 
\begin_inset Formula $\NAME{React}$
\end_inset

, we used other strategy.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, the developer should define the visual view as function of changeable
 state or props.
 Therefore, we created a base element, a react component, that defines the
 visual view as function of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that is passed to it by props.
\end_layout

\begin_layout Plain Layout
One of the samples is a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application (a library discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Multiple-Components"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We created class 
\begin_inset Formula $\LSTINLINE{RIVarComponent}$
\end_inset

 that can be 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This enables to create classes with fields and calculations, and then 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This helps to reduce code repetition, becuse without this ability, the
 need to not disturb exisintg clients leads to clone the code to the new
 clients with the added fields calcualtions.
 Another alternative is to not add calculations to existing fields, but
 to add new fields to the new needs, causes repetition in the fields.
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might lead
 to cycles.
 Consequently, we need to take care of the any location taht have access
 to the field, which make the code locations coupled, in contrast to the
 strategy of independent components to increase code reuse, to decrease
 code repetition.
 This is addition to the code repetition in mutiple calls fro the various
 events as explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
without being able to reuse existing 
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might dsiturb
 existing clients, if this closes a cycle in the dependencies.
 If code locations from other components update that field,
\end_layout

\begin_layout Plain Layout
has problems that it requires to consider 
\end_layout

\begin_layout Plain Layout
all the code that might update the field, 
\end_layout

\begin_layout Plain Layout
we can be inaware if a cycle been created, or that 
\end_layout

\begin_layout Plain Layout
, the developers need to handle cases of infinite loops
\end_layout

\begin_layout Plain Layout
with caring about the potentisal of infinite loops
\end_layout

\begin_layout Plain Layout
We evaluate the suggested framework by the Drug Administration example as
 an emparical evaluation.
 Our approach consists of adding fields calculation withiut to disturb existing
 clients and without to repeate code.
 The principal is that enabling to add fields calculations 
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
 The reason is that changes might disturb existing clients.
 Consequently, if there is a need to change, it leads to clone the codebase.
 Cloning or code repretiion is expensnise.
 
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
In the designing the classes for the Drug Administration in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, our approach does the most in the three aspects.
 The novality in our approach, in that fields calculation can be added without
 to disturb existing clients and without to repeate code.
 Previously, we could either add another variables to not disturb the clients,
 or add the functionality to update the exiting fields with the risk of
 an accidetal recursion, that will harm exisitng clients.
 In order to ot harm the clients, we could duplicate the component, and
 adjust the new component to the need.
\end_layout

\begin_layout Plain Layout
As in the Spreadsheet example, in FRP
\end_layout

\begin_layout Plain Layout
Consequently, we reduce code repetition.
 Comparing the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our approach, fields calculation can be added withiut to disturb existing
 clients and without to repeate code.
 Previously, we could add another variables to not disturb the clients,
 or to add the functionality to update the exiting fields with the risk
 that in runtime
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
However, if there is a component and a field that it contains, if we need
 to add a calculation, to update this field according to some other fields,
 there might be an accidental recursion.
\end_layout

\begin_layout Plain Layout
Our approach allows adding 
\end_layout

\begin_layout Plain Layout
In using the approach for Drug Administration, fields calculations are added
 
\end_layout

\begin_layout Plain Layout
Our framework allow, a good seperation where it is allowed to add fields
 calculations, without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
It has been recognized that in each design there is code duplication.
 We recognize several patterns.
 First code reptition to call to update variables in various locations,
 such as in response to events.
 Second, defining several variables to one real world variable.
 and the third and most known cloning code to not affect existing clients.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 In the Spreadsheet, there were variables repetitions.
 In the Hotdrink example, we explained the need to clone components.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 This repetion type is resolved in our framework, like FRP and constraints.
 In using our approach, there is no need to register code to update variables.
\end_layout

\begin_layout Plain Layout
In spreadsheets, that represent the high level abstraction of FRP, there
 is no need to repeat calling to the updates, however, it causes to repeat
 var
\end_layout

\begin_layout Plain Layout
Our discussion is in terms of code repition.
\end_layout

\begin_layout Plain Layout
We focus on the code repretition element.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP languages, that lifts the variables and the expressions (without
 streams), each variable is either an 
\emph on
input
\emph default
 variable or 
\emph on
calculated
\emph default
 variable.
 The input variable is like 
\end_layout

\begin_layout Plain Layout
basicly where each variable is either an input variable or calculated variable
 
\end_layout

\begin_layout Plain Layout
In the presented spreadsheet for implementing the Drug Administration in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there were duplications in the variables.
 Similary, in using the FRP paradign, with creating DAG, such that each
 variable is either an input variable or calculated variable
\end_layout

\begin_layout Plain Layout
We find that the FRP paradigm that created DAG, causes to create variables
 duplication.
\end_layout

\begin_layout Plain Layout
The FRP paradigm is basicly like spreadsheets, which require each variable
 to be either an input 
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
We recognize several code repretition types.
 First, the reptition calls to execute code in the various events.
 This has been 
\end_layout

\begin_layout Plain Layout
Second, the 
\end_layout

\begin_layout Plain Layout
We have explored several architutal designs to implement the Drug Administration
 application, and presented a new approach to design such applications.
 In this section we docu
\end_layout

\begin_layout Plain Layout
We compare the code duplications based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to our approach
\end_layout

\begin_layout Plain Layout
We evaluate the approach empirically: we compare the code duplications based
 on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 in the Drug Administration by our approach, as presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, to other approaches based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Repeating Calls
\end_layout

\begin_layout Plain Layout
In the imperative paradigm, the developer need to call to functions to calculate
 variables in case that their dependant variables changed.
 This might be several locations, in case that there are several variables
 that variable depends on.
\end_layout

\begin_layout Plain Layout
Declerative paradigm has the meaning that the developer need only to decalre,
 and there is runtime that will do it.
 both Spreadsheet and contraints are categorized to this declerative paradigm.
 In addition, the FRP paradigm aims also to helps the developers from the
 need to reminds to call to update the variables.
 it is said that this leads to a hges anount of bugs.
\end_layout

\begin_layout Plain Layout
The repeating calls are usualy related to mutating variables.
 This drawback is known, that in mutithreading applications, there might
 be deadlok.
 and even when it is a single thread, it is hard to determine the logic
 of mutiple events handlers and callbacks that are called by the events
 and update the variables.
 or it is hard to understand haw the data flows from the flow of the control.
 
\end_layout

\begin_layout Plain Layout
It should be noted, that also when using imutable stream.
 there might be the same problem.
 pushing a value notification to a centeral stream, seems similar ro updating
 a centeral variable.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Repeating Components
\end_layout

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 This absence of redundancy is upheld until the point at which the requirement
 arises to replicate the entire application.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our context, a good seperation should support adding fields calculations,
 without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The model of constraints, there is neither repeating calls nor repeating
 variables.
 The zero repeating is until reaching the need to clone the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This leads to the referential transparency property, which is a characteristic
 of FRP.
 It has been determined that the output streams are calculated from pure
 functions, thus maintaining referential transparency.
 It can also be observed that the principles that block the observable streams
 model from achieving referential transparency (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

) have been addressed.
 The merge operator and accidental recursion are addressed through the assignmen
t operator, while glitches, simultaneous events, and recursions are addressed
 through modeling an order and implementing a filter mechanism.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As a result, the new variant of FRP support multiple assignments.
 A variable with multiple assignments is interpreted as a merge operator
 over the variable and assigned expressions in the various statements.
 This is like a methodology that involves the variable inferring its value
 over time from various streams of samples.
 This leads also to the functional transparency
\emph on
 
\emph default
property, characterized by FRP.
 Because it has been determined, that the output streams are calculated
 from pure functions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our implementation includes a general propagation algorithm that enables
 developers to define clear logic.
 In the drug administration example, the business logic is well-defined,
 including the objects, variables, and how they are calculated.
 However, our implementation follows a strict order of updates, which may
 not meet specific requirements for other domains.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
