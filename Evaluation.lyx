#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Evaluation
\begin_inset CommandInset label
LatexCommand label
name "chap:Evaluation"

\end_inset


\end_layout

\begin_layout Standard
The idea of combining reactive variables from FRP to being instance variables
 in OOP is not new.
 REScala and ReactiveX has also reactive variable being an instance variable.
 Anyway, the new model has several additional properties:
\end_layout

\begin_layout Itemize
The model depends only on the basic objects, as tidy interface to clients,
 consisting of instance variables and methods.
 ReactiveX is also based on the basic objects, however it does not have
 the next property, therefore produces non predictable results in case of
 cycles and merges.
\end_layout

\begin_layout Itemize
The model has the referential transparency property, such that each of the
 variables has a function declaring its stream of values according to the
 input provided.
 This property is basic in FRP, however according to REScala, it requires
 a mediator to observe and update the variables, not just the objects model,
 as the previous property.
\end_layout

\begin_layout Itemize
The model corresponds to the concept of inheritance with subtyping.
 Because assigning a variable that belongs to a base class, 
\emph on
adds
\emph default
 a dependency.
 This is in contrast to REScala and ReactiveX, there the same action 
\emph on
replaces
\emph default
 a dependency.
\end_layout

\begin_layout Standard
In the next sections we will evaluate the results Our evaluation presents
 the code duplication aspect (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Code-Reuse"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Our method to handle any graph is also evaluated by comparing between our
 method and other solutions about special graphs (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Special-Graphs"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 At last we give a brief glance about our method compared to the paradigm
 of constraints systems (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Constraints-System"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Code Reuse
\begin_inset CommandInset label
LatexCommand label
name "sec:Code-Reuse"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Code reuse
\emph default
, 
\emph on
DRY 
\emph default
(Don't Repeat Yourself) or 
\emph on
SSOT
\emph default
 (Single Source of Truth.
 By not repeating code, there is no inconsistent behavior, each piece of
 logic has only one source of truth)
\emph on
 
\emph default
are obvious principles in programming.
 In this section, we presents three types of code repetition being removed
 by the new method.
 In the presentation, we refer to the used abstraction mechanisms and compare
 to the traditional methods.
\end_layout

\begin_layout Subsection
Repeating Updates
\begin_inset CommandInset label
LatexCommand label
name "subsec:Repeating-Updates"

\end_inset


\end_layout

\begin_layout Standard
Derived from the FRP paradigm, we abstract away the need to update variables
 in response to dependant variables' updates.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:background-FRP"
plural "false"
caps "false"
noprefix "false"

\end_inset

, The FRP paradigm maintain formulas automatically, so that there is no
 need to repeat registering to events to re-calculate variables.
 In the events paradigm, developers need to update variables in the events
 when other variables are updated.
 In case that a variable is updated according to several variables, we should
 register to all the relevant events to call to the variable to update.
 For example, as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "false"
noprefix "false"

\end_inset

, in order that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x}
\end_layout

\end_inset

 will contain the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{y+z}
\end_layout

\end_inset

 whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{y}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{z}
\end_layout

\end_inset

 is updated, we should calculate 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x}
\end_layout

\end_inset

 in two events handlers.
 We provide the abstraction mechanism so that the developers don't have
 to repeat on the code, they only need to declare 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{x:=y+z}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Repeating Variables
\begin_inset CommandInset label
LatexCommand label
name "subsec:Repeating-Variables"

\end_inset


\end_layout

\begin_layout Standard
In the FRP paradigm by nature, several reactive variables are declared to
 represent a single real world variable.
 the reactive variables are the functions they represent.
 This means that naturaly, once there is a function to calculate a varying
 value, a new reactive variable is declared.
 In contrast, we use the principal of several assigments, such that a single
 reactive variable is assigned to several functions.
 As a result, our method use a mechanism to not duplicate variables.
\end_layout

\begin_layout Subsubsection
Example
\end_layout

\begin_layout Standard
In the example, we demonstrate a development process.
 We use a bold font style to indicate for code, that it is changed compared
 to the previous step.
 The process is about the two variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

, the first refers to medication amount administered to a patient, and the
 second refers to whether the application should alert about abnormal medication
 amount.
 The following formula relates 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

, so that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}'s
\end_layout

\end_inset

 value be automatically according to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

, then the amount will be calculated by as product, thefore the code will
 be changed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput()
\end_layout

\begin_layout Plain Layout

__AmountByConcentrationAndVolume=Concentration*Volume__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),__IsAbnormal(AmountByConcentration AndVolume)
__)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, then the medication amount will be calculated by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 In such a case, we should again update the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

AmountByInput=FromInput() 
\end_layout

\begin_layout Plain Layout

AmountByConcentrationAndVolume=Concentration*Volume __AmountByDoseAndDuration=Do
se*Duration__ 
\end_layout

\begin_layout Plain Layout

Alert=Or(IsAbnormal(AmountByInput),
\end_layout

\begin_layout Plain Layout

IsAbnormal(AmountByConcentrationAndVolume),
\end_layout

\begin_layout Plain Layout

__IsAbnormal(AmountByDoseAndDuration)__) 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can be seen, that whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 need more values source, then we should update the assignment to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

.
 If we forget to update (as may happen in large complex applications), there
 become inconsistencies between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph*
Implementing by the new method
\begin_inset CommandInset label
LatexCommand label
name "par:no-duplicate-variables-example"

\end_inset


\end_layout

\begin_layout Standard
The should be an alert if the amount is abnormal, therefore the following
 formula relates 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

, so that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}'s
\end_layout

\end_inset

 value be automatically according to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{Amount}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=FromInput()
\end_layout

\begin_layout Plain Layout

Alert=IsAbnormal(Amount)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

, then the amount will be calculated by as product.
 It is enough to only add the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

Amount=Concentration*Volume
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The doctor may administer by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

, then the medication amount will be calculated by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose*Duration}
\end_layout

\end_inset

.
 It is enough to only add the code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none] 
\end_layout

\begin_layout Plain Layout

Amount=Dose*Duration
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nothing about variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 need updates, therfore there is no chance of consistency problem between
 the variables' values.
\end_layout

\begin_layout Subsection
Repeating Solutions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Repeating-Solutions"

\end_inset


\end_layout

\begin_layout Standard
The new method also provides an abstraction mechanism to not repeat on 
\emph on
solutions
\emph default
.
 As mentioned in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{subsec:Repeating-Updates,subsec:Repeating-Variables}
\end_layout

\end_inset

, the new method provides an abstraction mechanism to not repeat on updates
 and variables.
 However, we are not the first to provide such an abstraction mechanism.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

, in constraints systems, several constraints can output to the same variable,
 while constraints are such like formulas in FRP.
 Anyway, solutions created by constraints systems cannot be reused and extended
 with more constraints, without to change the original solution, because
 the constraints systems handle the updates using a centeral constraints
 solver.
 In contrast, with the new method, solutions can be reused, because our
 new variant of FRP provides adding formulas to existing solutions.
\end_layout

\begin_layout Standard
We derive from OOP the ability to reuse solutions.
 Before OOP, in order to reuse solutions, the developer has two alternatives:
 either to use an existing solution to the new client, or to copy-and paste
 it.
 The first alternative might cause unexpected changes to existing clients,
 because the developer might change the solution to the new client, affecting
 other cliebts unexpetcedly.
 The second alternative produce code duplication.
 In the second alternative, the duplicated code is related to a common logic,
 if it is changed in one solution, there might be an inconsistency in the
 behavior.
 OOP provides the inheritance and composition mechanisms to reuse existings
 solution without to duplicate and without to change existing solutions.
\end_layout

\begin_layout Standard
The inheritance and composition mechanisms are actually not simple to use.
 It is expected that the new code will not change the original behavior,
 however even if the code is specified only in the service or in the subclass,
 it might change the original behavior 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 When assigning reactive instance variables through a service or a specializatio
n interface (subclass assign a reactive variable of its base class), in
 REScala and ReactiveX, it 
\emph on
replaces
\emph default
 a dependency, then it 
\emph on
changes
\emph default
 the original behavior.
 In our method it 
\emph on
adds
\emph default
 the dependency, then it only 
\emph on
extends
\emph default
 the original behavior.
\end_layout

\begin_layout Section
Special Graphs
\begin_inset CommandInset label
LatexCommand label
name "sec:Special-Graphs"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we presented the new model that provides adding and supporting any formula.
 In order to support any formula, the model need to handle special graphs.
 In this section we compare the model against the traditional methods, in
 the way they handle glitches (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Glitch"
plural "false"
caps "false"
noprefix "false"

\end_inset

), cycles (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Cycles"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and several-assigments (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Several-Assigments"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Glitch"

\end_inset

Glitch
\end_layout

\begin_layout Standard
As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:background-FRP"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a variable might have several updates caused by a single update, e.g., in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "false"
noprefix "false"

\end_inset

, updating 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 leads to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, each of them lead to update 
\begin_inset ERT
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

.
 The updates that are not the last update, are incorrect, and called 
\emph on
glitch
\emph default
.
 This is handled by doing topological sorting 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, so each of the variables will be updated after all its dependencies have
 already been updated.
 But we cannot use this method for two reasons.
\end_layout

\begin_layout Standard
First, a topological sorting is possible only when the dependency graph
 has no cycles, in contrast to our conception that every dependency is possible.
 Second, topological sorting means managing the variables centrally, in
 contrast to the concept of objects managing their variables on their own.
 The need to manage the updates with a decentralized settings reminds the
 distributed settings.
\end_layout

\begin_layout Standard
The decentralized and distributed share the property that it is not applicable
 to have “global centralized knowledge about the topology of the dependency
 structure” 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 However, they are not distinct.
 Whereas distributed settings have challenges related to the network.
 FRP with decentralized settings is more about respecting encapsulation.
 Therefore, and because we support cycles, adapting existing algorithms
 becomes irrelevant most of the times.
\end_layout

\begin_layout Standard
We use the strategy like in the distributed settings, to attach data to
 the values 
\begin_inset CommandInset citation
LatexCommand cite
key "shibanai2018distributed,proencca2017quality"
literal "false"

\end_inset

.
 However we avoid the situation in the distributed settings, that the data
 about variables is public.
 The data becomes public, because the glitch is handled by tracking variables'
 versions, and because information about variables' versions is attached
 with the values.
\end_layout

\begin_layout Standard
Our order model reminds the order of 
\emph on
updates
\emph default
 described in the distributed system model 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
 In our order model, an incorrect (glitch) value (update), is considered
 as less than an existing value, so it is ignored.
 For example, in the dependency graph of 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Glitch"
plural "false"
caps "false"
noprefix "false"

\end_inset

, D with timestamps set {1}, getting an update depending on updated B {2}
 and not updated C {1}, produces timestamps set {1,2} that is a superset
 of the existing timestamps {1}.
 According to the order model, a superset is not considered greater so it
 is ignored.
\end_layout

\begin_layout Standard
Our model seems to solve only types of glitches (among 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

) caused from a single update for a single variable.
 This should satisfy many applications.
 Actualy, for UI application, glitch may be not a problem, because a temporary
 incomplete calculation is replaced very fast with the updated values.
 Anyway, for more strict requirements, such like requiring several synced
 variables, there is a possible solution named 
\emph on
source unification
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "shibanai2018distributed,watanabecomplete"
literal "false"

\end_inset

, to declare a variable deriving the variables.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Several-Assigments"

\end_inset

Several Assigments
\end_layout

\begin_layout Standard
Our model supports variables depending on several expressions such as in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Several-Assigments"
plural "false"
caps "false"
noprefix "false"

\end_inset

, while in runtime values are infered according to time, i.e., the variable's
 current value depends on the recent input events.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,3) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (A);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(B) + (0,-1)$)    {A:=B+1};
\end_layout

\begin_layout Plain Layout


\backslash
node[scale=0.6] at ($(C) + (0,-1)$)    {A:=C+1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Several-Assigments"

\end_inset

Several Assigments
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
FRP
\end_layout

\begin_layout Standard
In FRP, a reactive variable 
\emph on
is
\emph default
 the expression it is related to.
 The assigment operator is related to the imperative paradigm, not to the
 functional paradigm.
 However, languages in which the assigment symbol is used in the context
 of functional programming, means that the left side variable is the name
 of the assigned function.
 Similary in FRP, a formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=Var}
\end_layout

\end_inset

 declares 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 as a function that its body is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Var}
\end_layout

\end_inset

.
 Adding statement such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=Tar}
\end_layout

\end_inset

, is not suitable to the paradigm.
 In terms of reactive variables we cannot relate several sources to a single
 variable so we are forced to use the events abstraction.
\end_layout

\begin_layout Standard
In ReactiveX and Sodium, several streams can be merged into one stream by
 the use of an operator named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Merge}
\end_layout

\end_inset

.
 ReactiveX merges the streams based on the time according the runtime traversal
 order, which is unpredictable 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Sodium provides predictability by forcing the user to define how to merge
 the streams.
 Namely, no general predictable merge has been provided.
\end_layout

\begin_layout Standard
If the developer needs to specify the correct order, it is in contrast to
 the functional paradigm.
 The functional paradigm was meant to eliminate handling time.
 If the developer needs to handle time, it is not clear whether the paradigm
 outperforms the alternative paradigm, in which time is handled by the use
 of states and events 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 Our model handles the merge problem providing the developers the high level
 abstration without to handle time.
 
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Standard
In simple cases our model reminds the behavior when using events: when several
 events handlers calculate a single variable, the variable's value is according
 to the latest triggered event.
\end_layout

\begin_layout Paragraph*
Constraints
\begin_inset CommandInset label
LatexCommand label
name "par:Constraints"

\end_inset


\end_layout

\begin_layout Standard
As described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

, constraints systems like HotDrink solve the constraints according to the
 hierarchy derived from the order of the input.
 Consequently the produced behavior is the same as our new model.
 It is true that the constraints system handles two-way constraints while
 our model handles one-way constraints.
 However, as said in the section, the two-way constraints are declared and
 handled by one-way constraints.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Cycles"

\end_inset

Cycles
\end_layout

\begin_layout Standard
In the FRP paradigm, where FRP runtimes are developed, There are two opposing
 methods about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 Following the approach that cycles are avoided, there is an approach that
 the needed dependency graph is dynamically changed 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
FRP runtimes that support cycles uses various techniques to stop arisen
 loops.
 Terminating when it closes a cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, adding to the language a special operator to inform the runtime when to
 break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

, stop after a number of iterations, stop if the value has not changed,
 or changed only less than a threshold (available in 
\emph on
Microsoft Excel
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

).
 The various methods caused from the unknown, that a repeating update is
 either needed because previous update was a glitch, or that it is unneeded
 because the repeating update is caused from a cycle.
\end_layout

\begin_layout Standard
Our model provides the semantics described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Any-Formula"
plural "false"
caps "false"
noprefix "false"

\end_inset

: cycles are resulted from variables with more than one source.
 Those variables are updated whenever there is a newer value from any of
 the sources.
 Technically, loops are terminated, because values caused from cycles are
 not newer.
 However, we are not the first to handle cycles, as said in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

, constraints systems that handle two-way constraints handle cycles by their
 nature 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Nevertheless, the model treats the meaning issue about cycles more explicity.
\end_layout

\begin_layout Section
Constraints System
\begin_inset CommandInset label
LatexCommand label
name "sec:Constraints-System"

\end_inset


\end_layout

\begin_layout Standard
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "false"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assigments, and that they handle the variables'
 values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Standard
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Standard
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_body
\end_document
