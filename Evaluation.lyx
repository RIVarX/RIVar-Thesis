#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Evaluation"

\end_inset

Evaluation
\end_layout

\begin_layout Standard
This thesis approach, frame
\end_layout

\begin_layout Standard
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, user experience may be affected by code size, because it enhances fast
 customer feedback loops.
 Therefore, we compare code size along with application behavior (user experienc
e = the application behavior from users point of view).
 We use the Order Entry application mentioned throughout this thesis, over
 several implementation approaches.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, calling it Drug Administration
\end_layout

\end_inset

.
 We compare behavior and code size over several approaches for creating
 the application.
 User experience may be affected by code size, since (as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) it enhances fast customer feedback loops.
\end_layout

\begin_layout Section
Approaches
\end_layout

\begin_layout Standard
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Section
Behavior
\end_layout

\begin_layout Standard
——–
\end_layout

\begin_layout Standard
We created several variants for the Drug Administration application with
 diffrences in the code and the behavior.
\end_layout

\begin_layout Standard
We created it according to this thesis' approach, as an excel file (spreadsheet)
 to ilustrate code similar reactive variables and also a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
We compare code size, because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, large code resists against code changes, that is needed for enhance user
 experience with a fast customer feedback loops.
 Beside the code, we compare resulted behavior 
\end_layout

\begin_layout Standard
We compare code repettion over the implementations and approaches for creating
 the Drug Administration.
 We also mention the amount of elements in the screen and compare the applicatio
ns behavior as the cost.
\end_layout

\begin_layout Section
Co
\end_layout

\begin_layout Standard
—————–
\end_layout

\begin_layout Standard
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 We compare the code size because, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it affects user experience, because it enhances fast customer feedback
 loops.
 Beside the code size, we present its cost or outcome regrading the behavior
 experienced in the application.
\end_layout

\begin_layout Standard
———
\end_layout

\begin_layout Standard
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis.
 We created it with the name Drug Administration according to this thesis'
 approach.
 We also created a similar application as an excel file (spreadsheet) to
 ilustrate the application code as reactive variables.
 In addition, we created the Drug Administration as a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Our focus is on reducing the code size to enhance fast customer feedback
 loops.
\end_layout

\begin_layout Standard
because as the reason for poor user experience lies in the inability of
 a fast customer feedback loops.
\end_layout

\begin_layout Standard
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis, calling
 it Drug Administration.
 Our focus is in reducing code size.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, code size affects the user experience, because it affect the ability of
 a fast customer feedback loops.
 As mentioned, code size is affected from GUI elements amount and code repetitio
ns.
 Before delving into it, let's present several implementation/approaches
 fo implementing of the Drug Adminstration.
\end_layout

\begin_layout Paragraph
Excel
\end_layout

\begin_layout Standard
The implementation in excel is similar to reactive variables, that reactive
 variables are categorized into source and computed reactive variables.
 features of computed fields are provided in ....
\end_layout

\begin_layout Standard
This provides similar to calculations.
\end_layout

\begin_layout Standard
However, since field should depend on a single formula, and there are several
 filling options, we created two
\end_layout

\begin_layout Paragraph
Hotdrink
\end_layout

\begin_layout Paragraph
Events
\end_layout

\begin_layout Section
GUI Elements Amount
\end_layout

\begin_layout Standard
The Drug Administration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and does not contain 
\family typewriter
ordering style
\family default
 and 
\family typewriter
locker
\family default
 elements.
 This reduces the code size as there are less elements.
 
\end_layout

\begin_layout Standard
In the Drug Administration, users can edit any of the fields, while in the
 same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Standard
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We implemented an application named Drug Administration inspired from the
 Order Entry mentioned throughout this thesis.
 The Drug Adminstration contains the six numeric fields presented in the
 beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the Drug Administration, users can edit any of the fields, while in
 the same time, any of them can be updated with computed values by the system.
 This provides a cleaner interface with shortand processes.
 In the original application, users need to begin by selecting an 
\family typewriter
ordering style
\family default
 and, at times, clicking on 
\family typewriter
locker
\family default
 elements, making the processes longer.
\end_layout

\begin_layout Plain Layout
While I have highlighted the enhanced user-friendliness of the new Drug
 Administration, it worth mentioning that the original behavior has the
 advantage of being more referential transparent upon calculations flows.
 In the original application, by the 
\family typewriter
ordering style
\family default
 selection and the clicks upon the 
\family typewriter
locker
\family default
 elements, users manage what fields will the user fill, and what fields
 will be computed.
 In contrast, in the 
\family typewriter
Drug Administration
\family default
, the system takes decisions when and what fields to compute.
 This aspect need a further research.
 Nevertheless, the decisions are predictable and fit use cases that (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

) new input should override effects (input and computed values) of oldest
 input at the time of the input.
 We created the Drug Administration in Hotdrink (we will later further explain
 our appraoch improvness), and the behavior of the updates (decisions when
 and what fields to compute) are the same.
 Beside evaluating the decisions, it should be mentioned that the fields
 in the 
\family typewriter
Drug Administration
\family default
 uses two distinct styles to distinguish between input values and computed
 values (which does not ex).
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
 Beside the original application and the Drug Administration, there are
 various implementations enabled.
 For example, we implemented in Hotdrink an application just like the Drug
 Administration (except the indicator between input values and computed
 values).
 
\end_layout

\begin_layout Plain Layout
The effective of our approach lyes in reducing code size and reducing code
 repetitions.
\end_layout

\begin_layout Plain Layout
However, we asume that the centeral outcome of this thesis is in reducing
 code repetitions.
 We identify several architetual deisgns, and find common patterns of code
 repetions that is reduced in the Drug Administration.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are three types of repetition elements.
 First, when multiple events handlers need to call the same executation
 call consists of computations and updates.
 Second, when variables reflect the same real world variable.
 Third, components that are unable to reuse, causing to create similar other
 components.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This chapter focuses on evaluating effectiveness of our de-centralization
 approach for improving user experience.
 We evaluate by the Order Entry example.
 We created several implementations of Order Entry of our approach consisting
 the six numeric fields presented in the beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In those applications, users can in any stage edit any of the fields, while
 in the same time, any of them can be updated with computed values by the
 system.
 This is applied based on the rule described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that new input overrides effects (input and computed values) of oldest
 input at the time of the input.
\end_layout

\begin_layout Plain Layout
This is diffrent than in the original application.
 There, users need to start with choosing an orderyng style and sometimes
 to toggle lockers buttons to manage what fields will the user fill.
 At this point the new implementations are more simple and easy to use.
 This is the one hand.
 But in the other hand, the beavior in the original application is might
 be better because behavior is refertial trsnaparent to the user, because
 the user can manage what fields are input and what are computed.
 Therefore, the new implemnetations are imroved with graphical indiator
 of what values are input and what are computed.
 The compyted values have diffrent style than the input values, so it is
 clear to ther user.
\end_layout

\begin_layout Plain Layout
In order to imIn the new implementations, we 
\end_layout

\begin_layout Plain Layout
but in the other hand, it contains 
\end_layout

\begin_layout Plain Layout
Comparing such an implementation to the original presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the new one has reduced conginite loads.
 In the original impleentation, there are locker elements an ordering style
 to choose.
 In the current implementations there is no more than the six numeric fields.
 
\end_layout

\begin_layout Plain Layout
In order that it will be clear what values are input and what are computed,
 there is a graphicaly indicator, when the value is computed, and when the
 values is the one that the use fill.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Code Repetitions
\end_layout

\begin_layout Standard
The Order Entry 
\end_layout

\begin_layout Standard
Based on the example prisented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "true"
caps "true"
noprefix "false"

\end_inset

, we developed the Order Entry in .net and in javascript
\end_layout

\begin_layout Section
Functional Behavior
\end_layout

\begin_layout Section
Repetition Calls
\end_layout

\begin_layout Standard
——–
\end_layout

\begin_layout Standard
The efficacy of the thesis is demonstrated through a comparative analysis
 of code repetition elements across various implementations of the Order
 Entry.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In order to empirically evaluate our approach, we explore alternative design
 options for the mentioned Drug Administration Application.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To address this, recommended practices emphasize the design of multiple
 objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Furthermore, the separation to responsibilities should be alligned to the
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
implementations
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
In order to eliminate redundancy, a dedicated change event can be created
 for each field.
 Small functions containing the relevant calculations are registered to
 handle these events.
 In this way not all the values are calculated in response to an update
 by the user.
 Instead, it's possible for each field change event to trigger the recalculation
 of only those fields whose values are derived from the updated values.
\end_layout

\begin_layout Standard
However, this method causes another form of redundancy.
 Taking the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

 of implementing 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

, the recalculation of 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 needs to be triggered both when 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 is updated and when 
\begin_inset Formula $\LSTINLINE z$
\end_inset

 is updated.
 The calls to recalculate 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 are repeated within the two handlers of the change events for 
\begin_inset Formula $\LSTINLINE y$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE z$
\end_inset

.
 Similarly, in cases where a field relies on multiple fields, the registrations
 to recalculate it must be duplicated across the various change events of
 the fields it depends on.
 This places the responsibility on developers to meticulously ensure that
 no registration is overlooked.
\end_layout

\begin_layout Subsection
Spreadsheet
\end_layout

\begin_layout Standard
We implemented the Drug Administration example in a 
\begin_inset Formula $\NAME{Spreadsheet}$
\end_inset

, available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX/Evaluation/DrugAdministration.xlsx 
\end_layout

\end_inset

.
 Each cell can contain either a formula or a value.
 This leads to implement several modes to the drug administration.
 In the first mode, users set the 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, and the other fields are calculated.
 In the second mode, users set the 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, and once again, the other fields are calculated.
 This pattern can continue for additional modes.
 
\end_layout

\begin_layout Standard
This implementation has redundancy across the different modes, as several
 cells calculate the values of the same real-world variable.
 This is in contrast to the traditional OOP, where objects commonly store
 variables that mirror real-world attributes or variables.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Standard
We developed the Drug Administration application using the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library.
 However, the library currently lacks support for reusable components 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 Therefore, if we need to create another application based on an this one
 without modifying impacting the existing clients, we need to clone the
 existing codebase and then making the necessary changes to the new application.
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Standard
There are three types of repetitions.
 First, when multiple events handlers need to call the same executation
 call consists of computations and updates.
 Second, when variables reflect the same real world variable.
 Third, components that are unable to reuse, causing to create similar other
 components.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
repetitions element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
react/redux (State)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
cycle.js (Unidirectional Dataflow)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
hotdrink (Constraints) 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
components
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:analysis"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Repetition Analysis.
\end_layout

\end_inset

Code Repetition Analysis.
 The rows represent repetitions types and the columns represent an architutal
 appraoch.
 X represents that the repetitions type of the current row might apear in
 using the a architutal appraoch of the column.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Unlike our approach, the alternatives suffer from code duplication in three
 main patterns.
 First, there is duplication when updating variables in different locations,
 like in response to events.
 Second, multiple variables are used to represent a single real-world variable.
 Finally, code is cloned to avoid affecting existing clients.
 With our approach, developers can work without repetition, allowing the
 organization's business logic to be specified in the code as a 
\emph on
single source of truth
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
We recognize in the exploration three patterns of code duplication.
 First, calling to update variables in various locations, such as in response
 to events.
 Second, multiple variables to represent a single real-world variable.
 Finaly, cloning code to not affect existing clients.
 Since we could not prevent code repretition, we cannot provide a
\emph on
 single source of truth
\emph default
 for the organization's business logic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

import { useState } from 'react';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

export function VisualRIVar({ rivar, render }) {
\end_layout

\begin_layout Plain Layout

  const [value, setValue] = useState(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  rivar.subscribe((signal) => {
\end_layout

\begin_layout Plain Layout

    if (signal.value && value !== signal.value.toString()) {
\end_layout

\begin_layout Plain Layout

      setValue(signal.value.toString());
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  const change = (value) => {
\end_layout

\begin_layout Plain Layout

    rivar.next(new Signal(value));
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return render({ value, change });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

const App = () => {
\end_layout

\begin_layout Plain Layout

  const rivar = new Rivar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return (
\end_layout

\begin_layout Plain Layout

    <RIVarView rivar={rivar} render={({ value, change }) => (
\end_layout

\begin_layout Plain Layout

      <input
\end_layout

\begin_layout Plain Layout

        type="number"
\end_layout

\begin_layout Plain Layout

        value={value}
\end_layout

\begin_layout Plain Layout

        onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

      />
\end_layout

\begin_layout Plain Layout

    )}>
\end_layout

\begin_layout Plain Layout

    </VisualRIVar>
\end_layout

\begin_layout Plain Layout

  );
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:VisualRIVar"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset

The code snippest generates 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

, a react component that takes two props: 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 and a render prop function.
 The render prop function is used to render the child component.
 The render prop function is passed an object with two properties: value
 and change.
 The value property is the current value of the Rivar variable.
 The change function can be used to update the 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 variable.
 In the sample app, the code will render an input field that is connected
 to the rivar variable.
 When the user changes the value of the input field, the rivar variable
 will be updated.
 The rivar variable will then update the value prop of the input field.
 This will cause the input field to be re-rendered with the updated value.
 This pattern can be used to render any type of component inline and nested
 in the 
\begin_inset Formula $\LSTINLINE{VisualRIVar}$
\end_inset

 component.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
This is like previous works had to face the balancing between the abstraction
 level and the generalism of the propogation algorithm.
 The technaogy that enables completely custom propogation, has a problematic
 abstraction.
 Event-driven programming theortecaly provide customizable propagation.
 Hoever, the paradigm is error prone, so that it hard to realy customize
 according to the needs.
 Therfore, it is not new that the customizability, is by only choose a general
 propogation strategy.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
, the languages provide also the stream abstraction ( 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, 
\begin_inset Formula $\NAME{REScala}$
\end_inset

).
\end_layout

\begin_layout Plain Layout
have the ability to declare the data dependencies, but also have stream
 abstraction.
\end_layout

\begin_layout Plain Layout
However, we find various exceptions.
 In 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, in addition to the high level langauge.
 there is the concept of transaction to customize the way of how to handle
 cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In 
\begin_inset Formula $\NAME{FrTime}$
\end_inset

, there is the reserved word 
\begin_inset Formula $\NAME{\LSTINLINE{delay}}$
\end_inset

 to customize the way to how to handle cycles.
 Generaly, the languges does not only have the ability to declare the data
 dependencies, but also have stream abstraction.
\end_layout

\begin_layout Plain Layout
because it is not in addition to the lifted variables.
\end_layout

\begin_layout Plain Layout
The FRP paradigm promotes the concept that the developers need only to specify
 the data dependencies, and the runtime maintains the updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
\end_layout

\begin_layout Plain Layout
However, as the data dependencies might contain cycles, the 
\end_layout

\begin_layout Plain Layout
the langagues in order to handle cycles, the langiges are force to break
 the neat abstraction
\end_layout

\begin_layout Plain Layout
In our framework, like previous works, we had to face the balancing between
 the abstraction level and the generalism of the propogation algorithm.
 In the events driven programming, the framework completely enables completely
 custom propogation.
 In 
\begin_inset Formula $\ReactiveX$
\end_inset

, the developers can choose between several scueduler, to indicate the order
 of the updates.
 In contrast, the FRP paradigm promotes the concept that the developers
 need only to specify the data dependencies, and the runtime maintains the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 
\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Plain Layout
In our implementation, we provided a strict general propogation algorithm,
 to provide the developers to sepcify the logic clearly clear logic.
 In the drug administration example, the business logic is well specified:
 the objects, the variables, and how they are calculated from each other.
 However, the order of the updates are strict to our implementation.
 there may be domain-specific requirements for other orders for the updates.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 now we will weaken this argument.
\end_layout

\begin_layout Subsection
The state of the art
\end_layout

\begin_layout Plain Layout
In the events driven programming, that the framework that completely enables
 completely custom propogation, it is error prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, so that it hard to realy customize the propogation according to the needs.
 In frameworks that use streams it used to be also the case, because it
 has the difficulty similar to the evemts paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In working with streams such like like ReactiveX.
 In reactiveX, the developer can choose between several scueduler, to indicate
 the order of the updates.
 Hwoever, in working with streams, there is has the same general time problem
 we have in the events driven.
 Here, it is called 
\series bold
merge
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the FRP field reserach, the centeral high level concept is that the developer
s need only to specify the data dependencies, and the runtime maintain the
 updates.
 saying that the the runtime handles the non functional requirements, and
 the developer is free to handle only the functional equirements.
 Suprisngly, the general algorithm handles also some functional requirements,
 and also some non functional requirements break the neat abstraction.
 The root causes are glitches and cycles.
\end_layout

\begin_layout Paragraph
Glitches
\end_layout

\begin_layout Plain Layout
Glitch means an extra recomputation then expected.
 This is not only the extra work, that affect the perfomance, but also that
 the values that are based on stale values, until the last recomutation.
 There are several glicthes types,that arerelated to the required level
 of the consistency.
 So, this is a functional requirement, depending on the applicaton business.
 Hwever, it is handled strictly by the runtime.
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Plain Layout
In order to customize the way in which to evaluate cycles, the abstracion
 is not totaly high.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Our approach can be implemented (as we already implemented) as internal
 dsl, based on the existing popular frameworks.
 the comunication between the nodes is based on a simpler observer chanel.
 theoreticaly, the developers can debug the updates (however, in our implementat
ion, it is still not the case, because we use the framework that implemented
 the streams with schduler, and not completly directly method calls.
 theoreticaly, the nodes can cumunicate efficiently over a wire chanel,
 because the protocal (propogation algorthm) is peer to peer (means no madiator).
 The only limitation, is that the external input will be atached with an
 order, such that each input is atached with the incerenetal number.
 In large network, it might be a bottleneck.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
This consists of the use of inheritance and composition abstraction mechanisms
 used in OOP to not clone components.
 
\end_layout

\begin_layout Plain Layout
It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
This 
\end_layout

\begin_layout Plain Layout
We implemented the Bag and Pump classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The Pump class extends the Bag class and adds field calculations to the
 existing fields in the Bag class.
 We added also the UI as React components, so that Bag is a ready to use
 component, and Pump is an extension over it.
\end_layout

\begin_layout Plain Layout
We also created Bag React component and a Pump React component, that are
 components that include the UI with the interaction with the user.
 This means that if Bag component is used, and there is a need to extend
 it with the Pump, it is done.
\end_layout

\begin_layout Plain Layout
, each 
\end_layout

\begin_layout Plain Layout
This represents the novelity of our approach to add field calculations without
 disrupting existing clients.
\end_layout

\begin_layout Plain Layout
We also created a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application, keeping on the indepedance, such that a Bag UI component and
 a Pump UI component are indepedant from each other.
 The Bag UI component depends on the Bag class, and the Pump UI component
 depends on the Pump class.
 This present the new ability, that each class can contain fields calculation
 s independantly 
\end_layout

\begin_layout Plain Layout
We implemented 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 classes as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 extends 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 while adding fields calculations to existing fields that are in 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 This represent the advantage of our approach, to enable adding fields calculati
on withiut to disturb existing clients.
 We created also Bag UI component and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 UI component with reserved chrachstic.
\end_layout

\begin_layout Plain Layout
This charechstic in classes is reserved also in UI components.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 is a composition class, that contain 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and adds fields and calculations to calculate fields from 
\end_layout

\begin_layout Plain Layout
, the differences are mostly in the binding to the UI.
 
\end_layout

\begin_layout Plain Layout
Basicly, as 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 consists of an observable stream, when a UI change event occurs, it adds
 an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 However in 
\begin_inset Formula $\NAME{React}$
\end_inset

, we used other strategy.
 In 
\begin_inset Formula $\NAME{React}$
\end_inset

, the developer should define the visual view as function of changeable
 state or props.
 Therefore, we created a base element, a react component, that defines the
 visual view as function of 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that is passed to it by props.
\end_layout

\begin_layout Plain Layout
One of the samples is a 
\begin_inset Formula $\NAME{React}$
\end_inset

 application (a library discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Multiple-Components"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We created class 
\begin_inset Formula $\LSTINLINE{RIVarComponent}$
\end_inset

 that can be 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This enables to create classes with fields and calculations, and then 
\end_layout

\begin_layout Plain Layout
The advantage of our approach is to enable adding fields calculation withiut
 to disturb existing clients.
 This helps to reduce code repetition, becuse without this ability, the
 need to not disturb exisintg clients leads to clone the code to the new
 clients with the added fields calcualtions.
 Another alternative is to not add calculations to existing fields, but
 to add new fields to the new needs, causes repetition in the fields.
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might lead
 to cycles.
 Consequently, we need to take care of the any location taht have access
 to the field, which make the code locations coupled, in contrast to the
 strategy of independent components to increase code reuse, to decrease
 code repetition.
 This is addition to the code repetition in mutiple calls fro the various
 events as explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
without being able to reuse existing 
\end_layout

\begin_layout Plain Layout
The traditional alternative to register code to update fields might dsiturb
 existing clients, if this closes a cycle in the dependencies.
 If code locations from other components update that field,
\end_layout

\begin_layout Plain Layout
has problems that it requires to consider 
\end_layout

\begin_layout Plain Layout
all the code that might update the field, 
\end_layout

\begin_layout Plain Layout
we can be inaware if a cycle been created, or that 
\end_layout

\begin_layout Plain Layout
, the developers need to handle cases of infinite loops
\end_layout

\begin_layout Plain Layout
with caring about the potentisal of infinite loops
\end_layout

\begin_layout Plain Layout
We evaluate the suggested framework by the Drug Administration example as
 an emparical evaluation.
 Our approach consists of adding fields calculation withiut to disturb existing
 clients and without to repeate code.
 The principal is that enabling to add fields calculations 
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
 The reason is that changes might disturb existing clients.
 Consequently, if there is a need to change, it leads to clone the codebase.
 Cloning or code repretiion is expensnise.
 
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
In the designing the classes for the Drug Administration in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, our approach does the most in the three aspects.
 The novality in our approach, in that fields calculation can be added without
 to disturb existing clients and without to repeate code.
 Previously, we could either add another variables to not disturb the clients,
 or add the functionality to update the exiting fields with the risk of
 an accidetal recursion, that will harm exisitng clients.
 In order to ot harm the clients, we could duplicate the component, and
 adjust the new component to the need.
\end_layout

\begin_layout Plain Layout
As in the Spreadsheet example, in FRP
\end_layout

\begin_layout Plain Layout
Consequently, we reduce code repetition.
 Comparing the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our approach, fields calculation can be added withiut to disturb existing
 clients and without to repeate code.
 Previously, we could add another variables to not disturb the clients,
 or to add the functionality to update the exiting fields with the risk
 that in runtime
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
We compare the Drug Administration implementation by our approach to the
 explored architectural designs in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It has been recognized that code duplication is present in all designs.
 We have identified several patterns.
 First, code repetition is used to call to update variables in various locations
, such as in response to events.
 Second, several variables are defined to represent one real-world variable.
 The third and most well-known pattern is cloning code to not affect existing
 clients.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
However, if there is a component and a field that it contains, if we need
 to add a calculation, to update this field according to some other fields,
 there might be an accidental recursion.
\end_layout

\begin_layout Plain Layout
Our approach allows adding 
\end_layout

\begin_layout Plain Layout
In using the approach for Drug Administration, fields calculations are added
 
\end_layout

\begin_layout Plain Layout
Our framework allow, a good seperation where it is allowed to add fields
 calculations, without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
It has been recognized that in each design there is code duplication.
 We recognize several patterns.
 First code reptition to call to update variables in various locations,
 such as in response to events.
 Second, defining several variables to one real world variable.
 and the third and most known cloning code to not affect existing clients.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 In the Spreadsheet, there were variables repetitions.
 In the Hotdrink example, we explained the need to clone components.
\end_layout

\begin_layout Plain Layout
In the events paradigm, the repeating calls to update variables in the various
 events.
 This repetion type is resolved in our framework, like FRP and constraints.
 In using our approach, there is no need to register code to update variables.
\end_layout

\begin_layout Plain Layout
In spreadsheets, that represent the high level abstraction of FRP, there
 is no need to repeat calling to the updates, however, it causes to repeat
 var
\end_layout

\begin_layout Plain Layout
Our discussion is in terms of code repition.
\end_layout

\begin_layout Plain Layout
We focus on the code repretition element.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP languages, that lifts the variables and the expressions (without
 streams), each variable is either an 
\emph on
input
\emph default
 variable or 
\emph on
calculated
\emph default
 variable.
 The input variable is like 
\end_layout

\begin_layout Plain Layout
basicly where each variable is either an input variable or calculated variable
 
\end_layout

\begin_layout Plain Layout
In the presented spreadsheet for implementing the Drug Administration in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there were duplications in the variables.
 Similary, in using the FRP paradign, with creating DAG, such that each
 variable is either an input variable or calculated variable
\end_layout

\begin_layout Plain Layout
We find that the FRP paradigm that created DAG, causes to create variables
 duplication.
\end_layout

\begin_layout Plain Layout
The FRP paradigm is basicly like spreadsheets, which require each variable
 to be either an input 
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
We recognize several code repretition types.
 First, the reptition calls to execute code in the various events.
 This has been 
\end_layout

\begin_layout Plain Layout
Second, the 
\end_layout

\begin_layout Plain Layout
We have explored several architutal designs to implement the Drug Administration
 application, and presented a new approach to design such applications.
 In this section we docu
\end_layout

\begin_layout Plain Layout
We compare the code duplications based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to our approach
\end_layout

\begin_layout Plain Layout
We evaluate the approach empirically: we compare the code duplications based
 on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 in the Drug Administration by our approach, as presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, to other approaches based on our exploration in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Repeating Calls
\end_layout

\begin_layout Plain Layout
In the imperative paradigm, the developer need to call to functions to calculate
 variables in case that their dependant variables changed.
 This might be several locations, in case that there are several variables
 that variable depends on.
\end_layout

\begin_layout Plain Layout
Declerative paradigm has the meaning that the developer need only to decalre,
 and there is runtime that will do it.
 both Spreadsheet and contraints are categorized to this declerative paradigm.
 In addition, the FRP paradigm aims also to helps the developers from the
 need to reminds to call to update the variables.
 it is said that this leads to a hges anount of bugs.
\end_layout

\begin_layout Plain Layout
The repeating calls are usualy related to mutating variables.
 This drawback is known, that in mutithreading applications, there might
 be deadlok.
 and even when it is a single thread, it is hard to determine the logic
 of mutiple events handlers and callbacks that are called by the events
 and update the variables.
 or it is hard to understand haw the data flows from the flow of the control.
 
\end_layout

\begin_layout Plain Layout
It should be noted, that also when using imutable stream.
 there might be the same problem.
 pushing a value notification to a centeral stream, seems similar ro updating
 a centeral variable.
\end_layout

\begin_layout Subsection
Repeating Variables
\end_layout

\begin_layout Plain Layout
In the FRP paradigm, like in spreadsheets, each variable is either connected
 to the environment or consistently calculated from other variables.
 Therefore, as in spreadsheets, if there are two or more options of a certain
 variable to get the values from, redadnant variables need to be created.
 In order that a variable will contain values from more than a single source,
 the 
\emph on
stream
\emph default
 abstraction can be used (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Repeating Components
\end_layout

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 This absence of redundancy is upheld until the point at which the requirement
 arises to replicate the entire application.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\begin_layout Plain Layout
Inheritance and composition is the abstraction mechanisms used in OOP to
 not clone components.
 It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 The impact of a good seperation is, that if the business needs to provide
 a component that is based on an existing one, it is an addition, not a
 change.
\end_layout

\begin_layout Plain Layout
In our context, a good seperation should support adding fields calculations,
 without to distrub the existing ones.
 The events paradigm inherently supports to add an event handler to calculate
 field in response to changes in other fields.
 Similary, by the use of observable streams, code can be subscribed.
 However, this such additions might distrub existing calculations, because
 it might lead to an infinite loop.
\end_layout

\begin_layout Plain Layout
in runtime, the recalcuated field might be originated from its own recalculation.
 We metioned this in the background for streams with the name accidetal
 recursion.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the constraint model, there exist neither redundant function calls nor
 duplicated variables.
 The absence of redundancy persists until the point of necessitating the
 complete replication of the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
 When we encounter scenarios where we must offer a component that builds
 upon an existing one without altering or affecting current clients, we
 resort to component cloning.
 Within the cloned component, we implement the necessary modifications and
 subsequently deploy this tailored component to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The model of constraints, there is neither repeating calls nor repeating
 variables.
 The zero repeating is until reaching the need to clone the entire application.
 We clone components, if we need to provide a component that is based on
 existing component without modifying or impacting the existing clients.
 In the cloned component, we make the required changes and deploy this component
 to the new client.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This leads to the referential transparency property, which is a characteristic
 of FRP.
 It has been determined that the output streams are calculated from pure
 functions, thus maintaining referential transparency.
 It can also be observed that the principles that block the observable streams
 model from achieving referential transparency (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

) have been addressed.
 The merge operator and accidental recursion are addressed through the assignmen
t operator, while glitches, simultaneous events, and recursions are addressed
 through modeling an order and implementing a filter mechanism.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As a result, the new variant of FRP support multiple assignments.
 A variable with multiple assignments is interpreted as a merge operator
 over the variable and assigned expressions in the various statements.
 This is like a methodology that involves the variable inferring its value
 over time from various streams of samples.
 This leads also to the functional transparency
\emph on
 
\emph default
property, characterized by FRP.
 Because it has been determined, that the output streams are calculated
 from pure functions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Our implementation includes a general propagation algorithm that enables
 developers to define clear logic.
 In the drug administration example, the business logic is well-defined,
 including the objects, variables, and how they are calculated.
 However, our implementation follows a strict order of updates, which may
 not meet specific requirements for other domains.
 In addition, performance considerations (non functional requirements) may
 require changing the order of the updates, such as reducing consistency
 levels for heavy calculations.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
