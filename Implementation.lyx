#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
In this chapter we present an implementation to the model presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Modeling"
plural "false"
caps "false"
noprefix "false"

\end_inset

, attached with a small case study based on the motivating example from
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivating-Example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The model is implemented as a lightweight .NET library to C# developers
 named RIVarX
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar, https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset

.
 RIVarX provides RIVar functionality based on ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
ReactiveX provides observable streams which has already been presented as
 being reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 ReactiveX has two useful operators to implement latent variables: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/map.html
\begin_inset ERT
status open

\begin_layout Plain Layout

(in other programming languages it is named 
\backslash
lstinline{map})
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/combinelatest.html
\end_layout

\end_inset

.
 The default behavior is that values are pushed to subscribers synchronously,
 just like the required push model described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Execution-Model"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Consequently, FRP applications can be easily developed.
 For example, FRP application with the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=D+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 can be implemented by the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=D.Select(x=>x+1)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B.CombineLatest(C,(x,y)=>x+y))}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Basics
\begin_inset CommandInset label
LatexCommand label
name "sec:Basics"

\end_inset


\end_layout

\begin_layout Standard
To implement our model described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Modeling"
plural "false"
caps "false"
noprefix "false"

\end_inset

, there is only a small gap.
\end_layout

\begin_layout Paragraph*
Assignment Operator
\end_layout

\begin_layout Standard
The default assigment copies values bit by bit.
 Therefore, in the context of FRP applications, the assigment just makes
 the target variable to point on the constructed expressions, disconnecting
 from the old referenced expression if exists.
 The traditional assigment cannot be overriden, therefore RIVarX implements
 an alternative assigment function named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 uses the new approach to add the expression in addition to existing expressions.
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 method has two arguments: a reference to the target and the reference to
 the assigned expression.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is called, it subscribes to the two streams, so that for each signal from
 the assigned expression, it will compare to the signal produced latest
 in the target.
 Signal that is greater means later.
 Therefore, any signal coming from the expression, that is greater than
 the latest signal in the target, is pushed to the target.
\end_layout

\begin_layout Paragraph*
Order Model
\end_layout

\begin_layout Standard
The default order model just based on the 
\emph on
visit time
\emph default
 of the DFS traversal, and is insufficient for visits caused from the same
 event (simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Therefore, RIVar is implemented as an observable of type named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 type represents timed information about a phenomenon 
\begin_inset CommandInset citation
LatexCommand cite
key "priemer1991introductory"
literal "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IComparable}
\end_layout

\end_inset

 interface to abstract items that can be compared beween each other.
 Each signal (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

's instance) contains an array of timestamps that are used in comparisons.
\end_layout

\begin_layout Paragraph*
Operators
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 produce verbose syntax in building FRP applications 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Furthermore, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 operaotr uses the default order model.
\end_layout

\begin_layout Standard
Therefore, we developed 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 function, to lift functions over values to functions over RIVars (implemented
 as observable streams).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 has two overloads that are wrapper functions to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

.
 The one that wraps 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, before calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, filters out values that are less updated than their previous values.
\end_layout

\begin_layout Section
Additions and Usage
\end_layout

\begin_layout Standard
The model can completely be implemented and used by the ReactiveX types
 with some extensions described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 However, to get it more user friendly, we added the type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

 to be used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "false"
noprefix "false"

\end_inset

 presents a basic unittest to RIVarX to the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:instanceFirst,line:instanceSecond,line:instanceLast}
\end_layout

\end_inset

 initiate 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X},
\backslash
lstinline{Y} and 
\backslash
lstinline{Z}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:functionOverValues}
\end_layout

\end_inset

 defines the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{+}
\end_layout

\end_inset

 over values.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:Set}
\end_layout

\end_inset

 lifts the function to be applied on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y} and 
\backslash
lstinline{Z}
\end_layout

\end_inset

 and set it to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:setInputFirst}-line~
\backslash
ref{line:setInputLast}
\end_layout

\end_inset

 produce inputs like 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y=2} and 
\backslash
lstinline{Z=3}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 triggers the value 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{5}
\end_layout

\end_inset

.
 This is verified by the subscription in 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:subscribe}
\end_layout

\end_inset

, variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{result}
\end_layout

\end_inset

 declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:declareResult}
\end_layout

\end_inset

, is updated to the value pushed by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset

 and then verified in 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:checkResult}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

[TestMethod]
\end_layout

\begin_layout Plain Layout

public void SimpleUsage()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    //Construction
\end_layout

\begin_layout Plain Layout

    int result = 0;|
\backslash
label{line:declareResult}|
\end_layout

\begin_layout Plain Layout

    var X = new RIVar<int>();|
\backslash
label{line:instanceFirst}|
\end_layout

\begin_layout Plain Layout

    var Y = new RIVar<int>();|
\backslash
label{line:instanceSecond}|
\end_layout

\begin_layout Plain Layout

    var Z = new RIVar<int>();|
\backslash
label{line:instanceLast}|
\end_layout

\begin_layout Plain Layout

    Func<int, int, int> plus = (op1, op2) => op1 + op2;|
\backslash
label{line:functionOverValues}|
\end_layout

\begin_layout Plain Layout

    X.Set(plus.Lift(Y, Z));|
\backslash
label{line:Set}|
\end_layout

\begin_layout Plain Layout

    X.Subscribe(new observer<int>(i => { result = i; }));|
\backslash
label{line:subscribe}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Action
\end_layout

\begin_layout Plain Layout

    Y.OnNext(2);|
\backslash
label{line:setInputFirst}|
\end_layout

\begin_layout Plain Layout

    Z.OnNext(3);|
\backslash
label{line:setInputLast}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Test
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(5, result);|
\backslash
label{line:checkResult}|         
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Using-RIVarX"

\end_inset

Using RIVarX
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Standard
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 We reached the goal, that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

's instance does not aware of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unit-Test"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the existence of 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 does not change the behavior.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Unit-Test"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}' instance
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
