#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
With the solution for addressing unexpected feedback loops (as presented
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

), it becomes possible to introduce a new variant for FRP into the framework
 outlined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 This new variant builds upon the model of observable streams described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Not only are the variables considered as observable streams, but also the
 operators.
 Furthermore, the assignment operation is implemented as a method that generates
 observations to push to the target variable.
 Therefore, the variables implemented as 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 that is an observer, in addition to being an observable.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the expression 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 implies that the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x)=x+1}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 observes the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 The established connections are then used to the change propagation for
 connected UI fields (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Subscriptions created by components involved in the formula 
\begin_inset Formula $\LSTINLINE{A:B+1}$
\end_inset

.
\end_layout

\end_inset

Subscriptions created by components involved in the formula 
\begin_inset Formula $\LSTINLINE{A:B+1}$
\end_inset

.
 The sequence diagram illustrates interaction between the components in
 creating the subscriptions.
 the 
\begin_inset Formula $\LSTINLINE +$
\end_inset

 observes 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 observes 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x)=x+1}$
\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{next(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{next(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{next(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{next(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{next(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propogation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propogation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the formula, utilizing the 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This allows operations to handle unexpected feedback and glitches through
 the filtering mechanism proposed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For instance, an binary operators like 
\begin_inset Formula $\LSTINLINE +$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x,y)=x+y}$
\end_inset

) subscribes to the streams of the two operands, discarding values in each
 stream that are not greater than the previous value.
 The assignment operation subscribes to the streams of the left and right
 hands, which consist of the formulas, and compares the values from the
 two streams.
 If the value in the right-hand stream is greater, it is pushed into the
 variable in the left-hand stream.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The operations only allow values to pass through if they are greater than
 the previous value.
 This ensures that only meaningful updates propagate.
 In the context of feedback loops, this prevents unintended feedback by
 discarding values that are not greater than the previous value, thereby
 breaking the loop.
 Glitches are also managed, as the operation does not pass temporary inconsisten
cies that depend on stale values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Handling unexpected feedback and glitches becomes possible through the filtering
 mechanism proposed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The operations only allow values to pass through if they are greater than
 the previous value.
 This approach ensures that only meaningful updates propagate.
 In the context of feedback loops, the merge operation prevents unintended
 feedback by discarding values that are not greater than the previous value,
 thereby breaking the loop.
 Glitches are also managed, as the operation does not pass temporary inconsisten
cies, because they depend on stale values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
we find a similarly to other operators in consolidating multiple streams
 into a single stream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation operates similarly to other operators that consolidate multiple
 streams into a single stream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
The operations, before they pass each value, they compare it against the
 previous.
 Only if the value is 
\end_layout

\begin_layout Plain Layout
, that other operations that It produces a single stream from more than
 one stream.
 And the unexpected feedbacl loop becomes similar to the glitch issue.
 As a condition to pass a notification, they compare it against the previous.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
We implement a synchronous model, similar to the description in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, by the model of observable streams described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with values notifications that contain the timestamps sets.
 This produces a new variant of FRP where formulas create subscriptions
 to establish connections between the formulas' components for the change
 propagation.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the expression 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 implies that the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x)=x+1}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the assignment operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 observes the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 and finaly 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 observes the assignment operator.
 The established connections are then used to the change propogation for
 connected UI fields (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Plain Layout
The assignment operator is different than the traditional FRP.
 In the functional paradigm, from which FRP is derived, the assignment defined
 the unambiguously linkage between the name and the function body.
\end_layout

\begin_layout Plain Layout
Unlike the traditional FRP (as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Reactive-Variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the variable is not defined by its expression.
 The assignment operator subscribes
\end_layout

\begin_layout Plain Layout
The assignment operator is different than the traditional FRP.
 Unlike the traditional FRP (as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Reactive-Variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the variable is not defined by its expression.
 Instead, an assignment is a subscription.
 As a result, variables can have several assignments.
 As described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the variables need that assignments are enabled from outside of the objects.
 The formulas' components are observers and observable streams.
 Each variable pass notifications from its observations, producing a merged
 stream from the inputs and streams that the variable is subscribed to.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-merge-produce-concurrent-events"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is expected that the issue of unexpected feedback loop be handled in
 the merge operation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
We implement values as notifications containing the timestamps, and they
 are used to compare, as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, each notification with its previous.
\end_layout

\begin_layout Plain Layout
In order that the only newer values will propogate, we use notifications
 with timestamps to be populated through observable streams, which 
\end_layout

\begin_layout Plain Layout
The framework is implemented based on OOP, and the concept of observable
 streams.
 It consists of a new variant of FRP that handle the unexpected feedback
 loop as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The new variant of FRP uses objects and are also hosted within objects,
 as designed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
The Assignment Operator
\end_layout

\begin_layout Plain Layout
An assignment statement means an observation.
 The assignment is an operation that the left side variable subscribes to
 the expression.
 Unlike the traditional FRP (as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Reactive-Variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the variable is not defined by its expression.
 As an assignment is subscription, variables can have several assignments,
 as required in the framework.
 As described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the variables need that assignments are enabled from outside of the objects.
 The formulas' components are observers and observable streams.
 Each variable pass notifications from its observations, producing a merged
 stream from the streams that the variable is subscribed to.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-merge-produce-concurrent-events"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the merge operation, the unexpected feedback loop should be handled.
 
\end_layout

\begin_layout Plain Layout
The notifications contain the timestamps, and they are used to compare,
 as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, each notification with its previous.
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
The formulas in the new variant create subscriptions to establish connections
 between formulas' components for the change propagation.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the expression 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 implies that the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x)=x+1}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the assignment operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 observes the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 and finaly 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 observes the assignment operator.
 The established connections are then used to the change propogation for
 connected UI fields (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Plain Layout
Each variable pass notifications from its observations, producing a merged
 stream from the streams that the variable is subscribed to.
 
\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
In the new variant, variables and building blocks are treated as observers
 and observable streams (as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 As observables streams, the components involved in the formulas create
 subscriptions to establish connections for change propagation.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the expression 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 implies that the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing the function 
\begin_inset Formula $\LSTINLINE{f(x)=x+1}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the assignment operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 observes the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 and finaly 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 observes the assignment operator.
 The established connections are then used to the change propogation for
 connected UI fields (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Plain Layout
The concept that the assignment behaves as an observable, makes the new
 variant different from the traditional FRP (as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Reactive-Variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Because the variable stopped from being defined by its expression.
 Instead, the variable is an observable that pass notifications from its
 observations.
 The passed notifications produces a merged stream from the streams that
 the variable is subscribed to.
 
\end_layout

\begin_layout Plain Layout
In addition, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-merge-produce-concurrent-events"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the merge operation need to handle the unexpected feedback loop.
 The notifications contain the timestamps, and they are used to compare,
 as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, each notification with its previous.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
..
\end_layout

\begin_layout Chapter
Old
\end_layout

\begin_layout Plain Layout
In this section, we will delve into the implementation details of our approach.
 We leverage existing elements from ReactiveX as the foundation and introduce
 only a few additional components to bridge the remaining gap.
 These components include the RIVar and Signal classes, along with the Lift
 function.
 By incorporating these elements, we have successfully developed concrete
 libraries that demonstrate the feasibility and effectiveness of our approach.
\end_layout

\begin_layout Section
Required Elements from ReactiveX
\end_layout

\begin_layout Plain Layout
ReactiveX, available in languages like C# and JavaScript through frameworks
 like RxJS, provides observable streams that can be used as reactive instance
 variables.
 It offers useful operators such as Select (or map in JavaScript) and CombineLat
est for implementing latent variables.
 By default, values are synchronously pushed to subscribers, following the
 required push model.
 This makes it easy to develop Functional Reactive Programming (FRP) application
s.
 To illustrate this, consider the example of an FRP application with the
 statements B:=D+1 and A:=B+C.
 These statements can be implemented in ReactiveX as B=D.Select(x=>x+1) and
 A=B.CombineLatest(C,(x,y)=>x+y).
\end_layout

\begin_layout Plain Layout
ReactiveX also offers the merge function, which combines multiple streams
 into a single stream.
 It takes multiple source observables, subscribes to all of them, and forwards
 the emitted values from each stream into a single output observable.
 This operator follows a functional approach.
 We will use an alterantive approach.
 we achieve the same behavior imperatively, by using a Subject.
 In this approach, you create a Subject and call onNext on the subject to
 emit values from the various streams.
\end_layout

\begin_layout Section
Identifying Gaps and Challenges
\end_layout

\begin_layout Plain Layout
Despite the functionality provided by ReactiveX, there are several remaining
 issues that need to be addressed.
 Firstly, the order model must be considered.
 In cases where a node has an output stream constructed with multiple input
 streams, there is a possibility of stale values.
 This necessitates handling CombineLatest and merge to exclude stale values.
 Secondly, The default assignment copies values bit by bit, instead we need
 the custom assignment operators, that are based on the merge operation.
 Lastly, lift operations need to be taken into account.
 The verbose syntax produced by Select and CombineLatest in building FRP
 applications can be mitigated.
 However, the primary reason for not using Select and CombineLatest directly
 is to address the issue of stale values.
\end_layout

\begin_layout Section
Bridging the Gap
\end_layout

\begin_layout Plain Layout
To address the required functionality and overcome the gaps in ReactiveX,
 two data types are introduced: RIVar and Signal.
 RIVar is derived from Subject and serves as the carrier for signals.
 Each item in the stream is treated as a distinct signal, analogous to individua
l elements in a list.
 Just as a list comprises multiple elements, the stream contains multiple
 signals, where each signal represents a specific value.
\end_layout

\begin_layout Plain Layout
To handle the ordering of signals and identify stale ones, we establish
 a static, strictly increasing number.
 When creating a new signal, it can be assigned a number that corresponds
 to its time or order relative to other signals.
 Additionally, new signals can be derived from existing signals, inheriting
 a set of timestamps from their source signals.
 These timestamps associated with the signals play a crucial role in establishin
g the order among signals and identifying any stale ones.
\end_layout

\begin_layout Plain Layout
We also provide a lift function and the Set method.
 The lift function, lift function over values to function over RIVars.
 The Set method, facilitates RIVar objects, to be asked to assign calculations.
 The two functions need to not pass stale values, that are propogating to
 them.
 The Set method execution contributes to the merge of its variable.
 The Set method pass the signals by imperatively calls the OnNext.
 In order to not pass the stale values, it subscribes to the two streams,
 and compare incoming signals against the previous publshued signal.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Using RIVarX
\end_layout

\begin_layout Plain Layout
The interface provided by RIVarX uses ReactiveX combined with the new implemente
d interface.
 The new type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

, in addition to the operations introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:The-Main-Features"
plural "false"
caps "true"
noprefix "false"

\end_inset

, has the observation operations, because it implements an interface named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ISubject}
\end_layout

\end_inset

 derived from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObserver}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObservable}
\end_layout

\end_inset

.
 A complete usage example is listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

 in the form of a unit test.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

[TestMethod]
\end_layout

\begin_layout Plain Layout

public void SimpleUsage()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    //Construction
\end_layout

\begin_layout Plain Layout

    int result = 0;|
\backslash
label{line:declareResult}|
\end_layout

\begin_layout Plain Layout

    var X = new RIVar<int>();|
\backslash
label{line:instanceFirst}|
\end_layout

\begin_layout Plain Layout

    var Y = new RIVar<int>();|
\backslash
label{line:instanceSecond}|
\end_layout

\begin_layout Plain Layout

    var Z = new RIVar<int>();|
\backslash
label{line:instanceLast}|
\end_layout

\begin_layout Plain Layout

    Func<int, int, int> plus = (op1, op2) => op1 + op2;|
\backslash
label{line:functionOverValues}|
\end_layout

\begin_layout Plain Layout

    X.Set(plus.Lift(Y, Z));|
\backslash
label{line:Set}|
\end_layout

\begin_layout Plain Layout

    X.Subscribe(new observer<int>(i => { result = i; }));|
\backslash
label{line:subscribe}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Action
\end_layout

\begin_layout Plain Layout

    Y.OnNext(2);|
\backslash
label{line:setInputFirst}|
\end_layout

\begin_layout Plain Layout

    Z.OnNext(3);|
\backslash
label{line:setInputLast}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Test
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(5, result);|
\backslash
label{line:checkResult}|         
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Using-RIVarX"

\end_inset

Using RIVarX
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Declaring RIVars
\end_layout

\begin_layout Plain Layout
RIVars are declared parameterized with the type of values it should contain,
 as in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
cref{line:instanceFirst,line:instanceSecond,line:instanceLast})
\end_layout

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Functions over RIVars
\end_layout

\begin_layout Plain Layout
The developer needs to implement the function over values, and then lift
 it to be over RIVars.
 For example, the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus}
\end_layout

\end_inset

 specified in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:functionOverValues}
\end_layout

\end_inset

 is lifted to be over RIVars 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

 by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus.Lift(Y, Z)}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method returns an expression to be assigned.
\end_layout

\begin_layout Paragraph
Assigning
\end_layout

\begin_layout Plain Layout
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is used for assignments.
 The argument is of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Expression}
\end_layout

\end_inset

 produced by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method.
 Consequently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:Set}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Providing input
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y=2}
\end_layout

\end_inset

 is implemented by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y.OnNext(2)}
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:setInputFirst,line:setInputLast}
\end_layout

\end_inset

)
\end_layout

\begin_layout Paragraph
Get the output
\end_layout

\begin_layout Plain Layout
RIVars are observed to get its value's changes by calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Subscribe}
\end_layout

\end_inset

.
 In the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we update a local variable with the observed value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:subscribe}
\end_layout

\end_inset

) to verify it againt the expected value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:checkResult}
\end_layout

\end_inset

).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
rivarjs
\end_layout

\begin_layout Plain Layout
To incorporate the rivarjs library into a web form, all that is required
 of the developer is to add script tags to the HTML file.
 Firstly, the rxjs library on which rivarjs depends should be added, similar
 to how RVIarX depends on ReactiveX.
 Secondly, rivarjs itself should be added as our implemented library.
 Lastly, the custom script that utilizes the framework should be added.
\end_layout

\begin_layout Plain Layout
The library is in line with our proposed framework.
 In modern versions of JavaScript (ES6), developers have the ability to
 create classes and subclasses but interfaces are not supported.
 As a workaround, developers can set the RIVars of an object depending on
 the dynamic nature of the language.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
