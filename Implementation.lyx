#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
In this section, we will delve into the implementation details of our approach.
 We leverage existing elements from ReactiveX as the foundation and introduce
 only a few additional components to bridge the remaining gap.
 These components include the RIVar and Signal classes, along with the Lift
 function.
 By incorporating these elements, we have successfully developed concrete
 libraries that demonstrate the feasibility and effectiveness of our approach.
\end_layout

\begin_layout Section
Required Elements from ReactiveX
\end_layout

\begin_layout Standard
ReactiveX, available in languages like C# and JavaScript through frameworks
 like RxJS, provides observable streams that can be used as reactive instance
 variables.
 It offers useful operators such as Select (or map in JavaScript) and CombineLat
est for implementing latent variables.
 By default, values are synchronously pushed to subscribers, following the
 required push model.
 This makes it easy to develop Functional Reactive Programming (FRP) application
s.
 To illustrate this, consider the example of an FRP application with the
 statements B:=D+1 and A:=B+C.
 These statements can be implemented in ReactiveX as B=D.Select(x=>x+1) and
 A=B.CombineLatest(C,(x,y)=>x+y).
\end_layout

\begin_layout Standard
ReactiveX also offers the merge function, which combines multiple streams
 into a single stream.
 It takes multiple source observables, subscribes to all of them, and forwards
 the emitted values from each stream into a single output observable.
 This operator follows a functional approach.
 We will use an alterantive approach.
 we achieve the same behavior imperatively, by using a Subject.
 In this approach, you create a Subject and call onNext on the subject to
 emit values from the various streams.
\end_layout

\begin_layout Section
Identifying Gaps and Challenges
\end_layout

\begin_layout Standard
Despite the functionality provided by ReactiveX, there are several remaining
 issues that need to be addressed.
 Firstly, the order model must be considered.
 In cases where a node has an output stream constructed with multiple input
 streams, there is a possibility of stale values.
 This necessitates handling CombineLatest and merge to exclude stale values.
 Secondly, The default assignment copies values bit by bit, instead we need
 the custom assignment operators, that are based on the merge operation.
 Lastly, lift operations need to be taken into account.
 The verbose syntax produced by Select and CombineLatest in building FRP
 applications can be mitigated.
 However, the primary reason for not using Select and CombineLatest directly
 is to address the issue of stale values.
\end_layout

\begin_layout Section
Bridging the Gap
\end_layout

\begin_layout Standard
To address the required functionality and overcome the gaps in ReactiveX,
 two data types are introduced: RIVar and Signal.
 RIVar is derived from Subject and serves as the carrier for signals.
 Each item in the stream is treated as a distinct signal, analogous to individua
l elements in a list.
 Just as a list comprises multiple elements, the stream contains multiple
 signals, where each signal represents a specific value.
\end_layout

\begin_layout Standard
To handle the ordering of signals and identify stale ones, we establish
 a static, strictly increasing number.
 When creating a new signal, it can be assigned a number that corresponds
 to its time or order relative to other signals.
 Additionally, new signals can be derived from existing signals, inheriting
 a set of timestamps from their source signals.
 These timestamps associated with the signals play a crucial role in establishin
g the order among signals and identifying any stale ones.
\end_layout

\begin_layout Standard
We also provide a lift function and the Set method.
 The lift function, lift function over values to function over RIVars.
 The Set method, facilitates RIVar objects, to be asked to assign calculations.
 The two functions need to not pass stale values, that are propogating to
 them.
 The Set method execution contributes to the merge of its variable.
 The Set method pass the signals by imperatively calls the OnNext.
 In order to not pass the stale values, it subscribes to the two streams,
 and compare incoming signals against the previous publshued signal.
 
\end_layout

\begin_layout Section
Implemented Libraries
\end_layout

\begin_layout Standard
We have successfully developed two lightweight libraries, RIVarX for C#
 developers and rivarjs for JavaScript (ES6) developers, with the aim of
 facilitating separated data dependencies management for user interfaces.
\end_layout

\begin_layout Paragraph
RIVarX (C#)
\end_layout

\begin_layout Standard
RIVarX is a .NET library designed specifically for C# developers.
 It provides the capability to expose RIVars in classes and interfaces and
 allows for the assignment of calculations to them.
 This enables the creation of loosely coupled components with separated
 data dependencies.
 The library is publicly available on GitHub at
\begin_inset Flex URL
status open

\begin_layout Plain Layout

 https://github.com/RivkaAltshuler/RIVar
\end_layout

\end_inset

 and can be easily downloaded through the NuGet package manager at
\begin_inset Flex URL
status open

\begin_layout Plain Layout

 https://www.nuget.org/packages/RIVar.RIVarX
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
rivarjs (JavaScript)
\end_layout

\begin_layout Standard
To ensure wider adoption and cater to the vast JavaScript community, we
 have implemented the same approach in JavaScript (ES6) and released it
 as the rivarjs library.
 JavaScript has a thriving open-source ecosystem, making it an ideal platform
 for publishing and evaluating libraries.
 Additionally, since front-end development predominantly utilizes JavaScript,
 this library is specifically designed for front-end applications.
 You can access the rivarjs library on npm at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
By implementing these two libraries, we have showcased the viability of
 our approach and demonstrated its seamless integration into different programmi
ng languages.
 Leveraging the popularity of reactive extensions, which are widely embraced
 in modern programming paradigms, we have successfully developed RIVarX
 for C# developers and rivarjs for JavaScript developers.
 This highlights the versatility of our approach and paves the way for its
 adoption in other object-oriented languages that support reactive extensions.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Using RIVarX
\end_layout

\begin_layout Plain Layout
The interface provided by RIVarX uses ReactiveX combined with the new implemente
d interface.
 The new type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

, in addition to the operations introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:The-Main-Features"
plural "false"
caps "true"
noprefix "false"

\end_inset

, has the observation operations, because it implements an interface named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ISubject}
\end_layout

\end_inset

 derived from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObserver}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObservable}
\end_layout

\end_inset

.
 A complete usage example is listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

 in the form of a unit test.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

[TestMethod]
\end_layout

\begin_layout Plain Layout

public void SimpleUsage()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    //Construction
\end_layout

\begin_layout Plain Layout

    int result = 0;|
\backslash
label{line:declareResult}|
\end_layout

\begin_layout Plain Layout

    var X = new RIVar<int>();|
\backslash
label{line:instanceFirst}|
\end_layout

\begin_layout Plain Layout

    var Y = new RIVar<int>();|
\backslash
label{line:instanceSecond}|
\end_layout

\begin_layout Plain Layout

    var Z = new RIVar<int>();|
\backslash
label{line:instanceLast}|
\end_layout

\begin_layout Plain Layout

    Func<int, int, int> plus = (op1, op2) => op1 + op2;|
\backslash
label{line:functionOverValues}|
\end_layout

\begin_layout Plain Layout

    X.Set(plus.Lift(Y, Z));|
\backslash
label{line:Set}|
\end_layout

\begin_layout Plain Layout

    X.Subscribe(new observer<int>(i => { result = i; }));|
\backslash
label{line:subscribe}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Action
\end_layout

\begin_layout Plain Layout

    Y.OnNext(2);|
\backslash
label{line:setInputFirst}|
\end_layout

\begin_layout Plain Layout

    Z.OnNext(3);|
\backslash
label{line:setInputLast}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Test
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(5, result);|
\backslash
label{line:checkResult}|         
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Using-RIVarX"

\end_inset

Using RIVarX
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Declaring RIVars
\end_layout

\begin_layout Plain Layout
RIVars are declared parameterized with the type of values it should contain,
 as in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
cref{line:instanceFirst,line:instanceSecond,line:instanceLast})
\end_layout

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Functions over RIVars
\end_layout

\begin_layout Plain Layout
The developer needs to implement the function over values, and then lift
 it to be over RIVars.
 For example, the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus}
\end_layout

\end_inset

 specified in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:functionOverValues}
\end_layout

\end_inset

 is lifted to be over RIVars 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

 by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus.Lift(Y, Z)}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method returns an expression to be assigned.
\end_layout

\begin_layout Paragraph
Assigning
\end_layout

\begin_layout Plain Layout
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is used for assignments.
 The argument is of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Expression}
\end_layout

\end_inset

 produced by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method.
 Consequently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:Set}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Providing input
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y=2}
\end_layout

\end_inset

 is implemented by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y.OnNext(2)}
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:setInputFirst,line:setInputLast}
\end_layout

\end_inset

)
\end_layout

\begin_layout Paragraph
Get the output
\end_layout

\begin_layout Plain Layout
RIVars are observed to get its value's changes by calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Subscribe}
\end_layout

\end_inset

.
 In the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we update a local variable with the observed value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:subscribe}
\end_layout

\end_inset

) to verify it againt the expected value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:checkResult}
\end_layout

\end_inset

).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
rivarjs
\end_layout

\begin_layout Plain Layout
To incorporate the rivarjs library into a web form, all that is required
 of the developer is to add script tags to the HTML file.
 Firstly, the rxjs library on which rivarjs depends should be added, similar
 to how RVIarX depends on ReactiveX.
 Secondly, rivarjs itself should be added as our implemented library.
 Lastly, the custom script that utilizes the framework should be added.
\end_layout

\begin_layout Plain Layout
The library is in line with our proposed framework.
 In modern versions of JavaScript (ES6), developers have the ability to
 create classes and subclasses but interfaces are not supported.
 As a workaround, developers can set the RIVars of an object depending on
 the dynamic nature of the language.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
