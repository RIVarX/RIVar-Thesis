#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Section
RIVarX
\end_layout

\begin_layout Standard
In this section, we present an implementation of the model described in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a lightweight .NET library for C# developers named RIVarX.
 The library is available on GitHub at https://github.com/RivkaAltshuler/RIVar
 and can also be downloaded from the NuGet package manager at https://www.nuget.or
g/packages/RIvar.RIvarX.
 RIVarX is based on ReactiveX and provides C# developers with a simple way
 to implement reactive variables in their projects.
\end_layout

\begin_layout Standard
When implementing RIVarX, we started from adding extensions methods to existing
 types of ReactiveX.
 The model can be fully implemented by only add extensions.
 Only to provide a more user friendly syntax, we defined the class named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

 providing this type explicity.
 The main features we developed are to provide our model.
 The features are: (1) assignment operator, (2) order model and (3) operators.
\end_layout

\begin_layout Subsection
ReactiveX
\end_layout

\begin_layout Standard
ReactiveX provides observable streams which has already been presented as
 being reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 ReactiveX has two useful operators to implement latent variables: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/map.html
\begin_inset ERT
status open

\begin_layout Plain Layout

(in other programming languages it is named 
\backslash
lstinline{map})
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/combinelatest.html
\end_layout

\end_inset

.
 The default behavior is that values are pushed to subscribers synchronously,
 just like the required push model.
 Consequently, FRP applications can be easily developed.
 For example, FRP application with the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=D+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 can be implemented by the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=D.Select(x=>x+1)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B.CombineLatest(C,(x,y)=>x+y))}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The framewrk has also the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{merge}
\end_layout

\end_inset

 that combines multiple streams into a single stream.
 It takes multiple source observables and subscribes to all of them, forwarding
 the emitted values from all of them into a single output observable.
 This is a functional operator.
 On the other hand, the same behavior can be imperatively achived by using
 a Subject and calling onNext on the subject to emit values from the various
 streams.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-Main-Features"

\end_inset

The Main Features
\end_layout

\begin_layout Paragraph*
Assignment Operator
\end_layout

\begin_layout Standard
The default assignment copies values bit by bit.
 Therefore, in the context of FRP applications, the assignment just makes
 the target variable to point on the constructed expressions, disconnecting
 from the old referenced expression if exists.
 The traditional assignment cannot be overriden, therefore RIVarX implements
 an alternative assignment function named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 uses the new approach to add the expression in addition to existing expressions.
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 method has two arguments: a reference to the target and the reference to
 the assigned expression.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is called, it subscribes to the two streams, so that for each signal from
 the assigned expression, it will compare to the signal produced latest
 in the target.
 Signal that is greater refers to a signal that is later.
 Therefore, any signal coming from the expression, that is greater than
 the latest signal in the target, is pushed to the target.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(That's correct.
 The merge operator is a functional operator that combines multiple streams
 into a single stream.
 It takes multiple source observables and subscribes to all of them, forwarding
 the emitted values from all of them into a single output observable.
 On the other hand, using a Subject to implement the same behavior is an
 imperative approach that involves calling onNext on the subject to emit
 values from the various streams, and then subscribing to the subject to
 receive the merged output.
\end_layout

\begin_layout Plain Layout
While both approaches can achieve the same result, the functional approach
 with merge is often preferred as it promotes a more declarative programming
 style and can simplify the code by abstracting away the low-level details
 of merging streams.)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Order Model
\end_layout

\begin_layout Standard
The default order model just based on the 
\emph on
visit time
\emph default
 of the DFS traversal, and is insufficient for visits caused from the same
 event (simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Therefore, RIVar is implemented as an observable of type named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 type represents timed information about a phenomenon 
\begin_inset CommandInset citation
LatexCommand cite
key "priemer1991introductory"
literal "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IComparable}
\end_layout

\end_inset

 interface to abstract items that can be compared beween each other.
 Each signal (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

's instance) contains an array of timestamps that are used in comparisons.
\end_layout

\begin_layout Paragraph*
Operators
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 produce verbose syntax in building FRP applications 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Furthermore, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 operaotr uses the default order model.
\end_layout

\begin_layout Standard
Therefore, we developed 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 function, to lift functions over values to functions over RIVars (implemented
 as observable streams).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 has two overloads that are wrapper functions to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

.
 The one that wraps 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, before calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, filters out values that are less updated than their previous values.
\end_layout

\begin_layout Subsection
Using RIVarX
\end_layout

\begin_layout Standard
The interface provided by RIVarX uses ReactiveX combined with the new implemente
d interface.
 The new type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

, in addition to the operations introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:The-Main-Features"
plural "false"
caps "true"
noprefix "false"

\end_inset

, has the observation operations, because it implements an interface named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ISubject}
\end_layout

\end_inset

 derived from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObserver}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObservable}
\end_layout

\end_inset

.
 A complete usage example is listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

 in the form of a unit test.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

[TestMethod]
\end_layout

\begin_layout Plain Layout

public void SimpleUsage()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    //Construction
\end_layout

\begin_layout Plain Layout

    int result = 0;|
\backslash
label{line:declareResult}|
\end_layout

\begin_layout Plain Layout

    var X = new RIVar<int>();|
\backslash
label{line:instanceFirst}|
\end_layout

\begin_layout Plain Layout

    var Y = new RIVar<int>();|
\backslash
label{line:instanceSecond}|
\end_layout

\begin_layout Plain Layout

    var Z = new RIVar<int>();|
\backslash
label{line:instanceLast}|
\end_layout

\begin_layout Plain Layout

    Func<int, int, int> plus = (op1, op2) => op1 + op2;|
\backslash
label{line:functionOverValues}|
\end_layout

\begin_layout Plain Layout

    X.Set(plus.Lift(Y, Z));|
\backslash
label{line:Set}|
\end_layout

\begin_layout Plain Layout

    X.Subscribe(new observer<int>(i => { result = i; }));|
\backslash
label{line:subscribe}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Action
\end_layout

\begin_layout Plain Layout

    Y.OnNext(2);|
\backslash
label{line:setInputFirst}|
\end_layout

\begin_layout Plain Layout

    Z.OnNext(3);|
\backslash
label{line:setInputLast}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Test
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(5, result);|
\backslash
label{line:checkResult}|         
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Using-RIVarX"

\end_inset

Using RIVarX
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Declaring RIVars
\end_layout

\begin_layout Standard
RIVars are declared parameterized with the type of values it should contain,
 as in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
cref{line:instanceFirst,line:instanceSecond,line:instanceLast})
\end_layout

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Functions over RIVars
\end_layout

\begin_layout Standard
The developer needs to implement the function over values, and then lift
 it to be over RIVars.
 For example, the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus}
\end_layout

\end_inset

 specified in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:functionOverValues}
\end_layout

\end_inset

 is lifted to be over RIVars 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

 by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus.Lift(Y, Z)}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method returns an expression to be assigned.
\end_layout

\begin_layout Paragraph
Assigning
\end_layout

\begin_layout Standard
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is used for assignments.
 The argument is of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Expression}
\end_layout

\end_inset

 produced by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method.
 Consequently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:Set}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Providing input
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y=2}
\end_layout

\end_inset

 is implemented by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y.OnNext(2)}
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:setInputFirst,line:setInputLast}
\end_layout

\end_inset

)
\end_layout

\begin_layout Paragraph
Get the output
\end_layout

\begin_layout Standard
RIVars are observed to get its value's changes by calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Subscribe}
\end_layout

\end_inset

.
 In the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we update a local variable with the observed value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:subscribe}
\end_layout

\end_inset

) to verify it againt the expected value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:checkResult}
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
rivarjs
\end_layout

\begin_layout Standard
To allow a wider adoption, we implemented the approach also in javascript,
 and published to npm as a library rivarjs available in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset

.
 We also published our case study (drug administration) that uses it, and
 it can be accessed at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation/
\end_layout

\end_inset

 .
 JavaScript has a large and active open source community, which makes it
 an attractive platform for publishing and evaluating libraries.
 in addition, the library is intended to be used in front-end applications,
 and the majority of front-end development is currently done using JavaScript.
\end_layout

\begin_layout Standard
To incorporate the rivarjs library into a web form, all that is required
 of the developer is to add script tags to the HTML file.
 Firstly, the rxjs library on which rivarjs depends should be added, similar
 to how RVIarX depends on ReactiveX.
 Secondly, rivarjs itself should be added as our implemented library.
 Lastly, the custom script that utilizes the framework should be added.
\end_layout

\begin_layout Standard
The library is designed to be user-friendly.
 rivarjs offers three main elements: RIVar, Signal, and lift.
 RIVar is a Subject from rxjs, which is extended by the Set method, used
 to connect calculations.
 The arguments for the calculation are actually the result of the lift function.
 This function takes a given function and lifts it to be over the next two
 RIVar arguments.
 The input elements are linked to the RIVars, and they necessitate event
 handlers to keep each other up to date on any changes.
\end_layout

\begin_layout Standard
The library is in line with our proposed framework.
 In modern versions of JavaScript (ES6), developers have the ability to
 create classes and subclasses but interfaces are not supported.
 As a workaround, developers can set the RIVars of an object depending on
 the dynamic nature of the language.
\end_layout

\end_body
\end_document
