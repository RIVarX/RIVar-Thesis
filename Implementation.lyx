#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
In this chapter, we present an implementation of the model described in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a lightweight .NET library for C# developers named RIVarX.
 The library is available on GitHub at https://github.com/RivkaAltshuler/RIVar
 and can also be downloaded from the NuGet package manager at https://www.nuget.or
g/packages/RIvar.RIvarX.
 RIVarX is based on ReactiveX and provides C# developers with a simple way
 to implement reactive variables in their projects.
\end_layout

\begin_layout Section
RIVarX
\end_layout

\begin_layout Standard
When implementing RIVarX, we started from adding extensions methods to existing
 types of ReactiveX.
 The model can be fully implemented by only add extensions.
 Only to provide a more user friendly syntax, we defined the class named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

 providing this type explicity.
 The main features we developed are to provide our model.
 The features are: (1) assignment operator, (2) order model and (3) operators.
\end_layout

\begin_layout Subsection
ReactiveX
\end_layout

\begin_layout Standard
ReactiveX provides observable streams which has already been presented as
 being reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 ReactiveX has two useful operators to implement latent variables: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/map.html
\begin_inset ERT
status open

\begin_layout Plain Layout

(in other programming languages it is named 
\backslash
lstinline{map})
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io/documentation/operators/combinelatest.html
\end_layout

\end_inset

.
 The default behavior is that values are pushed to subscribers synchronously,
 just like the required push model.
 Consequently, FRP applications can be easily developed.
 For example, FRP application with the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=D+1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 can be implemented by the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B=D.Select(x=>x+1)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B.CombineLatest(C,(x,y)=>x+y))}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-Main-Features"

\end_inset

The Main Features
\end_layout

\begin_layout Paragraph*
Assignment Operator
\end_layout

\begin_layout Standard
The default assignment copies values bit by bit.
 Therefore, in the context of FRP applications, the assignment just makes
 the target variable to point on the constructed expressions, disconnecting
 from the old referenced expression if exists.
 The traditional assignment cannot be overriden, therefore RIVarX implements
 an alternative assignment function named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 uses the new approach to add the expression in addition to existing expressions.
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 method has two arguments: a reference to the target and the reference to
 the assigned expression.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is called, it subscribes to the two streams, so that for each signal from
 the assigned expression, it will compare to the signal produced latest
 in the target.
 Signal that is greater refers to a signal that is later.
 Therefore, any signal coming from the expression, that is greater than
 the latest signal in the target, is pushed to the target.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(That's correct.
 The merge operator is a functional operator that combines multiple streams
 into a single stream.
 It takes multiple source observables and subscribes to all of them, forwarding
 the emitted values from all of them into a single output observable.
 On the other hand, using a Subject to implement the same behavior is an
 imperative approach that involves calling onNext on the subject to emit
 values from the various streams, and then subscribing to the subject to
 receive the merged output.
\end_layout

\begin_layout Plain Layout
While both approaches can achieve the same result, the functional approach
 with merge is often preferred as it promotes a more declarative programming
 style and can simplify the code by abstracting away the low-level details
 of merging streams.)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Order Model
\end_layout

\begin_layout Standard
The default order model just based on the 
\emph on
visit time
\emph default
 of the DFS traversal, and is insufficient for visits caused from the same
 event (simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Therefore, RIVar is implemented as an observable of type named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 type represents timed information about a phenomenon 
\begin_inset CommandInset citation
LatexCommand cite
key "priemer1991introductory"
literal "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IComparable}
\end_layout

\end_inset

 interface to abstract items that can be compared beween each other.
 Each signal (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Signal}
\end_layout

\end_inset

's instance) contains an array of timestamps that are used in comparisons.
\end_layout

\begin_layout Paragraph*
Operators
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 produce verbose syntax in building FRP applications 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Furthermore, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

 operaotr uses the default order model.
\end_layout

\begin_layout Standard
Therefore, we developed 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 function, to lift functions over values to functions over RIVars (implemented
 as observable streams).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 has two overloads that are wrapper functions to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Select}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

.
 The one that wraps 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, before calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{CombineLatest}
\end_layout

\end_inset

, filters out values that are less updated than their previous values.
\end_layout

\begin_layout Section
Using RIVarX
\end_layout

\begin_layout Standard
The interface provided by RIVarX uses ReactiveX combined with the new implemente
d interface.
 The new type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

, in addition to the operations introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:The-Main-Features"
plural "false"
caps "true"
noprefix "false"

\end_inset

, has the observation operations, because it implements an interface named
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ISubject}
\end_layout

\end_inset

 derived from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObserver}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IObservable}
\end_layout

\end_inset

.
 A complete usage example is listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

 in the form of a unit test.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

[TestMethod]
\end_layout

\begin_layout Plain Layout

public void SimpleUsage()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    //Construction
\end_layout

\begin_layout Plain Layout

    int result = 0;|
\backslash
label{line:declareResult}|
\end_layout

\begin_layout Plain Layout

    var X = new RIVar<int>();|
\backslash
label{line:instanceFirst}|
\end_layout

\begin_layout Plain Layout

    var Y = new RIVar<int>();|
\backslash
label{line:instanceSecond}|
\end_layout

\begin_layout Plain Layout

    var Z = new RIVar<int>();|
\backslash
label{line:instanceLast}|
\end_layout

\begin_layout Plain Layout

    Func<int, int, int> plus = (op1, op2) => op1 + op2;|
\backslash
label{line:functionOverValues}|
\end_layout

\begin_layout Plain Layout

    X.Set(plus.Lift(Y, Z));|
\backslash
label{line:Set}|
\end_layout

\begin_layout Plain Layout

    X.Subscribe(new observer<int>(i => { result = i; }));|
\backslash
label{line:subscribe}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Action
\end_layout

\begin_layout Plain Layout

    Y.OnNext(2);|
\backslash
label{line:setInputFirst}|
\end_layout

\begin_layout Plain Layout

    Z.OnNext(3);|
\backslash
label{line:setInputLast}|
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //Test
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(5, result);|
\backslash
label{line:checkResult}|         
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Using-RIVarX"

\end_inset

Using RIVarX
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Declaring RIVars
\end_layout

\begin_layout Standard
RIVars are declared parameterized with the type of values it should contain,
 as in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
cref{line:instanceFirst,line:instanceSecond,line:instanceLast})
\end_layout

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Functions over RIVars
\end_layout

\begin_layout Standard
The developer needs to implement the function over values, and then lift
 it to be over RIVars.
 For example, the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus}
\end_layout

\end_inset

 specified in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:functionOverValues}
\end_layout

\end_inset

 is lifted to be over RIVars 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset

 by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{plus.Lift(Y, Z)}
\end_layout

\end_inset

.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method returns an expression to be assigned.
\end_layout

\begin_layout Paragraph
Assigning
\end_layout

\begin_layout Standard
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Set}
\end_layout

\end_inset

 is used for assignments.
 The argument is of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Expression}
\end_layout

\end_inset

 produced by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Lift}
\end_layout

\end_inset

 method.
 Consequently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:Set}
\end_layout

\end_inset

 implements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X:=Y+Z}
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Providing input
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y=2}
\end_layout

\end_inset

 is implemented by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Y.OnNext(2)}
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:setInputFirst,line:setInputLast}
\end_layout

\end_inset

)
\end_layout

\begin_layout Paragraph
Get the output
\end_layout

\begin_layout Standard
RIVars are observed to get its value's changes by calling to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Subscribe}
\end_layout

\end_inset

.
 In the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Using-RIVarX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we update a local variable with the observed value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:subscribe}
\end_layout

\end_inset

) to verify it againt the expected value (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{line:checkResult}
\end_layout

\end_inset

).
 
\end_layout

\end_body
\end_document
