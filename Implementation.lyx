#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
This thesis includes two implementations: 
\family typewriter
RIVarX
\family default
 and 
\family typewriter
rivarjs
\family default
 that depend on Rx.
 
\family typewriter
RIVarX
\family default
 is a code library in the 
\family typewriter
C#
\family default
 programming language, while 
\family typewriter
rivarjs
\family default
 is its 
\family typewriter
JavaScript
\family default
 counterpart.
 For 
\family typewriter
RivarX
\family default
 that is in 
\family typewriter
C#
\family default
, it depends on 
\family typewriter
Rx.NET
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/dotnet/reactive
\end_layout

\end_inset


\end_layout

\end_inset


\family default
 and for 
\family typewriter
rivarjs
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/reactivex/rxjs
\end_layout

\end_inset


\end_layout

\end_inset


\family default
 that is in 
\family typewriter
JavaScript
\family default
 it depends on 
\family typewriter
RxJS
\family default
.
 These libraries provide a concrete implementation of the approach described
 in this thesis, demonstrating how reactive instance variables can be applied
 in practice.
 The source code for 
\family typewriter
RIVarX
\family default
 is available at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/RIVarCSharp
\end_layout

\end_inset

, while the source code for rivarjs can be found at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs
\end_layout

\end_inset

.
 The name difference is due to 
\family typewriter
npm
\family default
 (the 
\family typewriter
JavaScript
\family default
 package manager) only supporting lowercase names.
 These libraries provide the same functionality through a shared underlying
 implementation strategy but are tailored for their respective programming
 environments.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two libraries are short, therefore reflecting the simplicity of the
 approach.
 For example, the core of 
\family typewriter
rivarjs
\family default
 consists of three short files.
 The longest file contains 60 lines of code, including blank lines and comments.
 The other two files contain about 42 lines of code each.
 Based on these results, it is easy to assume that implementing the approach
 using streams is easy to perform in other environments and programming
 languages.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As part of the thesis, we implemented two similar libraries: 
\family typewriter
RIVarX
\family default
 in 
\family typewriter
C#
\family default
 and 
\family typewriter
rivarjs
\family default
 in 
\family typewriter
JavaScript
\family default

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
which are based on the 
\begin_inset Formula $Observable$
\end_inset

 approach provided by 
\family typewriter
ReactiveX
\family default
.
\end_layout

\end_inset

.
 The library 
\family typewriter
RIVarX
\family default
 depends on the library 
\family typewriter
Rx.Net
\family default
 (that implements 
\family typewriter
ReactiveX
\family default
) and 
\family typewriter
rivarjs
\family default
 depends on 
\family typewriter
RxJS
\family default
.
 In 
\family typewriter
rivarjs
\family default
, the core consists of three short files.
 The longest file contains 60 lines of code, including blank lines and comments.
 The other two files contain about 42 lines of code each.
 Based on these results, it is easy to assume that implementing the approach
 using streams is easy to perform in other environments and programming
 languages.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The stream abstraction refers to the observable streams presented in ReactiveX.
 A stream is an observable of a list of items.
 Subscribers get subscribe and be called whenever it has a new item.
 Reactive instance variable is a
\end_layout

\begin_layout Plain Layout
Reactive instance variables can be implemented using a 
\begin_inset Formula $Subject$
\end_inset

 in the following ways: (1) defining reactive instance variables as instances
 of 
\begin_inset Formula $Subject$
\end_inset

; (2) creating a class 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that inherits from 
\begin_inset Formula $Subject$
\end_inset

 (this is the approach used in 
\family typewriter
rivarjs
\family default
); and (3) creating a class 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that is a 
\emph on
decorator
\emph default
 of 
\begin_inset Formula $Subject$
\end_inset

 (this is the approach used in 
\family typewriter
RIVarX
\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The implementation strategy is based on fundamentals from 
\family typewriter
ReactiveX
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Observable streams
\emph default
 represent streams of values for implementing reactive instance variables
 and expressions.
\end_layout

\begin_layout Itemize

\emph on
Subjects
\emph default
, which are both observable and observer, are used to represent reactive
 instance variables.
\end_layout

\begin_layout Itemize
Value assignment messages are conveyed using the 
\emph on
OnNext
\emph default
 method.
\end_layout

\begin_layout Itemize
The 
\emph on
OnNext
\emph default
 method is also used to inform UI controls about their values.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Core Components
\end_layout

\begin_layout Standard
The core elements exposed to users in both the 
\family typewriter
C# 
\family default
and 
\family typewriter
Javascript
\family default
 implementations are:
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While the implementations are very similar, there are slight differences
 in naming conventions between 
\family typewriter
C#
\family default
 and 
\family typewriter
Javascript
\family default
.
 
\family typewriter
C#
\family default
 uses uppercase for the first letter of element names (e.g., 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

), while Javascript uses lowercase (e.g., 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

).
 Additionally, method names may differ slightly, such as 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\family typewriter
C#
\family default
 compared to 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 in 
\family typewriter
Javascript
\family default
.
 For simplicity, the 
\family typewriter
C#
\family default
 conventions will generally be used in this text.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 for creating ordered values.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 for building expressions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that represents reactive instance variable.
\end_layout

\begin_layout Standard
In 
\family typewriter
C#
\family default
, 
\begin_inset Formula $\LSTINLINE{Expression}$
\end_inset

 is an additional element exposed returned by 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

.
 This is because 
\family typewriter
C# 
\family default
is a typed language, and this element allows the system to work with type-safe
 expressions.
\end_layout

\begin_layout Subsection
Signal
\end_layout

\begin_layout Standard
A type 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is created to represent a value update.
 A 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 object contains a 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 field that holds the updated value.
 The 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 type is generic, where the type of 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 is determined only when a 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 instance (signal) is instantiated.
 A comparison function between a pair of 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 instances is implemented within the 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 class.
 In the 
\family typewriter
C#
\family default
 implementation, the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class also inherits from the 
\begin_inset Formula $\LSTINLINE{IComparable}$
\end_inset

 interface, and then the comparison function is the 
\begin_inset Formula $\LSTINLINE{CompareTo}$
\end_inset

 function of the interface.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{Signal}$

\end_inset

 class includes a field that stores an array of numeric values representing
 timestamps.
 The timestamps are determined by a static 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 variable.
 Each time a 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 instance representing an external event is created, the 
\begin_inset Formula $\LSTINLINE{Counter}$

\end_inset

variable is incremented by 
\begin_inset Formula $1$
\end_inset

, and the timestamp of the new signal is set to the updated 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 value.
 For this purpose, the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class has a constructor that takes the value as a parameter and initializes
 the timestamp array with a size of 
\begin_inset Formula $1$
\end_inset

, containing the new timestamp.
 For a computed value, there is an additional constructor that also takes
 an array of numbers representing the timestamps as a parameter.
 The set of timestamps for a computed signal is calculated by performing
 a union operation on the sets of timestamps of the values from which it
 is derived.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the 
\family typewriter
C#
\family default
 implementation of 
\family typewriter
RIVarX
\family default
, an implicit conversion operator is implemented, allowing automatic conversion
 between a value and a 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 containing that value.
 This enables the language to continue using regular values.
 Thus, for a reactive instance variable A, one can perform 
\begin_inset Formula $A.OnNext(3)$
\end_inset

 instead of 
\begin_inset Formula $A.OnNext(newSignal(3))$
\end_inset

.
 This capability is specific to typed languages.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For each reactive instance variable or an expression, there is a corresponding
 reactive stream of signals (i.e., 
\begin_inset Formula $\LSTINLINE{Observable}$
\end_inset

 that emit 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 instances).
 The signals sequence should be 
\emph on
monotonic
\emph default
, i.e., each signal is greater (according to the comparison defined between
 signals) than its predecessor.
 To address this, the extension method 
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 is defined.
 Given a stream 
\begin_inset Formula $\LSTINLINE X$
\end_inset

, one can use the expression 
\begin_inset Formula $\LSTINLINE{X.Monotonic()}$
\end_inset

 to obtain a monotonic stream.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 implementation uses operators named 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 operator facilitates the sequential processing of signals within a stream,
 enabling the execution of an operation on each signal relative to its predecess
or.
 For example (using an alphabetical order for the example), a stream 
\begin_inset Formula $A,B,C,D,E$
\end_inset

 after applying the 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 operator becomes 
\begin_inset Formula $A,B,C,C,E$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$
\end_inset

 operator removes consecutive duplicates from the stream, such as the consecutiv
e 
\begin_inset Formula $C$
\end_inset

's in the example in the example, such that after applying 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$

\end_inset

 the stream from the example becomes 
\begin_inset Formula $A,B,C,E$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This method discards each value that, when compared to its predecessor,
 is found to be smaller.
 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 operation ensures a monotonically increasing stream of signals, where each
 signal is "greater than" its predecessor according to the defined comparison
 function.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the present context, the operation will be:
\end_layout

\begin_layout Itemize

\series bold
Compare
\series default
: The current signal will be compared to the previous one using the comparison
 function.
 
\end_layout

\begin_layout Itemize

\series bold
Replacement
\series default
: If the current signal is not greater than the previous one (i.e., less than
 or equal to it according to the comparison function), it will be replaced
 with the previous signal.
 
\end_layout

\begin_layout Plain Layout
For example (using an alphabetical order for the example), a stream initialy
 is 
\begin_inset Formula $A,B,C,D,E$
\end_inset

.
 Then, After applying the 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 operator, the stream becomes: 
\begin_inset Formula $A,B,C,C,E$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The following example illustrates the application of the 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 operator on a stream of signals.
 For simplicity, each signal is represented by a Latin letter, and the alphabeti
cal order determines the comparison function (i.e., 
\begin_inset Formula $A<B<C<...$
\end_inset

).
 A stream initialy is 
\begin_inset Formula $A,B,C,D,E$
\end_inset

.
 Then, After applying the 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

 operator, the stream becomes: 
\begin_inset Formula $A,B,C,C,E$
\end_inset

, because signal 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is replaced by 
\begin_inset Formula $\LSTINLINE C$ 

\end_inset

 because 
\begin_inset Formula $\LSTINLINE D$ 

\end_inset

 precedes 
\begin_inset Formula $\LSTINLINE C$ 

\end_inset

 in the alphabetical order (
\begin_inset Formula $D<C$
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$
\end_inset

 operator removes consecutive duplicates from the stream.
 In our case, it is important because after 
\begin_inset Formula $\LSTINLINE{Scan}$
\end_inset

, there might be identical signals in a sequence (like 
\begin_inset Formula $C,C$
\end_inset

 in the example).
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
After applying 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$ 

\end_inset

 to the stream from the example, we get: 
\begin_inset Formula $A,B,C,E$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In summary, the 
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 operation implements the following algorithm:
\end_layout

\begin_layout Enumerate
Apply the 
\begin_inset Formula $\LSTINLINE{Scan}$ 

\end_inset

 operator to replace each "problematic" signal (one that is not greater
 than its predecessor according to the comparison function) with its predecessor
's signal.
 
\end_layout

\begin_layout Enumerate
Apply the 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$
\end_inset

 operator to remove consecutive duplicates that resulted from the replacement.
 
\end_layout

\begin_layout Enumerate
Return the monotonic stream.
 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 operation ensures a monotonically increasing stream of signals, where each
 signal is "greater than" its predecessor according to the defined comparison
 function.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
The implementation of the 
\begin_inset Formula $Monotonic$
\end_inset

 operation utilizes a straightforward combination of operators.
 Employing the 
\begin_inset Formula $\LSTINLINE{Scan}$ 

\end_inset

 operator, values are replaced with their preceding value if they are found
 to be smaller.
 For each value, a comparison is made with the value from the previous iteration.
 If the current value is greater, it is designated as the value for the
 subsequent iteration; otherwise, the value from the previous iteration
 is retained.
 The stream returned by the Scan operator is then subjected to the 
\begin_inset Formula $\LSTINLINE{DistinctUntilChanged}$ 

\end_inset

 operator, which ensures that consecutive items in the sequence are not
 repeated.
 This effectively removes the redundant items introduced by the Scan operator,
 which were intended to replace items smaller than their predecessors.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lift
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 takes reactive instance variables and a function over values as parameters
 and produces a corresponding stream.
 The name 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 conveys the resulted semantic meaning of raising the level of abstraction.
 For example, for reactive instance variables 
\begin_inset Formula $\LSTINLINE X$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE Y$
\end_inset

 in the 
\family typewriter
JavaScript
\family default
-based 
\family typewriter
rivarjs
\family default
, the expression 
\begin_inset Formula $\LSTINLINE{Lift((x,y)=>x*y,X,Y)}$
\end_inset

 is semantically equivalent to an expression 
\begin_inset Formula $\LSTINLINE{X*Y}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\family typewriter
ReactiveX
\family default
 utilizes operators on streams that are analogous to those required for
 reactive instance variables.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For creating expressions over reactive instance variables, operators are
 used similar to as in 
\family typewriter
ReactiveX
\family default
:
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

: Creates a new stream from two existing streams.
 Whenever a new item is received in either of the streams, 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 takes the latest item from each stream and produces a new item in the new
 stream, based on some computation.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{map}$
\end_inset

): Creates a new stream from an existing stream.
 For each item in the original stream, 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 performs some computation and produces a new item in the new stream, at
 the same time.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 function enables a higher level of abstraction for constructing expressions
 over reactive instance variables.
\end_layout

\end_inset

The implementation of 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 features the following characteristics:
\end_layout

\begin_layout Itemize
Stream handling is internal: streams are handled internally within the implement
ation.
 Usage does not require explicit knowledge or handling of streams, thus
 achieving a higher level of abstraction.
 
\end_layout

\begin_layout Itemize
Signal-based computation: When generating a computed value, a new signal
 is produced with the computed value and the corresponding timestamps.
\end_layout

\begin_layout Itemize
Monotonicity enforcement: The implementation ensures the monotonicity of
 the streams.
\end_layout

\begin_layout Subsection
RIVar
\end_layout

\begin_layout Standard
A reactive instance variable (RIVar) is implemented using 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 from Rx.
 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 represents both 
\begin_inset Formula $\LSTINLINE{Observable}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Observer}$
\end_inset

.
 As observable, it represents a stream of signals.
 The value assignment operation is represented by the 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 method.
 The implementation can be achieved through one of three approaches:
\end_layout

\begin_layout Itemize

\series bold
Direct Instantiation
\series default
: Declare reactive instance variables directly as instances of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Inheritance
\series default
: Create a class 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that inherits from 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

.
 This approach is used in 
\family typewriter
rivarjs
\family default
.
\end_layout

\begin_layout Itemize

\series bold
Decoration
\series default
: Create a class 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that acts as a decorator 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

 for 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

.
 This approach is used in 
\family typewriter
RIVarX
\family default
.
\end_layout

\begin_layout Standard
The reactive assignment is implemented as an operation named 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

.
 The implementation of the 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 operation varies, depending on how reactive instance variable is implemented
 using 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 as a subclass of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 (
\family typewriter
rivarjs
\family default
): 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 is a method within the 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 class.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 as a decorator of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 (
\family typewriter
RIVarX
\family default
): 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 is implemented as an extension function of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

.
\end_layout

\begin_layout Itemize
Reactive instance variables as direct instances of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

: 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 is likely a method of the 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 class itself.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Value assignment is represented by the 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 method.
 Reactive assignment is achieved by extending 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 with a 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 operation, implemented either as a method within the 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 class or as an extension function of 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

, depending on the specific 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 implementation.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 operation is designed to represent the reactive assignment operation.
 The operation should resemble a regular assignment statement: for a reactive
 instance variable 
\begin_inset Formula $\LSTINLINE X$ 

\end_inset

 and an expression 
\begin_inset Formula $Expression$
\end_inset

, the expression 
\begin_inset Formula $X.Set(Expression)$
\end_inset

 denotes 
\begin_inset Formula $X:=Expression$
\end_inset

.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(Given the three ways to implement reactive instance variables using 
\begin_inset Formula $Subject$
\end_inset

, the implementation of the 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 operation varies: (1) 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 as a subclass of 
\begin_inset Formula $Subject$
\end_inset

 (
\family typewriter
rivarjs
\family default
): 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 is a method within the 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 class.
 (2) 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 as a decorator of 
\begin_inset Formula $Subject$
\end_inset

 (
\family typewriter
RIVarX
\family default
): 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 is implemented as an extension function of 
\begin_inset Formula $Subject$
\end_inset

.
 (3) Reactive instance variables as direct instances of 
\begin_inset Formula $Subject$
\end_inset

: 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 is likely a method of the 
\begin_inset Formula $Subject$
\end_inset

 class itself.)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
When 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 is invoked, the argument contains a stream of signals (i.e., instances of
 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 class) representing the stream of expression values over time.
 The 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 operation triggers propagation from the argument stream to the stream of
 the reactive instance variable.
 The stream of a reactive instance variable is the 
\begin_inset Formula $Subject$
\end_inset

, and changes are propagated to it by invoking its 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 method.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 method is invoked when a signal is identified as being greater than all
 preceding signals in the Subject.
 To achieve this, a stream of changes is defined.
 This stream of changes is created using the 
\begin_inset Formula $\LSTINLINE{WithLatestFrom}$
\end_inset

 operator on both the 
\begin_inset Formula $Subject$
\end_inset

 stream and the expression stream.
 This operator produces a stream where, each time there is a new item in
 the expression stream, an item is created containing both this new item
 and the latest item from the Subject stream.
 For each such pair, a check is performed to determine if the signal from
 the expression is greater than the signal from the Subject.
 Whenever it is determined that the new signal is indeed greater, the 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 method is invoked with this signal.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 operation takes a stream of signals as an argument, representing the expression
 values over time.
 It propagates values from the input stream to the stream of the subject
 (i.e., the stream of the reactive instance variable).
 This is implemented by subscribing to the input stream, with a callback
 function that calls the subject's 
\begin_inset Formula $\LSTINLINE{OnNext}$

\end_inset

 method, in case that the new signal is greater than the previous one.
\end_layout

\begin_layout Standard
For example, consider a reactive instance variable 
\begin_inset Formula $\LSTINLINE X$

\end_inset

 set to 
\begin_inset Formula $\LSTINLINE{Y+Z}$

\end_inset

, where 
\begin_inset Formula $\LSTINLINE Y$

\end_inset

 and 
\begin_inset Formula $\LSTINLINE Z$

\end_inset

 are also reactive instance variables.
 The expression 
\begin_inset Formula $\LSTINLINE{X.Set(Y+Z)}$

\end_inset

 creates a stream of signals representing the values of 
\begin_inset Formula $\LSTINLINE{Y+Z}$

\end_inset

 over time.
 The 
\begin_inset Formula $\LSTINLINE{Set}$

\end_inset

 operation propagates these values to the stream of 
\begin_inset Formula $\LSTINLINE X$

\end_inset

 using its 
\begin_inset Formula $\LSTINLINE{OnNext}$

\end_inset

, but only when the expression 
\begin_inset Formula $\LSTINLINE{Y+Z}$

\end_inset

 produces a greater signal.
\end_layout

\begin_layout Standard
To ensure that 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 is invoked only for greater signals, a stream of changes is defined using
 the 
\begin_inset Formula $\LSTINLINE{WithLatestFrom}$
\end_inset

 operator.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://reactivex.io/documentation/operators/combinelatest.html
\end_layout

\end_inset


\end_layout

\end_inset

 This operator takes the subject stream and the expression stream as input
 and produces a new stream where each item is a pair containing the latest
 item from the subject stream (the current value of the variable) and the
 new item from the expression stream (the newly received value).
 For each pair, the new signal is compared with the previous signal.
 If the new signal is greater, then 
\begin_inset Formula $\LSTINLINE{OnNext}$

\end_inset

 is invoked with this signal.
\end_layout

\begin_layout Standard
To illustrate, suppose the subject stream contains the signals 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE C$

\end_inset

 (For the example, each signal is a single letter, and the comparison is
 alphabetical), and the expression stream emits signals 
\begin_inset Formula $\LSTINLINE B$

\end_inset

, 
\begin_inset Formula $\LSTINLINE D$

\end_inset

, and 
\begin_inset Formula $\LSTINLINE A$

\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{WithLatestFrom}$
\end_inset

 operator will produce a stream of pairs 
\begin_inset Formula $\left(B,C\right)$
\end_inset

, 
\begin_inset Formula $\left(D,C\right)$
\end_inset

, and 
\begin_inset Formula $\left(A,D\right)$
\end_inset

.
 For each pair, the first signal is compared to the second.
 In this case, 
\begin_inset Formula $\LSTINLINE B$

\end_inset

 is not greater than 
\begin_inset Formula $\LSTINLINE C$

\end_inset

, 
\begin_inset Formula $\LSTINLINE D$

\end_inset

 is greater than 
\begin_inset Formula $\LSTINLINE C$

\end_inset

, and 
\begin_inset Formula $\LSTINLINE A$

\end_inset

 is not greater than 
\begin_inset Formula $\LSTINLINE D$ 

\end_inset

.
 Therefore, only 
\begin_inset Formula $\LSTINLINE D$

\end_inset

 will trigger the invocation of 
\begin_inset Formula $\LSTINLINE{OnNext}$

\end_inset

 and be propagated further in the variable's stream.
\end_layout

\begin_layout Standard
This process ensures that 
\begin_inset Formula $\LSTINLINE{OnNext}$

\end_inset

 is invoked only for greater signals according to the comparison function,
 maintaining the desired monotonicity of the stream.
\end_layout

\begin_layout Section
Usage and Integration
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
TBD present two Drug Administration Implementations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
Drug Administration
\family default
 example served as a basis for testing both libraries.
 For each library implementation, there is code that creates Bag and Pump
 (the classes of 
\family typewriter
Drug Administration
\family default
 ) instances, populates its reactive instance variables with values, and
 verifies that these variables are updated as expected.
 This code utilizes automated testing frameworks (
\family typewriter
mstest
\family default
 for 
\family typewriter
C#
\family default
 and 
\family typewriter
mocha
\family default
 for 
\family typewriter
Javascript
\family default
).
 Furthermore, each implementation includes a fully functional 
\family typewriter
Drug Administration
\family default
 application available in the source code.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bag_code_csharp"
plural "false"
caps "true"
noprefix "false"

\end_inset

 shows a 
\family typewriter
C#
\family default
 class using 
\family typewriter
RIVarX
\family default
, and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bag_code_rivarjs"
plural "false"
caps "true"
noprefix "false"

\end_inset

 shows a 
\family typewriter
JavaScript
\family default
 class using 
\family typewriter
rivarjs
\family default
.
 In both examples, reactive instance variables are created by declaring
 instance variables of type 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 and initializing them.
 In both, the 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 method is used for reactive assignments.
 The 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 method is used inline in the 
\family typewriter
JavaScript
\family default
 implementation.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bag_code_csharp"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bag_code_rivarjs"
plural "false"
caps "true"
noprefix "false"

\end_inset

 present usages of 
\family typewriter
RIVarX
\family default
 and 
\family typewriter
rivarjs
\family default
 respectively.
 In the two usages reactive instance variables are created by declaring
 instance variables of type 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 and initializing them.
 In the two, the 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 method is used for reactive assignments.
 The 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 is used inline in one of the implementations.
\end_layout

\begin_layout Plain Layout
The reactive assignments are created by using 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{\text{l}ift}$
\end_inset

) and 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

) methods.
 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 functions over a simple function and the 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 instances.
 This expression is sent as an argument to the 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 function associated with a 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that represents the left-hand variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Classes with reactive instance variables and reactive assignments can be
 initiated and used by connecting to the reactive instance variables.
 For example, a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance can be created by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{const bag = new Bag()}$
\end_layout

\end_inset

.
 Later, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(new Signal(}$
\backslash
-$
\backslash
LSTINLINE{100))}$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.volume.next(new Signal(200))}$
\end_layout

\end_inset

 is like 
\begin_inset Formula $\LSTINLINE{bag.amount=100}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{bag.v}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{olume=200}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Explicit use of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 might be confusing.
 In the 
\family typewriter
C#
\family default
 implementation, an implicit conversion operator
\emph on

\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-
defined-conversion-operators
\end_layout

\end_inset


\end_layout

\end_inset


\emph default
 has been implemented within 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 for ease of use.
 Therefore, explicit use of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is not required.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(100)}$
\end_layout

\end_inset

 can be written instead of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(n}$
\backslash
-$
\backslash
LSTINLINE{ew Signal(100))}$
\end_layout

\end_inset

.
 The value 100 is automatically converted to a new signal.
 This simplifies the syntax and makes the code cleaner.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

import { RIVar, lift } from 'rivarjs';
\end_layout

\begin_layout Plain Layout

const div = (x, y) => (x / y).toFixed(2);
\end_layout

\begin_layout Plain Layout

const mul = (x, y) => x * y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Bag {
\end_layout

\begin_layout Plain Layout

  constructor() {
\end_layout

\begin_layout Plain Layout

    this.amount = new RIVar();
\end_layout

\begin_layout Plain Layout

    this.volume = new RIVar();
\end_layout

\begin_layout Plain Layout

    this.concentration = new RIVar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    this.concentration.set(lift(div, this.amount, this.volume));
\end_layout

\begin_layout Plain Layout

    this.amount.set(lift(mul, this.concentration, this.volume));
\end_layout

\begin_layout Plain Layout

    this.volume.set(lift(div, this.amount, this.concentration));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bag_code_rivarjs"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code of a class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
JavaScript
\family default
 and 
\family typewriter
rivarjs
\family default
.
\end_layout

\end_inset

Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
JavaScript
\family default
 and 
\family typewriter
rivarjs
\family default
.
 
\begin_inset Formula $\LSTINLINE{amount}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{concentration}$
\end_inset

 are reactive instance variables.
 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 is the reactive assignment operation.
 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 is an extension method for creating expressions.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

import { RIVar, lift } from 'rivarjs';
\end_layout

\begin_layout Plain Layout

    public class Bag: IBag
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Amount { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Volume { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Concentration { get; set; } = new RIVar<decimal>()
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public Bag()
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Concentration.Set(Amount.Div(Volume));
\end_layout

\begin_layout Plain Layout

            Amount.Set(Concentration.Mul(Volume));
\end_layout

\begin_layout Plain Layout

            Volume.Set(Amount.Div(Concentration));
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bag_code_csharp"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code of a class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and 
\family typewriter
RIVarX
\family default
.
\end_layout

\end_inset

Code of a class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and 
\family typewriter
RIVarX
\family default
.
 
\begin_inset Formula $\LSTINLINE{Amount}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 are reactive instance variables.
 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 is the reactive assignment operation.
 
\begin_inset Formula $\LSTINLINE{Div}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Mul}$
\end_inset

 are extension methods created by using 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public class Bag
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Amount { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Volume { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Concentration { get; set; } = new RIVar<decimal>()
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public Bag()
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Concentration.Set(Amount.Div(Volume));
\end_layout

\begin_layout Plain Layout

            Amount.Set(Concentration.Mul(Volume));
\end_layout

\begin_layout Plain Layout

            Volume.Set(Amount.Div(Concentration));
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   public static class Operators
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        static decimal DIVOverValues(decimal operand1, decimal operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            return operand1 / operand2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public static Expression<decimal> Div(this RIVar<decimal> operand1,
 RIVar<decimal> operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            return SignalExtension.Lift(DIVOverValues, operand1, operand2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public static Expression<decimal> Mul(this RIVar<decimal> operand1,
 RIVar<decimal> operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Func<decimal, decimal, decimal> mul = (x, y) => x * y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            return mul.Lift(operand1, operand2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bag_code_rivarx"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and 
\family typewriter
RIVarX
\family default
.
\end_layout

\end_inset

Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and RIVarX.
 
\begin_inset Formula $\LSTINLINE{Amount}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 are reactive instance variables.
 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 is the reactive assignment operation.
 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 is an method for creating expressions.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Usage in C#
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integration
\end_layout

\begin_layout Standard
Reactive instance variable has been implemented as observables, that are
 naturaly connected to UI elements.
 As an example, 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bind"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a function 
\begin_inset Formula $\LSTINLINE{bind}$
\end_inset

 in 
\family typewriter
Javascript
\family default
.
 The 
\begin_inset Formula $\LSTINLINE{bind}$
\end_inset

 function connects an input element to a reactive instance variable.
 The binding is bidirectional: Changes to the input value update the reactive
 instance variable.
 Changes to the reactive instance variable update the input value.
 The code uses 
\begin_inset Formula $\LSTINLINE{addEventListener}$
\end_inset

 to listen for input events, and subscribe to listen for changes to the
 reactive instance variable.
 Changing the input value via the reactive instance variable causes the
 font style to change to italic, to signal to the user that the value is
 derived from other values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

    function bind(inputID, variable) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      var input = document.getElementById(inputID);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      input.addEventListener('input', (event) => {
\end_layout

\begin_layout Plain Layout

        const value = event.target.value;
\end_layout

\begin_layout Plain Layout

        variable.next(new Signal(value));
\end_layout

\begin_layout Plain Layout

        input.style.fontStyle = "normal";
\end_layout

\begin_layout Plain Layout

      });
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      variable.subscribe((signal) => {
\end_layout

\begin_layout Plain Layout

        if (input.value !== signal.value.toString()) {
\end_layout

\begin_layout Plain Layout

          input.value = signal.value.toString();
\end_layout

\begin_layout Plain Layout

          input.style.fontStyle = "italic";
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      });
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bind"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Binding a Reactive Instance Variable to a UI Control.
\end_layout

\end_inset

 Binding a Reactive Instance Variable to a UI Control.
 The function connects an input element (such as a text box) to a reactive
 variable.
 The binding is bidirectional: (1) Changes to the input value update the
 reactive instance variable.(2) Changes to the reactive variable update the
 input value.
 Changing the input value via the reactive variable causes the font style
 to change to italic, to signal to the user that the value is derived from
 other values.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integration with 
\family typewriter
React
\end_layout

\begin_layout Standard
As part of the thesis, a 
\family typewriter
React
\family default
 component named 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 has been designed for being a UI component of a reactive instance variable.
 
\end_layout

\begin_layout Standard

\family typewriter
React
\family default
 is designed with a mechanism like reactive variables, where components
 are declared as functions.
 However, in 
\family typewriter
React
\family default
 there is a markup language like 
\family typewriter
XML
\family default
, that means like calling functions.
 An element name in the markup refers to a function name and while attribute
 names (named in 
\family typewriter
React
\family default
 as 
\family typewriter
props
\family default
) refers to named arguments.
 Additionally, nested elements within a component are passed to that component's
 function as another argument (named 
\family typewriter
children.
 
\end_layout

\begin_layout Standard
According to this explanation, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 is a function.
 It has an argument named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 for specifying the needed reactive instance variable, and also a nested
 function element that specifies the nested UI element as a function of
 a varying value and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 function.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={x}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview-2-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code Example of 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in a 
\family typewriter
React
\family default
 Application.
\end_layout

\end_inset

Code Example of 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in a 
\family typewriter
React
\family default
 Application.
 This code snippet demonstrates how to use the RIVarView component to create
 a UI element bound to a reactive instance variable.
 The 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{rivar\{x\}}$
\end_inset

 refers to this reactive instance variable.
 The input element shown can be replaced with other UI elements as needed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
has a functional approach, such that the UI is declared as functions, or
 like reactive variables.
\end_layout

\begin_layout Plain Layout
It has an attribute (in React it is named prop) named rivar for assigning
 the reactive instance variable, and the nested element should be a function
 that returns the view of the nested element based on arguments value and
 change.
 The value means that varying value of the reactive instance variable, and
 change means the function to raise a change to the reactive insatnce variable.
 RIVarView is created by using the mechanism of React named useState.
 whenever reactive instance vairbale raises a change, it change an internal
 state value, thise raises React to rerender the nested elementaccording
 to the new value (because react rerender whenevre the state is changed.
\end_layout

\begin_layout Plain Layout
In 
\family typewriter
React
\family default
 there is a mechnism that update automatically the UI according to changes.
\end_layout

\begin_layout Plain Layout
Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
\end_layout

\begin_layout Plain Layout
Reactive instance variables are fed by events from UI controls, such as
 the 
\begin_inset Formula $\LSTINLINE{OnChange}$
\end_inset

 event of a text box, and feed these controls by updating properties like
 the 
\begin_inset Formula $\LSTINLINE{Text}$
\end_inset

 property.
\end_layout

\begin_layout Plain Layout
It is crucial to prevent the creation of loops.
 While the thesis approach addresses loops in reactive assignments, loops
 can still occur when interacting with UI controls.
 For example, if a change in a reactive variable updates a control's property,
 triggering an event that in turn updates the variable, an infinite loop
 may arise.
\end_layout

\begin_layout Plain Layout
Another challenge is whether and how integration with existing reactive
 libraries can be achieved.
 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 is a component built in 
\family typewriter
React
\family default
 and included in the 
\family typewriter
rivarjs
\family default
 library.
 It utilizes a 
\family typewriter
React
\family default
 design pattern called 
\family typewriter
Function as a Child Component
\family default
.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component in 
\family typewriter
JSX
\family default
 accepts a 
\family typewriter
prop
\family default
 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 to establish a connection with a 
\begin_inset Formula $\RIVar$
\end_inset

 instance.
 Additionally, a function that receives change and value as arguments and
 returns 
\family typewriter
JSX
\family default
 is nested within the component.
\end_layout

\begin_layout Plain Layout
When defining the component, value is used to display the current value,
 and change is used to signal a change in the value.
 For example, in an 
\family typewriter
HTML
\family default
 input element, the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event triggers the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 function, and the value attribute is set to the current value of the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
This chapter presented implementations of the approach described in this
 work, using basic elements of 
\family typewriter
ReactiveX
\family default
.
 Two implementations were presented in different programming languages,
 which were tested with code examples and even connected to the UI and tested
 against sample applications.
 By successfully implementing this approach using basic elements, this chapter
 has clearly demonstrated its feasibility.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A reactive instance variable is implemented using a 
\begin_inset Formula $Subject$
\end_inset

.
 The value assignment operator is the 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 (or 
\begin_inset Formula $next$
\end_inset

) operation.
 The reactive assignment operator is implemented as a new operation called
 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 with a parameter that specifies the expression on the right-hand side of
 the assignment statement.
 That is, 
\begin_inset Formula $A.Set(Expression)$
\end_inset

 denotes 
\begin_inset Formula $A:=Expression$
\end_inset

 where 
\begin_inset Formula $Expression$
\end_inset

 denotes an expression composed of reactive instance variables.
 The ability to build 
\begin_inset Formula $Expressions$
\end_inset

 is implemented using a 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

) operation.
 Each value or update is of a new type called 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

 operations implement the strategy of maintaining the order relation, the
 details of which are implemented as part of the 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

 class.
 The 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

 operation filters the stream so that the stream of an expression is monotonic
 (i.e., each item in the list must be "greater," meaning "newer," than the
 value preceding it).
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 operation defines a stream of tuples where each tuple contains updates
 from the streams of both sides of the assignment.
 It filters this stream, allowing only tuples where the update from the
 right-hand side expression is "greater" (meaning more recent) than the
 update from the reactive instance variable on the left-hand side.
 This stream is then used to trigger the 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 (or 
\begin_inset Formula $next$
\end_inset

) operation on the 
\begin_inset Formula $Subject$
\end_inset

 of the left-hand side reactive instance variable whenever there is a "greater"
 (newer) update from the right-hand side expression's stream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
A reactive instance variable is implemented using a 
\begin_inset Formula $Subject$
\end_inset

.
 The value assignment operator is the 
\begin_inset Formula $\LSTINLINE{OnNext}$ 

\end_inset

 (or 
\begin_inset Formula $next$
\end_inset

) operation.
 The reactive assignment operator is implemented as a new operation called
 
\begin_inset Formula $\LSTINLINE{Set}$ 

\end_inset

 with a parameter that specifies the expression on the right-hand side of
 the assignment statement.
 That is, 
\begin_inset Formula $A.Set(Expression)$
\end_inset

 denotes 
\begin_inset Formula $A:=Expression$
\end_inset

 where 
\begin_inset Formula $Expression$
\end_inset

 denotes an expression composed of reactive instance variables.
 The ability to build 
\begin_inset Formula $Expressions$
\end_inset

 is implemented using a 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Lift}$ 

\end_inset

) operation.
 Each value or update is of a new type called 
\begin_inset Formula $\LSTINLINE{Signal}$ 

\end_inset

.
\end_layout

\begin_layout Plain Layout
A core principle is that, in any reactive assignment
\emph on
 the left-hand variable subscribes to the right-hand expression, such that
 the right-hand expression calls to the left-hand variable to update it
\emph default
.
 This performs like a 
\family typewriter
merge 
\family default
function over 
\emph on
observable streams of values
\emph default
.
 The order of the values would be according to the order of the input events.
 From the user pespective any input would propogate changes while overriding
 oldest values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
