#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation-Strategy"

\end_inset

Implementation Strategy
\end_layout

\begin_layout Standard
This chapter presents an implementation strategy based on reactive streams.
 Reactive variables are reactive streams, such that each item in the stream
 of a reactive variable is an update or a new value at the point in time
 corresponding to the item.
 The change propagation principle described in the thesis approach resembles
 the 
\emph on
Depth-First Search (DFS)
\emph default
 algorithm in that it "traverses" a branch of dependencies in depth before
 backtracking.
 Accordingly, each visit to a node is an item in a reactive stream.
\end_layout

\begin_layout Section
Analyzing Challenges in Change Propagation
\end_layout

\begin_layout Standard
In the automatic change propagation, when a value assignment message is
 received, it is possible that the update is outdated.
 There are three reasons why a value might be outdated:
\end_layout

\begin_layout Itemize

\series bold
Glitch
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

: The value was calculated based on outdated values.
\end_layout

\begin_layout Itemize

\series bold
Feedback
\series default
: The value was calculated as a result of the previous value of the same
 variable (due to a loop), as in the example in the introduction.
\end_layout

\begin_layout Itemize

\series bold
Multiple Assignments
\series default
: When there are multiple assignments to the same variable, where at least
 one of them is a reactive assignment, value assignment messages are received
 from multiple sources.
\end_layout

\begin_layout Subsection
Glitch
\end_layout

\begin_layout Standard
Glitch means that certain nodes are visited multiple times, while some of
 these visits involve outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a spanning tree, resulting from the DFS traversal, contains nodes with
 more than one incoming edge.
 Such a propagation is caused from a value assignment into 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 by the reactive assignment statements 
\begin_inset Formula $\LSTINLINE{Concentration:=Drug/Volume}$
\end_inset

 (in 
\family typewriter
Bag
\family default
), and 
\begin_inset Formula $\LSTINLINE{Volume:=Duration*Rate}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug:=Duration*Dose}$
\end_inset

 in 
\family typewriter
Pump
\family default
.
 The multiple incoming edges of a node represent 
\emph on
simultaneous events
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which are related to the same time, that were originally caused by a single
 event.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{value(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{value(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{value(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{value(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B=A*1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C=A*1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D=B/C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Glitch Example in Change Propagation.
\end_layout

\end_inset

Glitch Example in Change Propagation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents a sequence diagram of change propagation
 through reactive instance variables, initiated by a change event to 
\backslash
lstinline{A}.
 The calls order in the sequence diagram is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}) (
\backslash
subref{fig:graph}) presentes the spanning tree resulted from the  traversal
 order, leading that the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Given the reactive assignment statements: 
\begin_inset Formula $\LSTINLINE{Concentration:=Drug/Volume}$
\end_inset

 (in 
\family typewriter
Bag
\family default
), and 
\begin_inset Formula $\LSTINLINE{Volume:=Duration*Rate}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug:=Duration*Dose}$
\end_inset

 in 
\family typewriter
Pump
\family default
.
 The propagation can be according to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:DrugAdministrationGlitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\family typewriter
Duration
\family default
 is propagated to 
\family typewriter
Drug
\family default
, and from there to 
\family typewriter
Concentration
\family default
, then propagated from 
\family typewriter
Duration
\family default
 to 
\family typewriter
Volume
\family default
 and from there again to 
\family typewriter
Concentration
\family default
.
 The first of the two updates is called a Glitch because it relies on outdated
 values that represents 
\family typewriter
Drug
\family default
.
 This means that a certain variable may be updated several times, and only
 the last of them will be the correct update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance=2cm]
\end_layout

\begin_layout Plain Layout

  
\backslash
node (X) [circle, draw] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y1) [circle, draw, below left of=X] {Y1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y2) [circle, draw, below right of=X] {Y2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Z) [circle, draw, below right of=Y1] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->] (X) --  (Y1);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->] (X) --  (Y2);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->, dotted] (Y1) -- (Z);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->, dotted] (Y2) -- (Z);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DrugAdministrationGlitch"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Glitch Example in Drug Administration Application.
\end_layout

\end_inset

Glitch Example in 
\family typewriter
Drug Administration
\family default
 Application.
 The nodes 
\family typewriter
X
\family default
, 
\family typewriter
Y1
\family default
, 
\family typewriter
Y2
\family default
, and 
\family typewriter
Z
\family default
 represent 
\family typewriter
Duration
\family default
, 
\family typewriter
Volume
\family default
, 
\family typewriter
Drug
\family default
, and 
\family typewriter
Concentration
\family default
, respectively.
 The solid edges denote dataflow (raising changes) within a 
\family typewriter
Pump
\family default
 instance while dotted edges indicate dataflow within a 
\family typewriter
Bag
\family default
 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cycles
\end_layout

\begin_layout Standard
It is important to distinguish between two types of graphs.
 One graph describes dependencies between variables, and the other graph
 describes propagation of changes or dataflow.
 In the dataflow graph, edges describe the direction of the flow or propagation.
 In the dependency graph, the direction of the edges is reversed, similar
 to defining dependencies in UML.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Unified Modeling Language
\end_layout

\end_inset

 For example, if we define 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, then 
\family typewriter
A
\family default
 depends on 
\family typewriter
B
\family default
, meaning there's an edge 
\begin_inset Formula $A\rightarrow B$
\end_inset

, while the dataflow has an edge from 
\family typewriter
B
\family default
 to 
\family typewriter
A
\family default
, meaning 
\begin_inset Formula $A\leftarrow B$
\end_inset

.
 Using these graphs, we can expand our understanding of feedback loops.
\end_layout

\begin_layout Standard
Feedback occurs when a cycle is created in the change propagation process.
 The process starts with an edge entering a certain vertex and returning
 to the same vertex from another edge.
 This means that a certain variable is updated, which triggers a chain of
 updates that eventually leads to another update of the same variable.
 In other words, there are two incoming edges to the vertex.
\end_layout

\begin_layout Standard
For example, given 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, then 
\family typewriter
A
\family default
 depends on 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 and receives updates from it.
 But 
\family typewriter
A
\family default
 can also receive an input.
 Therefore, in change propagation, it has two incoming edges.
 Similarly, 
\family typewriter
A
\family default
 can depend on two expressions according to two different reactive assignments.
\end_layout

\begin_layout Standard
This means that a reactive instance variable can depend on multiple different
 expressions, such that a message that arrived as a result of one reactive
 assignment statement led to a propagation chain until it eventually led
 to a message as a result of a second reactive assignment statement.
 Similarly, it is possible that a value assignment statement led the update
 chain until it eventually led to a message as a result of a reactive assignment
 statement.
\end_layout

\begin_layout Subsection
Multiple Assignments
\end_layout

\begin_layout Standard
As a result of supporting cycles, it is necessary to support the syntax
 and semantics of multiple assignments.
 Examples of the syntax appear under implementation inheritance and composition;
 there are two reactive assignments to the reactive instance variable 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 The first statement is 
\begin_inset Formula $\LSTINLINE{Drug:=Concentration/Volume}$
\end_inset

 and the second statement is 
\begin_inset Formula $\LSTINLINE{Drug:=Dose*Duration}$
\end_inset

.
\end_layout

\begin_layout Standard
To determine the value of a variable appearing on the left-hand side of
 multiple reactive assignment statements, it is necessary to consider the
 issue of shared memory.
 When different code segments share memory, two code segments can write
 to the same variable.
 And when the value is read, the value is determined by the last code segment
 that has run.
 That is, the state of a variable changes over time, and its value is determined
 according to the time at which each line of code was executed.
\end_layout

\begin_layout Standard
A streams model is an alternative solution to the problem 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 (of variable assignments by different code segments running at different
 points in time).
 A stream is a list of values over time, similar to components "flowing"
 in a pipe.
 However, in the streams model, the unresolved problem is the merge problem.
 When there are streams from different sources, it is unclear how to merge
 them into one stream.
 The merge problem presented also in FRP as the problem on how to determine
 predictable order over values that are considered as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Supporting the syntax and semantics of multiple assignments means to address
 a sub-problem.
 For a set of reactive assignment statements, a variable can receive messages
 from multiple left-hand expressions according to reactive assignment statements
 for which it is the left-hand side variable.
 This means to merge streams of values from multiple sources.
 Regarding user input, It is not that different, input also serves as another
 source of values for merging.
 Supporting the syntax and semantics of multiple assignments require semantics
 like sampling values of a single variable from multiple sources.
 Just like the general merge problem, it requires to address the problem
 of how to manage the order of the values produced from the messages from
 the whole sources.
 
\end_layout

\begin_layout Section
Addressing the Challenges
\end_layout

\begin_layout Standard
Assuming that the input values constitute an ordered set, any two values
 can be compared based on the input values under whose influence they were
 generated.
 Each input value has a timestamp based on its position in the ordered set.
 Each value has an associated set of timestamps, representing the timestamps
 of the input values that influenced its generation.
 The timestamp set of a value is calculated by performing a union operation
 on the timestamp sets of the values from which it is derived.
 The timestamp set of a value is calculated by performing a union operation
 on the timestamp sets of the values from which it is derived.
\end_layout

\begin_layout Standard
For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Change-Propagation-with"
plural "false"
caps "true"
noprefix "false"

\end_inset

), let 
\begin_inset Formula $Y$
\end_inset

, 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 be variables containing 
\begin_inset Formula $8$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $1$
\end_inset

, respectively, from three input events corresponding to timestamps 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, respectively.
 Let 
\begin_inset Formula $Z_{1}$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $16$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $Z_{1}=X*Y$
\end_inset

.
 The value 
\begin_inset Formula $16$
\end_inset

 is influenced by the values 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $8$
\end_inset

, whose timestamps are 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $2$
\end_inset

.
 Therefore, the corresponding timestamp for the value 16 is the set 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

.
 Let 
\begin_inset Formula $Z_{2}$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $9$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $Z_{2}=X+D$
\end_inset

, with the corresponding timestamp 
\begin_inset Formula $\left\{ 1,3\right\} $
\end_inset

.
 Let 
\begin_inset Formula $V$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $25$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $V=Z_{1}+Z_{2}$
\end_inset

, with the corresponding timestamp 
\begin_inset Formula $\left\{ 1,2,3\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping Between Values and Sets of Timestamps.
\end_layout

\end_inset

Mapping Between Values and Sets of Timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename example_change_propagation-removebg-preview.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Change-Propagation-with"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Change Propagation with Order Relation.
\end_layout

\end_inset

Change Propagation with Order Relation.
 The nodes represent variables and expressions.
 Edges represent value assignment messages.
 Each incoming edge is labeled with timestamps of the value of the message.
 The dotted edge represents a feedback loop.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The order relation between any pair 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 of values is determined by the timestamps of the values.
 Ostensibly, if there is a newer timestamp in the set of 
\begin_inset Formula $X$
\end_inset

, then 
\begin_inset Formula $X>Y$
\end_inset

.
 However, this check is insufficient due to feedback loops.
 If the set of timestamps of 
\begin_inset Formula $X$
\end_inset

 is a subset of the set of timestamps of 
\begin_inset Formula $Y$
\end_inset

, then 
\begin_inset Formula $X>Y$
\end_inset

 even if 
\begin_inset Formula $Y$
\end_inset

 has a newer timestamp.
 For example (presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), adding to the aforementioned example the reactive assignment statement
 
\begin_inset Formula $X:=Z_{1}/Y$
\end_inset

.
 The value of 
\begin_inset Formula $X$
\end_inset

 is calculated from 
\begin_inset Formula $Z_{1}$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

, whose timestamps are 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

 and 
\begin_inset Formula $\left\{ 2\right\} $
\end_inset

 respectively, and therefore the timestamps of 
\begin_inset Formula $X$
\end_inset

 according to this statement are 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

.
 Recall that the value of 
\begin_inset Formula $X$
\end_inset

 according to the input has timestamp 
\begin_inset Formula $\left\{ 1\right\} $
\end_inset

, and although 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

 has a newer timestamp, the relation is 
\begin_inset Formula $\left\{ 1\right\} >\left\{ 1,2\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the Order of Values Based on Their Timestamp Sets.
\end_layout

\end_inset

Comparing the Order of Values Based on Their Timestamp Sets.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a greater
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We investigate a graph of a cyclical propagation change.
 Such a case is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The propagation starts from an incoming edge (the dotted edge in the figure)
 into a node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure), that is the cycle's first node.
 Then, it continues through several edges and nodes until reaching again
 the first node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure) from another edge (in the figure, the edge from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 towards 
\begin_inset Formula $\LSTINLINE C$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$value$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We make a process similar to reverse engineering, i.e., we consider change
 propagation and inffer data dependencies that constructed it.
 As one of the nodes has two incoming edges, it must be one of two options.
 First, that the node represents an input variable which also connected
 to an expression.
 Second, that the node represents a variable that are connected to two expressio
ns simultaneously.
\end_layout

\begin_layout Plain Layout
From this process we introduce syntax for data dependencies, that multiple
 assignments (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

) are allowed, and without differentiating input variables.
 From this syntax the following code is correct.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

A:=B+C //assignments means as data dependencies
\end_layout

\begin_layout Plain Layout

A:=D+E //assignments means as data dependencies
\end_layout

\begin_layout Plain Layout

A=1 // input
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Plain Layout
Every update in the system is of type 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 contains a 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 field that holds the new value according to the update.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is a generic variable, where the type of 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 is only determined when an instance of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is created.
 A comparison function between a pair of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 instances is implemented within the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class.
 In the 
\family typewriter
C#
\family default
 implementation, the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class also inherits from the 
\begin_inset Formula $\LSTINLINE{IComparable}$
\end_inset

 interface, and then the comparison function is the 
\begin_inset Formula $\LSTINLINE{Compare}$
\end_inset

 function of the interface.
\end_layout

\begin_layout Plain Layout
An instance of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 contains an array of numbers used in comparisons.
 Timestamps are determined by a static 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 variable.
 Each time a 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 indicating an external event is created, the 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 is incremented by 1, and the timestamp of the new 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is set to the new value of the 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
For this purpose, 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 has a constructor that receives the 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 as a parameter and defines the timestamp array to be of size 1 with the
 new timestamp.
 For a calculated value, there is an additional constructor that also receives
 the array of numbers representing the timestamps as a parameter.
\end_layout

\begin_layout Plain Layout
The calculation of the timestamp set of a computed 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is performed by a 
\family typewriter
union
\family default
 operation on the timestamp sets of the values from which it is calculated.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
The reactive assignment operation means a 
\emph on
merge accumulation operator
\emph default
.
 In each execution of a reactive assignment statement, the items from the
 stream of the expression on the right-hand side are added to the stream
 of the variable on the left-hand side.
 Formally, for a reactive instance variable 
\begin_inset Formula $X$
\end_inset

 and a reactive assignment statement 
\begin_inset Formula $X:=Expression$
\end_inset

, the result is represented as 
\begin_inset Formula $X=merge(X,Expression)$
\end_inset

.
\end_layout

\begin_layout Standard
When there are multiple reactive assignment statements, the accumulation
 is performed similarly to the following example.
 Executing a reactive assignment statement 
\begin_inset Formula $A:=B$
\end_inset

 creates the meaning of 
\begin_inset Formula $A=merge(A,B)$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Executing an additional reactive assignment statement 
\begin_inset Formula $A:=D$
\end_inset

 creates the meaning of 
\begin_inset Formula $A=merge(merge(A,B),D)$
\end_inset

.
 In general, suppose we have n reactive assignment statements of the form
 
\begin_inset Formula $X:=V_{\text{i}}$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is a number between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 If the assignment statements are executed one after the other, the final
 meaning will be: 
\begin_inset Formula $X=merge(merge(...(X,V_{1}),V2)...,V_{n})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2-1-1"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The Assignment Operator as an Accumulation Merge Operator.
\end_layout

\end_inset

The Assignment Operator as an Accumulation Merge Operator.
 The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In contrast, the required semantics is that a variable receives value assignment
 messages from the expressions on the right-hand side of the reactive assignment
s where it is the left-hand side variable, as well as from input feeds.
 Formally, 
\begin_inset ERT
status open

\begin_layout Plain Layout

for a variable 
\backslash
(X
\backslash
) and a set of variables 
\backslash
(V = 
\backslash
{ V_1, V_2,...
 V_n
\backslash
}
\backslash
), and reactive assignments such that for each 
\backslash
(V_i
\backslash
) in 
\backslash
(V
\backslash
) there is a reactive assignment 
\backslash
(X := V_i
\backslash
) then, 
\backslash
(X
\backslash
) is assigned with 
\backslash
(merge(X, V_1, V_2,...
 V_n)
\backslash
).
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Claim
\end_layout

\begin_layout Standard
The semantics of the reactive assignment operation yields the desired semantics,
 such that the following holds:
\end_layout

\begin_layout Standard
\begin_inset Formula $merge(X,V_{1},V_{2},...V_{n})=merge(merge(...(X,V_{1}),V_{2})...,V_{n})$
\end_inset


\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
The correctness of the claim follows from a proof by induction on an associativi
ty property of the merge operation.
 The meaning of associativity is that the order of applying the merge operation
 on a set of elements does not change the final result.
 In our case, this means that 
\begin_inset Formula $merge(merge(A,B),D)=merge(A,merge(B,D))$
\end_inset

.
 This property stems from the fact that the order of execution of reactive
 assignment statements is inconsequential.
\end_layout

\begin_layout Standard
Based on this property, the proof of the claim by induction is as follows:
\end_layout

\begin_layout Itemize
Base case (
\begin_inset Formula $n=1$
\end_inset

): In this case, we have only one element (
\begin_inset Formula $V_{1}$
\end_inset

) in addition to 
\begin_inset Formula $X$
\end_inset

, and the equality becomes: 
\begin_inset Formula $merge(X,V_{1})=merge(X,V_{1})$
\end_inset

.
 This holds trivially, as both sides are identical.
 
\end_layout

\begin_layout Standard
Inductive hypothesis: Assume that the claim holds for some number n=k.
 That is, assume that:
\end_layout

\begin_layout Standard
\begin_inset Formula $merge(X,V_{1},V_{2},...V_{k})=merge(merge(...(X,V_{1}),V_{2})...,V_{k})$
\end_inset


\end_layout

\begin_layout Standard
holds.
 
\end_layout

\begin_layout Itemize
Inductive step: We need to show that if the hypothesis is true (the equality
 holds for k), then the equality also holds for k+1.
 In other words, we need to show that: 
\begin_inset Formula $merge(X,V_{1},V_{2},...V_{k},V_{k+1})=merge(merge(...(X,V_{1}),V_{2})...,V_{k},V_{k+1})$
\end_inset

.
\end_layout

\begin_layout Standard
Starting with the left-hand side, and using the definition of merge, the
 inductive hypothesis, and the associativity property:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula $merge(X,V_{1},V_{2},...V_{k},V_{k+1})$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
=
\begin_inset Formula $merge(merge(X,V_{1},V_{2},...V_{k}),V_{k+1})$
\end_inset

 //by the associativity property
\end_layout

\begin_layout Standard

\family typewriter
=
\begin_inset Formula $merge(merge(merge(...X,V_{1}),V_{2},...V_{k}),V_{k+1})$
\end_inset

 //by the inductive hypothesis
\end_layout

\begin_layout Standard

\family typewriter
=
\begin_inset Formula $merge(merge(...X,V_{1}),V_{2})...V_{k},V_{k+1})$
\end_inset

 //by the associativity property
\end_layout

\begin_layout Standard
And thus we have arrived at the right-hand side! This means that if the
 equality holds for 
\begin_inset Formula $k$
\end_inset

, then it necessarily holds for 
\begin_inset Formula $k+1$
\end_inset

 as well.
\end_layout

\begin_layout Paragraph
Conclusion
\end_layout

\begin_layout Standard
By the principle of mathematical induction, the claim is true for all natural
 numbers n, and therefore the semantics of the reactive assignment operation
 indeed yields the desired semantics.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
The implementation strategy includes:
\end_layout

\begin_layout Itemize
Multi-assignment semantics that define a merge of streams.
\end_layout

\begin_layout Itemize
Definition of an order over the messages according to the order of input
 events.
\end_layout

\begin_layout Standard
The implementation strategy is based on two facts regarding cycles.
 Firstly, when there is a cycle (i.e., feedback), the problem is similar to
 a known issue called a 
\emph on
glitch
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 To address this, a solution is to discard each value if it is not up-to-date.
\end_layout

\begin_layout Standard
Secondly, if there is a cycle, it means that a vertex represents a variable
 that is the left-hand side variable of multiple reactive assignment statements.
 Alternatively, it could be both an input and output variable (i.e., it is
 updated according to both a reactive assignment statement and input).
 This results in the multi-assignment semantics that define a merge of streams.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This chapter uses the analogy of DFS traversal in a graph, as well as the
 concept of streams, to define an implementation strategy that accommodates
 cycles.
\end_layout

\begin_layout Paragraph
According to the analogy of DFS traversal in a graph:
\end_layout

\begin_layout Plain Layout
Reactive instance variables representing vertices receive value messages
 from expressions of reactive assignment statements where they are the left-hand
 side variable, as well as from input messages.
 In each visit, that is a message is received at a vertex, it should be
 ignored if the value is not up-to-date.
\end_layout

\begin_layout Plain Layout
The implementation strategy is to implement a partial order between any
 two messages, which allows checking if any value is "lesser", meaning older.
 Thus, when a message is received at a vertex, it should be ignored if the
 value is not up-to-date.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For a set of reactive assignment statements, a variable can receive messages
 from multiple expressions, according to the reactive assignment statements
 in which it is the left-hand side variable, where input values are also
 sent to the variable as messages and serve as an additional source.
 For each message, it must be checked whether the value is up-to-date.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
According to the analogy of streams:
\end_layout

\begin_layout Plain Layout
Reactive variables are reactive streams and a reactive assignment is an
 accumulation operation of merging streams.
 As a result, the semantics of multiple assignments is that of merging streams.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Plain Layout
The strategy defines an 
\emph on
order relation
\emph default
, allowing each value to be checked if it is 
\emph on
lesser
\emph default
, meaning 
\emph on
older
\emph default
.
 If it is older, it is filtered out of the stream.
\end_layout

\begin_layout Plain Layout
Supporting the syntax and semantics of multiple assignments require semantics
 like sampling values of a single variable from multiple sources.
 Just like the general merge problem, it requires to address the problem
 of how to manage the order of the values produced from the messages from
 the whole sources.
 
\end_layout

\begin_layout Plain Layout
In summary, 
\end_layout

\begin_layout Plain Layout
The chapter presents an implementation strategy that reactive instance variables
 consist of observable streams and a reactive assignment is represented
 as a 
\emph on
merge
\emph default
 operation.
 Each item in the stream of a reactive instance variable is an update or
 a new value at the point in time corresponding to the item.
 Accordingly, in the DFS algorithm used for change propagation, each visit
 to a node is an item in the stream.
 The strategy defines an 
\emph on
order relation
\emph default
, allowing each value to be checked if it is 
\emph on
lesser
\emph default
, meaning 
\emph on
older
\emph default
.
 If it is older, it is filtered out of the stream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the new approach, an assignment
\emph on
 adds a dependency
\emph default
.
 A variable (
\family typewriter
RIVar
\family default
) can be assigned multiple times, and in each time the variable depends
 on a new expression in addition to existing dependencies.
 This leads that a single variable can be updated from several expressions.
 Additionally, all the variables are input variables that can be updated
 directly.
\end_layout

\begin_layout Plain Layout
Practically, assignment would be an operation that performs that
\emph on
 the left-hand variable subscribes to the right-hand expression, such that
 the right-hand expression calls to the left-hand variable to update it
\emph default
.
 By using this technique, we create an effect similar to 
\family typewriter
merge 
\family default
function over streams of values.
 The order of the values would be according to the order of the input events.
 From the user pespective any input would propogate changes while overriding
 oldest values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
