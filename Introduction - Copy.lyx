#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a paradigm that abstracts away the need to update variables in response
 to other variables' updates.
 A 
\emph on
reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, or 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

) can be assigned by an expression consisting of a set of other reactive
 variables, consequently the value of the variable is set to the value of
 the expression, and continuously re-evaluated in response to changes in
 the value of any of the variables appearing in the expression.
 For example, given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 changes in response to any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Previous works 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards,boix2013object"
literal "false"

\end_inset

 found that FRP has potential to be integrated with the traditional OOP
 paradigm.
 In the popular approach 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, an existing language can be extended with reactive variables as data type.
 Accordingly, Libraries such as ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

 and REscala 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://www.rescala-lang.com}
\end_layout

\end_inset

, support having 
\emph on
reactive instance variables
\emph default
, that are reactive variables as objects' data members (or instance variables).
 Therefrom, objects' classes can contain formulas, that are activated once
 objects are created.
 For instance, class 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 contains reactive variables associated with the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
However, reactive instance variables highlights two challenges existing
 in the FRP paradigm.
 First, applications must avoid recursive definitions e.g., having in the
 application both 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 The reason is that, recursive definitions leads to infinite loop.
 As in the example, the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Second, if there are several variables calculated from one variable, and
 the variables apear in one expression.
 Then it is incorrect to evaluate the expression, while other variables
 have not updated yet.
 This is known as 
\emph on
glitch.

\emph default
 e.g., 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
 The problem can be avoided by substituting the variables with their associated
 expressions.
 e.g., replace 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=2*B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For the first challenge, reactive instance variables can have recursive
 definitions, e.g., base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 For the second challenge, reactive instance variables can have glitches,
 e.g., base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

 , while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
———–
\end_layout

\begin_layout Standard
Reactive instance variables can have recursive definitions, e.g., given 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 reactive instance variables of a base class, the base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 However, 
\end_layout

\begin_layout Standard
Recursive definitions, or 
\emph on
cycles
\emph default
, have been referenced by previous works.
 However, good solution is missing, the FRP mainstream handles only DAG.
\end_layout

\begin_layout Standard
—————–
\end_layout

\begin_layout Standard
The paradigm of OOP with FRP should have semantics.
 In the previous work, 
\end_layout

\begin_layout Standard
In the two works we found about the semantics of integrating OOP with FRP,
 one forms 
\end_layout

\begin_layout Standard
Considering the semantics.
 One previous work invented reactive objects, that are objects that are
 reactive with their fields.
 reactive 
\end_layout

\begin_layout Standard
There is previous work about the semantics of OOP integrated with FRP.
 One handles DAG reactive objects
\end_layout

\begin_layout Standard
———-
\end_layout

\begin_layout Standard
Furthermore, if we could refer reactive variables, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

X.A
\end_layout

\end_inset

, to a given reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 exposed by an object 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, then accessing the variables of the objects would have sometimes involved
 dynamic dispatch processes.
 If so, then the application would have discovered the actual used variables
 only in runtime, without being aware of existence of circular dependencies.
\end_layout

\begin_layout Standard
———
\end_layout

\begin_layout Standard
There are two limitations when using FRP.
 First, applications must avoid recursive definitions e.g., having in the
 application both 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 The reason is that, recursive definitions leads to infinite loop.
 As in the example, the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Second, if there are several variables calculated from one variable, and
 the variables apear in one expression.
 Then it is incorrect to evaluate the expression, while other variables
 have not updated yet.
 This is known as 
\emph on
glitch.

\emph default
 e.g., 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
 The problem can be avoided by substituting the variables with their associated
 expressions.
 e.g., replace 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=2*B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
FRP works correctly as a monolith application, because the developers can
 manage the variables and formulas.
 The application is managed with variables and formulas well designed as
 an acyclic graph, by a single block of code.
 However, for a non-monolith application, the FRP paradigm has been poorly
 applied.
 It is challenged because existing formulas may be hidden.
 e.g., given two reactive variables A and B, and hidden formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 in unit X, then in unit Y, there may be 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Similary, given hidden formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

 in unit X, then in unit Y there may be 
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In this work we focus on the integration of FRP with the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
\end_layout

\begin_layout Standard
—————-
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming langauge 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable as an 
\emph on
event stream
\emph default
, which is an observable emitting values to subscribers, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Standard
However, integration of functional-reactive code with imperative code might
 contain circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in case recursive definitions are presented.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 contain circular dependencies: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
(*** add existing solutions to circular dependencies?)
\end_layout

\begin_layout Standard
In modular programming, avoiding circular dependencies might be difficult.
 It is unclear how well can we separate the functional-reactive code to
 software units such as modules, objects, components, micro-services, micro-fron
tends and so on.
 It is desirable, to have an extensible black-box software exposing reactive
 variables, without the risk of having infinite loops.
 (and without limitations such as, to avoid setting the exposed reactive
 variables).
 
\end_layout

\begin_layout Standard
We choose to focus on integration of FRP with 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm, from which can we learn about the others.
 Also, since having reported experiments 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards,boix2013object"
literal "false"

\end_inset

 in the field, it seems on demand.
 Our experiment deals with separating functional-reactive code to objects'
 classes.
\end_layout

\begin_layout Standard
In the practices of OOP, developers require to develop classes independently
 from code existing in other classes.
 This leads to unknown circular dependencies, e.g., a base class contains
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Furthermore, if we could refer reactive variables, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

X.A
\end_layout

\end_inset

, to a given reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 exposed by an object 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, then accessing the variables of the objects would have sometimes involved
 dynamic dispatch processes.
 If so, then the application would have discovered the actual used variables
 only in runtime, without being aware of existence of circular dependencies.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We introuce semantics for FRP on top of event stream, which support circular
 dependencies.
 The new semantics is applied with an introduced 
\emph on
Reactive Instance variable
\emph default
, named 
\emph on
RIvar
\emph default
, being consistent with both 
\emph on
instance variable
\emph default
 from OOP and 
\emph on
reactive variable
\emph default
 from FRP.
 We then implement a prototype of an application demonstrating how RIvars
 are used, and evaluate RIvar on its help in the abstraction.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{Outline.}
\end_layout

\end_inset

 Chapter 3 presents a motivation example, Chapter 4 presents the proposed
 semantics, Chapter 5 uses the new semantics by implementing the new type
 
\emph on
RIvar
\emph default
 for C# programming language.
 Chapter 6 evaluate the results by the help of a prototype application.
\end_layout

\end_body
\end_document
