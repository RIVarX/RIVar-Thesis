#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset

Introduction
\end_layout

\begin_layout Standard

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 is a core concept in the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Consider an example of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 .
 In the example, a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is updated in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In essence, operations (like the 
\begin_inset Formula $\LSTINLINE +$
\end_inset

) over values are 
\emph on
lifted 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 to operate over reactive variables and to compose expressions (like 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

).
 An association (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) establishes data dependencies, so that the left-hand variable
 depends on the variables in the right-hand side, and it is continuously
 re-evaluated according to changes in the dependencies.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // causes A=2
\end_layout

\begin_layout Plain Layout

B=6 // causes A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
hspace{3cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operation establishes a data dependency, depicted by the graph from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Consequently, the subsequent 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 operations of assigning values to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 cause corresponding changes to
\begin_inset space ~
\end_inset


\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can be applied to input fields in GUI applications.
 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 are one of such GUIs.
 The behavior of reactive variables is similar to the behavior of cells
 in 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

.
 The cells can contain formulas to determine values based on other cells.
 This is similar to reactive variables that are associated with expressions
 composed of other reactive variables.
 Also in other applications, GUI developers need often to develop behaviors
 similar to reactive variables.
 Fields in GUI often involved in 
\emph on
calculations
\emph default
, i.e., update fields values based on other values filled in the other fields.
 In developing front-end applications, the calculations are usually defined,
 independently of the GUI, using a dedicated 
\emph on
state management solution
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.
 Consequently, we refine calculations as updating variables values based
 on other values in the other variables.
\end_layout

\begin_layout Standard
Unfortunately, the way in which calculations are managed, do not stand with
 the standard to breaking down code into modules or objects.
 An example is a widespread adoption of a state management solution named
 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Also in FRP, most implementations uses a centralized mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Also in harmonizing FRP with OOP, there is coupling to a centralized component
 which handles the calculations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
A possible reason is the need to avoid unacceptable feedback loops, i.e.,
 a change in one field leads to a subsequent change that feeds back and
 affects the original field itself.
 When declaring new data dependencies, it is essential to ensure that transitive
 dependencies do not depend on the fields from which the new dependencies
 originate.
 Therefore, transitive dependencies should be reachable.
\end_layout

\begin_layout Standard
Besides the need to handle cycles, The cycles are currently treated only
 as an edge case.
 Typically, calculations are hierarchical, i.e., variables are connected to
 the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this thesis, we introduce a new variant of FRP, named Non-Hierarchical
 FRP (NH-FRP), that indeed supports cycles.
 By using NH-FRP, reactive variables can be associated with objects as instance
 variables, which we name 
\emph on
reactive instance variables
\emph default
 (a 
\begin_inset Formula $\RIVar$
\end_inset

 in singular), while calculations over 
\begin_inset Formula $\RIVar$
\end_inset

s are managed as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
In the new variant, we use a propagation strategy, in which the propagated
 values are accompanied by timestamp data.
 According to the timestamp data, obsolete values from feedback loops are
 identified and blocked from passing forward.
 By using NH-FRP, reactive variables can be associated to objects, with
 the name 
\emph on
reactive instance variables
\emph default
 (a RIVar in singular), while also the calculations over them are managed
 as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
To solve the problem we introduce Non Hirarchial FRP, a new varian;t of
 FRP that support cycles.
 This new variant consists of a propogation strategy, so that the propogated
 values are attached with data about their time, by whom absolete value
 from feedback loops are not passed forward.
\end_layout

\begin_layout Plain Layout
This new varaint enables cycles by embedding an algorithm, that each variable
 ignores absolete values.
\end_layout

\begin_layout Plain Layout
This new variant enables cycles by an approach, that each variable can depend
 on multiple sources, where each of the sources can update the variable
 on its updated value.
\end_layout

\begin_layout Plain Layout
For example, given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formulas 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A-1}$
\end_inset

 create associations, so that A
\end_layout

\begin_layout Plain Layout
associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
In the context of FRP, Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 suggests an alternative mechanism the centerlized mechanism that have access
 to the entire dependancy graph.
 
\end_layout

\begin_layout Plain Layout
this includes two stages.
 First, a centerlized mechanism that have access to the entire dependancy
 graph.
 Second, 
\end_layout

\begin_layout Plain Layout
FRP still does not provide a better solution in this aspect.
 
\end_layout

\begin_layout Plain Layout
In FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
 This is the state also in works that harmonizes FRP with OOP.
\end_layout

\begin_layout Plain Layout
Two stages do exist in the task: declaring the calculations and the runtime.
 For the two stages, the centerlization is unaccepted.
 In DFRP, there are decenterlized algorithms to decenterlzed in runtime
\end_layout

\begin_layout Plain Layout
.
 First to depedencies.
 The decenterlized implemention need 
\end_layout

\begin_layout Plain Layout
A possible reason is that adding 
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
Unfortunaly, the way the state is managed, does not stand with the standard
 to breaking down code into modules or objects.
 An example is a widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Similarly in FRP
\end_layout

\begin_layout Plain Layout
The centerlization includes the runtime and the code.
\end_layout

\begin_layout Plain Layout
The centerliation is applied in runtime, by a centerlized mechanism that
 have access to the entire dependancy graph.
 This has solution in the field of Distributed FRP 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 For the centerliation in code, there is a problem 
\end_layout

\begin_layout Plain Layout
In addition, when maintaining the code, adding a dependancy requires the
 check against transitive dependencies to not create cycles.
 means sometimes to check against unreachable classes or objects
\end_layout

\begin_layout Plain Layout
This problem is applied also in FRP: according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
 
\end_layout

\begin_layout Plain Layout
The centerlization consists of two parts.
 First, in runtime, one centerlzed mechanism that access the ..
\end_layout

\begin_layout Plain Layout
second, in the code itself, 
\end_layout

\begin_layout Plain Layout
The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\begin_layout Plain Layout
FRP aims to solve the difficulties in controlling the calculations.
 In the events driven paradigm updating a field might trigger a change event
 which trigger other updates and so on.
 In the worst case, the chain of updates can being an infinite loop of updates.
\end_layout

\begin_layout Plain Layout
Traditionaly, two strategies handle the problem.
 First, specifying calculations hierarchically, i.e., variables are connected
 to the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 This fact is often mentioned in FRP.
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to keep from unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamicaly.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitary break existing cycles.
 Overall, cycles are considered as an 
\emph on
edge-case
\emph default
, i.e., a special situation without a common sense solutions.
\end_layout

\begin_layout Plain Layout
The second strategy is centerlization.
 in front ends development there is widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Also in FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
This work is motivated 
\end_layout

\begin_layout Plain Layout
Furtheremore, while keeping from undesirable cycles, dependencies must be
 reachable, leading again to centerlization.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The second strategy is centerlization.
 according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations of FRP depends on a centerlized mechanism
 that have access to the entire dependancy graph.
 Also in front ends development there is a common sence to manage the caculation
s in a centerlized mannar since the widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We focus on enabling calculation without those conditions.
 We adapt OOP, such that objects handle their calculation separately, and
 also that the objects contain calculations without ever knowing about other
 related calculations.
 In this new settings, we does not avoid cycles.
 The check against cycles requires that, whenever fields calculations are
 added, to check that the data dependency graph remains acyclic.
 The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Generaly, the graph is managed in a centerlized mannar.
\end_layout

\begin_layout Plain Layout
In order to implemented the reactive variables correctly, the graph is managed
 in a centerlized mannar, otherwize there might be inpredictable behavior.
 
\end_layout

\begin_layout Plain Layout
In order to improve the error-prone development of reactive variables or
 fields calculations, 
\end_layout

\begin_layout Plain Layout
The development of fields calculations is error prone.
 Therefore 
\end_layout

\begin_layout Plain Layout
The noval approach of FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beside this approach, there is the event-driven approach that fit Object
 Oriented Orogramming (OOP).
 In this approach, components can be extended, to react to variables' updates.
 On top of this
\end_layout

\begin_layout Plain Layout
There is the event-driven programming by which developers have a complete
 control over the propagation order,
\end_layout

\begin_layout Plain Layout
Beside this approach, there are approaches that fit Object Oriented Orogramming
 (OOP).
 There is the event-driven programming by which developers have a complete
 control over the propagation order, but this is error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 There is also frameworks like 
\begin_inset Formula $\ReactiveX$
\end_inset

 that provide a more abstract approach, to function over streams of events,
 that are closely related to the reactive variables.
 There the developers can choose between several schedulers to indicate
 the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 is a library in 
\begin_inset Formula $\NAME{Scala}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.scala-lang.org/
\end_layout

\end_inset


\end_layout

\end_inset

 that allows reactive variables being within objects or classes, modeling
 the fields calculations as part of components.
 The library derives previous FRP implementations, which is designed to
 produce consistent behavior, by an algorithm that carefully determines
 the order in which to update the variables.
 Another library 
\begin_inset Formula $\ReactiveX$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 that has first introduced for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 but adopted for more programming languages, provides an an API based on
 some OOP design patterns, to treat variables as streams of their changes.
 This can also been considered as reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 which objects can contain.
\end_layout

\begin_layout Plain Layout
The the two have different approaches, which lead to different results.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 leading to 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, outdated values are filtered out.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For example, when saying Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, there is no guarantee for 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 .
\end_layout

\begin_layout Plain Layout
We call them 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive variables remind fields in front-end applications, that are calculated
 according to other fields.
 In FRP, in order to create a variable that is automaticaly calculated according
 to other variables, it should be specified decleratively as a formula.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to change to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(It might be challenging, to deal with the fields calculations that involve
 long chain of updates.
 The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

.
 The left challenge is in managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
an API based on some OOP design patterns, to treat variables as streams
 of their changes.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, abstracting
 components with fields.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefully determines the order in which
 to update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables as
 streams of their changes.
 Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
the tra of the declaring the data depedencies explicity, it should become
 easier.
\end_layout

\begin_layout Plain Layout
In the development of front-end and other reactive applications there are
 two dependencies types: data dependencies and source code depedencies,
 which should be organaized efficiently.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, there is an effort to make the data dependencies declared in the languages,
 instead that the developers need to understad the depedencies from the
 control of the programs.
 Traditionaly, it is hard to understand the dependencies, because it is
 spread over the event handlers.
\end_layout

\begin_layout Plain Layout
In the paradigm of OOP, there are abstraction mechanism to manage the source
 code dependencies.
 according to business needs, then changes in the code that handle data
 dependencies in one component might lead to require other components to
 be changed accordingly.
 
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, lanigages has been deveoped that lift the assignment statements, to create
 data dependencies, so that the variables will continoue to update according
 to the depeodencies.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
\end_layout

\begin_layout Plain Layout
Reactive variables have a special assignment operation (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operator) that defines a 
\emph on
data
\emph default
 
\emph on
dependenc
\emph default
y: the target reactive variable depends on the variables in the expression.
 The expressions are 
\emph on
lifted 
\emph default
executed functions, so that the target reactive variable continuously contains
 the value derived from the values of the reactive variables it depends
 on.
 A propogation of changes starts whenever any of the variables get user
 input (
\begin_inset Formula $\LSTINLINE=$
\end_inset

 operator).
 This causes the dependencies to re-evaluate, which causes their dependencies
 to re-evaluate, and so on.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 Applications are usually composed of several or many components that runs
 in one or many hosts.
 In such settings, changes in the code that handle data dependencies in
 one component might lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the Object Oriented Paradigm (OOP) difrent parts of the application in
 the form of objects can be loosly coupled, even when they interacts in
 such a way that variable in one object depends on variables of other objects.
\end_layout

\begin_layout Plain Layout
applications are modeled as objects that the components can usesuggests
 to form applications by objects to be used model running components or
 that can extend and compose each other, that can react to 
\end_layout

\begin_layout Plain Layout
In the events paradigm, it is hard to control what the data depedencies
 are, because logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 In addition, if an application is composed of several components, according
 to business needs, then changes in the code that handle data dependencies
 in one component might lead to require other components to be changed according
ly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
it might be hard as every large application, that contains too much details
 to the developer think.
 
\end_layout

\begin_layout Plain Layout
the complex or huge logic, in the form of uge amount of data depedencies.
\end_layout

\begin_layout Plain Layout
the huge amount of data depedecies might be hard to manage as it is complex
 logic 
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 The first difficulty is to control the data dependencies.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In FRP, the goal is that the developer has a langague to express the data
 dependenies directly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage the dependencies between code components.
 If the code that handles data dependencies handling involves several components
, they might become 
\emph on
coupled
\emph default
.
 If changes in one component lead to require other components to be changed
 accordingly, the first component depends on the second component 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In the Object Oriented Programming, the applications parts has the form
 of objects.
\end_layout

\begin_layout Plain Layout
, that consume and extend each other, which are used to manage the code
 changes efficiently.
 The objects are used to sompose applications
\end_layout

\begin_layout Plain Layout
According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, although
 they have different focuses.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefuly determines the order in which to
 update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables by
 streams of their changes.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 from the 
\emph on
Functional Paradigm
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
 
\end_layout

\begin_layout Plain Layout
Reactive variables can be used to fields calculations, by connecting to
 visual fields.
 
\end_layout

\begin_layout Plain Layout
For instance, 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 is a state management solution for 
\begin_inset Formula $\NAME{React}$
\end_inset


\end_layout

\begin_layout Plain Layout
applications, with the functionality like reactive variables.
 
\end_layout

\begin_layout Plain Layout
provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In maintaining and updating the variables, we sometimes face an unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications grow
 and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
 
\end_layout

\begin_layout Plain Layout
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 
\end_layout

\begin_layout Plain Layout
The second complexity part is to separate the task into small manageable
 and independent tasks, for being in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second, we relate to the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
 This paradigm enables that different parts of the software, in the form
 of objects, are loosely coupled and do not depend on one another.
 This makes it easier to change objects without affecting the others.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 the reactive variables are part of the object interface, but implemented
 differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
 
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We present a semantic framework that enables the separation of data dependency
 management within objects.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both C# and
 JavaScript, along with a small application example.
\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Plain Layout
We first start with demonstrating the balance in the existing solutions,
 between predictable and decenterlzed solutions.
 Then we demonstrate our framework, an implementation.
 Finaly we compare
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start with deonstrating an example for an application, and dicuse the
 existing the challenges exsting in the exsiting approaches
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Background}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a background about implementing FRP under the hood.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

presents an example to demonstrate the need for 
\begin_inset Formula $\RIVar$
\end_inset

s.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Method}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present the new variant of FRP, so that reactive variables will be able
 to be 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Evaluation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we compare the model against the other solutions and paradigms, in handling
 graphs and reducing code duplication.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Implementation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present 
\begin_inset Formula $\RIVarX$
\end_inset

 with an implementation to the example presented in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

 being the case study.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities, 
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
 
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We focus on enabling FRP in OOP settings, so that it can be used across
 components.
 The point is that the visibilty of the elements can vary according to the
 organizations needs.
 The functions are defined over elements named 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they are reactive variables that can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
 The second point is that the visibility of the calculations are kept also
 in runtime by avoiding a madiator or any centeral engine to handle the
 calculations.
 We keep it simple, that each update trigger the next one as a simple function
 call.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We introduce 
\begin_inset Formula $\RIVar$
\end_inset

, i.e., reactive instance variables.
 This concept harmonizes the concept of reactive variable with the concept
 of instance variable.
\end_layout

\begin_layout Itemize
We introduce Non-Hierarchical FRP (NH-FRP), a new variant of FRP which can
 be applied upon 
\begin_inset Formula $\RIVar$
\end_inset

s.
\end_layout

\begin_layout Itemize
We provide 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 This provides also a state management solution.
\end_layout

\begin_layout Itemize
We introduce a small application example that uses the above.
\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we list state of the art strategies for calculations input fields in GUI
 applications.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present aspects for enhancements in fields calculations.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we explain our approach and implementation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we evaluate the approach.
 We explore architectural design options to the Drug Administration application
 and compare it to the one achived by our approach.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Related-Work"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we associate concepts in our approach to the previous paradigms.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusion"
plural "false"
caps "true"
noprefix "false"

\end_inset

 contains the conclusion and the future work.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
