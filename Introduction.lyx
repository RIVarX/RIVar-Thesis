#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // A=2
\end_layout

\begin_layout Plain Layout

B=6 // A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[<-] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The provided code demonstrates the distinction from the imperative paradigm,
 where assignments have a lasting effect on variables.
 The accompanying graph illustrates the meaning that 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\myName{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
 Reactive variables can be used to fields calculations, by being connected
 to fields.
 For instance, 
\begin_inset Formula $\myName{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\myName{React}$
\end_inset

.
 
\begin_inset Formula $\myName{React}$
\end_inset

 provides a framework that does the connection, by updating the view with
 the fields, according to the reactive variables.
\end_layout

\begin_layout Standard
In implementing fields calculations and reactive variables, we might face
 an unpredictable behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

, especially when applications grow and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
 
\end_layout

\begin_layout Standard
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 This has the solution of reactive variables, in explicitly declaring the
 data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The second complexity part is to manage the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, in order to manage code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in declared data dependencies in one component might cause effects
 on other components, requiring them to be changed accordingly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities, 
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
 
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We present a semantic framework for separating data dependency management
 within objects, so that object is responsible for managing its own set
 of data dependencies.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which are the variables that the objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both 
\begin_inset Formula $\myName{C\#}$
\end_inset

 and 
\begin_inset Formula $\myName{JavaScript}$
\end_inset

, along with a small application example.
\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we explore traditional methods employed for handling field calculations
 and discuss the possibility of dividing them into components.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 addresses the problem we aim to solve, outlines the required framework,
 and identifies the obstacles hindering its implementation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we present our solution to overcome these obstacles.
 Finally, 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 offers a comprehensive implementation of our proposed semantic framework.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
