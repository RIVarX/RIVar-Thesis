#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 paradigm deals with abstracting away the need to handle variables' consistency,
 i.e., eliminates the need to update variables in response to other variables'
 updates.
 Declaring a 
\emph on
reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (similar to 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, or 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

) assigned by an expression consisting of a set of other reactive variables,
 produces an automation such that, the value of the variable is set to the
 value of the expression, which is evaluated in response to changes in the
 value of any of the variables appearing in the expression.
 For example, given reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, to change the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming langauge 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable as an 
\emph on
event stream
\emph default
, emitting the values over time, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Standard
However, integration of functional-reactive code with imperative code might
 contain circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in presence of recursive definitions.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-1
\end_layout

\end_inset

 contain circular dependencies: the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, and the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

A-1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Avoiding circular dependencies might be difficult, for a modular code.
 It is unclear how well can we separate the functional-reactive code to
 software units such as modules, objects, components, micro-services, micro-fron
tends and so on.
 It is desirable, to have an extensible black-box software exposing reactive
 variables, without the risk of having infinite loops.
 (and without limitations such as, to avoid setting the exposed reactive
 variables).
 
\end_layout

\begin_layout Standard
We choose to focus on integration of FRP with 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm, from which can we learn about the others.
 Also, since having reported experiments 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards,boix2013object"
literal "false"

\end_inset

 in the field, it seems on demand.
 Our experiment deals with separating functional-reactive code to objects'
 classes.
\end_layout

\begin_layout Standard
In the practices of OOP, developers require to develop classes independently
 from code existing in other classes.
 This leads to unknown circular dependencies, e.g., a base class contains
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Furthermore, if we could refer reactive variables, such as 
\begin_inset ERT
status open

\begin_layout Plain Layout

X.A
\end_layout

\end_inset

, to a given reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 exposed by an object 
\begin_inset ERT
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, then accessing the variables of the objects would have sometimes involved
 dynamic dispatch processes.
 If so, then the application would have discovered the actual used variables
 only in runtime, without being aware of the circular dependencies.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We introuce semantics for FRP on top of event stream, which support circular
 dependencies.
 The new semantics is applied with an introduced 
\emph on
Reactive Instance variable
\emph default
, named 
\emph on
RIvar
\emph default
, behaves as a combination of instance variable from OOP and reactive variable
 from FRP.
 We then implement a prototype of an application demonstrating how RIvars
 are used, and evaluate RIvar on its help in seperating the application
 and reducing code repetition.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{Outline.}
\end_layout

\end_inset

Chapter 3 presents an introductory example to concretely illustrate the
 problem and the solution's design space.
 This example demonstrates a drug calculation user interface, and an object-orie
nted design to seperate its concerns.
 Chapter 4 presents the approach and illustrate the concept of RIvar (Reactive
 Instance Variable).
 Chapter 5 presents the implementation.
 Chapter 6, presents the evaluation.
\end_layout

\end_body
\end_document
