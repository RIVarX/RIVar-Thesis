#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset

Introduction
\end_layout

\begin_layout Standard

\emph on
Change propagate
\emph default
 is a common process, in which data updates recursively require other data
 updates.
 In this thesis, we focus mainly on change propogation of fields in graphical-us
er interface
\begin_inset space ~
\end_inset

(GUI) in response to user input.
 But as mentioned, change propogation is a common process.
 For example, 
\family typewriter
Git
\family default
 branches are merged from each other
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "miller2022introduction"
literal "false"

\end_inset

, which means that code changes in a specific merge is propogated to other
 branches.
 Another example is that in the 
\family typewriter
ETL
\family default
 (Extract, Transform, Load) field 
\begin_inset CommandInset citation
LatexCommand cite
key "mali2015survey"
literal "false"

\end_inset

, changes are propagated across systems.
 In addition, upgrade processes, which means updating software packages.
 Upgrading software packages may lead to further upgrades of other related
 packages, such like change propagation.
\end_layout

\begin_layout Standard
In another perspective, the discussion is about 
\emph on
data dependencies
\emph default
.
 A data element is considered 
\emph on
dependent
\emph default
 on other elements when a change in their values triggers an automatic update
 in its own value.
 Data dependencies are modeled as a graph, where nodes represent data entities,
 and directed edges represent dependencies between them.
 Change propagation is also modeled using a graph with the same nodes, but
 the directed edges represent the direction of propagation, which is opposite
 to that of dependencies.
\end_layout

\begin_layout Standard
To achieve the representation of nodes, dependencies, and change propagation,
 we utilize 
\emph on
reactive variables
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

).
 With reactive variables, an assignment establishes a dependency between
 the left-hand variable and the right-hand expression.
 once a reactive variable is assigned, it is associated to the assigned
 expression, to continuously re-evaluated according to relevant changes.
 For example
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 defines that 
\family typewriter
A
\family default
 depends on 
\family typewriter
B
\family default
.
 Then, an input 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 raises 
\family typewriter
A
\family default
 to contain 2.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // causes A=2
\end_layout

\begin_layout Plain Layout

B=6 // causes A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
hspace{3cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operation establishes a data dependency, depicted by the graph from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Consequently, the subsequent 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 operations of assigning values to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 cause corresponding changes to
\begin_inset space ~
\end_inset


\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We present 
\emph on
Reactive Instance Variable
\family typewriter
\emph default

\begin_inset space ~
\end_inset

(
\family default
RIVar).
 RIVar is a combination of reactive variable from 
\emph on
Functional Reactive Programming 
\emph default
(FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 with 
\emph on
instance variable
\emph default
 from 
\emph on
Object-Oriented Programming
\begin_inset space ~
\end_inset


\emph default
(OOP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wegner1990concepts"
literal "false"

\end_inset

.
 Therefrom, our contribution includes:
\end_layout

\begin_layout Itemize
A novel approach combining FRP with OOP.
\end_layout

\begin_layout Itemize
New semantics for handling cycles and apparent conflicts emerged from adapting
 the encapsulation principle of OOP.
\end_layout

\begin_layout Itemize
A library implementation of our approach.
 For 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we create a 
\family typewriter
nuget
\family default
 package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language, we create a 
\family typewriter
npm
\family default
 package called 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A case study from the healthcare domain to illustrate the practical application
 of the presented principals.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our contribution is in introducing a concept 
\begin_inset Formula $\RIVar$
\end_inset

.
 This name refers to 
\family typewriter
Reactive Instance
\family default
 
\family typewriter
Variable
\family default
, a combination of 
\family typewriter
reactive variable
\family default
 with 
\family typewriter
instance variable
\family default
 (i.e., field associated with an object).
\end_layout

\begin_layout Plain Layout
Upon 
\begin_inset Formula $\RIVar$
\end_inset

, we implement libraries available in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

.
 For 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we create a 
\family typewriter
nuget
\family default
 package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language, we create a 
\family typewriter
npm
\family default
 package called 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 In both, we created a class named 
\begin_inset Formula $\RIVar$
\end_inset

 with a method named 
\family typewriter
Set
\family default
, that represents the new assignment operation.
 We also created an extension method named 
\family typewriter
Lift
\family default
, for creating the expressions.
\end_layout

\begin_layout Plain Layout
The frameworks have been integrated with UI frameworks.
 Conceptually, 
\begin_inset Formula $\RIVar$
\end_inset

 consists of observable streams facilitating binding with the UI.
 When a UI change event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 Additionaly, for an integration with 
\begin_inset Formula $\NAME{React}$
\end_inset

, we created a component, 
\family typewriter
RIVarView,
\family default
 that seamlessly integrates 
\begin_inset Formula $\RIVar$
\end_inset

 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we provide some background in the context of GUI.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we outline a motivation problem.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present the approach and implementation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present a validation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Related-Work"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present related work.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusion"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarizes our findings and discusses future work.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, 
\family typewriter
Redux
\family default
, manages variables as a central state in 
\family typewriter
React
\family default
 applications
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

.
 This central entity might also be human.
 For example, software architects ensure that there are no cycles in dependencie
s
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout

\emph on
Data dependencies 
\emph default
refers to dependencies between projects, dependencies between fields and
 so on.
 Generally, one element depends on other elements, such that if one of the
 latter elements is updated, the first element should be updated accordingly.
 We use a uniform approach of graphs, such that projects or fields serve
 as the nodes, with directed edges that represents the dependencies between
 them.
\end_layout

\begin_layout Plain Layout
Sometimes, sets of nodes and edges are grouped as distinct components.
 This has the advantage of 
\emph on
separation of concerns
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "parnas1972criteria"
literal "false"

\end_inset

.
 For example, GUI components that handle their logic internally.
 Additionally, with 
\emph on
mono repository
\emph default
 (i.e., that multiple projects are on the same location, but should keep on
 an isolation), each project manages locally its dependencies.
\end_layout

\begin_layout Plain Layout
The challenge we aim to address is, that this partitioning is often imperfect.
 This stems from a component that manages these dependencies, that is convention
ally central.
 This component uses an algorithm that 
\emph on
propagates changes
\emph default
.
 It recognizes changes started from input, and recursively propagates the
 changes to dependencies.
 An example of such a component is 
\family typewriter
Redux
\family default
, which manages the variables as a central state in 
\family typewriter
React
\family default
 applications
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

.
 This central component might also be human.
 For example, software architects ensure that there are no cycles in dependencie
s
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 From this point, we focus on providing an abstraction model to the problem.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Reactive Variables
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We model data dependencies as a graph model, where data entities serve as
 nodes, and directed edges represent dependencies between them.
 Propagation change is according to the dependencies: an element depending
 on other elements, means that if one of the latter elements is updated,
 the first element should be updated accordingly.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
To achieve the representation of nodes, dependencies, and change propagation,
 we utilize 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) from the 
\family typewriter
Reactive Programming
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 .
 The origin of reactive variables is from the 
\family typewriter
Functional Reactive Programming
\family default

\begin_inset space ~
\end_inset

(FRP) paradigm
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott1997functional"
literal "false"

\end_inset

, that aims to use principles from the 
\family typewriter
Functional Programming
\family default
 (FP) paradigm.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Functional_programming
\end_layout

\end_inset


\end_layout

\end_inset

 Reactive variables are presented similar to pure functions in FP, in expressing
 code that calculate needed output based on arguments.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 is equivalent to 
\color blue
function A(B){return B+1}
\color inherit
 in the 
\family typewriter
JavaScript
\family default
 programming language.
 
\end_layout

\begin_layout Plain Layout
Reactive variables model varying values depending on each other, similar
 to the original meaning for functions in mathematics.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Function_(mathematics)
\end_layout

\end_inset


\end_layout

\end_inset

 Frameworks that implement reactive variables enable to model varying values
 by re-evaluating values automatically.
 Typically, these frameworks initiate dependencies, track them, and re-evaluate
 values in response to changes in the dependencies.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), an expression 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 creates a dependency.
 In this dependency, A depends on B.
 This forms a 
\emph on
dataflow 
\emph default
(or 
\emph on
propogaton
\emph default
) from B to A, such that any update of B will cause a corresponding update
 of A.
 In case that B is an input variable, an expression 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 creates an update of B, causing A to contain 2.
 Next, an expression 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 creates an update to B, causing A to contain 2.
\end_layout

\begin_layout Section
Objects
\end_layout

\begin_layout Plain Layout
For presenting the partitioning, we utilize 
\emph on
classes
\emph default
 or 
\emph on
objects
\emph default
 within 
\family typewriter
Object Oriented Programming
\family default

\begin_inset space ~
\end_inset

(OOP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wegner1990concepts"
literal "false"

\end_inset

.
 Objects group fields and operations.
 Classes are the templates for objects.
 Interface is the outer form from the prespective of a client.
\end_layout

\begin_layout Plain Layout
OOP has an advantage in enabling 
\emph on
indirect interface
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

, by which providers and clients do not depend on each other directly.
 A useful example is the 
\family typewriter
Observer
\family default
 pattern
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, by which one object named 
\emph on
observable
\emph default
 triggers other objects named 
\emph on
observers
\emph default
 about new content.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The concept of objects enables code-reuse in two forms.
 First, 
\emph on
inheritance
\emph default
, that class derived from another class.
 Second, 
\emph on
composition
\emph default
, that a class contains a reference to another class.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Section
Problem
\end_layout

\begin_layout Plain Layout
At this point, our question is regarding an integration.
 Several research directions have been presented in order to connect between
 reactive variables and objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018,Salvaneschi2014,boix2013object,salvaneschi2014towards"
literal "false"

\end_inset

.
 One of them 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, suggested that reactive variables would be part of the interface of an
 object.
 The interface consists of operations that can be invoked by clients, but
 it also consists of fields by 
\family typewriter
getter
\family default
 and 
\family typewriter
setter
\family default
 methods.
 Therefore, adding to the interface also reactive variables seems a valid
 research direction.
 We call such a reactive variable 
\family typewriter
RIVar
\family default
, a short name to 
\family typewriter
Reactive Instance Variable
\family default
 or also 
\family typewriter
Reactive Interface Variable
\family default
.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In a similar setting, we name the reactive variables as reactive instance
 (interface) variables, or simply RIVar.
 In using RIVars, the assignment operator, rather than initiating a variable
 according to the right-hand expression, will only register the left-hand
 variable to be updated to changes of the right-hand expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 This concept is similar to one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This concept exists also in constraints programming with the name one-way
 dataflow constraint 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, on top of events programming (or the Observer pattern), this setting
 is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
One question upon this suggestion is whether 
\family typewriter
RIVar
\family default
 can be reassigned 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 This has been related to a question, what 
\family typewriter
RIVar
\family default
 is? Is 
\family typewriter
RIVar
\family default
 more similar to a method, or is 
\family typewriter
RIVar
\family default
 more like a field? If 
\family typewriter
RIVar
\family default
 can be reassigned, it would be more similar to a field.
 However, this raises a challenge, on how to manage resulted dynamic dependencie
s.
 This promotes again the question for 
\family typewriter
RIVar
\family default
, to reassign ot not reassign?
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Another question that is more general, is whether (and how) to support 
\emph on
cycles
\emph default
 in dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Cycles is created in case that variables define each other (
\family typewriter
mutual recursion
\family default
).
 For instance, if 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are included in code, which means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is defined in term of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and vice versa.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, the main point is our initial discussion of the centralized mechanism,
 of how to manage the dependencies or propogate the changes.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Background"

\end_inset

Background
\end_layout

\begin_layout Plain Layout
Our approach is based on the concept of 
\emph on
observable streams
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A complete knowledge and references about observable streams are available
 in
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

 https://introtorx.com/
\end_layout

\end_inset

 (in 
\family typewriter
C#
\family default
 programming language) and 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rxjs.dev/
\end_layout

\end_inset

 (in 
\family typewriter
JavaScript
\family default
 programming language)
\end_layout

\end_inset

 An observable stream is similar to a list in that it delivers ordered items.
 However, unlike a traditional list, the entire history of values isn't
 necessarily stored.
 Rather, observable streams represent an abstraction that provides access
 to a sequence of values.
 To access these values, consumers must first subscribe to the observable
 stream.
 We take the concept of observable streams for presenting variables.
 An example is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Each item in an observable stream represents a change in the value that
 the variable contain.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We take the concept of observable streams for presenting variables.
 An observable stream consists of values or changes over time, as illustrated
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values"
plural "false"
caps "true"
noprefix "false"

\end_inset

, generated from events of UI elements.
 Furthermore, Each node in a dependancy graph can be represented as an observabl
e stream.
 Each Item represents a visit in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variable value changes as an observable stream
\end_layout

\end_inset

Variable value changes as an observable stream.
 Variable 
\begin_inset Formula $A$
\end_inset

 changed to 
\begin_inset Formula $5$
\end_inset

 initially, then to 
\begin_inset Formula $3$
\end_inset

, and after a longer period, it changed to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Upon observable streams, 
\emph on
operators 
\emph default
are used for transforming those observable streams.
 The operators act similarly to the concept of 
\emph on
lifting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, because they convert a function to be a 
\emph on
higher order function.
 
\emph default
A unary operator can be lifted by an operator 
\family typewriter
map
\family default
 that maps each item according to an argumented function.
 A binary operator can be lifted by an operator 
\family typewriter
CombineLatest
\family default
 works for two observable streams, mapping based on items from the two.
 The operators create an observable stream, subscribe to the argumented
 observable stream, and deliver items through the created observable stream.
 
\end_layout

\begin_layout Plain Layout
By using these concepts, the propagation change 
\emph on
may
\emph default
 be managed by the individual nodes.
 To support this, delivered items can contain meta-data in addition to the
 values 
\begin_inset CommandInset citation
LatexCommand cite
key "proencca2017quality"
literal "false"

\end_inset

.
 In addition, the dependencies 
\emph on
may
\emph default
 be managed by individual objects.
 However, if coordination is required between nodes or objects, then the
 problem of our initial discussion remains.
 Nevertheless, the presented concepts form the cornerstone of our approach.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Higher order functions upon reactive variables forms expressions that themselves
 become observable streams.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our approach is based on existing concepts borrowed from ReactiveX.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Approach
\end_layout

\begin_layout Plain Layout
Our approach to the problem requires investigating 
\emph on
cycles
\emph default
.
\end_layout

\begin_layout Subsection
Investigating Cycles
\end_layout

\begin_layout Plain Layout
Cycles are created in case that variables define each other (
\family typewriter
mutual recursion
\family default
).
 For instance, if 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are included in code, which means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is defined in term of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and vice versa.
 
\end_layout

\begin_layout Plain Layout
We would focus on a consequence dataflow.
 In the dataflow of a cycle, it must be, that one of the nodes has two incoming
 edges.
 This is clearly derived from the way we illustrate a cycle (depicted in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We start from an incoming edge (the dotted edge in the figure) into a node
 (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure), that is the cycle's first node.
 Then, we continue through several nodes until reaching again the first
 node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure) from another edge (in the figure, the edge from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 towards 
\begin_inset Formula $\LSTINLINE C$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$value$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1-1-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
For the node with the two incoming edges, we make a process like reverse
 engineering: from the dataflow we find the dependencies.
 It must be one of two options.
 In the first option, the node represents an input variable which also depends
 on an expression.
 In the second option, the node represents a variable that depends on two
 expressions simultaneously.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We investigate 
\emph on
cycles
\emph default
 by a process similar to reverse engineering.
 Typicaly, the process is that dependencies are declared first and the dataflow
 (propagation change) is determined according to the dependencies.
 By an example, the flow starts with declaring 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 This means that A depends on B and illustrated (similar to UML notation)
 as 
\begin_inset Formula $A\longrightarrow B$
\end_inset

.
 The consequence runtime is a dataflow or a propogation change from B to
 A, illustrated as 
\begin_inset Formula $B\longrightarrow A$
\end_inset

.
 In our investigation process, we starts from a dataflow, and then analyse
 the consequence dependencies.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Typically, dependencies are declared first, and the dataflow is then determined
 based on those dependencies.
 For example, declaring a dependency like 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 indicates that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 (A->B).
 From this dependency, the dataflow is determined from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 In our invetigation process, by analyzing the dataflow we determine dependencie
s.
\end_layout

\begin_layout Plain Layout
For investigating cycles, we take a reversed approach.
 We begin by investigating a dataflow, and from that dataflow, we determine
 dependencies.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the dataflow of a cycle, it must be that one of the nodes has two incoming
 edges.
 This is clearly derived from the way we illustrate a cycle (depicted in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We start from an incoming edge (the dotted edge in the figure) into a node
 (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure), that is the cycle's first node.
 Then, we continue through several nodes until reaching again the first
 node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure) from another edge (in the figure, the edge from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 towards 
\begin_inset Formula $\LSTINLINE C$
\end_inset

).
\end_layout

\begin_layout Plain Layout
Following the dataflow invetigation, we determine dependencies.
 For the node that has two incoming edges, it must be one of two options.
 First, the node represents an input variable which also depends on an expressio
n.
 In the second options, the node represents a variable that depends on two
 expressions simultaneously.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this case, an incoming value into the variable propagates through several
 nodes until reaching again the variable through the expression it depends
 on.
 For example, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is an input variable and it is declared
\end_layout

\begin_layout Plain Layout
For example, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable and it is declared that 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and also that 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

.
 In the second options, the node represents a variable that depends on two
 expressions simultaneously.
 An example for this case, is the previous example, while that 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is an input variable, and it is declared that 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
New Semantics
\end_layout

\begin_layout Plain Layout
From this investigation of cycles, we change from the reassignment question
 to 
\emph on
multiple assignments.
 
\emph default
Our assignment will perform
\emph on
 adding a dependency
\emph default
.
 A variable (
\family typewriter
RIVar
\family default
) can be assigned multiple times, and in each time the variable depends
 on a new expression in addition to existing dependencies.
 This leads that a single variable can be updated from several expressions.
 Additionally, all the variables are input variables that can be updated
 directly.
\end_layout

\begin_layout Plain Layout
Practically, our assignment operation performs that
\emph on
 the left-hand variable subscribes to the right-hand expression, such that
 the right-hand expression calls to the left-hand variable to update it
\emph default
.
 This concept is inspired from the observable streams abstraction.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Like that a high level function subscribes to observable streams, the assignment
 operation subscribes to the observable stream of the right-hand expression.
 However, the high level functions creates new observable streams, while
 the assignment operation deliver items to the existing observable stream
 of the left-hand variable.
\end_layout

\end_inset

 The assignment operation is like a 
\family typewriter
merge
\family default
 function.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
like 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://reactivex.io/documentation/operators/merge.html
\end_layout

\end_inset


\end_layout

\end_inset

 For each variable, it combines an observable stream that represents the
 variable with observable streams that represent the expressions assigned
 to the variable.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From this investigation upon cycles, we introduce semantics of 
\emph on
multiple assignments
\emph default
, a novel approach against the questioned reassignment.
\end_layout

\begin_layout Itemize
An assignment performs
\emph on
 adding a dependency
\emph default
 or 
\emph on
extending
\emph default
, rather than the reassignment, which is like
\emph on
 update
\emph default
 or 
\emph on
override
\emph default
.
\end_layout

\begin_layout Itemize
The assignment is an operation based on the 
\family typewriter
Observer
\family default
 pattern.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression calls to the left-hand variable to propogate
 changes.
\end_layout

\begin_layout Plain Layout
By using observable streams, we refer to 
\emph on
multiple assignments
\emph default
 similar to sampling a real world variable by a 
\emph on
multiple
\emph default
 sensors, with the need to merge the observable streams.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the delivery, we employee a 
\emph on
decentralized propogation change algorithm, that will achive predictability.
\end_layout

\begin_layout Plain Layout
we employee a 
\emph on
decentralized propogation change algorithm.
 
\emph default
We consider the specific delivery in the invetigation, in which the node
 was reached again.
 It had nothing to update, because it was not newer than the latest updated
 value.
 Accordingly, we employee a 
\emph on
decentralized propogation change algorithm
\emph default
 by which
\end_layout

\begin_layout Plain Layout
, the was nothing values was not newer.
 
\end_layout

\begin_layout Plain Layout
In the cycles investigation, in the delivery in which a node is reached
 again, the delivered item is not newer, therefore we would discard.
\end_layout

\begin_layout Plain Layout
From invetigating a change propogation through a cycles, it is desirable
 that 
\end_layout

\begin_layout Plain Layout
In the delivery we employee a 
\emph on
decentralized propogation change algorithm, by which we order the values,
 and discard absolete values 
\emph default
that is basicly, to discard absolete values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach, with an additional meaning similar to the inheritance mechanism
 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 We introduce a custom assignment operation for 
\family typewriter
RIVar
\family default
 based on the 
\family typewriter
Observer
\family default
 pattern.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression calls to the left-hand variable to propogate
 changes.
 This performs
\emph on
 adding a dependency
\emph default
 or 
\emph on
extending
\emph default
 (like inheritance), rather than the reassignment, which is like
\emph on
 update
\emph default
 or 
\emph on
override
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach, with an additional similar to the inheritance mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 We introduce a custom assignment operation for 
\family typewriter
RIVar
\family default
 based on the 
\family typewriter
Observer
\family default
 pattern.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression calls to the left-hand variable to propogate
 changes.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach, with an additional similar to the inheritance mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 We introduce a custom assignment operation for 
\family typewriter
RIVar 
\family default
that:
\end_layout

\begin_layout Itemize
Based on the 
\family typewriter
Observer
\family default
 pattern.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression calls to the left-hand variable to propogate
 changes.
\end_layout

\begin_layout Itemize
Performs
\emph on
 adding a dependency
\emph default
 or 
\emph on
extending
\emph default
 (like inheritance), rather than the reassignment, which is like
\emph on
 update
\emph default
 or 
\emph on
override
\emph default
.
\end_layout

\begin_layout Itemize
In propogating changes, raises changes according to an algorithm that deals
 with cycles correctly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An assignment operation, based on the 
\family typewriter
Observer
\family default
 pattern, performs that left-hand variable subscribes to get only relevant
 changes from the right-hand expression, based on the 
\family typewriter
Observer
\family default
 pattern.
 This will perform
\emph on
 adding a dependency
\emph default
 or 
\emph on
extending
\emph default
 (like inheritance), rather than reassignment, which is like
\emph on
 update
\emph default
 or 
\emph on
override
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach, a meaning similar to the inheritance mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 We introduce an assignment operation that enables 
\emph on
multiple assignments.
 
\emph default
That is to
\emph on
 add
\emph default
 or 
\emph on
extend
\emph default
, rather than the meaning of the reassignment
\emph on
 
\emph default
to
\emph on
 update
\emph default
 or 
\emph on
override
\emph default
.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach, which also harmonizes with the inheritance mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 We consider reassignment as 
\emph on
overriding a 
\emph default
dependency.
 Overriding has a negative impacts in objects inheritance, because it breaks
 exsting behavior rather than extending it.
 We introduce an assignment operation in which, the left-hand variable depends
 on the right-hand expression, as 
\emph on
adding
\emph default
 a dependency.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We introduce an assignment operation in which, the left-hand variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression.
 an assignment operation 
\emph on
adds
\emph default
 a dependency rather than 
\emph on
override
\emph default
 it
\emph on
.

\emph default
 The left-hand variable will depend 
\end_layout

\begin_layout Plain Layout
Instead of reassignment we introduce 
\emph on
extension with a new dependency
\emph default
.
 
\end_layout

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach.
 We introduce an assignment operation in which, the left-hand variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression.
 Therefore, assignment operation will facilitate, instead of reassignment,
 
\emph on
multiple assignments
\emph default
, or 
\emph on
extending with a new dependency
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The two questions, of reassignment and cycles are connected by a novel third
 approach.
 We introduce an assignment operation that enables multiple assignments,
 rather than reassignment, by which cycles are supported by design.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For facilitating FRP into component-based applications, an approach that
 still not researched is, what if an assignment means that the left-hand
 variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression.
 This approach is based on an existing concept that right-hand expressions
 are implemented as observables that trigger changes.
 Since assignment behaves like an operation, the assignment could be part
 of an indirect (object) interfaces
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, EDP still has an advantage in its ability to promote loose coupling
 between components.
 This is based on the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 In this pattern one component named 
\emph on
observable
\emph default
 triggers other components named 
\emph on
observers
\emph default
 about new content.
 An observable is decoupled from its observers, since its knowledge about
 them is limited to only hold their references (of type 
\family typewriter
Observer
\family default
) upon their registration for updates.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, EDP still has an advantage in its ability to promote loose coupling
 between components.
 This is achieved through the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 In this pattern, one component, the 
\emph on
observable
\emph default
, triggers other components, the 
\emph on
observers
\emph default
, about new content.
 The key to loose coupling lies in dynamic dispatch.
 The observable maintains a reference to observers using an interface (like
 Observer) but doesn't know their specific implementations.
 When notifying observers, the observable iterates through the list, and
 dynamic dispatch ensures that the appropriate update method is called on
 each observer based on its actual type.
 This allows for tailored behavior and flexibility without tight coupling
 between the observable and specific observer implementations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, EDP still has an advantage in its ability to promote loose coupling
 between components.
 This is based on the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 In this pattern one component named 
\emph on
observable
\emph default
 triggers other components named 
\emph on
observers
\emph default
 about new content.
 An observable is decoupled from its observers, since its knowledge about
 them is limited to only hold their references (of type 
\family typewriter
Observer
\family default
) upon their registration for updates.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, in this paradigm dependencies between variables are determined
 from executing the programs line by line.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(For facilitating FRP into component-based applications, an approach that
 still not researched is, what if an assignment means that the left-hand
 variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression.
 This approach is based on an existing concept that right-hand expressions
 are implemented as observables that trigger changes.
 Since assignment behaves like methods, it facilitates 
\emph on
dynamic dispatch.

\emph default
 In OOP, dynamic dispatch is a mechanism where the specific method to be
 called is determined at runtime based on the object's actual type.
 Consequently, it would be supported to assign variable through an interface,
 while the actual variable being assigned will be determined in runtime.
 
\end_layout

\begin_layout Plain Layout
For facilitating FRP into component-based applications, an approach that
 still not researched is, what if an assignment means that the left-hand
 variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression.
 This approach is based on an existing concept that right-hand expressions
 are implemented as observables that trigger changes.
 The current approach facilitates 
\emph on
dynamic dispatch
\emph default
, such that an actual left-hand variable is determined at runtime.)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The directed calls in subscribing means to not depend on a madiator.
 In particular, it facilitates 
\emph on
dynamic dispatch
\emph default
, such that the actual left-hand variable is determined at runtime.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In using the 
\family typewriter
Observer
\family default
 pattern, an approach that still not researched is, what if an assignment
 means that the left-hand variable subscribes to get changes from the right-hand
 expression 
\emph on
directly
\emph default
.
 The directed calls in subscribe has a meaning to not depends on a madiator.
 It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 achieves a deterministic execution order, a propagation algorithm of a
 depth-first search (DFS) traversal, rooted in the variable being updated.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
This enables to assign variable that exposed from a component
\end_layout

\begin_layout Plain Layout
rather than initiating a variable according to the right-hand expression,
 will register the left-hand variable to be directly updated to changes
 of the right-hand expression.
\end_layout

\begin_layout Plain Layout
In this thesis, we introduce a concept named RIVar as a short name to Reactive
 Instance Variable.
\end_layout

\begin_layout Plain Layout
As Object Oriented Programming (OOP) formalizes and emphasizes components,
 RIVar 
\end_layout

\begin_layout Plain Layout
This concept harmonizes 
\end_layout

\begin_layout Plain Layout
In this thesis, we introduces a concept that an assignment, rather than
 initiating a variable according to the right-hand expression, will only
 register the left-hand variable to be directly updated to changes of the
 right-hand expression.
\end_layout

\begin_layout Plain Layout
However, EDP has also an advantage that it is used to decouple components
 from each other.
 This is based on the observer pattern, such that an observable trigger
 interested parties about new content.
\end_layout

\begin_layout Plain Layout
In a similar setting, an assignment operator, rather than initiating a variable
 according to the right-hand expression, will only register the left-hand
 variable to be updated to changes of the right-hand expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 This has in common with one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This also has in common with constraints programming with the name one-way
 dataflow constraint
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, on top of events programming (or the Observer pattern), this setting
 is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
 
\end_layout

\begin_layout Plain Layout
A significant problem in this setting is 
\emph on
cycles
\emph default
 or 
\emph on
loops
\emph default
 that might be produced from creating 
\emph on
mutual recursions
\emph default
.
 In EDP, events raise more events inawaring by which they originaly raises.
 This might lead to loops, such that an event is raised indirectly by itself,
 and need to make an algorithm that stops the loop.
 For reactive variables, mutual recursions can be created causing such loops
 that lead to redundant updates for the variables.
 For example, A:=B and B:=A that produces A.changed += { (e) -> B.Change(e.value)
 } and B.changed += { (e) -> A.Change(e.value) }.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
The novality in RIVar is that can be exposed as part of an interface, and
 it facilitates dynamic dispatch, such that 
\end_layout

\begin_layout Plain Layout
We introduce a concept named 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s harmonize reactive variables with instance variables (i.e., fields associated
 with objects).
 RIVar can be exposed as objects and interfaces, and RIVars exposes an assignmen
t that 
\end_layout

\begin_layout Plain Layout
We introduce a concept named 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We present a conceptual framework in which FRP is embedded into Object Oriented
 Programming (OOP) for adapting in components applications.
 At the core of this framework is a named
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 We provide implementations of our framework in both C# (RIVarX) and JavaScript
 (rivarjs), along with a small application example.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We introduce a new propagation algorithm with the following properties.
\end_layout

\begin_layout Description
Decentralized
\end_layout

\begin_layout Description
Predictable
\end_layout

\begin_layout Description
Cycles
\end_layout

\begin_layout Plain Layout
We introduce a framework with the following properties.
\end_layout

\begin_layout Description
OOP Variables exposed from objects, Assignments initiate dependencies
\end_layout

\begin_layout Description
FRP
\end_layout

\begin_layout Description
Constraints
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) is a concept from the 
\family typewriter
Reactive Programming
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 paradigm that aims to solve problems in 
\family typewriter
Events Driven Programming
\family default
 (EDP) paradigm.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While event-driven programming encompasses various mechanisms, this discussion
 is limited to its implementation using the Observer pattern.
 This pattern allows objects to register interest in events and be notified
 when they occur, fostering loose coupling and flexibility.
\end_layout

\end_inset

 The origin of reactive variables is from the 
\family typewriter
Functional Reactive Programming
\family default

\begin_inset space ~
\end_inset

(FRP) paradigm, that aims to use principles from the 
\family typewriter
Fucntional Programming
\family default
 (FP) paradigm.
 Reactive variables have a representation similar to pure functions in FP,
 in expressing code that calculate needed output based on arguments.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 is similar to function A(B){return B+1}.
 The meaning is similar to functions in mathematics
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Function_(mathematics)
\end_layout

\end_inset


\end_layout

\end_inset

 as a model of how varying values (real-world variables) depend one on another.
\end_layout

\begin_layout Plain Layout
Frameworks that implement reactive variables enable to model varying values
 by re-evaluating values automaticaly.
 Typically, these frameworks initiate dependencies, track them, and re-evaluate
 values in response to changes in the dependencies.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), in expressing 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, a dependency is initiated, such that A depends on B, such that whenever
 B has a change, A will be updated accordingly.
\end_layout

\begin_layout Plain Layout
The reactive variable abstraction makes the dependency between variables
 explicit, rather than in the traditional EDP 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 For example, in 
\family typewriter
EScala
\family default
 [16], in order to implement 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is achieved by calling an event, namely, changed, assuming that the object
 B has that event: 
\begin_inset Formula $\LSTINLINE{B.changed(newValue);}$
\end_inset

 The behavior executed when that event is fired is registered as an event
 handler that calculates the power difference for the motor as follows:
 
\begin_inset Formula $\LSTINLINE{B.changed+={(e)->A=e+1}}$
\end_inset

.
 Whereas the firing of an event is placed in the code that reads the sensor
 value, the event handler is declaratively represented.
 Thus, both are separately represented, and the dependency between 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

 is implicit.
\end_layout

\begin_layout Plain Layout
Despite the advantages of reactive variables, the traditional representation
 offers benefits for component-based applications.
 Modern component technologies, including microservices and micro-frontends,
 which formalizes and emphasizes in Object Oriented Programming (OOP) paradigm.
 A key strength of both OOP and component technologies is the use of events
 to decouple components.
 This decoupling promotes loose coupling, which improves maintainability,
 reusability, and testability in component-based systems.
\end_layout

\begin_layout Plain Layout
In this thesis, we focus on a setting that an assignment operator, rather
 than initiating a variable according to the right-hand expression, will
 register the left-hand variable to be updated to changes of the right-hand
 expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 
\end_layout

\begin_layout Plain Layout
This setting has advantages and disadvantages.
 The advantage is that it is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
 The disadvantage is that cycles can be created in the dependencies, which
 leads to loops in the updates.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
A setting used in one-way databinidng (for example <h2 innerHTML="{{ text
 }}"></h2>) and also in one-way dataflow constraint 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

, that 
\end_layout

\begin_layout Section
The Concept
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
In this thesis, we introduce a concept named RIVar as short name to reactive
 instance (or interface) variable.
 RIVar exposes an assignment operator that produces the needed steps, in
 terms of regitering to events, to make a left-hand variable to depend and
 be updated according to the right-hand expression.
 Basicly, an expression A:=B will produce something like A.changed += { (e)
 -> B.Change(e.value) }.
 Similarly, an expression like X.A:=B is applicable for an object X that
 exposes a variable.
 This opens a challenge, that we adress as well, that FRP still does not
 have a good answer for: how to deal with cycles.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, the old representation has an advantage for components-based applicatio
ns.
 Current components technalogy includes: micro-services, micro-frontends
 and so on.
 A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In components technalogy and OOP, events enable to decouple components
 from one another.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The traditional EDP achieves similar functionality, but requires a more
 verbose implementation.
 First, a variable is declared.
 Second, a change event associated with that variable is defined.
 Third, whenever the variable is updated, the change event is raised.
 Finally, event handlers can be registered to listen for this event and
 execute code that updates other variables.
\end_layout

\begin_layout Plain Layout
EDP is an important concept needed to components-based applications.
 Current components technalogy includes: micro-services, micro-frontends
 and so on.
 Even though they are popular, they does not provide a scalable solution
 for handling variables or 
\emph on
state.

\emph default
 State refers to what software remembers from past used to its future behavior.
 Generaly, it refers to any changeable data, stored anywere, used to determine
 output.
 In order to response to another component's changes, usualy code is registered
 to an exposed event.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 
\end_layout

\begin_layout Plain Layout
It has been suggested to connect between the EDP and FRP, connecting concepts
 from the two worlds.
 For example, in 
\family typewriter
REScala
\family default
, convertions functions does convertions between reactive variables and
 events 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In addition, it has been suggested, that a change in ractive variable raises
 an event and considered as 
\emph on
side effect
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 In addition, stream of events represents by a few as reactive variables
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
In this approach, operators over streams produce behavior similar to frameworks
 that support reactive variables.
\end_layout

\begin_layout Plain Layout
However, traditional 
\family typewriter
Events Driven Programming
\family default
 (EDP) or the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

 is still in demand.
 Events enable service's consumer to register 
\end_layout

\begin_layout Plain Layout
In components technalogy, Current components technalogy includes: micro-services
, micro-frontends and so on.
 A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In EDP, in order to sync between variables, several steps are needed.
 First, declaring a variable.
 Second, declaring a change event.
 Third, raise the event whenever the variable is updated.
 Finaly, registering an event handler, with code that update the other variables.
 This process enable to decouple between components, as code that change
 a variable need not to be aware of the code that change the second variable.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Even though they are popular, they does not provide a scalable solution
 for handling variables
\end_layout

\begin_layout Plain Layout

\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis' focus on feasibility for scalable technalogies of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In this thesis, we focus on an idea that the explicit syntax for initiating
 dependencies, will produce events driven programming, as the mean of an
 assignment operator.
 Basicly, an expression A:=B will produce something like A.changed += { (e)
 -> B.Change(e.value) }.
 Similarly, an expression like X.A:=B is applicable for an object X that
 exposes a variable A.
 The assignment operator produces the needed steps to make a left-hand variable
 to depend and be updated according to the right-hand expression.
 This opens a challenge that FRP still does not have a good answer for:
 how to deal with cycles.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We propose a conceptual framework that harmonizes the concept of reactive
 variable with existing development environment, by depending on the events
 driven programming and the observer pattern.
 In this framework we introduce a noval approach in handling cycles in the
 dependencies.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Reactive variables are similar to one-way dataflow constraint of constraints
 systems.
 In constraints systems, a set of equation is provided to the system, and
 in runtime the systems search for solutions to satisfy the equations.
 For GUI, the user would set values to variables, and in response a component
 named constraints solver would find a solution, such that most of constaints
 would be satsified
\end_layout

\begin_layout Plain Layout
are basicly declared like functions with arguments.
 Automaticaly, the reactive variables are updated in response to changes
 in the values
\end_layout

\begin_layout Plain Layout
, and are updated automaticaly in response to changes
\end_layout

\begin_layout Plain Layout
replace the error prone events driven programming
\end_layout

\begin_layout Plain Layout
Events Driven Programming is a paradigm in which code can be registered
 to an event, by which data can be sync.
 For example, assuming that the object sensorValue has that event: sensorValue.ch
anged(newValue); The behavior executed when that event is fired is registered
 as an event handler that calculates the power difference for the motor
 as follows: sensorValue.changed += { (e) -> powerDierence = f(e) },Whereas
 the firing of an event is placed in the code that reads the sensor value,
 the event handler is declaratively represented.
 Thus, both are separately represented, and the dependency between sensorValue
 and powerDierence is implicit.
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming is a paradigm derived from the Functional
 Programming paradigm and aims to replace the Events Driven Programming.
 The approach given by FRP, is that developers declare functions which initiate
 dependencies by which change ate automaticaly ptopagated.
 For example, powerDierence = f(sensorValue) makes that whenever sensorValue
 is changed, f is re-eavluated, and powerDierence is updated.
 In FRP, the dependencies are in a tree, without cycles.
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming is a paradigm derived from the Functional
 Programming paradigm.
 In FRP, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This syntax makes the dependencies directed or explicit compared to the
 traditional events programming.
 
\end_layout

\begin_layout Plain Layout
In events programming, code is registered to an event, and the code makes
 the updates.
 we write sensorValue.changed(newValue); and sensorValue.changed += { (e)
 -> powerDierence = f(e) } using reactive variables, we just write powerDierence
 = f(sensorValue).
 
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
This thesis' focus on feasibility for scalable technalogies of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 It has a 
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 Caused by event driven programming, code logic is spread over many functions.
 chain of updates executed through many code locations can sometimes be
 horrible.
 It is known as it is hard to reason about.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
\end_layout

\begin_layout Plain Layout
, enables to extend objects by register methods to execute
\end_layout

\begin_layout Plain Layout
Basicly, the problem in state management is that chain of updates executed
 through many code locations can sometimes be horrible.
 It is known as it is hard to reason about.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
 This problem is usualy caused by the event driven programming, as the code
 logic is spread over many functions.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP), while it does bear from related difficulties as well
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
An enhancement for managing state is a concept named 
\emph on
reactive variable
\emph default
 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

).
 The idea is that functions and variables are lifted so that assignments
 are applied for a long term.
\end_layout

\begin_layout Plain Layout
Various frameworks enable to declare depedencies to make dependencies more
 directed than in the events driven paradigm.
\end_layout

\begin_layout Plain Layout
This enables direct dependencies compared to the events driven paradigm.
 For example, in events driven paradigm, we write sensorValue.changed(newValue);
 and sensorValue.changed += { (e) -> powerDierence = f(e) } using reactive
 variables, we just write powerDierence = f(sensorValue).
 The idea is that functions and variables are lifted so that assignments
 are applied in a long term.
\end_layout

\begin_layout Plain Layout
Events driven paradigm fit to components, makeing it enabled to extend them.
\end_layout

\begin_layout Plain Layout
In contrast, reactive variables do not.
 (but they better in the declerative style).
\end_layout

\begin_layout Plain Layout
we introduce an harmonized concept named reactive instance (or interface)
 variable (RIVar).
 In the new concept, the assignment establishes a continuous association,
 and also be called similar to an operation, without to determine type or
 internal details.
 For example, given RIVars B and C and also an object X that contains a
 RIVar A, performing X.A:=B+C are performed for various types of X, such
 that assignment is a method that establish the continuous association.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is inspired from the functional paradigm, producing hirarcial data
 dependencies.
 This paradigm uses a dedicated framework, that propgate the changes automatical
y and predictability.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
In this work, we develop an idea that an assignment produces a subscribtion
 directly.
 For example, powerDierence = f(sensorValue) produces sensorValue.changed
 += { (e) -> powerDierence = f(e) }
\end_layout

\begin_layout Plain Layout
We introduce a concept named RIVar, that is Reactive Instance (or Interface)
 Variable.
 RIVar harmonizes the concept reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and a concept named instance variable from the Object Oriented paradigm.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An enhancement for this subject is a concept named 
\emph on
reactive variable
\emph default
 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) can be specified by a declarative manner, sometimes 
\emph on
lifting
\emph default
 a call-by-value programming language
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Consider 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 (depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

) of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 (using syntax specified by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset

).
 The expression associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to (or changes in a value
 of) 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Further, expressing 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 means an input of 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , which triggers to change a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE2$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE+$
\end_inset

 in the example) are converted (or lifted) from operating over values to
 operate over reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Generally, such associations establish 
\emph on
data dependencies
\emph default
, in which a left-hand variable depends on variables in a right-hand side.
 According to dependencies, variables are continuously re-evaluated, by
 change propagation processes.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
In case of a push notification, a chain of updates even may produce an infinite
 loop, in case of an accidental cycle.
\end_layout

\begin_layout Plain Layout
(Cascading updates across numerous, scattered code locations can quickly
 become a maintenance nightmare.
 A centralized state management approach is often a safer and more manageable
 solution.
 This is because dispersed updates make it notoriously difficult to trace
 the origin, timing, and cause of a value change ("hard to reason about").
 For instance, when inspecting a variable, it can be a daunting task to
 determine who modified it, when, and why.
 Even worse, in case that a change triggers a cascade of updates that form
 a cycle, an accidental infinite loop can occur, leading to an endless and
 potentially damaging process.)
\end_layout

\begin_layout Plain Layout
In a recent reaserch in reactive programming (RP) paradigm, a direct syntax
 for data depedencies is presented to replace the tradtional event driven
 programming.
 In RP, decalring A:=B is like A.changed+=A_changed; and in A_changed it
 is specfied to update B.
 In order to handle cycles
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\emph on
Reactive variable
\emph default
 is a variable abstraction in which the assignment operator establishes
 dependencies, such that an assigned variable becomes dependent on the variables
 within the assigned expression, therefore updated in response to their
 updates.
 For example, given variables A, B, and C, the formula A := B + C means
 that whenever B or C are updated the operation + is executed on the values
 that B and C contain, and update A with the result.
 This declarative style produces a 
\emph on
single source of truth
\emph default
, rather than repetition calls to update variables in many code locations.
\end_layout

\begin_layout Plain Layout
This arises questions on such abstraction feasibility for scalable technalogies
 of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
 
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In this paradigm, an inheritance is a usefull meha
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Paragraph
Contribution
\end_layout

\begin_layout Itemize
Defining a total order on the set of updates, by which a feedback is less
 than a current, and would be ignored.
\end_layout

\begin_layout Itemize
providing a general reactive framework that takes care of propogating changes
 in th correct order.
\end_layout

\begin_layout Plain Layout
If all values to update are attached with timestamps, then it would be feasible
 to compare each new value, if it is updated than the previous
\end_layout

\begin_layout Plain Layout
By far, it does reflect the described challenges.
 In OOP, an object encapsulate variables and expose operations.
 In case that an objects operation calls another object's operation and
 so on, producing a chain of operations, it might re-entrance the same object
 by calling again an operation in this chain.
 The latter call might be unexpected, as the first call did not finish,
 and it is in the mid of its work, with some variables updated, and some
 still not.
\end_layout

\begin_layout Plain Layout
some variables are unpdated, and some other will be updated only in the
 end of the first oprt, the object might contain inconsistency 
\end_layout

\begin_layout Plain Layout
it has reliability mainly on passive and stateless ones.
 
\end_layout

\begin_layout Plain Layout
reliability is provided is mainly on passive and stateless components.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Or+++++iented
 Programming (OOP).
 Even though OOP is highly used, it has been criticized that it has problems
\end_layout

\begin_layout Plain Layout
Components can be passive.
 For example, rest services are available to anyone to be called.
 Such components does not have 
\end_layout

\begin_layout Plain Layout
Components can be stateless, which means that they does not hold variables
 or datastore.
 However, 
\end_layout

\begin_layout Plain Layout
This arises questions around feasibility for scalable technalogy of 
\emph on
reactive 
\emph default
or
\emph on
 stateful components
\emph default
.
 Components are sort of micro services, micro frontends, react components,
 OOP, plugins and so on.
 Components can be passive, that means that clients calls their services.
 Reactivity means that components react to 
\end_layout

\begin_layout Plain Layout
Reactivity means to listen to input over time and to produce output
\end_layout

\begin_layout Plain Layout
Reactive components first need to be stateful.
 They use internal state to determine output according to input.
 A paradigm that formalizes and emphasizes stateful components that interact
 through directed and indirected messages is Object Oriented Programming
 (OOP).
 
\end_layout

\begin_layout Plain Layout
Altough that centralized state management is safer, components-based programming
 is in demand.
 For exmaple, micro services, micro frontends, react components, OOP, plugin
 architeture and so on.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Chain of updates composed of many code locations can sometimes be horrible.
 It is much more safe to manage it centralizly.
 It is known as 
\begin_inset Quotes eld
\end_inset

it is hard to reason about
\begin_inset Quotes erd
\end_inset

.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
 In case of a push notification, a chain of updates even may produce an
 infinite loop, in case of an accidental cycle.
\end_layout

\begin_layout Plain Layout
Conceptual Framework
\end_layout

\begin_layout Itemize
decentralized (appropriate to stateful components)
\end_layout

\begin_layout Itemize
explicit dependencies (like spreadsheet, not handling state and events)
\end_layout

\begin_layout Plain Layout
Features
\end_layout

\begin_layout Itemize
Add Filling Option
\end_layout

\begin_layout Plain Layout
My idea is that
\end_layout

\begin_layout Itemize
a:=exp is implemented as exp.Subscribe(a.next())
\end_layout

\begin_layout Itemize
multiple assignments makes sum streams to merge
\end_layout

\begin_layout Itemize
an decnetralized online algorithm with an sort function over the propagated
 values
\end_layout

\begin_layout Plain Layout
results
\end_layout

\begin_layout Itemize
code reuse frp+oop
\end_layout

\begin_layout Itemize
dectralized contraints system
\end_layout

\begin_layout Plain Layout
ReactiveX is a library that provide FRP on top of OOP.
 It expose a function (named operator) Map that map each item according
 to an argument function.
\end_layout

\begin_layout Plain Layout
with an observable argument and return an observable that each item is produced
 in response to an item in the argumented observablr.
 
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
Handling 
\emph on
state
\emph default
 is an important aspect in programming.
 State refers to what software remembers from past used to its future behavior.
 It is represented as changeable data, stored anywere, used by the applcation
 to determine its output.
 Basicly, variables that contain values represent an application state.
 Components with state are referred to as 
\emph on
stateful components.

\emph default
 A paradigm that formalizes and emphasizes stateful components that interact
 through directed and indirected messages is Object Oriented Programming
 (OOP).
 
\end_layout

\begin_layout Plain Layout
Recently, a paradigm Functional Reactive Programming (FRP) becomes attractive
 in in focusing on network models.
 The variables are represented as nodes linked to each other propagating
 changes in repsonse to new input.
 The framework usualy 
\end_layout

\begin_layout Plain Layout
OOP formalizes and emphasizes the idea of stateful components that interact
 through directed and indirected messages.
 Components-based applications are useful, and hand
\end_layout

\begin_layout Plain Layout
State is an important aspect in applications.
 It can be managed as a centralized component.
 
\end_layout

\begin_layout Plain Layout
In beceknd, stateless components are generally easier to manage.
 as they can be readily replicated across multiple servers without the need
 for complex synchronization or state sharing between instances.
 In backend, the state is the database.
\end_layout

\begin_layout Plain Layout
State are sometimes managed in one component, the database
\end_layout

\begin_layout Plain Layout
as they can be readily replicated across multiple servers without the need
 for complex synchronization or state sharing between instances.
\end_layout

\begin_layout Plain Layout
as it is usualy distingwished between stateful and stateless components.
 
\end_layout

\begin_layout Plain Layout
Components used to be called stateful in case that they manage a state
\end_layout

\begin_layout Plain Layout
In microservices architecture, a key distinction is made between stateful
 and stateless components.
 Stateless components are generally easier to manage as they can be readily
 replicated across multiple servers without the need for complex synchronization
 or state sharing between instances.
 In micro-frontend architeture, managing state is one of the key chalenges.
 
\end_layout

\begin_layout Plain Layout
In micro services, it is distingwished between stateful and stateless components.
 Components that are stateless, are easier as they are easily replicated
 across multiple servers, because there is no need to synchronize or share
 state between instances.
 In front end applications, micro frontends need to cope how to interact
 to manage state.
\end_layout

\begin_layout Plain Layout
Basicly, variables that contain values represent an application state.
 
\end_layout

\begin_layout Plain Layout
Simply, it is variables that hold values.
 
\end_layout

\begin_layout Plain Layout
State is an important aspect for applications in all levels.
 In micro services, it is distingwished between stateful and stateless component
s.
 Components that are stateless, are easier as they are easily replicated
 across multiple servers, because there is no need to synchronize or share
 state between instances.
 In front end applications, micro frontends need to cope how to interact
 to manage state.
\end_layout

\begin_layout Plain Layout
As microarchitecture evolves, enhancing the capabilities of stateful components
 is a natural progression.
 The paradigm that formalizes and emphasizes this idea is Object Oriented
 Programming (OOP).
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
is much more easy becauses it does not change behavior over time, and can
 be replicated without need to synchronize or share state between instances.
\end_layout

\begin_layout Plain Layout
State is a very important aspect.
 In software design, it is often distingwished between statefull components
 and stateless ones.
 Stateless is much more easy becauses it does not change behavior over time,
 and can be replicated without need to synchronize or share state between
 instances.
\end_layout

\begin_layout Plain Layout
Often state is represented as variables that hold values, but it refers
 to any data stored anywere used by the applcation to determine its output.
 Over time, applications' state are changed by updating 
\end_layout

\begin_layout Plain Layout
It is desirable to harmonize the concept Reactive Variable in Object Oriented
 Programming (OOP).
 OOP formalizes and emphasizes the idea of stateful components that interact
 through directed and indirected messages.
 Components-based applications are useful, and hand
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In Reactive Programming, there is a research exploring programming models
 of networks of variables that are interconnected based on how their values
 should be inferred or derived from each other.
 Such a programming model affects the framework or the syntax to be clear
 and easy to develop compared to traditional, because the syntax says explicity
 what traditional been written implicity.
 For example, A:=B+C explcity declares the dependancy of A on B+C, while
 traditionaly we could only develop a process: 
\begin_inset Quotes eld
\end_inset

whenever B or C are updated the operation + is executed on the values that
 B and C contain, and update A with the result.
 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout
As implemented by many, the netwrok is implemented as a data strcuture in
 memory, such that an intermidate madiator manage the values according to
 the network.
 Another implementation category, is for distributed applications.
 Therefore, the programs are turned into farmewokrs like actor based model,
 such that messages are sent over a network, and need a deceltralized approach
 (here, madiator is not good).
 In another implementation, it is neither relay on a madiator, nor itended
 to distributed applications, however it is still decntralized by depending
 on the observer pattern.
 
\end_layout

\begin_layout Plain Layout
Among many other challenges, we focus on three.
 First, cycles, when and how to break them to not infinitely continue the
 updates.
 Second, centraliztion madiator - coupling.
 Finaly, the obvious principle of code reuse, is not completlly achived
 for any application.
\end_layout

\begin_layout Plain Layout
We turn reacticeX from 
\begin_inset Quotes eld
\end_inset

functions over streams
\begin_inset Quotes erd
\end_inset

 into such a network model, We implement A:=B as A.suscribe(B.next()).
 We build an online distirbuted algorithm
\end_layout

\begin_layout Plain Layout
The core reusbability and decoupling 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In Reactive Programming, it has been presented that applications' state
 can be managed by a programming model of a network of variables connected
 to each other according to how they should be inferred from each other.
\end_layout

\begin_layout Plain Layout
a programming model of a network-like has been presented a programming model
 such that variables are connected 
\end_layout

\begin_layout Plain Layout
Many programming frameworks uses a programming model related to a network
 for managing , such that each node is a variable or a data store, and the
 edges represent 
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
A statement like A:=B+1 has diffrent distinct meaning across programming
 languages and frameworks.
 In the imperative paradigm, that is the traditional conventional way of
 programming, A is a 
\emph on
variable
\emph default
, which means a memory location, similar to a data store.
 The sign := is named 
\emph on
assignment
\emph default
, which means that the value from evaluating the right hand side is copied
 into A, such that A will contain that value.
 Rather, in constraints programming, the statement means that the framework
 will automaticaly adjust the values according to the statement as a constraint.
 In reactive programming and also in one-way dataflow constraints, it means
 that the left hand variable (in the statement, it is A) will continously
 be adjusted according to the right hand side.
\end_layout

\begin_layout Plain Layout
The assignment in reactive programming harmonize two meanings.
 First, it binds a name to an expression 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Reactive Variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) are like variables that abstract out repetetive code, related to their
 updates.
 For example, usualy in order that a variable A will continously contains
 B+C, we should update A in two code locations, of when B and C are updated.
 In contrast, using reactive variables, it is enough to just declare A:=B+C,
 while the actual updates are managed automatically.
 This is depicted in figure XXX.
 An input for B (B=1), then an input for C (C=2), in response A contain
 3.
\end_layout

\begin_layout Plain Layout
One library mentioned as one that implements reactive variables is named
 ReactiveX.
 Actualy ReactiveX implements 
\emph on
observable streams
\emph default
 based on the observer (and more) design pattern.
 Observable streams are objects that contain a subscribers list, to which
 they emit items over time.
 With a form of reactive variables, the items are value changes.
 Often those objects are both observable streams and subscribers.
 In such cases, they emit value changes in response to changes in observable
 streams they are subcsribed to.
 This is applied using 
\emph on
operators
\emph default
.
 For example, given observable streams B and C, the operator CombineLatest
 in A = B.CombineLatest(C, (b, c) => b + c) establishes subscriptions to
 both B and C.
 Whenever either B or C emits a new value, the lambda expression (b, c)
 => b + c is executed.
 Here, b represents the latest emitted value from B, and c represents the
 latest value from C.
 The results are collected as a new observable stream A, such that each
 result is then emitted as the next value in A.
 Another operator named merge subscribed to two observable streams and produced
 an observable stream by passing any item from any of them.
\end_layout

\begin_layout Plain Layout
Extending the concept to form reactive instance variables seems quit easy
 and powerfull for code reusability.
 Given RIVars A,B and C, where object X contains the A, in expressing X.A:=B+C,
 we achive code reuse, with the support for varying types for X.
 In inheritance, code reuse should be achived directly.
 For example, a subclass contains A:=B+C, while A is a member of its superclass.
\end_layout

\begin_layout Plain Layout
However, this is tricky, since it is unclear what is this assignment actualy
 means.
 In functional programming , from where reactive variables have been branched,
 it is unabled to assign value, instead values are bound, without an ability
 to replace it.
 
\end_layout

\begin_layout Plain Layout
in imperative paradigm an assignment means an update, or replace the previous
 value with a new one.
 
\end_layout

\begin_layout Plain Layout
This focus on ReactiveX is since it uses OOP thst used to enhance code reusabili
ty.
 For example, the plugin architecture allows a single code product to perform
 various tasks by incorporating customized processes triggered by specific
 events.
 Another example is the reusability of GUI components, which saves developers
 from programming GUIs from scratch.
 We therefore need to use the observer pattern to perform RIVars and reuseabilit
y.
 
\end_layout

\begin_layout Plain Layout
Code reuse in OOP is produced by inheritance and also by polymorphism.
 We start from polymorphism.
 Given RIVars A,B and C, where object X contains the A, in expressing X.A:=B+C,
 we hope to achive code reuse, with the support for varying types for X.
 In inheritance, code reuse should be achived directly.
 For example, a subclass contains A:=B+C, while A is a member of its superclass.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
OOP is associated to design patterns that improve code reuse.
 For example, using the plugin architeture, various applications can be
 performed by a code product with customized processes trigerred in certain
 events.
 Another example, is GUI components can be reused, rather than programming
 GUI from sctractch.
 The two examples are related to the observer pattern.
 This pattern perform creating objects named observables for whom other
 objects, named obsrvers can be subscribed.
 The observables calls the observers without determine their type or internal
 details.
 In this was, we create highly reusable code, as we can extend the observable
 be adding processes to be executed during (in certain events) its existing
 processes.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Inspired from ReactiveX, 
\end_layout

\begin_layout Plain Layout
In comparing the neat syntax against that of ReactiveX, 
\end_layout

\begin_layout Plain Layout
ReactiveX has a verobe syntax.
 Instead of just :=, we need to the operator CombineLatest
\end_layout

\begin_layout Plain Layout
by continuous associations
\end_layout

\begin_layout Plain Layout
Subscribers are often also observable streams, that in our terms are reactive
 variables that 
\end_layout

\begin_layout Plain Layout
For example, we can produce similar to A:=B+C by expressing A=B.CombineLatest(C,
 (b,c)=>b+c)).
 Whenever B or C 
\end_layout

\begin_layout Plain Layout
given observable streams B and C 
\end_layout

\begin_layout Plain Layout
with a verbose syntax.
 A formula A:=B+C is expresses A=B.CombineLatest(C, (b,c)=>b+c)) 
\end_layout

\begin_layout Plain Layout
ReactiveX imeplemts actualy observable streams.
 This uses a concept harmonized several design patterns.
 
\end_layout

\begin_layout Plain Layout
Therefore, it has a verbose langiage, for example, the neat formula A:=B+C
 in ReactiveX A=B.CombineLatest(C, (b,c)=>b+c))
\end_layout

\begin_layout Plain Layout
In one popular library named ReactiveX, reactive variables are provided
 as observable streams.
 Observable streams are 
\end_layout

\begin_layout Plain Layout
One interseting implementations for reactive variables are named Reactive
\end_layout

\begin_layout Plain Layout
Nevertheless, in using the old OOP patterns, code reuse is highly performed.
 For example, using the plugin architeture, various applications can be
 performed by a code product with customized processes trigerred in certain
 events.
 Another example, is GUI components can be reused, rather than programming
 GUI from sctractch.
 The two examples are related to the observer pattern.
 This pattern perform creating objects named observables for whom other
 objects, named obsrvers can be subscribed.
 The observables calls the observers without determine their type or internal
 details.
 In this was, we create highly reusable code, as we can extend the observable
 be adding processes to be executed during (in certain events) its existing
 processes.
\end_layout

\begin_layout Plain Layout
We focuse on ReactiveX, in our way to harmonize the concepts.
 ReactiveX provides concepts similar to reactive variables that is implemnted
 internaly using OOP patterns.
 It uses the observer pattern.
 An observer must have a method named 
\emph on
next.
 
\emph default
an observable calls its subscribers'
\emph on
 next
\emph default
 that informs them about a value change.
 For example, given A as an observable and B as an observer A will be subscribed
 like 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val+1))}$
\end_inset

.
 Very often, objects are both an observer and observable, therefore the
 executions of next, forward the changes for further objects.
 In the example, given B as both an observer and an observale, and another
 observer C, C will be subscribed to further forward the changes like 
\begin_inset Formula $\LSTINLINE{B.subscribe(val=>C.next(val+1))}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
objects often are both an observer and observable, therefore the executing
 of next, will forwars further subscribers.
\end_layout

\begin_layout Plain Layout
One interestting implementation of reactive variables by using the observer
 and more OOP patterns is ReactiveX.
 In this library, an observer must have a method named 
\emph on
next
\emph default
.
 an observable is reactive variable, by executing its subscribers'
\emph on
 next
\emph default
 whenever it informs about a new value.
 objects often are both an observer and observable, therefore the executing
 of next, will forwars further subscribers.
 For example, given A as an observable and B as an observer A will be subscribed
 like 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val+1))}$
\end_inset

, so that whenever the next in A is exeuted, the next in B will exeuted.
 
\end_layout

\begin_layout Plain Layout
Going further, various operations are implemnted to handle observables as
 values by functions, making them similar to the concept of reactive variables.
\end_layout

\begin_layout Plain Layout
an operation named map has an observable argument and returns another observable
, that map each value of the argumented observable into another values in
 the returned observable.
\end_layout

\begin_layout Plain Layout
An operators the uses these interfaces provides code style that is similar
 
\end_layout

\begin_layout Plain Layout
This We declared an implementation similar to 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, becasue 
\end_layout

\begin_layout Plain Layout
Reactive variables like asbtarction are introduced by using several OOP
 patterns.
\end_layout

\begin_layout Itemize
Explain X:=Y+Z, that it is instead of calling to calculate two times.
\end_layout

\begin_layout Itemize
Explain the code reuse perforned in using observer pattern
\end_layout

\begin_layout Itemize
Explain how reactive variables are implemented as observables streams, map
 and combine latest.
 how these operator works by subscribe
\end_layout

\begin_layout Itemize
the two methods are combined using Subscribe as an assignment operation.
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
An assignment establishes a continuous association, while the left hand
 variable is accessed similar to while it is like an operation the left
 hand variable is like a dynamic type.
\end_layout

\begin_layout Plain Layout
and also can be perfomed without to determine the left-hand 
\end_layout

\begin_layout Plain Layout
We introduce a concept name reactive interface variables that harmonizes
 the two concepts.
 For example, A := B + C are performed as continuous association, and without
 to determine the type of A.
\end_layout

\begin_layout Plain Layout
We introduce a concept name reactive interface variables that harmonizes
 the two concepts.
 We introduce an assignment operator that establishes a continuous association
 with the inheritance and polymorphism mechanisms
\end_layout

\begin_layout Plain Layout
, and that are performed with the 
\end_layout

\begin_layout Plain Layout
by introducing an assignment operator.
 Given reactive instance variables A,B and C, in performing A := B + C,
 we establish the continuous association
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
a sorting algorithm depends on a comparison function that is implemented
 differently according to the type.
\end_layout

\begin_layout Plain Layout
An older concept for code reuse is the mechanisms of object-oriented programming
 (OOP), inheritance and polymorphism are such that developers can define
 logic once, even if it's used for various types.
 For example, a sorting algorithm depends on a comparison function that
 is implemented differently according to the type.
\end_layout

\begin_layout Plain Layout
means that we can program code depending on operations without to learn
 about the implemetation.
 For example, A+B means to sum A and B as fit to their type.
\end_layout

\begin_layout Plain Layout
, so that objects can be replaced.
 In this way, the code is written once, without to repeat the same logic
 for each conceret type.
 For example, 
\end_layout

\begin_layout Plain Layout
, that code can depends on other code from its outer form, such that 
\end_layout

\begin_layout Plain Layout
whenevr B or C is updates, A is updated according to the values they contain
 and according to the operator +.
\end_layout

\begin_layout Plain Layout
In Object Oriented Programming (OOP), calling an operation is like sending
 a message, as the actual called method should be hidden from the callee.
 
\end_layout

\begin_layout Plain Layout
Code reuse is a core principle in programming.
 For example, a execution call in Object Oriented Programming (OOP) is decoupled
 from the choose of the actual method been called, so that the logic will
 holds to diffrent methods implementations.
\end_layout

\begin_layout Plain Layout
A good examples for code reuse is the inheritance and composition abstraction
 mechanisms.
 It is based on an 
\emph on
object
\emph default
 concept, that is a unit of variables bundled with set of operations, that
 can represent real world objects.
 Inheritance means to make an object that 
\emph on
is
\emph default
 another object with more variables and operations.
 Composition means to make object that 
\emph on
has
\emph default
 other objects, so that in its operation, it can call internaly to objects
 it has internaly.
 Code reuse stands in contrast to code duplication or redundancy, where
 the same functionality is implemented repeatedly.
 When code is duplicated, any changes or bug fixes need to be applied to
 each instance.
 This can lead to inconsistencies and maintenance headaches.
 By reusing code, modifications only need to be made in one place, ensuring
 consistency and reducing effort.
\end_layout

\begin_layout Plain Layout
A concept named 
\emph on
reactive variable
\emph default
 provides also code reuse, in that it automaticaly update variables when
 needed.
 For example, given reactive variables A,B and C, performing A:=B+C makes
 that when either B or C is updated, A is updated to contain a value that
 is the sum of the values that B and C contain.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In software programming, developers are sometimes encounter 
\emph on
cycles 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, 
\emph on
circular dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

 or similar.
 For variables, it means that a change in one variable (of its contained
 value) causes transitively, through a chain of changes, this same variable
 to change again.
 Typically, the flow continues, such that the second change produces a third
 change, etc.
 In the worst case, this chain continues endlessly, breaking programs unexpected
ly.
\end_layout

\begin_layout Plain Layout
Consequently, software developers are often forced to break the cycles by
 creating hierarchical data models.
 A remarkable example is a birth of 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As described in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.clariontech.com/blog/mvc-vs-flux-vs-redux-the-real-differences
\end_layout

\end_inset


\end_layout

\end_inset

 In previous libraries that use MVC, models are updated according to the
 view and vice versa, sometimes mentioned as 
\emph on
multidirectional
\emph default
 dataflow, which means that data flows among components in multiple directions.
 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 provides an alternative approach that proposes a design that data flow
 in one direction, such that data flows from each component to its child
 components.
 This way protects developers from encounter cycles.
\end_layout

\begin_layout Plain Layout
By far, the semantics given for cycles is 
\emph on
operational semantics
\emph default
.
 Operational semantics describes the behavior of a program in terms of the
 steps taken to execute it.
 To illustrate this concept, we will examine conventional methods for handling
 cycles within 
\family typewriter
Microsoft Excel
\family default
.
 There, cells can contain formulas that determine their values based on
 the values of other cells.
 These formulas reference other cells.
 For example, cell 
\begin_inset Formula $\LSTINLINE{A1}$
\end_inset

 can contain the formula 
\begin_inset Formula $\LSTINLINE{=B1+C1}$
\end_inset

.
 When a user updates the value in cell 
\begin_inset Formula $\LSTINLINE{B1}$
\end_inset

 or 
\begin_inset Formula $\LSTINLINE{C1}$
\end_inset

, the value in cell 
\begin_inset Formula $\LSTINLINE{A1}$
\end_inset

 will automatically recalculate to reflect the changes.
 Excel prohibits cycles.
 However, this can be changed by configuration.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-gb/office/change-formula-recalculation-iteration-
or-precision-in-excel-73fc7dac-91cf-4d36-86e8-67124f6bcce4
\end_layout

\end_inset

 If cycles are enabled, it should be customized how to break cycles.
 Two methods do exist to break cycles.
 The first one is stopping after a customized number of iterations.
 The second method is checking changes; if a value has not changed, or changed
 only less than a threshold, then it will continue to propagate.
\end_layout

\begin_layout Plain Layout
In this thesis, we focus on introducing 
\emph on
denotational semantics
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which would provide a more abstract interpretation, more closed to problem
 domain than to solution domain.
 
\end_layout

\begin_layout Plain Layout
This concept is equivalent to extract out 
\emph on
accidental
\emph default
 complexity.
 This concept refers to complexity that arises from the applications development
, rather than from the complexity of the business domain 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Since cycles will not be a concern of the implementation, it is expected
 that creation of at least some tools or real-life applications will be
 improved.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In this thesis, we focus on introducing 
\emph on
denotational semantics
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which would provide a more abstract interpretation, more closed to problem
 domain than to solution domain.
 This concept is equivalent to extract out 
\emph on
accidental
\emph default
 complexity.
 This concept refers to complexity that arises from the applications development
 (rather than from the complexity of the business domain) 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Cycles have been considered as 
\emph on
accidental
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, while cycles are stopped from being a concern of the implementation.
 Since cycles will have an interpretation closed to users perspective, we
 would be more planned open to encounters with them in real life applications.
\end_layout

\begin_layout Plain Layout
Accidental complexity is complexity that is not of essential difficulty
 from the problem domain.
\end_layout

\begin_layout Plain Layout
We extract out cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
that is not of essential difficulty from the problem domain.
\end_layout

\begin_layout Plain Layout
Since we extract out the need to handle cycles as 
\emph on
accidental complexity.
\end_layout

\begin_layout Plain Layout
This concept is equivalent to extract out complexity that is not of essential
 difficulty from the problem domain.
 Cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
This difficulty is named 
\emph on
accidental.

\emph default
 because cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
named as
\emph on
 accidental
\emph default
, while essential
\end_layout

\begin_layout Plain Layout
distinguishing accidental from essential diculty
\end_layout

\begin_layout Plain Layout
In this way, cycles need not be 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 This concept refers to complexity that arises from the applications development
 (rather than from the complexity of the business domain) 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Since cycles will have an interpretation closed to users perspective, we
 would be more open to encounters with them in real life applications.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We introduce a framework where variables and dependencies from FRP are embedded
 into objects of OOP, constructing a 
\emph on
composite
\emph default
 
\emph on
graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 Each object represent one sub-graph of the composite.
 Our main contribution are in particular:
\end_layout

\begin_layout Itemize
Change propagation algorithm that support cycles.
\end_layout

\begin_layout Itemize
Change propagation algorithm
\end_layout

\begin_layout Plain Layout
, such that each object refer to one of the sub-graphs where the that its
 composed sub-graphs are the objects that contain
\end_layout

\begin_layout Plain Layout
We introduce a framework of a 
\emph on
composite graph
\emph default
 from constructing objects of OOP with variables and dependencies of FRP.
 Each object constructs a sub-graph, 
\end_layout

\begin_layout Plain Layout
A composite graph is a graph composed of simpler graphs or sub-graphs.
 
\end_layout

\begin_layout Plain Layout
harmonizing OOP with that is a graph composed of simpler graphs or sub-graphs,
 that contains the following 
\end_layout

\begin_layout Plain Layout
We introduce a new paradigm named Non-Hierarchical FRP (NH-FRP), a dedicated
 concept named 
\series bold
Reactive Instance Variable
\series default
 ( 
\family typewriter
RIVar)
\end_layout

\begin_layout Itemize
We introduce a new variant of FRP named Non-Hierarchical FRP (NH-FRP), in
 which variables and dependencies form a 
\emph on
composite graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 In each of the sub-graphs, it is free to add edges without worrying about
 accidentally creating a cycle.
 This implies the separation of concerns principle, referring each sub-graph
 to represent a distinct concern.
 Accordingly, at a time, a single sub-graph can be observed without to observe
 any more nodes or vertices from other sub-graphs in the composite graph.
\end_layout

\begin_layout Itemize
We implement NH-FRP as a framework by harmonizing Object Oriented Programming
 (OOP) with Functional Reactive Programming
\begin_inset space ~
\end_inset

(FRP).
 We borrow 
\series bold
reactive variables
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 from FRP embedding them as 
\series bold
instance variables
\series default
 of OOP.
 This introduces a new concept named as 
\series bold
Reactive Instance Variable
\series default
, 
\family typewriter
RIVar
\family default
 for short.
 This new form of variables are used to create sub-graphs in the various
 objects composing the composite graphs.
\end_layout

\begin_layout Itemize
We provide a new programming language extension, by which applications would
 use the new framework.
 For 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we create a 
\family typewriter
nuget
\family default
 package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language, we create a 
\family typewriter
npm
\family default
 package called 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 We created for 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

, an integration to 
\begin_inset Formula $\NAME{React}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 hoping that it would be helpfull for real-life applications.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
and also a 
\family typewriter
npm
\family default
 package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 The extension exposes a few elements.
 First, RIVar as a type implemented as a class.
 Secondly, Lift 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 function for composing expressions.
 Finaly, an assignment operation implemented as a class method, for binding
 expressions to RIVars' instances.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
exploses a method named Set that implements the assignment operation.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
In the extension, RIVar is provided as a type implemented internaly as a
 class, RIVar exploses a method named Set that implements the assignment
 operation.
\end_layout

\begin_layout Plain Layout
we introduce a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
As a as a proof of concept, we introduce a small lightwight package called
 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and a similar also an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
We present also that the conceptual framework is feasible as a programming
 language extension.
 As a as a proof of concept.
 For the 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we introduce a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we introduce an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 In the two, RIVar is provided as 
\end_layout

\begin_layout Plain Layout
We also provide a concrete framework based on existing programming languages.
 An extension is created to the language that includes RIVar as a datatype,
 implemented internaly as a class.
 The assignment operation for RIVar objects is defined as a method.
 Finaly for enabling expressions of RIVars, a Lift function is added.
\end_layout

\begin_layout Plain Layout
Such extensions have been created as a proof of concept.
 For the 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we offer a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we provide an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
We suggest this frameowrk
\end_layout

\begin_layout Plain Layout
OOP and FRP are harmonized such that each object contain a subgraph declared
 as in FRP.
 Object composition and inheritance
\end_layout

\begin_layout Plain Layout
The subgraphs are connected and form
\end_layout

\begin_layout Plain Layout
Composite graphs are created from referncing variables of other
\end_layout

\begin_layout Plain Layout
Objects compositions and inheritance 
\end_layout

\begin_layout Plain Layout
The subgraphs are composed in a composite graph, because variables are 
\end_layout

\begin_layout Plain Layout
variables are part of the object interface
\end_layout

\begin_layout Plain Layout
We introduce RIVar, that is Reactive Instance (or Interface) Variable, which
 harmonizes reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 Each object represent a subgraph, 
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 This will harmonize nicely the concepts reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 For this paragraph, we call it simply variable.
 This new concept aims to enable a framework of building composite graphs
 of depedancies.
\end_layout

\begin_layout Plain Layout
Our goal is, that it will enable a framework that each object can contain
 variables and assignments.
\end_layout

\begin_layout Plain Layout
According to the new concept, the assignment operator
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 is re-defined, to bind the right-side expression to it without removing
 previous binding.
 The goal is to enable a framework that each object can contain variables
 and assignments.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
\end_layout

\begin_layout Plain Layout
RIVar is designed to be an observer of the expressions bound to it, which
 are observables.
\end_layout

\begin_layout Plain Layout
The bound expressions are managed localy, as the variable
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 RIVar is a variable of a new generation, because it harmonizes features
 nicely.
 The assignment of RIVar binds the right-side expression to it without removing
 previous binding.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enables a framework that each object can contain variables and assignments.
\end_layout

\begin_layout Plain Layout
decoupling, such that each object can have responsibility that consists
 of variables and assignments.
\end_layout

\begin_layout Plain Layout
This enable to assign from outside of objects or interfaces, so that their
 consumers can assign as their internal behavior.
\end_layout

\begin_layout Plain Layout
This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enable to design 
\end_layout

\begin_layout Plain Layout
We design and implement this as extensions.
\end_layout

\begin_layout Plain Layout
without to aware of other assignments.
\end_layout

\begin_layout Plain Layout
As its name, it is both reactive and associated to object, which means an
 automation in updates and decoupling.
\end_layout

\begin_layout Plain Layout
As its name, it is reactive variable, because its 
\end_layout

\begin_layout Plain Layout
For example, the assignment of RIVar bind the expression to it rather than
 change it.
 similar to the functional 
\end_layout

\begin_layout Plain Layout
The main contribution in this thesis, is in introducing a new method for
 applying separation of concerns.
 This is provided as a new framework that harmonizes concepts from FRP and
 OOP.
 From OOP, we gain objects reuse including composition, inheritance and
 polymorphism.
 From FRP, we gain explicit dataflow and referntial transparency.
 From this harmoniztion we invented a new concept named RIVar, i.e., reactive
 instance variable.
 reactive variables refer to variables in FRP.
 instance variables refer to variables associated to objects in OOP.
 For evaluation, we provide a case study of designing a small according
 to the new method, and compare its effectiveness with alternative designs.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We evaluate this method by designing 
\end_layout

\begin_layout Plain Layout
The evaluation of this method 
\end_layout

\begin_layout Plain Layout
The new method is evaluated using a case study.
\end_layout

\begin_layout Plain Layout
in objects.
 like reactive variables, 
\end_layout

\begin_layout Plain Layout
such a variable is continously re-evaluated to its assigned expression
\end_layout

\begin_layout Plain Layout
One interseted concept 
\end_layout

\begin_layout Plain Layout
Harmonized from the two worlds, we form a new concept named reactive instance
 variables.
 reactive variable determine the explicit data flow in the code, and instance
 variable determinzes
\end_layout

\begin_layout Plain Layout
We provide a noval approach to cycles in software developments, and put
 it into practice.
 We introduce a framework, where each class of OOP contain a variables and
 formulas similar to determining variables in FRP.
 The variables and formulas are managed as a new noval variant of FRP named
 NH-FRP.
 We provide a real implementation of NH-FRP by programming extensions.
 We use a case study all over the thesis, by which we presnet an improveness
 by the new approach.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
First, we provide a motivation problem, an poored design application due
 acycliclicity in depedancies.
 Then we explain NH-FRP and the framework...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
and out of a problem that software solves, a concept that is often discussed
 in software development and design, an idea of abstraction and granularity.
\end_layout

\begin_layout Plain Layout
We name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges.
 When observing a sugraph, other subgraphs does exist, with common nodes
 (meaning that a node can be observed in diffrent subgraphs).
 When observing a sugraph, the other graphs are not observed.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout
In software development, the ability to zoom in and out on the problem that
 software solves is a concept often discussed in software development and
 design.
 This concept is closely related to the idea of abstraction and granularity.
 In diffrent prespectivs diffrent details are observed, ignoring other details.
 It is related to the seperation of concern principle, that the diffrent
 concern are handled independenctly, without to observe other concrens 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
One concept named one way unindirectional dataflow, with its contrary, multi
 directional dataflow.
 This concept refer to directions of data flow among components.
 Normaly, components can interacts by calling each other, causing data to
 flow to all directions.
 Unindirectional dataflow comes as a better approach, by design one direction
 to the dataflow.
 For example, in react, data flows from parents to child componnts in the
 rendrig process.
 
\end_layout

\begin_layout Plain Layout
One-way unindirectional dataflow strict that data flows 
\end_layout

\begin_layout Plain Layout
In FRP, two opposing methods do exist about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Sometimes, it is claimed that cycles should be avoided to achive predictability.
 For example, FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 forbidding cycles makes FRP unacceptably weak, because many applications
 have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
FRP is a research field used to provide predictable algorithms to propogate
 changes.
 The explicitness of the data dependencies and the namangement 
\end_layout

\begin_layout Plain Layout
In order to manage this inpredctable, the data dependencies graph are used
 to by acylic.
 The acylicy helps to provide efficient and predictable algorithm to propogate
 changes.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
For example
\end_layout

\begin_layout Plain Layout
Another approach used to avoid cycles.
 
\end_layout

\begin_layout Plain Layout
Executing an arbitary number of iterations might In FRP, various algorithms
 have been introduced, even 
\end_layout

\begin_layout Plain Layout
An example of preventing cilular references is in React that uses unindirectlion
al data flow to prevents cycles.
 
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming is a new paradigm based on the functional
 paradigm, where variables are defined in terms of other variables like
 functions are defined in terms of each other.
 This approach causes explicit dependencies graphs that are handled by the
 runtime, that update variables automaticaly similar to the behavior in
 Excel.
 For example A:=B+C means that B and C depends on A.
 I a grapg, each of the varibales are represented as nodes, and edges from
 A to B and C represent a dependancy that A depends on B and C.
 In a dataflow representation, there are edges from B and C to A to inform
 the direction of the data flow in runtime.
\end_layout

\begin_layout Plain Layout
In large scale applications, we name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges, while other edges and
 nodes are hidden.
 The entire graph is a composite graph, and each time a distinct subgraph
 can be identified and handled independently.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
that aims to solve complexity in programming, by explict data dependencies
\end_layout

\begin_layout Plain Layout
, where data dependencies are identified explicity to make the langiage
 
\end_layout

\begin_layout Plain Layout
It might be even limitations in provided tools to prevent 
\end_layout

\begin_layout Plain Layout
(available in 
\emph on
Microsoft Excel
\emph default
)
\begin_inset Foot
status open

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In frameworks like react, 
\end_layout

\begin_layout Plain Layout
Frameworks in which variables are expressed in terms of other variables
 
\end_layout

\begin_layout Plain Layout
Frameworks, data dependencies are expor
\end_layout

\begin_layout Plain Layout
There are two approaches: to break the cycles to not to create infinite
 loops or to not create cycles at all.
 We can learn from Angular, how to break cycles.
 
\end_layout

\begin_layout Plain Layout
Generaly, the approach is to avoid cycles or to break them to not create
 infinite loops.
 One example is redux
\end_layout

\begin_layout Plain Layout
break cycles and to avoid infinite loops.
 
\end_layout

\begin_layout Plain Layout
Many frameworks allow to declare 
\emph on
data dependencies
\emph default
 explicity, 
\end_layout

\begin_layout Plain Layout
In order to organazie the code to avoid such cycles, it is suggested to
 declare 
\emph on
data dependencies
\emph default
 explicity and to form acylclic graphs.
 Other than in event paradigm, that 
\end_layout

\begin_layout Plain Layout
and and again re-updated in another execution of this event handler, as
 a result from 
\end_layout

\begin_layout Plain Layout
Such a cycle in events leads to cycles in the vatiables
\end_layout

\begin_layout Plain Layout
Various paradigms, frameworks and libraries aims to provide high level abstracti
ons for managing state.
 
\end_layout

\begin_layout Plain Layout

\emph on
Cycles
\emph default
 can be a headache in application development, that a change in one variable
 causes transitively, through chain of changes, this same variable to again
 change its value.
 In another prespective, cycles accured in using events (or related patterns):
 each event handler can trigger more events, inawaring of the events from
 which they have been triggered, therefore an event handler might trigger
 an event from which it was originaly triggered.
\end_layout

\begin_layout Plain Layout
In a more higher level, variables depend on each othern
\end_layout

\begin_layout Plain Layout
In the Functional Reactive Programming, the graph by which the variables
 are affected each other is explicity declared.
 In FRP, there is no room that code inform changes in variables, so that
 other code will update other variables.
 Instead, the assignment statements initiate a relationship to continously
 update the variables.
\end_layout

\begin_layout Plain Layout
Declaring A:=B+C means that A depends on B and C, because its value 
\end_layout

\begin_layout Plain Layout
In order to avoid inpredictable executions or updates
\end_layout

\begin_layout Plain Layout
But we need to be more precize in our meaning for cycles.
 The first
\end_layout

\begin_layout Plain Layout
In order to completely understand cycles, we have to 
\end_layout

\begin_layout Plain Layout
Consequently, an event handler might be triggered indirectly from itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles because an event handler might be triggered
 indirectly from itself.
 But we need to be careful when we are talking about
\end_layout

\begin_layout Plain Layout
In such executions, an event handler can be triggered indirectly by itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles, 
\end_layout

\begin_layout Plain Layout
as the same event handler can be trigerred therefore might trigger them
 again.
 
\end_layout

\begin_layout Plain Layout
FRP is a paradigm to express the flow directly.
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
variables are like data store , holding values.
\end_layout

\begin_layout Plain Layout
the memory locations refered by names.
 Typicaly the variable
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
In software programming, mutable variables refer to variables as memory
 locations that can be updated by the assignment operator, and can be read
 in order to update other variables accordingly.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 A subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The framework is extended to provide a mechanism to that variables will
 be updated according to other variables, 
\end_layout

\begin_layout Plain Layout
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>B=A)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In order to keep on consistency, variables should be updated whenever the
 other related variables changed.
\end_layout

\begin_layout Plain Layout
In case that the code is inaccesible, while 
\end_layout

\begin_layout Plain Layout
For achiving data syncroization, no mechanism inform potential readers of
 changes.
 For example, creating a varable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 derived from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, by 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 
\end_layout

\begin_layout Plain Layout
two options are avilable.
 First, 
\end_layout

\begin_layout Plain Layout
We gradually identify abstractions for managing variables:
\end_layout

\begin_layout Itemize
Initially, code assigns values to variables, allowing other code to read
 them.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, a subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Itemize
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>...)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Itemize
Finally, these components are intertwined, enabling writing into a variable
 to automatically trigger other code to read the new values.
 For instance, declaring 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 establishes a continuous relationship between variables, so that when the
 code 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 is executed, variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated automatically to reflect this new value.
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists 
\emph on
accidental
\emph default
 complexity, that does not the inherently complexity of the problem at hand.
 In the first abstraction, there is no mechanism to inform potential readers
 of changes.
 Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 The second approach provide reactivity, by informing potential readers
 of changes.
 However, it requires to control when to inform readers, and for readers
 to inform which changes to subscribe to.
 This approach is difficult in high scale applications.
 Because, it is not always clear when to inform readers about changes, or
 for the readers when to subscribe to or unsubscribe from.
 The last approach abstract out the previous complexity, so that writing
 into variables triggers potential readers to read the changes.
\end_layout

\begin_layout Plain Layout
This thesis's contribution is providing even a more clean abstraction by
 abstracting out accidental 
\emph on
cycles
\emph default
.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presented, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 This thesis proposes a paradigm shift where cycles need not be detected,
 as they are supported and considered meaningful.
\end_layout

\begin_layout Plain Layout
We introduce this paradigm by adapting it to Object-Oriented Programming
 (OOP)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 and encapsulation.
 For instance,
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE{C.A}$
\end_inset

 refer to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 associated with an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is a variable associated with the current class.
 Similarly, in inheritance, a behavior can be represented by the formula
 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is associated with the current class.
 According to the encapsulation principle, a class containing a formula
 treats it as private details, unknown to others.
 Indeed, it is unable to prevent creating cycles, but enables simplicity,
 as each class owns its own responsibility without concern for other responsibil
ities
\end_layout

\begin_layout Paragraph
Data Dependencies and Dataflow
\end_layout

\begin_layout Paragraph
Circular Dependencies
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
that the left hand variable 
\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\RIVar$
\end_inset

 stands for 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables,
\emph default
 being 
\emph on
reactive
\emph default
 variables and also 
\emph on
instance
\emph default
 variables (i.e., fields associated with objects).
 The name reactive refer to the contino 
\end_layout

\begin_layout Plain Layout
This enables creating formulas as 
\end_layout

\begin_layout Plain Layout
so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
This paradigm is based on Object Oriented Programming (OOP) with encapsulation.
 We name 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default

\begin_inset Formula $\RIVar$
\end_inset

 for short, being reactive variables and also instance variables (i.e., fields
 associated with objects), so that they can be associated externally like
 using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
that the software solves.
 
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists a complexity that a variable change
 might indirectly result from itself.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presents, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 
\end_layout

\begin_layout Plain Layout
Depending on how users see the software, complexity is considered as 
\emph on
accidental
\emph default
 if it does not inherent in the problem that the software solves.
 
\end_layout

\begin_layout Plain Layout
We aims to adds required abstractions for abstracting out complexity related
 to cycles or loops.
\end_layout

\begin_layout Plain Layout
Depending on the problem, this complexity can inherent in the problem that
 the software solves as seen by the users, or accidental as it arises only
 through the implementation.
 Nevertheless, a variable change might indirectly result from itself is
 accidental, because 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Functional Reactive Programming (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a new paradigm that aims to provide a high-level language where data
 dependencies are specified directly by the language, rather than relying
 on the traditional event-driven paradigm where developers manually manage
 variable values.
 For example, in the event-driven paradigm, variables 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
 each have a 
\family typewriter
change
\family default
 event to which event handlers are registered.
 Within these event handlers, code calculates the sum of the values contained
 in 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
, and then updates a variable, 
\family typewriter
A
\family default
, with that value.
 From an FRP perspective, this should be declared simply as 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 making the data dependencies explicit directly in the code.
 In this context variables are named 
\emph on
reactive variables
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
traditionaly named in some variations: 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 and also (like us) 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named sometimes 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
Focusing on 
\begin_inset Formula $\RIVar$
\end_inset

, this thesis emphasizes 
\emph on
de-centralization
\emph default
.
 Analogous to OOP that used to model applications with classes and objects,
 many modern applications consist of components 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 Similarly, systems are often interconnected, functioning as a single cohesive
 unit with multiple subsystems (e.g., a Customer Relationship Management (CRM)
 system combined with an order processing system).
 (In FRP, most implementations use a centralized mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Even in harmonizing FRP with OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

, there is coupling to a centralized component which handles calculations.
 Similarly, in GUI applications, there is widespread adoption of solutions
 like 
\begin_inset Formula $\NAME{Redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

 which provide centerlized state management
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.)
\end_layout

\begin_layout Plain Layout
The research direction focuses on de-centralization by enabling cycles in
 data dependencies.
 This approach stands in contrast to a conventional method of constructing
 hierarchical graphs, where variables are connected to the input elements,
 and subsequently variables depend on other variables, forming an acyclic
 dependency graph (DAG) 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Additionally, the research direction diverges from the traditional perspective
 that regards cycles as merely an edge case 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, we say that, a variable depends on other variables, if changes in
 those variable propogate to the first.
 In FRP, various algorithm has been developed to automate the propagations.
 This automation
\end_layout

\begin_layout Plain Layout
FRP is a programming paradigm where specification of fields contents are
 decoupled from the way of how to apply it in runtime.
 The developers use a library that manage graphs,
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
State management is an aspect in front end development, responsible on updating
 fields according to other fields.
 The specifications of how to manage the updates are of various forms and
 patterns.
 One of the forms suggests high level specifications by lifting
\end_layout

\begin_layout Plain Layout
uses a concept that functions can be lifted
\end_layout

\begin_layout Plain Layout
One of the forms uses a concept, that similar to function over values (and
 variables that contain values) to function over fields.
 Then establish continous relationship instead of the traditional temporal
 assignment.
\end_layout

\begin_layout Plain Layout
between the function and the target variable.
\end_layout

\begin_layout Plain Layout
values and operations are lifted
\end_layout

\begin_layout Plain Layout
, rules and input over time.
 In response to an input, code is executed and update fields.
\end_layout

\begin_layout Plain Layout
There are several common abstractions (with variants) used for this task.
 events, streams, one-way constraints and two way constraints.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 is a core concept in 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, including some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Consider an example of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the example, a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE+$
\end_inset

 in the example) are converted from operating over values to operate over
 reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Such an association establishes data dependencies, so that the left-hand
 variable depends on the variables in the right-hand side, and it is continuousl
y re-evaluated according to updates in the dependencies.
 Such a behavior of the continuously re-evaluations defines the variables
 (such as 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 in the example) to be reactive variables.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This can be applied to input fields in GUI applications.
 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 are one of such GUIs.
 Similar to reactive variables associated with expressions composed of other
 reactive variables, cells in 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 contain formulas to determine values based on other cells.
 Also in other applications, GUI developers need often to develop behaviors
 similar to reactive variables (i.e., update fields values based on other
 values filled in the other fields).
 In modern frameworks, this is applied using 
\emph on
state management solutions
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\begin_layout Plain Layout
The research direction stems from an analysis of the impact of preventing
 cycles.
 When declaring new data dependencies, in order to avoid cycles, it is essential
 to ensure that transitive dependencies do not depend on the fields from
 which the new dependencies originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A possible reason for not being de-centralized, is because of unintended
 unacceptable feedback loops, i.e., a change in one field leads to a subsequent
 change that feeds back and affects the original field itself.
 When declaring new data dependencies, it is essential to ensure that transitive
 dependencies do not depend on the fields from which the new dependencies
 originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(composing many pieces of small functionality togather, might leads to huge
 complexety.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Accordingly,
\end_layout

\begin_layout Plain Layout
Besides the need to handle cycles, cycles are often treated only as an edge
 case.
 Typically, calculations are hierarchical, i.e., variables are connected to
 the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis focuses on enabling de-centralization by introducing an embedded
 support for cycles.
 We introduce a framework that classes of OOP contain reactive variables
 and also contain associations that establish data dependencies.
 Objects instantiated from these classes then manage updates privately based
 on the (private) data dependencies within their class.
 We introduce this framework, by defining a new concept named 
\family typewriter
Reactive Instance Variable
\family default
\emph on
,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 According to its name, the new concept harmonizes 
\family typewriter
reactive variable
\family default
 of FRP with 
\family typewriter
instance variable
\family default
 of OOP.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis defines 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, for breaking down code of reactive variables into objects.
 
\begin_inset Formula $\RIVar$
\end_inset

 is an harmonized concept of reactive variable and instance variable, because
 
\begin_inset Formula $\RIVar$
\end_inset

 is a reactive variable associated to objects of OOP.
 Over such reactive variables (
\begin_inset Formula $\RIVar$
\end_inset

s), this thesis introuduces a new variant for FRP named Non-Hierarchical
 FRP (NH-FRP) with an embedded support for cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
because objects can contain formulas as internal behavior and the updates
 in runtime are also managed privatly.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we introduce a new variant of FRP, named Non-Hierarchical
 FRP (NH-FRP), that indeed supports cycles.
 By using NH-FRP, reactive variables can be associated with objects as instance
 variables, which we name 
\emph on
reactive instance variables
\emph default
 (a 
\begin_inset Formula $\RIVar$
\end_inset

 in singular), while calculations over 
\begin_inset Formula $\RIVar$
\end_inset

s are managed as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
In the new variant, we use a propagation strategy, in which the propagated
 values are accompanied by timestamp data.
 According to the timestamp data, obsolete values from feedback loops are
 identified and blocked from passing forward.
 By using NH-FRP, reactive variables can be associated to objects, with
 the name 
\emph on
reactive instance variables
\emph default
 (a RIVar in singular), while also the calculations over them are managed
 as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
To solve the problem we introduce Non Hirarchial FRP, a new varian;t of
 FRP that support cycles.
 This new variant consists of a propagation strategy, so that the propogated
 values are attached with data about their time, by whom absolete value
 from feedback loops are not passed forward.
\end_layout

\begin_layout Plain Layout
This new varaint enables cycles by embedding an algorithm, that each variable
 ignores absolete values.
\end_layout

\begin_layout Plain Layout
This new variant enables cycles by an approach, that each variable can depend
 on multiple sources, where each of the sources can update the variable
 on its updated value.
\end_layout

\begin_layout Plain Layout
For example, given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formulas 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A-1}$
\end_inset

 create associations, so that A
\end_layout

\begin_layout Plain Layout
associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In the context of FRP, Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 suggests an alternative mechanism the centerlized mechanism that have access
 to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
this includes two stages.
 First, a centerlized mechanism that have access to the entire dependancy
 graph.
 Second,
\end_layout

\begin_layout Plain Layout
FRP still does not provide a better solution in this aspect.
\end_layout

\begin_layout Plain Layout
In FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
 This is the state also in works that harmonizes FRP with OOP.
\end_layout

\begin_layout Plain Layout
Two stages do exist in the task: declaring the calculations and the runtime.
 For the two stages, the centerlization is unaccepted.
 In DFRP, there are decenterlized algorithms to decenterlzed in runtime
\end_layout

\begin_layout Plain Layout
.
 First to depedencies.
 The decenterlized implemention need
\end_layout

\begin_layout Plain Layout
A possible reason is that adding
\end_layout

\begin_layout Plain Layout
-
\end_layout

\begin_layout Plain Layout
Unfortunaly, the way the state is managed, does not stand with the standard
 to breaking down code into modules or objects.
 An example is a widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Similarly in FRP
\end_layout

\begin_layout Plain Layout
The centerlization includes the runtime and the code.
\end_layout

\begin_layout Plain Layout
The centerliation is applied in runtime, by a centerlized mechanism that
 have access to the entire dependancy graph.
 This has solution in the field of Distributed FRP 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 For the centerliation in code, there is a problem
\end_layout

\begin_layout Plain Layout
In addition, when maintaining the code, adding a dependancy requires the
 check against transitive dependencies to not create cycles.
 means sometimes to check against unreachable classes or objects
\end_layout

\begin_layout Plain Layout
This problem is applied also in FRP: according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
The centerlization consists of two parts.
 First, in runtime, one centerlzed mechanism that access the ..
\end_layout

\begin_layout Plain Layout
second, in the code itself,
\end_layout

\begin_layout Plain Layout
The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\begin_layout Plain Layout
FRP aims to solve the difficulties in controlling the calculations.
 In the events driven paradigm updating a field might trigger a change event
 which trigger other updates and so on.
 In the worst case, the chain of updates can being an infinite loop of updates.
\end_layout

\begin_layout Plain Layout
Traditionaly, two strategies handle the problem.
 First, specifying calculations hierarchically, i.e., variables are connected
 to the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 This fact is often mentioned in FRP.
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to keep from unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamicaly.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitary break existing cycles.
 Overall, cycles are considered as an 
\emph on
edge-case
\emph default
, i.e., a special situation without a common sense solutions.
\end_layout

\begin_layout Plain Layout
The second strategy is centerlization.
 in front ends development there is widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Also in FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
This work is motivated
\end_layout

\begin_layout Plain Layout
Furtheremore, while keeping from undesirable cycles, dependencies must be
 reachable, leading again to centerlization.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The second strategy is centerlization.
 according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations of FRP depends on a centerlized mechanism
 that have access to the entire dependancy graph.
 Also in front ends development there is a common sence to manage the caculation
s in a centerlized mannar since the widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We focus on enabling calculation without those conditions.
 We adapt OOP, such that objects handle their calculation separately, and
 also that the objects contain calculations without ever knowing about other
 related calculations.
 In this new settings, we does not avoid cycles.
 The check against cycles requires that, whenever fields calculations are
 added, to check that the data dependency graph remains acyclic.
 The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Generally, the graph is managed in a centerlized mannar.
\end_layout

\begin_layout Plain Layout
In order to implemented the reactive variables correctly, the graph is managed
 in a centerlized mannar, otherwize there might be inpredictable behavior.
\end_layout

\begin_layout Plain Layout
In order to improve the error-prone development of reactive variables or
 fields calculations,
\end_layout

\begin_layout Plain Layout
The development of fields calculations is error prone.
 Therefore
\end_layout

\begin_layout Plain Layout
The noval approach of FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Beside this approach, there is the event-driven approach that fit Object
 Oriented Orogramming (OOP).
 In this approach, components can be extended, to react to variables' updates.
 On top of this
\end_layout

\begin_layout Plain Layout
There is the event-driven programming by which developers have a complete
 control over the propagation order,
\end_layout

\begin_layout Plain Layout
Beside this approach, there are approaches that fit Object Oriented Orogramming
 (OOP).
 There is the event-driven programming by which developers have a complete
 control over the propagation order, but this is error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 There is also frameworks like 
\begin_inset Formula $\ReactiveX$
\end_inset

 that provide a more abstract approach, to function over streams of events,
 that are closely related to the reactive variables.
 There the developers can choose between several schedulers to indicate
 the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 is a library in 
\begin_inset Formula $\NAME{Scala}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.scala-lang.org/
\end_layout

\end_inset


\end_layout

\end_inset

 that allows reactive variables being within objects or classes, modeling
 the fields calculations as part of components.
 The library derives previous FRP implementations, which is designed to
 produce consistent behavior, by an algorithm that carefully determines
 the order in which to update the variables.
 Another library 
\begin_inset Formula $\ReactiveX$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 that has first introduced for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 but adopted for more programming languages, provides an an API based on
 some OOP design patterns, to treat variables as streams of their changes.
 This can also been considered as reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 which objects can contain.
\end_layout

\begin_layout Plain Layout
The the two have different approaches, which lead to different results.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 leading to 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, outdated values are filtered out.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, when saying Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, there is no guarantee for 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 .
\end_layout

\begin_layout Plain Layout
We call them 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables remind fields in front-end applications, that are calculated
 according to other fields.
 In FRP, in order to create a variable that is automaticaly calculated according
 to other variables, it should be specified decleratively as a formula.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to change to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
(It might be challenging, to deal with the fields calculations that involve
 long chain of updates.
 The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

.
 The left challenge is in managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
an API based on some OOP design patterns, to treat variables as streams
 of their changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, abstracting
 components with fields.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefully determines the order in which
 to update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables as
 streams of their changes.
 Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
the tra of the declaring the data depedencies explicity, it should become
 easier.
\end_layout

\begin_layout Plain Layout
In the development of front-end and other reactive applications there are
 two dependencies types: data dependencies and source code depedencies,
 which should be organaized efficiently.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, there is an effort to make the data dependencies declared in the languages,
 instead that the developers need to understad the depedencies from the
 control of the programs.
 Traditionaly, it is hard to understand the dependencies, because it is
 spread over the event handlers.
\end_layout

\begin_layout Plain Layout
In the paradigm of OOP, there are abstraction mechanism to manage the source
 code dependencies.
 according to business needs, then changes in the code that handle data
 dependencies in one component might lead to require other components to
 be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, lanigages has been deveoped that lift the assignment statements, to create
 data dependencies, so that the variables will continoue to update according
 to the depeodencies.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
\end_layout

\begin_layout Plain Layout
Reactive variables have a special assignment operation (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operator) that defines a 
\emph on
data
\emph default
 
\emph on
dependenc
\emph default
y: the target reactive variable depends on the variables in the expression.
 The expressions are 
\emph on
lifted 
\emph default
executed functions, so that the target reactive variable continuously contains
 the value derived from the values of the reactive variables it depends
 on.
 A propagation of changes starts whenever any of the variables get user
 input (
\begin_inset Formula $\LSTINLINE=$
\end_inset

 operator).
 This causes the dependencies to re-evaluate, which causes their dependencies
 to re-evaluate, and so on.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 Applications are usually composed of several or many components that runs
 in one or many hosts.
 In such settings, changes in the code that handle data dependencies in
 one component might lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the Object Oriented Paradigm (OOP) difrent parts of the application in
 the form of objects can be loosly coupled, even when they interacts in
 such a way that variable in one object depends on variables of other objects.
\end_layout

\begin_layout Plain Layout
applications are modeled as objects that the components can usesuggests
 to form applications by objects to be used model running components or
 that can extend and compose each other, that can react to
\end_layout

\begin_layout Plain Layout
In the events paradigm, it is hard to control what the data depedencies
 are, because logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 In addition, if an application is composed of several components, according
 to business needs, then changes in the code that handle data dependencies
 in one component might lead to require other components to be changed according
ly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
it might be hard as every large application, that contains too much details
 to the developer think.
\end_layout

\begin_layout Plain Layout
the complex or huge logic, in the form of uge amount of data depedencies.
\end_layout

\begin_layout Plain Layout
the huge amount of data depedecies might be hard to manage as it is complex
 logic
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 The first difficulty is to control the data dependencies.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In FRP, the goal is that the developer has a langague to express the data
 dependenies directly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage the dependencies between code components.
 If the code that handles data dependencies handling involves several components
, they might become 
\emph on
coupled
\emph default
.
 If changes in one component lead to require other components to be changed
 accordingly, the first component depends on the second component 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In the Object Oriented Programming, the applications parts has the form
 of objects.
\end_layout

\begin_layout Plain Layout
, that consume and extend each other, which are used to manage the code
 changes efficiently.
 The objects are used to sompose applications
\end_layout

\begin_layout Plain Layout
According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, although
 they have different focuses.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefuly determines the order in which to
 update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables by
 streams of their changes.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 from the 
\emph on
Functional Paradigm
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Itemize
An evaluation of procedural programming for achiving an alternative for
 data synchronization using a push model.
\end_layout

\begin_layout Itemize
We introduce an encapsulation method of bundling data dependencies utilized
 for data synchronization in a push model.
\end_layout

\begin_layout Itemize
We introduce a change propagation mechanism through sending and receiving
 messages (for being aligned with the encapsulation principle)
\end_layout

\begin_layout Itemize
We introduce a declerative language for specifing the bundles.
\end_layout

\begin_layout Itemize
We introduce a programming lanuage feautre (as an extension or library)
 for enabling the above concepts.
\end_layout

\begin_layout Itemize
We expand knowledge about cycles and loops in data synchronization.
\end_layout

\begin_layout Itemize
We introduce a feature 
\begin_inset Quotes eld
\end_inset

add filling option
\begin_inset Quotes erd
\end_inset

 beside the traditional feature 
\begin_inset Quotes eld
\end_inset

add computed field
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
\end_layout

\begin_layout Plain Layout
Reactive variables can be used to fields calculations, by connecting to
 visual fields.
\end_layout

\begin_layout Plain Layout
For instance, 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 is a state management solution for 
\begin_inset Formula $\NAME{React}$
\end_inset


\end_layout

\begin_layout Plain Layout
applications, with the functionality like reactive variables.
\end_layout

\begin_layout Plain Layout
provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In maintaining and updating the variables, we sometimes face an unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications grow
 and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
\end_layout

\begin_layout Plain Layout
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
\end_layout

\begin_layout Plain Layout
The second complexity part is to separate the task into small manageable
 and independent tasks, for being in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second, we relate to the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
 This paradigm enables that different parts of the software, in the form
 of objects, are loosely coupled and do not depend on one another.
 This makes it easier to change objects without affecting the others.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 the reactive variables are part of the object interface, but implemented
 differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We present a semantic framework that enables the separation of data dependency
 management within objects.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both C# and
 JavaScript, along with a small application example.
\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Plain Layout
We first start with demonstrating the balance in the existing solutions,
 between predictable and decenterlzed solutions.
 Then we demonstrate our framework, an implementation.
 Finaly we compare
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start with deonstrating an example for an application, and dicuse the
 existing the challenges exsting in the exsiting approaches
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Background}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a background about implementing FRP under the hood.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

presents an example to demonstrate the need for 
\begin_inset Formula $\RIVar$
\end_inset

s.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Method}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present the new variant of FRP, so that reactive variables will be able
 to be 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Evaluation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we compare the model against the other solutions and paradigms, in handling
 graphs and reducing code duplication.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Implementation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present 
\begin_inset Formula $\RIVarX$
\end_inset

 with an implementation to the example presented in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

 being the case study.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities,
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
We focus on enabling FRP in OOP settings, so that it can be used across
 components.
 The point is that the visibilty of the elements can vary according to the
 organizations needs.
 The functions are defined over elements named 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they are reactive variables that can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
 The second point is that the visibility of the calculations are kept also
 in runtime by avoiding a madiator or any centeral engine to handle the
 calculations.
 We keep it simple, that each update trigger the next one as a simple function
 call.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize
We name a concept 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, an harmonized concept of 
\emph on
reactive variable
\emph default
 with 
\emph on
instance variable
\emph default
.
\end_layout

\begin_layout Itemize
We introduce Non-Hierarchical FRP (NH-FRP), a new variant of FRP, that supports
 cycles.
\end_layout

\begin_layout Itemize
We introduce a new form of abstraction, that enables ...
\end_layout

\begin_layout Itemize
We introduce a method
\end_layout

\begin_layout Itemize
We provide 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 This provides also a state management solution.
\end_layout

\begin_layout Itemize
We introduce an abstraction mecainsm of 
\begin_inset Quotes eld
\end_inset

add filling options
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We introduce semantics for mutual recursions, which traditionally causes
 cycles or loops in the change propagation.
\end_layout

\begin_layout Itemize
We introduce an algorithm that handles mutual recursions.
\end_layout

\begin_layout Itemize
We create a simple framework for creating computed fields.
\end_layout

\begin_layout Itemize
We provide an implementation: 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 The later is provided as a state management solution, that has integration
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
