#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables remind fields in front-end applications, that are calculated
 according to other fields.
 In FRP, in order to create a variable that is automaticaly calculated according
 to other variables, it should be specified decleratively as a formula.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to change to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // A=2
\end_layout

\begin_layout Plain Layout

B=6 // A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[<-] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The provided code demonstrates the distinction from the imperative paradigm.
 The accompanying graph illustrates the established dependencies.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It might be challenging, to deal with the fields calculations that involve
 long chain of updates.
 The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

.
 The left challenge is in managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.
\end_layout

\begin_layout Standard
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, abstracting
 components with fields.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefully determines the order in which
 to update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables as
 streams of their changes.
 Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
the tra of the declaring the data depedencies explicity, it should become
 easier.
\end_layout

\begin_layout Plain Layout
In the development of front-end and other reactive applications there are
 two dependencies types: data dependencies and source code depedencies,
 which should be organaized efficiently.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, there is an effort to make the data dependencies declared in the languages,
 instead that the developers need to understad the depedencies from the
 control of the programs.
 Traditionaly, it is hard to understand the dependencies, because it is
 spread over the event handlers.
\end_layout

\begin_layout Plain Layout
In the paradigm of OOP, there are abstraction mechanism to manage the source
 code dependencies.
 according to business needs, then changes in the code that handle data
 dependencies in one component might lead to require other components to
 be changed accordingly.
 
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, lanigages has been deveoped that lift the assignment statements, to create
 data dependencies, so that the variables will continoue to update according
 to the depeodencies.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
\end_layout

\begin_layout Plain Layout
Reactive variables have a special assignment operation (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operator) that defines a 
\emph on
data
\emph default
 
\emph on
dependenc
\emph default
y: the target reactive variable depends on the variables in the expression.
 The expressions are 
\emph on
lifted 
\emph default
executed functions, so that the target reactive variable continuously contains
 the value derived from the values of the reactive variables it depends
 on.
 A propogation of changes starts whenever any of the variables get user
 input (
\begin_inset Formula $\LSTINLINE =$
\end_inset

 operator).
 This causes the dependencies to re-evaluate, which causes their dependencies
 to re-evaluate, and so on.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 Applications are usually composed of several or many components that runs
 in one or many hosts.
 In such settings, changes in the code that handle data dependencies in
 one component might lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the Object Oriented Paradigm (OOP) difrent parts of the application in
 the form of objects can be loosly coupled, even when they interacts in
 such a way that variable in one object depends on variables of other objects.
\end_layout

\begin_layout Plain Layout
applications are modeled as objects that the components can usesuggests
 to form applications by objects to be used model running components or
 that can extend and compose each other, that can react to 
\end_layout

\begin_layout Plain Layout
In the events paradigm, it is hard to control what the data depedencies
 are, because logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 In addition, if an application is composed of several components, according
 to business needs, then changes in the code that handle data dependencies
 in one component might lead to require other components to be changed according
ly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
it might be hard as every large application, that contains too much details
 to the developer think.
 
\end_layout

\begin_layout Plain Layout
the complex or huge logic, in the form of uge amount of data depedencies.
\end_layout

\begin_layout Plain Layout
the huge amount of data depedecies might be hard to manage as it is complex
 logic 
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 The first difficulty is to control the data dependencies.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In FRP, the goal is that the developer has a langague to express the data
 dependenies directly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage the dependencies between code components.
 If the code that handles data dependencies handling involves several components
, they might become 
\emph on
coupled
\emph default
.
 If changes in one component lead to require other components to be changed
 accordingly, the first component depends on the second component 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
 
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In the Object Oriented Programming, the applications parts has the form
 of objects.
\end_layout

\begin_layout Plain Layout
, that consume and extend each other, which are used to manage the code
 changes efficiently.
 The objects are used to sompose applications
\end_layout

\begin_layout Plain Layout
According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, although
 they have different focuses.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefuly determines the order in which to
 update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables by
 streams of their changes.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 from the 
\emph on
Functional Paradigm
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, outdated values are filtered out.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
 
\end_layout

\begin_layout Plain Layout
Reactive variables can be used to fields calculations, by connecting to
 visual fields.
 
\end_layout

\begin_layout Plain Layout
For instance, 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 is a state management solution for 
\begin_inset Formula $\NAME{React}$
\end_inset


\end_layout

\begin_layout Plain Layout
applications, with the functionality like reactive variables.
 
\end_layout

\begin_layout Plain Layout
provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
In maintaining and updating the variables, we sometimes face an unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications grow
 and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
 
\end_layout

\begin_layout Plain Layout
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 
\end_layout

\begin_layout Plain Layout
The second complexity part is to separate the task into small manageable
 and independent tasks, for being in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second, we relate to the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
 This paradigm enables that different parts of the software, in the form
 of objects, are loosely coupled and do not depend on one another.
 This makes it easier to change objects without affecting the others.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 the reactive variables are part of the object interface, but implemented
 differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
 
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We present a semantic framework that enables the separation of data dependency
 management within objects.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both C# and
 JavaScript, along with a small application example.
\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Plain Layout
We first start with demonstrating the balance in the existing solutions,
 between predictable and decenterlzed solutions.
 Then we demonstrate our framework, an implementation.
 Finaly we compare
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start with deonstrating an example for an application, and dicuse the
 existing the challenges exsting in the exsiting approaches
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Background}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a background about implementing FRP under the hood.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

presents an example to demonstrate the need for 
\begin_inset Formula $\RIVar$
\end_inset

s.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Method}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present the new variant of FRP, so that reactive variables will be able
 to be 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Evaluation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we compare the model against the other solutions and paradigms, in handling
 graphs and reducing code duplication.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Implementation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present 
\begin_inset Formula $\RIVarX$
\end_inset

 with an implementation to the example presented in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

 being the case study.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities, 
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
 
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
 
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We present a framework along with implemented libraries for separating data
 dependency management within objects, in accordance with the information
 hiding principle.
 At the heart of this framework lies the concept of a 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), which is implemented as a data type hosted within existing programming
 languages.
 
\begin_inset Formula $\RIVar$
\end_inset

s can be assigned from outside objects and associated with expressions,
 while keeping other related formulas encapsulated.
 Moreover, runtime isolation is maintained, eliminating the need for a mediator.
 Instead, each variable directly updates its dependencies.
\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we explore traditional methods employed for handling field calculations
 and discuss the possibility of dividing them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we provide an exploration for one specific application example.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we point out our approach and implementation.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
