#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset

Introduction
\end_layout

\begin_layout Standard
In software programming, developers sometimes encounter 
\emph on
cycles 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 in 
\emph on
dependencies
\emph default
 (mentioned also as circular dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

 and recursions 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
 While software dependencies can arise in many contexts, we focus specifically
 on cycles that occur when implementing dependencies between (mutable) variables.
 Therefore, in this thesis' scope, cycles means that a change in one variable
 causes transitively, through chain of changes, this same variable to again
 change its value.
 
\end_layout

\begin_layout Standard
For example,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Our presentation is based on Tetsuo Kaminaa at al
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
\end_layout

\end_inset

 in using event-based programming, each event handler can trigger more events,
 in-awaring of the events from which they have been triggered.
 Therefore it is likely that an event handler transitively triggers an event
 from which it was originally triggered.
 If a variable is updated by an event handler, and this event handler triggers
 more events which lead to execute again this event handler, the variable
 is re-updated.
\end_layout

\begin_layout Standard
In Functional Reactive Programming (FRP), potentially cycles can be more
 explicity represented.
 In FRP, variables are specified in terms of each other, initiating dependencies
 to automatically update each other.
 For instance, A := f(B) indicates that A depends on B, meaning that when
 B's value changes, A's value is adjusted accordingly.
 Using this abstraction, B := g(A) establishes a dependency in a reversed
 direction, resulting in a cycle.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis discusse against an argument, that hirarchial data is a nececray
 condition for achiving predictability.
 This argument is inspired from several 
\end_layout

\begin_layout Plain Layout
This argument are inferred 
\end_layout

\begin_layout Plain Layout
Many couple predictability with the acylciity for graphs that abstract the
 depedancies.
 This represent an argument that hirarchial data is a nececray condition
 for achiving predictability.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Why Cycles Matters
\end_layout

\begin_layout Standard
Cycles are often challenged applications' developers and library designers.
 A remarkable example is a birth of 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As described in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.clariontech.com/blog/mvc-vs-flux-vs-redux-the-real-differences
\end_layout

\end_inset


\end_layout

\end_inset

 In previous libraries that use MVC, models are updated according to the
 view and vice versa, sometimes mentioned as 
\emph on
multidirectional
\emph default
 dataflow, which means that data flows among components in multiple directions.
 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 provides an alternative approach that proposes a design that data flow
 in one direction, such that data flows from each component to its child
 components.
 
\end_layout

\begin_layout Standard
The design choice of avoiding cycles has its cost.
 For example, the lack of a feature named 
\family typewriter
binding
\family default
, by which variables are decleratively bound, so that a change in one variable
 update the other variable and vise verca.
 A similar feature is named multidirectionality
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 (equivalent to multi-way constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

) that means that when neccesary, changes in derived values are propagated
 back to the values from which they were derived.
 
\end_layout

\begin_layout Standard
Another example for the challenging is in FrTime 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 In the design of FrTime, a special 
\family typewriter
delay
\family default
 operator is implemented in order to handle cycles.
 Similarly, Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special constructs named 
\family typewriter
CellLoops
\family default
 and 
\family typewriter
StreamLoops
\family default
 for handling cycles.
 Another example is in a feature called 
\family typewriter
reactive variables
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 to imperative languages.
 The feature limits the dependents to the lexical scope of its declaration
 for being acyclic.
 Sodium also hold a concept transaction for handling cycles created from
 integrating FRP with event handling code.
 A change propagated through an FRP variable can trigger an event handler,
 which in turn might create another update.
 This update could then feed back into the original FRP variable, creating
 a cycle.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Cycles are traditionaly considered has causing negative effects.
 They are sometimes considered as 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, i.e., complexity that is not inherent in the problem that the software solves
 (as seen by the users) but arises only from the implementation.
 For example, the birth of React is to solve cycles created in MVC.
 
\end_layout

\begin_layout Plain Layout
Also in declerative frameworks like Angular, cycles has a mining as something
 to handle, rather than a more absrract meaning.
 Indeed, cycles are sometimes considered as 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, i.e., complexity that is not inherent in the problem that the software solves
 (as seen by the users) but arises only from the implementation.
\end_layout

\begin_layout Plain Layout
An effort 
\end_layout

\begin_layout Plain Layout
This opposed appraoches exist in frameworks provided for fornt end programming.
 Frameworks like Angular support a feature named binding.
 This feature enables view and model to interacts, so that models are updated
 according to the view and vice versa.
 This is mentioned sometimes as multidirectional dataflow, as data flows
 among components in mutipal directions.
 An alternative approach propsed a design data flow in one direction.
 This approach is used in React, when data flows from each component to
 its child components.
 This aims to provide predictability.
 It should be noted, that user events are produced from the view into a
 state managemnt manager, that is consumed by the components, and this integrati
on might create accidental cycles.
\end_layout

\begin_layout Plain Layout
The oppsed approaches affects also a feature named multidirectionality 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This feature means that when neccesary changes in derived values are propagated
 back to the values from which they were derived.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

implies that whenever a new value of either A or B is available the other
 value is updated.
 In the constraints programming paradigm, there are local propagation solvers,
 that are similar to FRP with and without multidirectionality.
 Solvers with multidirectionality are sometimes mentioned as more challenged
 to implement than solvers without multidirectionality, while solvers with
 multidirectionality may provide a more frienly framework 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Opinions among researchers are divided regarding whether to support cycles.
 
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to a second approach, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Cycles are matter.
 This is obvious as it is frequesntly discussed explicity and implcity in
 resraches and tools documentations.
 In FRP
\end_layout

\begin_layout Plain Layout
For example, FrTime 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 has special 
\family typewriter
delay
\family default
 operator to handle cycles.
\end_layout

\begin_layout Plain Layout
Another example, Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special constructs named 
\family typewriter
CellLoops
\family default
 and 
\family typewriter
StreamLoops
\family default
 to allow cycles, that should be declared under an explicit transaction.
 
\end_layout

\begin_layout Plain Layout
Actualy, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Sodium has special constructs to handle cycles.
\end_layout

\begin_layout Plain Layout
Stephen Blackheath at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 adds to 
\end_layout

\begin_layout Plain Layout
In many frameworks and resraches, there is considerstion of cycles.
 Forbidding cycles makes FRP unacceptably weak, because many applications
 have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 However, 
\end_layout

\begin_layout Plain Layout
Opinions among researchers are divided regarding whether to support cycles.
 In FRP, One approach is to avoid 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 FRP is derived from Functional Programming (FP).
 For example, Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In FP we achive
\emph on
 referential transparency
\emph default
, which means that input consistently produces the same output.
 If cycles do exist, it produces
\end_layout

\begin_layout Plain Layout
The paradigm is derived from the functional paradigm, with the referential
 transparency property.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to referential transparency, meaning the input consistently
 produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to a second approach, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
This opposed appraoches exist in frameworks provided for fornt end programming.
 Frameworks like Angular support a feature named binding.
 This feature enables view and model to interacts, so that models are updated
 according to the view and vice versa.
 This is mentioned sometimes as multidirectional dataflow, as data flows
 among components in mutipal directions.
 An alternative approach propsed a design data flow in one direction.
 This approach is used in React, when data flows from each component to
 its child components.
 This aims to provide predictability.
 It should be noted, that user events are produced from the view into a
 state managemnt manager, that is consumed by the components, and this integrati
on might create accidental cycles.
\end_layout

\begin_layout Plain Layout
The oppsed approaches affects also a feature named multidirectionality 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This feature means that when neccesary changes in derived values are propagated
 back to the values from which they were derived.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

implies that whenever a new value of either A or B is available the other
 value is updated.
 In the constraints programming paradigm, there are local propagation solvers,
 that are similar to FRP with and without multidirectionality.
 Solvers with multidirectionality are sometimes mentioned as more challenged
 to implement than solvers without multidirectionality, while solvers with
 multidirectionality may provide a more frienly framework 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantic Investigations
\end_layout

\begin_layout Standard
Methods of how to handle cycles can be learnt from Microsoft Excel.
 In Excel, formulas are created in cells, referencing other cells.
 Any cell that contains a formula will contain values according to that
 formula.
 Therefore when a user update a cell, any cell that refer to it in its formula,
 is updated in response.
 In Excel, cycles are not allowed, but this change be changed by configuration.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

 If cycles are enabled, it should be customized how to break cycles.
 Two methods do exist to break cycles.
 First, stopping after a customized number of iterations.
 Second, checking changes.
 If a value has not changed, or changed only less than a threshold, then
 it will continue to propagate.
\end_layout

\begin_layout Standard
This style has been used by many.
 For example, in an SDK provided for developing plugins for Microsoft Dynamics,
 a property named Depth
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/api/microsoft.xrm.sdk.iexecutioncontext.depth
?view=dataverse-sdk-latest
\end_layout

\end_inset


\end_layout

\end_inset

 is provided.
 This property are provided for plugins registered in an update message,
 containing a number that is increased when a plugin is re-executed as a
 result of its own execution.
 A developer can compare the value of Depth, and customizing a logic for
 updates according to the iterations.
 This helps to avoid an infinite loop, that each update message cause a
 plugin to exeute which in turn, call update, that cause again an update
 message and so on.
 The method to stop propagation according to changes detection, is typicaly
 provided as well.
 In most SDK, code have have access during the execution the old and new
 values, to be compared and detect changes.
\end_layout

\begin_layout Standard
By far, the semantics given for cycles is 
\emph on
operational semantics
\emph default
.
 Operational semantics describes the behavior of a program in terms of the
 steps taken to execute it.
 Another semantic type, 
\emph on
denotational semantics
\emph default
 would provide a more abstract interpretation, which ia more closed to problem
 domain than to solution domain.
 Likewise, cycles are sometimes considered as 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, i.e., complexity that is not inherent in the problem that the software solves
 (as seen by the users) but arises only from the implementation, of how
 that problem is solved.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Normaly, depedancies causes 
\end_layout

\begin_layout Plain Layout
We use FRP, data dependencies initate data flow.
 For example A:=B makes B to depends on A, and this makes a data flow from
 B to A.
 Consequently, representing data dependencies as edges have a direction
 reversed from edges representd the resulted dataflow.
 For example, the data deoendencies of A:=B seems A->B and the dataflow
 seems B<-A.
 Therefore, an incoming edge in dataflow inform a variable that depends
 on an expression, or that it is an input variable (updated by a user or
 any external input).
 
\end_layout

\begin_layout Plain Layout
Returning back to cycle's starting point, which is a node with two incoming
 edges.
 This inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 Second, a variable that depends on two expressions simultaneously.
 For instance, a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable, from where values are propagated.
 Similarly, an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
 From this investigation, we find a new semantic to cycles as belonged to
 a broader concept, that any variable can depend on several expressions
 simultaneously.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Methodology
\end_layout

\begin_layout Standard
We absract variables and dependencies as a directed graph, where each node
 represent a variable, and the edges are constructed according to flow of
 updates.
 In a cycle, we start from an incoming edge into a node, that is a cycle's
 starting point, then through several nodes untill reaching again the first
 node from another edge.
 Yet, it is discovered, that a cycle's starting point has two incoming edges.
 
\end_layout

\begin_layout Standard
We make like reverse-engineering: according to such a graph, we name as
 
\emph on
dataflow graph
\emph default
, we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=f(B).
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
 
\end_layout

\begin_layout Standard
From this investigation, we find a new semantic to cycles as belonged to
 a broader concept, that any variable can depend on several expressions
 simultaneously.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We introduce a paradigm that variables and dependencies form a 
\emph on
composite graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 Subgraphs are free to add edges without worrying about accidentally creating
 a cycle.
 This implies the separation of concerns principle, referring each sub-graph
 to represent a distinct concern.
 Accordingly, at a time, a single sub-graph can be observed without to observe
 any more nodes or vertices from other sub-graphs in the composite graph.
\end_layout

\begin_layout Standard
As a conceptual framework, we introduce Reactive Instance Variable, RIVar
 for short, that extends OOP framework.
 RIVar harmonizes the concept of reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, from the reactive programming paradigm, with instance variable from the
 Object Oriented paradigm.
 Its main feature is an assignment operator, by which a composite graph
 is constructed, such that each object contains a subgraph.
\end_layout

\begin_layout Standard
We also provide a concrete framework based on existing programming languages.
 An extension is created to the langage that includes RIVar as a datatype,
 implemented internaly as a class.
 The assignment operation for RIVar objects is defined as a method.
 Finaly for enabling expressions of RIVars, a Lift function is added.
\end_layout

\begin_layout Standard
Such extensions have been created as a proof of concept.
 For the 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we offer a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we provide an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions as a state management solution that integrates seamlessly with
 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————-
\end_layout

\begin_layout Plain Layout
We suggest this frameowrk
\end_layout

\begin_layout Plain Layout
OOP and FRP are harmonized such that each object contain a subgraph declared
 as in FRP.
 Object composition and inheritance
\end_layout

\begin_layout Plain Layout
The subgraphs are connected and form
\end_layout

\begin_layout Plain Layout
Composite graphs are created from referncing variables of other
\end_layout

\begin_layout Plain Layout
Objects compositions and inheritance 
\end_layout

\begin_layout Plain Layout
The subgraphs are composed in a composite graph, because variables are 
\end_layout

\begin_layout Plain Layout
variables are part of the object interface
\end_layout

\begin_layout Plain Layout
We introduce RIVar, that is Reactive Instance (or Interface) Variable, which
 harmonizes reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 Each object represent a subgraph, 
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 This will harmonize nicely the concepts reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 For this paragraph, we call it simply variable.
 This new concept aims to enable a framework of building composite graphs
 of depedancies.
\end_layout

\begin_layout Plain Layout
Our goal is, that it will enable a framework that each object can contain
 variables and assignments.
\end_layout

\begin_layout Plain Layout
According to the new concept, the assignment operator
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 is re-defined, to bind the right-side expression to it without removing
 previous binding.
 The goal is to enable a framework that each object can contain variables
 and assignments.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
\end_layout

\begin_layout Plain Layout
RIVar is designed to be an observer of the expressions bound to it, which
 are observables.
\end_layout

\begin_layout Plain Layout
The bound expressions are managed localy, as the variable
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 RIVar is a variable of a new generation, because it harmonizes features
 nicely.
 The assignment of RIVar binds the right-side expression to it without removing
 previous binding.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enables a framework that each object can contain variables and assignments.
\end_layout

\begin_layout Plain Layout
decoupling, such that each object can have responsibility that consists
 of variables and assignments.
\end_layout

\begin_layout Plain Layout
This enable to assign from outside of objects or interfaces, so that their
 consumers can assign as their internal behavior.
\end_layout

\begin_layout Plain Layout
This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enable to design 
\end_layout

\begin_layout Plain Layout
We design and implement this as extensions.
\end_layout

\begin_layout Plain Layout
without to aware of other assignments.
\end_layout

\begin_layout Plain Layout
As its name, it is both reactive and associated to object, which means an
 automation in updates and decoupling.
\end_layout

\begin_layout Plain Layout
As its name, it is reactive variable, because its 
\end_layout

\begin_layout Plain Layout
For example, the assignment of RIVar bind the expression to it rather than
 change it.
 similar to the functional 
\end_layout

\begin_layout Plain Layout
The main contribution in this thesis, is in introducing a new method for
 applying separation of concerns.
 This is provided as a new framework that harmonizes concepts from FRP and
 OOP.
 From OOP, we gain objects reuse including composition, inheritance and
 polymorphism.
 From FRP, we gain explicit dataflow and referntial transparency.
 From this harmoniztion we invented a new concept named RIVar, i.e., reactive
 instance variable.
 reactive variables refer to variables in FRP.
 instance variables refer to variables associated to objects in OOP.
 For evaluation, we provide a case study of designing a small according
 to the new method, and compare its effectiveness with alternative designs.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
We evaluate this method by designing 
\end_layout

\begin_layout Plain Layout
The evaluation of this method 
\end_layout

\begin_layout Plain Layout
The new method is evaluated using a case study.
\end_layout

\begin_layout Plain Layout
in objects.
 like reactive variables, 
\end_layout

\begin_layout Plain Layout
such a variable is continously re-evaluated to its assigned expression
\end_layout

\begin_layout Plain Layout
One interseted concept 
\end_layout

\begin_layout Plain Layout
Harmonized from the two worlds, we form a new concept named reactive instance
 variables.
 reactive variable determine the explicit data flow in the code, and instance
 variable determinzes
\end_layout

\begin_layout Plain Layout
We provide a noval approach to cycles in software developments, and put
 it into practice.
 We introduce a framework, where each class of OOP contain a variables and
 formulas similar to determining variables in FRP.
 The variables and formulas are managed as a new noval variant of FRP named
 NH-FRP.
 We provide a real implementation of NH-FRP by programming extensions.
 We use a case study all over the thesis, by which we presnet an improveness
 by the new approach.
 
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
First, we provide a motivation problem, an poored design application due
 acycliclicity in depedancies.
 Then we explain NH-FRP and the framework...
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
and out of a problem that software solves, a concept that is often discussed
 in software development and design, an idea of abstraction and granularity.
\end_layout

\begin_layout Plain Layout
We name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges.
 When observing a sugraph, other subgraphs does exist, with common nodes
 (meaning that a node can be observed in diffrent subgraphs).
 When observing a sugraph, the other graphs are not observed.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout
In software development, the ability to zoom in and out on the problem that
 software solves is a concept often discussed in software development and
 design.
 This concept is closely related to the idea of abstraction and granularity.
 In diffrent prespectivs diffrent details are observed, ignoring other details.
 It is related to the seperation of concern principle, that the diffrent
 concern are handled independenctly, without to observe other concrens 
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
One concept named one way unindirectional dataflow, with its contrary, multi
 directional dataflow.
 This concept refer to directions of data flow among components.
 Normaly, components can interacts by calling each other, causing data to
 flow to all directions.
 Unindirectional dataflow comes as a better approach, by design one direction
 to the dataflow.
 For example, in react, data flows from parents to child componnts in the
 rendrig process.
 
\end_layout

\begin_layout Plain Layout
One-way unindirectional dataflow strict that data flows 
\end_layout

\begin_layout Plain Layout
In FRP, two opposing methods do exist about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Sometimes, it is claimed that cycles should be avoided to achive predictability.
 For example, FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 forbidding cycles makes FRP unacceptably weak, because many applications
 have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
FRP is a research field used to provide predictable algorithms to propogate
 changes.
 The explicitness of the data dependencies and the namangement 
\end_layout

\begin_layout Plain Layout
In order to manage this inpredctable, the data dependencies graph are used
 to by acylic.
 The acylicy helps to provide efficient and predictable algorithm to propogate
 changes.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
For example
\end_layout

\begin_layout Plain Layout
Another approach used to avoid cycles.
 
\end_layout

\begin_layout Plain Layout
Executing an arbitary number of iterations might In FRP, various algorithms
 have been introduced, even 
\end_layout

\begin_layout Plain Layout
An example of preventing cilular references is in React that uses unindirectlion
al data flow to prevents cycles.
 
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming is a new paradigm based on the functional
 paradigm, where variables are defined in terms of other variables like
 functions are defined in terms of each other.
 This approach causes explicit dependencies graphs that are handled by the
 runtime, that update variables automaticaly similar to the behavior in
 Excel.
 For example A:=B+C means that B and C depends on A.
 I a grapg, each of the varibales are represented as nodes, and edges from
 A to B and C represent a dependancy that A depends on B and C.
 In a dataflow representation, there are edges from B and C to A to inform
 the direction of the data flow in runtime.
\end_layout

\begin_layout Plain Layout
In large scale applications, we name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges, while other edges and
 nodes are hidden.
 The entire graph is a composite graph, and each time a distinct subgraph
 can be identified and handled independently.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
that aims to solve complexity in programming, by explict data dependencies
\end_layout

\begin_layout Plain Layout
, where data dependencies are identified explicity to make the langiage
 
\end_layout

\begin_layout Plain Layout
It might be even limitations in provided tools to prevent 
\end_layout

\begin_layout Plain Layout
(available in 
\emph on
Microsoft Excel
\emph default
)
\begin_inset Foot
status open

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In frameworks like react, 
\end_layout

\begin_layout Plain Layout
Frameworks in which variables are expressed in terms of other variables
 
\end_layout

\begin_layout Plain Layout
Frameworks, data dependencies are expor
\end_layout

\begin_layout Plain Layout
There are two approaches: to break the cycles to not to create infinite
 loops or to not create cycles at all.
 We can learn from Angular, how to break cycles.
 
\end_layout

\begin_layout Plain Layout
Generaly, the approach is to avoid cycles or to break them to not create
 infinite loops.
 One example is redux
\end_layout

\begin_layout Plain Layout
break cycles and to avoid infinite loops.
 
\end_layout

\begin_layout Plain Layout
Many frameworks allow to declare 
\emph on
data dependencies
\emph default
 explicity, 
\end_layout

\begin_layout Plain Layout
In order to organazie the code to avoid such cycles, it is suggested to
 declare 
\emph on
data dependencies
\emph default
 explicity and to form acylclic graphs.
 Other than in event paradigm, that 
\end_layout

\begin_layout Plain Layout
and and again re-updated in another execution of this event handler, as
 a result from 
\end_layout

\begin_layout Plain Layout
Such a cycle in events leads to cycles in the vatiables
\end_layout

\begin_layout Plain Layout
Various paradigms, frameworks and libraries aims to provide high level abstracti
ons for managing state.
 
\end_layout

\begin_layout Plain Layout

\emph on
Cycles
\emph default
 can be a headache in application development, that a change in one variable
 causes transitively, through chain of changes, this same variable to again
 change its value.
 In another prespective, cycles accured in using events (or related patterns):
 each event handler can trigger more events, inawaring of the events from
 which they have been triggered, therefore an event handler might trigger
 an event from which it was originaly triggered.
\end_layout

\begin_layout Plain Layout
In a more higher level, variables depend on each othern
\end_layout

\begin_layout Plain Layout
In the Functional Reactive Programming, the graph by which the variables
 are affected each other is explicity declared.
 In FRP, there is no room that code inform changes in variables, so that
 other code will update other variables.
 Instead, the assignment statements initiate a relationship to continously
 update the variables.
\end_layout

\begin_layout Plain Layout
Declaring A:=B+C means that A depends on B and C, because its value 
\end_layout

\begin_layout Plain Layout
In order to avoid inpredictable executions or updates
\end_layout

\begin_layout Plain Layout
But we need to be more precize in our meaning for cycles.
 The first
\end_layout

\begin_layout Plain Layout
In order to completely understand cycles, we have to 
\end_layout

\begin_layout Plain Layout
Consequently, an event handler might be triggered indirectly from itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles because an event handler might be triggered
 indirectly from itself.
 But we need to be careful when we are talking about
\end_layout

\begin_layout Plain Layout
In such executions, an event handler can be triggered indirectly by itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles, 
\end_layout

\begin_layout Plain Layout
as the same event handler can be trigerred therefore might trigger them
 again.
 
\end_layout

\begin_layout Plain Layout
FRP is a paradigm to express the flow directly.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
variables are like data store , holding values.
\end_layout

\begin_layout Plain Layout
the memory locations refered by names.
 Typicaly the variable
\end_layout

\begin_layout Plain Layout
————–
\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
In software programming, mutable variables refer to variables as memory
 locations that can be updated by the assignment operator, and can be read
 in order to update other variables accordingly.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

 to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 A subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The framework is extended to provide a mechanism to that variables will
 be updated according to other variables, 
\end_layout

\begin_layout Plain Layout
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>B=A)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In order to keep on consistency, variables should be updated whenever the
 other related variables changed.
\end_layout

\begin_layout Plain Layout
In case that the code is inaccesible, while 
\end_layout

\begin_layout Plain Layout
For achiving data syncroization, no mechanism inform potential readers of
 changes.
 For example, creating a varable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 derived from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, by 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 
\end_layout

\begin_layout Plain Layout
two options are avilable.
 First, 
\end_layout

\begin_layout Plain Layout
We gradually identify abstractions for managing variables:
\end_layout

\begin_layout Itemize
Initially, code assigns values to variables, allowing other code to read
 them.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, a subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Itemize
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>...)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Itemize
Finally, these components are intertwined, enabling writing into a variable
 to automatically trigger other code to read the new values.
 For instance, declaring 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 establishes a continuous relationship between variables, so that when the
 code 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 is executed, variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated automatically to reflect this new value.
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists 
\emph on
accidental
\emph default
 complexity, that does not the inherently complexity of the problem at hand.
 In the first abstraction, there is no mechanism to inform potential readers
 of changes.
 Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 The second approach provide reactivity, by informing potential readers
 of changes.
 However, it requires to control when to inform readers, and for readers
 to inform which changes to subscribe to.
 This approach is difficult in high scale applications.
 Because, it is not always clear when to inform readers about changes, or
 for the readers when to subscribe to or unsubscribe from.
 The last approach abstract out the previous complexity, so that writing
 into variables triggers potential readers to read the changes.
\end_layout

\begin_layout Plain Layout
This thesis's contribution is providing even a more clean abstraction by
 abstracting out accidental 
\emph on
cycles
\emph default
.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presented, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 This thesis proposes a paradigm shift where cycles need not be detected,
 as they are supported and considered meaningful.
\end_layout

\begin_layout Plain Layout
We introduce this paradigm by adapting it to Object-Oriented Programming
 (OOP)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 and encapsulation.
 For instance,
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE{C.A}$
\end_inset

 refer to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 associated with an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is a variable associated with the current class.
 Similarly, in inheritance, a behavior can be represented by the formula
 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is associated with the current class.
 According to the encapsulation principle, a class containing a formula
 treats it as private details, unknown to others.
 Indeed, it is unable to prevent creating cycles, but enables simplicity,
 as each class owns its own responsibility without concern for other responsibil
ities
\end_layout

\begin_layout Paragraph
Data Dependencies and Dataflow
\end_layout

\begin_layout Paragraph
Circular Dependencies
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
that the left hand variable 
\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\RIVar$
\end_inset

 stands for 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables,
\emph default
 being 
\emph on
reactive
\emph default
 variables and also 
\emph on
instance
\emph default
 variables (i.e., fields associated with objects).
 The name reactive refer to the contino 
\end_layout

\begin_layout Plain Layout
This enables creating formulas as 
\end_layout

\begin_layout Plain Layout
so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
This paradigm is based on Object Oriented Programming (OOP) with encapsulation.
 We name 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default

\begin_inset Formula $\RIVar$
\end_inset

 for short, being reactive variables and also instance variables (i.e., fields
 associated with objects), so that they can be associated externally like
 using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
that the software solves.
 
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists a complexity that a variable change
 might indirectly result from itself.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presents, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 
\end_layout

\begin_layout Plain Layout
Depending on how users see the software, complexity is considered as 
\emph on
accidental
\emph default
 if it does not inherent in the problem that the software solves.
 
\end_layout

\begin_layout Plain Layout
We aims to adds required abstractions for abstracting out complexity related
 to cycles or loops.
\end_layout

\begin_layout Plain Layout
Depending on the problem, this complexity can inherent in the problem that
 the software solves as seen by the users, or accidental as it arises only
 through the implementation.
 Nevertheless, a variable change might indirectly result from itself is
 accidental, because 
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a new paradigm that aims to provide a high-level language where data
 dependencies are specified directly by the language, rather than relying
 on the traditional event-driven paradigm where developers manually manage
 variable values.
 For example, in the event-driven paradigm, variables 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
 each have a 
\family typewriter
change
\family default
 event to which event handlers are registered.
 Within these event handlers, code calculates the sum of the values contained
 in 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
, and then updates a variable, 
\family typewriter
A
\family default
, with that value.
 From an FRP perspective, this should be declared simply as 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 making the data dependencies explicit directly in the code.
 In this context variables are named 
\emph on
reactive variables
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
traditionaly named in some variations: 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 and also (like us) 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, reactive variable (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) can be specified by a declarative manner, sometimes 
\emph on
lifting
\emph default
 a call-by-value programming language
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Consider 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 (depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

) of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 (using syntax specified by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset

).
 The expression associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to (or changes in a value
 of) 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Further, expressing 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 means an input of 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , which triggers to change a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE 2$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE +$
\end_inset

 in the example) are converted (or lifted) from operating over values to
 operate over reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Generally, such associations establish 
\emph on
data dependencies
\emph default
, in which a left-hand variable depends on variables in a right-hand side.
 According to dependencies, variables are continuously re-evaluated, by
 change propagation processes.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // causes A=2
\end_layout

\begin_layout Plain Layout

B=6 // causes A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
hspace{3cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operation establishes a data dependency, depicted by the graph from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Consequently, the subsequent 
\begin_inset Formula $\LSTINLINE =$
\end_inset

 operations of assigning values to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 cause corresponding changes to
\begin_inset space ~
\end_inset


\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named sometimes 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
Focusing on 
\begin_inset Formula $\RIVar$
\end_inset

, this thesis emphasizes 
\emph on
de-centralization
\emph default
.
 Analogous to OOP that used to model applications with classes and objects,
 many modern applications consist of components 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 Similarly, systems are often interconnected, functioning as a single cohesive
 unit with multiple subsystems (e.g., a Customer Relationship Management (CRM)
 system combined with an order processing system).
 (In FRP, most implementations use a centralized mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Even in harmonizing FRP with OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

, there is coupling to a centralized component which handles calculations.
 Similarly, in GUI applications, there is widespread adoption of solutions
 like 
\begin_inset Formula $\NAME{Redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

 which provide centerlized state management
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.)
\end_layout

\begin_layout Plain Layout
The research direction focuses on de-centralization by enabling cycles in
 data dependencies.
 This approach stands in contrast to a conventional method of constructing
 hierarchical graphs, where variables are connected to the input elements,
 and subsequently variables depend on other variables, forming an acyclic
 dependency graph (DAG) 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Additionally, the research direction diverges from the traditional perspective
 that regards cycles as merely an edge case 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, we say that, a variable depends on other variables, if changes in
 those variable propogate to the first.
 In FRP, various algorithm has been developed to automate the propagations.
 This automation
\end_layout

\begin_layout Plain Layout
FRP is a programming paradigm where specification of fields contents are
 decoupled from the way of how to apply it in runtime.
 The developers use a library that manage graphs,
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
State management is an aspect in front end development, responsible on updating
 fields according to other fields.
 The specifications of how to manage the updates are of various forms and
 patterns.
 One of the forms suggests high level specifications by lifting
\end_layout

\begin_layout Plain Layout
uses a concept that functions can be lifted
\end_layout

\begin_layout Plain Layout
One of the forms uses a concept, that similar to function over values (and
 variables that contain values) to function over fields.
 Then establish continous relationship instead of the traditional temporal
 assignment.
\end_layout

\begin_layout Plain Layout
between the function and the target variable.
\end_layout

\begin_layout Plain Layout
values and operations are lifted
\end_layout

\begin_layout Plain Layout
, rules and input over time.
 In response to an input, code is executed and update fields.
\end_layout

\begin_layout Plain Layout
There are several common abstractions (with variants) used for this task.
 events, streams, one-way constraints and two way constraints.
\end_layout

\begin_layout Plain Layout
————–
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 is a core concept in 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, including some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Consider an example of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the example, a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE +$
\end_inset

 in the example) are converted from operating over values to operate over
 reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Such an association establishes data dependencies, so that the left-hand
 variable depends on the variables in the right-hand side, and it is continuousl
y re-evaluated according to updates in the dependencies.
 Such a behavior of the continuously re-evaluations defines the variables
 (such as 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 in the example) to be reactive variables.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This can be applied to input fields in GUI applications.
 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 are one of such GUIs.
 Similar to reactive variables associated with expressions composed of other
 reactive variables, cells in 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 contain formulas to determine values based on other cells.
 Also in other applications, GUI developers need often to develop behaviors
 similar to reactive variables (i.e., update fields values based on other
 values filled in the other fields).
 In modern frameworks, this is applied using 
\emph on
state management solutions
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\begin_layout Plain Layout
The research direction stems from an analysis of the impact of preventing
 cycles.
 When declaring new data dependencies, in order to avoid cycles, it is essential
 to ensure that transitive dependencies do not depend on the fields from
 which the new dependencies originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A possible reason for not being de-centralized, is because of unintended
 unacceptable feedback loops, i.e., a change in one field leads to a subsequent
 change that feeds back and affects the original field itself.
 When declaring new data dependencies, it is essential to ensure that transitive
 dependencies do not depend on the fields from which the new dependencies
 originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(composing many pieces of small functionality togather, might leads to huge
 complexety.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Accordingly,
\end_layout

\begin_layout Plain Layout
Besides the need to handle cycles, cycles are often treated only as an edge
 case.
 Typically, calculations are hierarchical, i.e., variables are connected to
 the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis focuses on enabling de-centralization by introducing an embedded
 support for cycles.
 We introduce a framework that classes of OOP contain reactive variables
 and also contain associations that establish data dependencies.
 Objects instantiated from these classes then manage updates privately based
 on the (private) data dependencies within their class.
 We introduce this framework, by defining a new concept named 
\family typewriter
Reactive Instance Variable
\family default
\emph on
,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 According to its name, the new concept harmonizes 
\family typewriter
reactive variable
\family default
 of FRP with 
\family typewriter
instance variable
\family default
 of OOP.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis defines 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, for breaking down code of reactive variables into objects.
 
\begin_inset Formula $\RIVar$
\end_inset

 is an harmonized concept of reactive variable and instance variable, because
 
\begin_inset Formula $\RIVar$
\end_inset

 is a reactive variable associated to objects of OOP.
 Over such reactive variables (
\begin_inset Formula $\RIVar$
\end_inset

s), this thesis introuduces a new variant for FRP named Non-Hierarchical
 FRP (NH-FRP) with an embedded support for cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
because objects can contain formulas as internal behavior and the updates
 in runtime are also managed privatly.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we introduce a new variant of FRP, named Non-Hierarchical
 FRP (NH-FRP), that indeed supports cycles.
 By using NH-FRP, reactive variables can be associated with objects as instance
 variables, which we name 
\emph on
reactive instance variables
\emph default
 (a 
\begin_inset Formula $\RIVar$
\end_inset

 in singular), while calculations over 
\begin_inset Formula $\RIVar$
\end_inset

s are managed as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
In the new variant, we use a propagation strategy, in which the propagated
 values are accompanied by timestamp data.
 According to the timestamp data, obsolete values from feedback loops are
 identified and blocked from passing forward.
 By using NH-FRP, reactive variables can be associated to objects, with
 the name 
\emph on
reactive instance variables
\emph default
 (a RIVar in singular), while also the calculations over them are managed
 as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
To solve the problem we introduce Non Hirarchial FRP, a new varian;t of
 FRP that support cycles.
 This new variant consists of a propagation strategy, so that the propogated
 values are attached with data about their time, by whom absolete value
 from feedback loops are not passed forward.
\end_layout

\begin_layout Plain Layout
This new varaint enables cycles by embedding an algorithm, that each variable
 ignores absolete values.
\end_layout

\begin_layout Plain Layout
This new variant enables cycles by an approach, that each variable can depend
 on multiple sources, where each of the sources can update the variable
 on its updated value.
\end_layout

\begin_layout Plain Layout
For example, given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formulas 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A-1}$
\end_inset

 create associations, so that A
\end_layout

\begin_layout Plain Layout
associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
In the context of FRP, Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 suggests an alternative mechanism the centerlized mechanism that have access
 to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
this includes two stages.
 First, a centerlized mechanism that have access to the entire dependancy
 graph.
 Second,
\end_layout

\begin_layout Plain Layout
FRP still does not provide a better solution in this aspect.
\end_layout

\begin_layout Plain Layout
In FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
 This is the state also in works that harmonizes FRP with OOP.
\end_layout

\begin_layout Plain Layout
Two stages do exist in the task: declaring the calculations and the runtime.
 For the two stages, the centerlization is unaccepted.
 In DFRP, there are decenterlized algorithms to decenterlzed in runtime
\end_layout

\begin_layout Plain Layout
.
 First to depedencies.
 The decenterlized implemention need
\end_layout

\begin_layout Plain Layout
A possible reason is that adding
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
Unfortunaly, the way the state is managed, does not stand with the standard
 to breaking down code into modules or objects.
 An example is a widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Similarly in FRP
\end_layout

\begin_layout Plain Layout
The centerlization includes the runtime and the code.
\end_layout

\begin_layout Plain Layout
The centerliation is applied in runtime, by a centerlized mechanism that
 have access to the entire dependancy graph.
 This has solution in the field of Distributed FRP 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 For the centerliation in code, there is a problem
\end_layout

\begin_layout Plain Layout
In addition, when maintaining the code, adding a dependancy requires the
 check against transitive dependencies to not create cycles.
 means sometimes to check against unreachable classes or objects
\end_layout

\begin_layout Plain Layout
This problem is applied also in FRP: according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
The centerlization consists of two parts.
 First, in runtime, one centerlzed mechanism that access the ..
\end_layout

\begin_layout Plain Layout
second, in the code itself,
\end_layout

\begin_layout Plain Layout
The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\begin_layout Plain Layout
FRP aims to solve the difficulties in controlling the calculations.
 In the events driven paradigm updating a field might trigger a change event
 which trigger other updates and so on.
 In the worst case, the chain of updates can being an infinite loop of updates.
\end_layout

\begin_layout Plain Layout
Traditionaly, two strategies handle the problem.
 First, specifying calculations hierarchically, i.e., variables are connected
 to the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 This fact is often mentioned in FRP.
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to keep from unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamicaly.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitary break existing cycles.
 Overall, cycles are considered as an 
\emph on
edge-case
\emph default
, i.e., a special situation without a common sense solutions.
\end_layout

\begin_layout Plain Layout
The second strategy is centerlization.
 in front ends development there is widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Also in FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
This work is motivated
\end_layout

\begin_layout Plain Layout
Furtheremore, while keeping from undesirable cycles, dependencies must be
 reachable, leading again to centerlization.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The second strategy is centerlization.
 according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations of FRP depends on a centerlized mechanism
 that have access to the entire dependancy graph.
 Also in front ends development there is a common sence to manage the caculation
s in a centerlized mannar since the widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We focus on enabling calculation without those conditions.
 We adapt OOP, such that objects handle their calculation separately, and
 also that the objects contain calculations without ever knowing about other
 related calculations.
 In this new settings, we does not avoid cycles.
 The check against cycles requires that, whenever fields calculations are
 added, to check that the data dependency graph remains acyclic.
 The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Generally, the graph is managed in a centerlized mannar.
\end_layout

\begin_layout Plain Layout
In order to implemented the reactive variables correctly, the graph is managed
 in a centerlized mannar, otherwize there might be inpredictable behavior.
\end_layout

\begin_layout Plain Layout
In order to improve the error-prone development of reactive variables or
 fields calculations,
\end_layout

\begin_layout Plain Layout
The development of fields calculations is error prone.
 Therefore
\end_layout

\begin_layout Plain Layout
The noval approach of FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Beside this approach, there is the event-driven approach that fit Object
 Oriented Orogramming (OOP).
 In this approach, components can be extended, to react to variables' updates.
 On top of this
\end_layout

\begin_layout Plain Layout
There is the event-driven programming by which developers have a complete
 control over the propagation order,
\end_layout

\begin_layout Plain Layout
Beside this approach, there are approaches that fit Object Oriented Orogramming
 (OOP).
 There is the event-driven programming by which developers have a complete
 control over the propagation order, but this is error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 There is also frameworks like 
\begin_inset Formula $\ReactiveX$
\end_inset

 that provide a more abstract approach, to function over streams of events,
 that are closely related to the reactive variables.
 There the developers can choose between several schedulers to indicate
 the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 is a library in 
\begin_inset Formula $\NAME{Scala}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.scala-lang.org/
\end_layout

\end_inset


\end_layout

\end_inset

 that allows reactive variables being within objects or classes, modeling
 the fields calculations as part of components.
 The library derives previous FRP implementations, which is designed to
 produce consistent behavior, by an algorithm that carefully determines
 the order in which to update the variables.
 Another library 
\begin_inset Formula $\ReactiveX$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 that has first introduced for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 but adopted for more programming languages, provides an an API based on
 some OOP design patterns, to treat variables as streams of their changes.
 This can also been considered as reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 which objects can contain.
\end_layout

\begin_layout Plain Layout
The the two have different approaches, which lead to different results.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 leading to 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, outdated values are filtered out.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, when saying Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, there is no guarantee for 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 .
\end_layout

\begin_layout Plain Layout
We call them 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables remind fields in front-end applications, that are calculated
 according to other fields.
 In FRP, in order to create a variable that is automaticaly calculated according
 to other variables, it should be specified decleratively as a formula.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to change to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
(It might be challenging, to deal with the fields calculations that involve
 long chain of updates.
 The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

.
 The left challenge is in managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
an API based on some OOP design patterns, to treat variables as streams
 of their changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, abstracting
 components with fields.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefully determines the order in which
 to update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables as
 streams of their changes.
 Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
the tra of the declaring the data depedencies explicity, it should become
 easier.
\end_layout

\begin_layout Plain Layout
In the development of front-end and other reactive applications there are
 two dependencies types: data dependencies and source code depedencies,
 which should be organaized efficiently.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, there is an effort to make the data dependencies declared in the languages,
 instead that the developers need to understad the depedencies from the
 control of the programs.
 Traditionaly, it is hard to understand the dependencies, because it is
 spread over the event handlers.
\end_layout

\begin_layout Plain Layout
In the paradigm of OOP, there are abstraction mechanism to manage the source
 code dependencies.
 according to business needs, then changes in the code that handle data
 dependencies in one component might lead to require other components to
 be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, lanigages has been deveoped that lift the assignment statements, to create
 data dependencies, so that the variables will continoue to update according
 to the depeodencies.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
\end_layout

\begin_layout Plain Layout
Reactive variables have a special assignment operation (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operator) that defines a 
\emph on
data
\emph default
 
\emph on
dependenc
\emph default
y: the target reactive variable depends on the variables in the expression.
 The expressions are 
\emph on
lifted 
\emph default
executed functions, so that the target reactive variable continuously contains
 the value derived from the values of the reactive variables it depends
 on.
 A propagation of changes starts whenever any of the variables get user
 input (
\begin_inset Formula $\LSTINLINE =$
\end_inset

 operator).
 This causes the dependencies to re-evaluate, which causes their dependencies
 to re-evaluate, and so on.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 Applications are usually composed of several or many components that runs
 in one or many hosts.
 In such settings, changes in the code that handle data dependencies in
 one component might lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the Object Oriented Paradigm (OOP) difrent parts of the application in
 the form of objects can be loosly coupled, even when they interacts in
 such a way that variable in one object depends on variables of other objects.
\end_layout

\begin_layout Plain Layout
applications are modeled as objects that the components can usesuggests
 to form applications by objects to be used model running components or
 that can extend and compose each other, that can react to
\end_layout

\begin_layout Plain Layout
In the events paradigm, it is hard to control what the data depedencies
 are, because logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 In addition, if an application is composed of several components, according
 to business needs, then changes in the code that handle data dependencies
 in one component might lead to require other components to be changed according
ly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
it might be hard as every large application, that contains too much details
 to the developer think.
\end_layout

\begin_layout Plain Layout
the complex or huge logic, in the form of uge amount of data depedencies.
\end_layout

\begin_layout Plain Layout
the huge amount of data depedecies might be hard to manage as it is complex
 logic
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 The first difficulty is to control the data dependencies.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In FRP, the goal is that the developer has a langague to express the data
 dependenies directly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage the dependencies between code components.
 If the code that handles data dependencies handling involves several components
, they might become 
\emph on
coupled
\emph default
.
 If changes in one component lead to require other components to be changed
 accordingly, the first component depends on the second component 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In the Object Oriented Programming, the applications parts has the form
 of objects.
\end_layout

\begin_layout Plain Layout
, that consume and extend each other, which are used to manage the code
 changes efficiently.
 The objects are used to sompose applications
\end_layout

\begin_layout Plain Layout
According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, although
 they have different focuses.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefuly determines the order in which to
 update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables by
 streams of their changes.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 from the 
\emph on
Functional Paradigm
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Itemize
An evaluation of procedural programming for achiving an alternative for
 data synchronization using a push model.
\end_layout

\begin_layout Itemize
We introduce an encapsulation method of bundling data dependencies utilized
 for data synchronization in a push model.
\end_layout

\begin_layout Itemize
We introduce a change propagation mechanism through sending and receiving
 messages (for being aligned with the encapsulation principle)
\end_layout

\begin_layout Itemize
We introduce a declerative language for specifing the bundles.
\end_layout

\begin_layout Itemize
We introduce a programming lanuage feautre (as an extension or library)
 for enabling the above concepts.
\end_layout

\begin_layout Itemize
We expand knowledge about cycles and loops in data synchronization.
\end_layout

\begin_layout Itemize
We introduce a feature 
\begin_inset Quotes eld
\end_inset

add filling option
\begin_inset Quotes erd
\end_inset

 beside the traditional feature 
\begin_inset Quotes eld
\end_inset

add computed field
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
\end_layout

\begin_layout Plain Layout
Reactive variables can be used to fields calculations, by connecting to
 visual fields.
\end_layout

\begin_layout Plain Layout
For instance, 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 is a state management solution for 
\begin_inset Formula $\NAME{React}$
\end_inset


\end_layout

\begin_layout Plain Layout
applications, with the functionality like reactive variables.
\end_layout

\begin_layout Plain Layout
provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In maintaining and updating the variables, we sometimes face an unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications grow
 and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
\end_layout

\begin_layout Plain Layout
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
\end_layout

\begin_layout Plain Layout
The second complexity part is to separate the task into small manageable
 and independent tasks, for being in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second, we relate to the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
 This paradigm enables that different parts of the software, in the form
 of objects, are loosely coupled and do not depend on one another.
 This makes it easier to change objects without affecting the others.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 the reactive variables are part of the object interface, but implemented
 differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We present a semantic framework that enables the separation of data dependency
 management within objects.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both C# and
 JavaScript, along with a small application example.
\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Plain Layout
We first start with demonstrating the balance in the existing solutions,
 between predictable and decenterlzed solutions.
 Then we demonstrate our framework, an implementation.
 Finaly we compare
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start with deonstrating an example for an application, and dicuse the
 existing the challenges exsting in the exsiting approaches
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Background}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a background about implementing FRP under the hood.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

presents an example to demonstrate the need for 
\begin_inset Formula $\RIVar$
\end_inset

s.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Method}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present the new variant of FRP, so that reactive variables will be able
 to be 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Evaluation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we compare the model against the other solutions and paradigms, in handling
 graphs and reducing code duplication.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Implementation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present 
\begin_inset Formula $\RIVarX$
\end_inset

 with an implementation to the example presented in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

 being the case study.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities,
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
We focus on enabling FRP in OOP settings, so that it can be used across
 components.
 The point is that the visibilty of the elements can vary according to the
 organizations needs.
 The functions are defined over elements named 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they are reactive variables that can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
 The second point is that the visibility of the calculations are kept also
 in runtime by avoiding a madiator or any centeral engine to handle the
 calculations.
 We keep it simple, that each update trigger the next one as a simple function
 call.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize
We name a concept 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, an harmonized concept of 
\emph on
reactive variable
\emph default
 with 
\emph on
instance variable
\emph default
.
\end_layout

\begin_layout Itemize
We introduce Non-Hierarchical FRP (NH-FRP), a new variant of FRP, that supports
 cycles.
\end_layout

\begin_layout Itemize
We introduce a new form of abstraction, that enables ...
\end_layout

\begin_layout Itemize
We introduce a method
\end_layout

\begin_layout Itemize
We provide 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 This provides also a state management solution.
\end_layout

\begin_layout Itemize
We introduce an abstraction mecainsm of 
\begin_inset Quotes eld
\end_inset

add filling options
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We introduce semantics for mutual recursions, which traditionally causes
 cycles or loops in the change propagation.
\end_layout

\begin_layout Itemize
We introduce an algorithm that handles mutual recursions.
\end_layout

\begin_layout Itemize
We create a simple framework for creating computed fields.
\end_layout

\begin_layout Itemize
We provide an implementation: 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 The later is provided as a state management solution, that has integration
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we list state of the art strategies for calculations input fields in GUI
 applications.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present aspects for enhancements in fields calculations.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we explain our approach and implementation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we evaluate the approach.
 We explore architectural design options to the Drug Administration application
 and compare it to the one achived by our approach.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Related-Work"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we associate concepts in our approach to the previous paradigms.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusion"
plural "false"
caps "true"
noprefix "false"

\end_inset

 contains the conclusion and the future work.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
