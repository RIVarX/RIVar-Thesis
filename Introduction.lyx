#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
In Functional Reactive Programming (FRP) paradigm, a reactive variable 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 can be assigned by an expression consisting of a set of reactive variables,
 for being populated in response to changes.
 Concretely, the value of the variable equals to the value of the expression,
 which is evaluated in response to changes in the value of any of the variables
 existing in the expression.
 For example, the meaning of the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 is that the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, so that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
FRP abstracts away the need to handle variables' consistency, i.
 e.
 from the need to update variables in response to variables' changes.
 However, it is desireable to use also Object Oriented Programming (OOP),
 to have an additional abstraction mechanism that is missing in FRP.
 In detail, programmers in OOP can use mechniams such as inheritance to
 reduce code duplication.
 Consequently, a change request does not require changing the code in several
 places.
 Therefore, the data consistency defining the software behavior is abstracted
 away.
 Thus, the software behavior can have a 
\emph on
single source of truth.
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code of the OOP
 paradigm.
 For example REScala, which is an extension to Scala language, enables convertin
g between reactive variables and events.
 An additional library SignalJ includes an integration mechanism providing
 events considered as side-effects for variables' changes.
 An API named ReactiveX for C# Langauge, adoped by more languages (e.g.
 RxJS in JavaScript) provides a reactive variable as an events stream.
 The reactive variable value is presented over time by the events stream.
\end_layout

\begin_layout Standard
Integration of functional-reactive code with imperative code might contain
 circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might cause an execution
 of an event handler, causing the reactive variable to change.
 The problem might happen also in pure FRP (such as might happen by imperative-b
ased implememtation), in presence of recursive definitions.
 For example, the formulas defintions 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-1
\end_layout

\end_inset

 contains circular dependencies: the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, and the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 relates to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

A-1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The responsibility to avoid circular dependencies is applied to many places
 in the code.
 However, is there an option to separate the functional-reactive code to
 classes (to use OOP on top of FRP), and map them to responsibilities, with
 no responsibility leakage? It impacts software architecture: given a
\emph on
 black-box
\emph default
 software component exposing reactive variables, can it be extended, including
 assigment, without digging into components' internal details (avoiding
 
\emph on
closing cycles
\emph default
)?
\end_layout

\begin_layout Standard
In an attempt to combine FRP with OOP, declaring class variables with reactive
 variables behavior, we face the following conflict.
 According to FRP, time resolution is abstracted away.
 Consequently if an expression is reated to a variable, it does not make
 sence to reassign it, e.g.
 to evaluate 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 
\emph on
and then
\emph default
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=C+1
\end_layout

\end_inset

.
 However, in OOP, to those reactive variables that should be assigned, thare
 might be encapsulated evaluated formulas.
 Thus reassign procedure is required.
 
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We solve the conflict between the paradigms, by defining semantics to multiple-a
ssigments instead of reassigment, and which enable recursion defintions.
\end_layout

\begin_layout Standard
We define 
\emph on
Reactive Instance variable
\emph default
, named 
\emph on
RIvar
\emph default
, as a combination of 
\emph on
instance
\emph default
 variable from OOP and 
\emph on
reactive
\emph default
 variable from FRP.
 RIvar abstracts a stream, an assigment abstracts stream-registration, and
 the mutiple-assigment abstracts somehow a merge beween the registered streams.
 
\end_layout

\begin_layout Standard
We present semantics to mutiple-assigment similar to one used in constraints
 systems, and implement a prototype of an application which uses RIvars
 to define contracts between objects.
 This prototype might help in reducing complexity by seperating real world
 complex applications.
\end_layout

\end_body
\end_document
