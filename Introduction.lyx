#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a paradigm that abstracts away the need to update variables in response
 to other variables' updates.
 A 
\emph on
reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, or 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

) can be assigned by an expression consisting of a set of other reactive
 variables, consequently the value of the variable is set to the value of
 the expression, and continuously re-evaluated in response to changes in
 the value of any of the variables appearing in the expression.
 For example, given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 changes in response to any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Previous works 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards,boix2013object"
literal "false"

\end_inset

 research the integration of FRP with the traditional Object Oriented Programmin
g (OOP).
 In OOP, classes evolve without interfering other classes by using 
\emph on
contracts
\emph default
, and encapsulating the internal implementation.
 In the simplified form, the contract is the 
\emph on
interface
\emph default
, which defines the accesible variables and methods, to consumers or subclasses
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 In the integrated paradigm, we then expect to abstract away the need to
 update variables, while keeping classes' encapsulation.
\end_layout

\begin_layout Standard
In this work we focus on the approach 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, in which an existing language can be extended with a variation of reactive
 variables as a data type.
 Accordingly, libraries such as ReactiveX
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

 and REscala
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://www.rescala-lang.com}
\end_layout

\end_inset

, support having a variation of reactive variables as objects' data members
 (named also 
\emph on
instance variables
\emph default
).
 
\end_layout

\begin_layout Standard
Therefrom, objects' classes can contain
\emph on
 reactive instance variables
\emph default
, that are instance variables of type reactive variables.
 Also, objects' classes can contain formulas based on the reactive instance
 variables they contain.
 The formulas are activated once the objects are created.
 e.g., class 
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 contains two reactive instance variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, and contains also the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

.
 Consequently, in each instance of C, 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 that is associated to the instance will continuously re-evaluated in response
 to changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 that is associated to the same instance.
\end_layout

\begin_layout Standard
Interfaces also can contain reactive instance variables.
 Also, classes' internal behavior can contain formulas, refering the reactive
 instance variables accessed by the interfaces.
 e.g., base class contains two reactive instance variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, and a derived class have access to them and contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 Similary, class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

x.B:=x.A
\end_layout

\end_inset

, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a reference type, with an access to an object, contained reactive instance
 variables A and B.
\end_layout

\begin_layout Standard
Accordingly, the reactive instance variables are accessed via interfaces
 and been associated without being aware of other related associations.
 However, it might lead to constructions, for which the semantics should
 be clearly defined.
 Otherwize, they are avoided by breaking classes' encapsulation.
 In the next lines we will present the problematic constructions.
 In the examples below, reactive instance variables are declared in the
 base class, the derived class have access to them.
 and the both contains formulas associating them without being aware of
 other associations.
\end_layout

\begin_layout Standard
Reactive instance variables can have 
\emph on
cycles
\emph default
, e.g., base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

.
 This might lead to infinite loop: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In addition, reactive instance variables can have 
\emph on
glitches
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

: if there are several variables calculated from one variable, and the variables
 apear in one expression, then it might be incorrect to evaluate the expression,
 while other variables have not updated yet.
 e.g., base class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=B
\end_layout

\end_inset

 , while the derived class contains 
\begin_inset ERT
status open

\begin_layout Plain Layout

D:=A+C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In FRP, cycles are generaly avoided, otherwize the behavior is not 
\emph on
predictable.
 
\emph default
In contrast, FRP is generaly 
\emph on
glitch-free
\emph default
, by algorithms that handling the order of the evaluations.
 However, there are more possible semantics and algorithms to both.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We introuce semantics for FRP which support cycles and is glitch-free.
 The new semantics is applied with the introduced reactive instance variables,
 being consistent with both 
\emph on
instance variables
\emph default
 from OOP and 
\emph on
reactive variables
\emph default
 from FRP.
 We then implement a prototype of an application and compare it against
 other approaches and solutions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{Outline.}
\end_layout

\end_inset

 Chapter 3 presents a motivation example, Chapter 4 presents the proposed
 semantics, Chapter 5 uses the new semantics by implementing the new type
 
\emph on
RIvar
\emph default
 for C# programming language.
 Chapter 6 evaluate the results by the help of a prototype application.
\end_layout

\end_body
\end_document
