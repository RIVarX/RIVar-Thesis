#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset

Introduction
\end_layout

\begin_layout Standard

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) is a concept from the 
\family typewriter
Reactive Programming
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 paradigm that aims to solve problems in 
\family typewriter
Events Driven Programming
\family default
 (EDP) paradigm.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While event-driven programming encompasses various mechanisms, this discussion
 is limited to its implementation using the Observer pattern.
 This pattern allows objects to register interest in events and be notified
 when they occur, fostering loose coupling and flexibility.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The origin of reactive variables is from the 
\family typewriter
Functional Reactive Programming
\family default

\begin_inset space ~
\end_inset

(FRP) paradigm, that aims to use principles from the 
\family typewriter
Fucntional Programming
\family default
 (FP) paradigm.
 Reactive variables have a representation similar to pure functions in FP,
 in expressing code that calculate needed output based on arguments.
 For example, in 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 is equivilent to in Javascript
\color blue
 function A(B){return B+1}
\color inherit
.
 The meaning is similar to functions in mathematics
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Function_(mathematics)
\end_layout

\end_inset


\end_layout

\end_inset

 as a model of how varying values (real-world variables) depend one on another.
\end_layout

\begin_layout Standard
Frameworks that implement reactive variables enable to model varying values
 by re-evaluating values automaticaly.
 Typically, these frameworks initiate dependencies, track them, and re-evaluate
 values in response to changes in the dependencies.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), in expressing 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, a dependency is initiated, such that A depends on B, such that whenever
 B has a change, A will be updated accordingly.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

A:=B+1
\end_layout

\begin_layout Plain Layout

B=1 // causes A=2
\end_layout

\begin_layout Plain Layout

B=6 // causes A=7
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
hspace{3cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (B) at (0,0) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (A) at (-2,0) {A};
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (A) -- node[above] {} (B);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reactive-variables-basics-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reactive variables example.
\end_layout

\end_inset

Reactive variables example.
 The 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operation establishes a data dependency, depicted by the graph from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Consequently, the subsequent 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 operations of assigning values to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 cause corresponding changes to
\begin_inset space ~
\end_inset


\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is an example of using reactive variables, where the value of variable
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 depends on the value of variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
 (We choose to represent the dependancy from the derived variable to the
 variable it is derived from, to be consistent with derived class that in
 uml the dependencay is illustrated from the derived class to the subclass.
 The direction presents that change causes the dependancy to change, and
 not the direction of the data flow.) Whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 is automatically updated accordingly.
 The formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, which means that the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any changes in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In a similar setting, we name the reactive variables as reactive instance
 (interface) variables, or simply RIVar.
 In using RIVars, the assignment operator, rather than initiating a variable
 according to the right-hand expression, will only register the left-hand
 variable to be updated to changes of the right-hand expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 This concept is similar to one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This concept exists also in constraints programming with the name one-way
 dataflow constraint 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, on top of events programming (or the Observer pattern), this setting
 is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, EDP still has an advantage in its ability to promote loose coupling
 between components.
 This is based on the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 In this pattern one component, the 
\emph on
observable,
\emph default
 triggers other components, the observers, about new content.
 An observable is decoupled from its observers, since its knowledge about
 them is limited to only hold their references (of type Observer) upon their
 registration for updates.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, in this paradigm dependencies between variables are determined
 from executing the programs line by line.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In using the Observer pattern, an approach that still not researched is,
 what if an assignment means to directly update the left-hand variable according
 to changes from the right-hand expression.
 This makes the framework to fit component-based applications.
 In the other hand, this change requires to rethink about the propagation
 change algorithm.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
This enables to assign variable that exposed from a component
\end_layout

\begin_layout Plain Layout
rather than initiating a variable according to the right-hand expression,
 will register the left-hand variable to be directly updated to changes
 of the right-hand expression.
\end_layout

\begin_layout Plain Layout
In this thesis, we introduce a concept named RIVar as a short name to Reactive
 Instance Variable.
\end_layout

\begin_layout Plain Layout
As Object Oriented Programming (OOP) formalizes and emphasizes components,
 RIVar 
\end_layout

\begin_layout Plain Layout
This concept harmonizes 
\end_layout

\begin_layout Plain Layout
In this thesis, we introduces a concept that an assignment, rather than
 initiating a variable according to the right-hand expression, will only
 register the left-hand variable to be directly updated to changes of the
 right-hand expression.
\end_layout

\begin_layout Plain Layout
However, EDP has also an advantage that it is used to decouple components
 from each other.
 This is based on the observer pattern, such that an observable trigger
 interested parties about new content.
\end_layout

\begin_layout Plain Layout
In a similar setting, an assignment operator, rather than initiating a variable
 according to the right-hand expression, will only register the left-hand
 variable to be updated to changes of the right-hand expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 This has in common with one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This also has in common with constraints programming with the name one-way
 dataflow constraint
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, on top of events programming (or the Observer pattern), this setting
 is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
 
\end_layout

\begin_layout Plain Layout
A significant problem in this setting is 
\emph on
cycles
\emph default
 or 
\emph on
loops
\emph default
 that might be produced from creating 
\emph on
mutual recursions
\emph default
.
 In EDP, events raise more events inawaring by which they originaly raises.
 This might lead to loops, such that an event is raised indirectly by itself,
 and need to make an algorithm that stops the loop.
 For reactive variables, mutual recursions can be created causing such loops
 that lead to redundant updates for the variables.
 For example, A:=B and B:=A that produces A.changed += { (e) -> B.Change(e.value)
 } and B.changed += { (e) -> A.Change(e.value) }.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present a problem 
\end_layout

\begin_layout Standard
we present cycles as encountered in the field of reactive programming (including
 events, dataflow and constraints).
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
We introduce a new propagation algorithm with the following properties.
\end_layout

\begin_layout Description
Decentralized
\end_layout

\begin_layout Description
Predictable
\end_layout

\begin_layout Description
Cycles
\end_layout

\begin_layout Standard
We introduce a framework with the following properties.
\end_layout

\begin_layout Description
OOP Variables exposed from objects, Assignments initiate dependencies
\end_layout

\begin_layout Description
FRP
\end_layout

\begin_layout Description
Constraints
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
———–
\end_layout

\begin_layout Standard

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) is a concept from the 
\family typewriter
Reactive Programming
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 paradigm that aims to solve problems in 
\family typewriter
Events Driven Programming
\family default
 (EDP) paradigm.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While event-driven programming encompasses various mechanisms, this discussion
 is limited to its implementation using the Observer pattern.
 This pattern allows objects to register interest in events and be notified
 when they occur, fostering loose coupling and flexibility.
\end_layout

\end_inset

 The origin of reactive variables is from the 
\family typewriter
Functional Reactive Programming
\family default

\begin_inset space ~
\end_inset

(FRP) paradigm, that aims to use principles from the 
\family typewriter
Fucntional Programming
\family default
 (FP) paradigm.
 Reactive variables have a representation similar to pure functions in FP,
 in expressing code that calculate needed output based on arguments.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 is similar to function A(B){return B+1}.
 The meaning is similar to functions in mathematics
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Function_(mathematics)
\end_layout

\end_inset


\end_layout

\end_inset

 as a model of how varying values (real-world variables) depend one on another.
\end_layout

\begin_layout Standard
Frameworks that implement reactive variables enable to model varying values
 by re-evaluating values automaticaly.
 Typically, these frameworks initiate dependencies, track them, and re-evaluate
 values in response to changes in the dependencies.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), in expressing 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, a dependency is initiated, such that A depends on B, such that whenever
 B has a change, A will be updated accordingly.
\end_layout

\begin_layout Standard
The reactive variable abstraction makes the dependency between variables
 explicit, rather than in the traditional EDP 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 For example, in 
\family typewriter
EScala
\family default
 [16], in order to implement 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is achieved by calling an event, namely, changed, assuming that the object
 B has that event: 
\begin_inset Formula $\LSTINLINE{B.changed(newValue);}$
\end_inset

 The behavior executed when that event is fired is registered as an event
 handler that calculates the power difference for the motor as follows:
 
\begin_inset Formula $\LSTINLINE{B.changed+={(e)->A=e+1}}$
\end_inset

.
 Whereas the firing of an event is placed in the code that reads the sensor
 value, the event handler is declaratively represented.
 Thus, both are separately represented, and the dependency between 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

 is implicit.
\end_layout

\begin_layout Standard
Despite the advantages of reactive variables, the traditional representation
 offers benefits for component-based applications.
 Modern component technologies, including microservices and micro-frontends,
 which formalizes and emphasizes in Object Oriented Programming (OOP) paradigm.
 A key strength of both OOP and component technologies is the use of events
 to decouple components.
 This decoupling promotes loose coupling, which improves maintainability,
 reusability, and testability in component-based systems.
\end_layout

\begin_layout Standard
In this thesis, we focus on a setting that an assignment operator, rather
 than initiating a variable according to the right-hand expression, will
 register the left-hand variable to be updated to changes of the right-hand
 expression.
 For example, an expression A:=B will produce A.changed += { (e) -> B.Change(e.valu
e) }.
 
\end_layout

\begin_layout Standard
This setting has advantages and disadvantages.
 The advantage is that it is applicable for components and objects.
 For example, an expression like X.A:=B is applicable for an object or component
 X that exposes a variable A.
 The disadvantage is that cycles can be created in the dependencies, which
 leads to loops in the updates.
\end_layout

\begin_layout Standard
–
\end_layout

\begin_layout Standard
A setting used in one-way databinidng (for example <h2 innerHTML="{{ text
 }}"></h2>) and also in one-way dataflow constraint 
\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

, that 
\end_layout

\begin_layout Section
The Concept
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
In this thesis, we introduce a concept named RIVar as short name to reactive
 instance (or interface) variable.
 RIVar exposes an assignment operator that produces the needed steps, in
 terms of regitering to events, to make a left-hand variable to depend and
 be updated according to the right-hand expression.
 Basicly, an expression A:=B will produce something like A.changed += { (e)
 -> B.Change(e.value) }.
 Similarly, an expression like X.A:=B is applicable for an object X that
 exposes a variable.
 This opens a challenge, that we adress as well, that FRP still does not
 have a good answer for: how to deal with cycles.
\end_layout

\begin_layout Standard
————
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, the old representation has an advantage for components-based applicatio
ns.
 Current components technalogy includes: micro-services, micro-frontends
 and so on.
 A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In components technalogy and OOP, events enable to decouple components
 from one another.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The traditional EDP achieves similar functionality, but requires a more
 verbose implementation.
 First, a variable is declared.
 Second, a change event associated with that variable is defined.
 Third, whenever the variable is updated, the change event is raised.
 Finally, event handlers can be registered to listen for this event and
 execute code that updates other variables.
\end_layout

\begin_layout Standard
EDP is an important concept needed to components-based applications.
 Current components technalogy includes: micro-services, micro-frontends
 and so on.
 Even though they are popular, they does not provide a scalable solution
 for handling variables or 
\emph on
state.

\emph default
 State refers to what software remembers from past used to its future behavior.
 Generaly, it refers to any changeable data, stored anywere, used to determine
 output.
 In order to response to another component's changes, usualy code is registered
 to an exposed event.
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 
\end_layout

\begin_layout Standard
It has been suggested to connect between the EDP and FRP, connecting concepts
 from the two worlds.
 For example, in 
\family typewriter
REScala
\family default
, convertions functions does convertions between reactive variables and
 events 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In addition, it has been suggested, that a change in ractive variable raises
 an event and considered as 
\emph on
side effect
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 In addition, stream of events represents by a few as reactive variables
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
In this approach, operators over streams produce behavior similar to frameworks
 that support reactive variables.
\end_layout

\begin_layout Standard
However, traditional 
\family typewriter
Events Driven Programming
\family default
 (EDP) or the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

 is still in demand.
 Events enable service's consumer to register 
\end_layout

\begin_layout Standard
In components technalogy, Current components technalogy includes: micro-services
, micro-frontends and so on.
 A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In EDP, in order to sync between variables, several steps are needed.
 First, declaring a variable.
 Second, declaring a change event.
 Third, raise the event whenever the variable is updated.
 Finaly, registering an event handler, with code that update the other variables.
 This process enable to decouple between components, as code that change
 a variable need not to be aware of the code that change the second variable.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Even though they are popular, they does not provide a scalable solution
 for handling variables
\end_layout

\begin_layout Plain Layout

\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis' focus on feasibility for scalable technalogies of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Plain Layout
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this thesis, we focus on an idea that the explicit syntax for initiating
 dependencies, will produce events driven programming, as the mean of an
 assignment operator.
 Basicly, an expression A:=B will produce something like A.changed += { (e)
 -> B.Change(e.value) }.
 Similarly, an expression like X.A:=B is applicable for an object X that
 exposes a variable A.
 The assignment operator produces the needed steps to make a left-hand variable
 to depend and be updated according to the right-hand expression.
 This opens a challenge that FRP still does not have a good answer for:
 how to deal with cycles.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We propose a conceptual framework that harmonizes the concept of reactive
 variable with existing development environment, by depending on the events
 driven programming and the observer pattern.
 In this framework we introduce a noval approach in handling cycles in the
 dependencies.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
Reactive variables are similar to one-way dataflow constraint of constraints
 systems.
 In constraints systems, a set of equation is provided to the system, and
 in runtime the systems search for solutions to satisfy the equations.
 For GUI, the user would set values to variables, and in response a component
 named constraints solver would find a solution, such that most of constaints
 would be satsified
\end_layout

\begin_layout Standard
are basicly declared like functions with arguments.
 Automaticaly, the reactive variables are updated in response to changes
 in the values
\end_layout

\begin_layout Standard
, and are updated automaticaly in response to changes
\end_layout

\begin_layout Standard
replace the error prone events driven programming
\end_layout

\begin_layout Standard
Events Driven Programming is a paradigm in which code can be registered
 to an event, by which data can be sync.
 For example, assuming that the object sensorValue has that event: sensorValue.ch
anged(newValue); The behavior executed when that event is fired is registered
 as an event handler that calculates the power difference for the motor
 as follows: sensorValue.changed += { (e) -> powerDierence = f(e) },Whereas
 the firing of an event is placed in the code that reads the sensor value,
 the event handler is declaratively represented.
 Thus, both are separately represented, and the dependency between sensorValue
 and powerDierence is implicit.
\end_layout

\begin_layout Standard
Functional Reactive Programming is a paradigm derived from the Functional
 Programming paradigm and aims to replace the Events Driven Programming.
 The approach given by FRP, is that developers declare functions which initiate
 dependencies by which change ate automaticaly ptopagated.
 For example, powerDierence = f(sensorValue) makes that whenever sensorValue
 is changed, f is re-eavluated, and powerDierence is updated.
 In FRP, the dependencies are in a tree, without cycles.
\end_layout

\begin_layout Standard
Functional Reactive Programming is a paradigm derived from the Functional
 Programming paradigm.
 In FRP, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This syntax makes the dependencies directed or explicit compared to the
 traditional events programming.
 
\end_layout

\begin_layout Standard
In events programming, code is registered to an event, and the code makes
 the updates.
 we write sensorValue.changed(newValue); and sensorValue.changed += { (e)
 -> powerDierence = f(e) } using reactive variables, we just write powerDierence
 = f(sensorValue).
 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
This thesis' focus on feasibility for scalable technalogies of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 It has a 
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 Caused by event driven programming, code logic is spread over many functions.
 chain of updates executed through many code locations can sometimes be
 horrible.
 It is known as “it is hard to reason about”.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
\end_layout

\begin_layout Standard
, enables to extend objects by register methods to execute
\end_layout

\begin_layout Standard
Basicly, the problem in state management is that chain of updates executed
 through many code locations can sometimes be horrible.
 It is known as “it is hard to reason about”.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
 This problem is usualy caused by the event driven programming, as the code
 logic is spread over many functions.
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP), while it does bear from related difficulties as well
 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
An enhancement for managing state is a concept named 
\emph on
reactive variable
\emph default
 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

).
 The idea is that functions and variables are lifted so that assignments
 are applied for a long term.
\end_layout

\begin_layout Standard
Various frameworks enable to declare depedencies to make dependencies more
 directed than in the events driven paradigm.
\end_layout

\begin_layout Standard
This enables direct dependencies compared to the events driven paradigm.
 For example, in events driven paradigm, we write sensorValue.changed(newValue);
 and sensorValue.changed += { (e) -> powerDierence = f(e) } using reactive
 variables, we just write powerDierence = f(sensorValue).
 The idea is that functions and variables are lifted so that assignments
 are applied in a long term.
\end_layout

\begin_layout Standard
Events driven paradigm fit to components, makeing it enabled to extend them.
\end_layout

\begin_layout Standard
In contrast, reactive variables do not.
 (but they better in the declerative style).
\end_layout

\begin_layout Standard
we introduce an harmonized concept named reactive instance (or interface)
 variable (RIVar).
 In the new concept, the assignment establishes a continuous association,
 and also be called similar to an operation, without to determine type or
 internal details.
 For example, given RIVars B and C and also an object X that contains a
 RIVar A, performing X.A:=B+C are performed for various types of X, such
 that assignment is a method that establish the continuous association.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This is inspired from the functional paradigm, producing hirarcial data
 dependencies.
 This paradigm uses a dedicated framework, that propgate the changes automatical
y and predictability.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
In this work, we develop an idea that an assignment produces a subscribtion
 directly.
 For example, powerDierence = f(sensorValue) produces sensorValue.changed
 += { (e) -> powerDierence = f(e) }
\end_layout

\begin_layout Standard
We introduce a concept named RIVar, that is Reactive Instance (or Interface)
 Variable.
 RIVar harmonizes the concept reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and a concept named instance variable from the Object Oriented paradigm.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An enhancement for this subject is a concept named 
\emph on
reactive variable
\emph default
 (in some variations, known also as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) can be specified by a declarative manner, sometimes 
\emph on
lifting
\emph default
 a call-by-value programming language
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Consider 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 (depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

) of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 (using syntax specified by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset

).
 The expression associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to (or changes in a value
 of) 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Further, expressing 
\begin_inset Formula $\LSTINLINE{B=1}$
\end_inset

 means an input of 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , which triggers to change a value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE2$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE+$
\end_inset

 in the example) are converted (or lifted) from operating over values to
 operate over reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Generally, such associations establish 
\emph on
data dependencies
\emph default
, in which a left-hand variable depends on variables in a right-hand side.
 According to dependencies, variables are continuously re-evaluated, by
 change propagation processes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\end_layout

\begin_layout Standard
In case of a push notification, a chain of updates even may produce an infinite
 loop, in case of an accidental cycle.
\end_layout

\begin_layout Standard
(Cascading updates across numerous, scattered code locations can quickly
 become a maintenance nightmare.
 A centralized state management approach is often a safer and more manageable
 solution.
 This is because dispersed updates make it notoriously difficult to trace
 the origin, timing, and cause of a value change ("hard to reason about").
 For instance, when inspecting a variable, it can be a daunting task to
 determine who modified it, when, and why.
 Even worse, in case that a change triggers a cascade of updates that form
 a cycle, an accidental infinite loop can occur, leading to an endless and
 potentially damaging process.)
\end_layout

\begin_layout Standard
In a recent reaserch in reactive programming (RP) paradigm, a direct syntax
 for data depedencies is presented to replace the tradtional event driven
 programming.
 In RP, decalring A:=B is like A.changed+=A_changed; and in A_changed it
 is specfied to update B.
 In order to handle cycles
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard

\emph on
Reactive variable
\emph default
 is a variable abstraction in which the assignment operator establishes
 dependencies, such that an assigned variable becomes dependent on the variables
 within the assigned expression, therefore updated in response to their
 updates.
 For example, given variables A, B, and C, the formula A := B + C means
 that whenever B or C are updated the operation + is executed on the values
 that B and C contain, and update A with the result.
 This declarative style produces a 
\emph on
single source of truth
\emph default
, rather than repetition calls to update variables in many code locations.
\end_layout

\begin_layout Standard
This arises questions on such abstraction feasibility for scalable technalogies
 of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
 
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Oriented
 Programming (OOP).
 In this paradigm, an inheritance is a usefull meha
\end_layout

\begin_layout Standard
—–
\end_layout

\begin_layout Paragraph
Contribution
\end_layout

\begin_layout Itemize
Defining a total order on the set of updates, by which a feedback is less
 than a current, and would be ignored.
\end_layout

\begin_layout Itemize
providing a general reactive framework that takes care of propogating changes
 in th correct order.
\end_layout

\begin_layout Standard
If all values to update are attached with timestamps, then it would be feasible
 to compare each new value, if it is updated than the previous
\end_layout

\begin_layout Standard
By far, it does reflect the described challenges.
 In OOP, an object encapsulate variables and expose operations.
 In case that an objects operation calls another object's operation and
 so on, producing a chain of operations, it might re-entrance the same object
 by calling again an operation in this chain.
 The latter call might be unexpected, as the first call did not finish,
 and it is in the mid of its work, with some variables updated, and some
 still not.
\end_layout

\begin_layout Standard
some variables are unpdated, and some other will be updated only in the
 end of the first oprt, the object might contain inconsistency 
\end_layout

\begin_layout Standard
it has reliability mainly on passive and stateless ones.
 
\end_layout

\begin_layout Standard
reliability is provided is mainly on passive and stateless components.
\end_layout

\begin_layout Standard
A paradigm that formalizes and emphasizes components is Object Or+++++iented
 Programming (OOP).
 Even though OOP is highly used, it has been criticized that it has problems
\end_layout

\begin_layout Standard
Components can be passive.
 For example, rest services are available to anyone to be called.
 Such components does not have 
\end_layout

\begin_layout Standard
Components can be stateless, which means that they does not hold variables
 or datastore.
 However, 
\end_layout

\begin_layout Standard
This arises questions around feasibility for scalable technalogy of 
\emph on
reactive 
\emph default
or
\emph on
 stateful components
\emph default
.
 Components are sort of micro services, micro frontends, react components,
 OOP, plugins and so on.
 Components can be passive, that means that clients calls their services.
 Reactivity means that components react to 
\end_layout

\begin_layout Standard
Reactivity means to listen to input over time and to produce output
\end_layout

\begin_layout Standard
Reactive components first need to be stateful.
 They use internal state to determine output according to input.
 A paradigm that formalizes and emphasizes stateful components that interact
 through directed and indirected messages is Object Oriented Programming
 (OOP).
 
\end_layout

\begin_layout Standard
Altough that centralized state management is safer, components-based programming
 is in demand.
 For exmaple, micro services, micro frontends, react components, OOP, plugin
 architeture and so on.
 
\end_layout

\begin_layout Standard
–
\end_layout

\begin_layout Standard
Chain of updates composed of many code locations can sometimes be horrible.
 It is much more safe to manage it centralizly.
 It is known as 
\begin_inset Quotes eld
\end_inset

it is hard to reason about
\begin_inset Quotes erd
\end_inset

.
 when looking in a variable/field and research from where this value arrived.
 Why, when and by whom a value has been replaced.
 In case of a push notification, a chain of updates even may produce an
 infinite loop, in case of an accidental cycle.
\end_layout

\begin_layout Standard
Conceptual Framework
\end_layout

\begin_layout Itemize
decentralized (appropriate to stateful components)
\end_layout

\begin_layout Itemize
explicit dependencies (like spreadsheet, not handling state and events)
\end_layout

\begin_layout Standard
Features
\end_layout

\begin_layout Itemize
Add Filling Option
\end_layout

\begin_layout Standard
My idea is that
\end_layout

\begin_layout Itemize
a:=exp is implemented as exp.Subscribe(a.next())
\end_layout

\begin_layout Itemize
multiple assignments makes sum streams to merge
\end_layout

\begin_layout Itemize
an decnetralized online algorithm with an sort function over the propagated
 values
\end_layout

\begin_layout Standard
results
\end_layout

\begin_layout Itemize
code reuse frp+oop
\end_layout

\begin_layout Itemize
dectralized contraints system
\end_layout

\begin_layout Standard
ReactiveX is a library that provide FRP on top of OOP.
 It expose a function (named operator) Map that map each item according
 to an argument function.
\end_layout

\begin_layout Standard
with an observable argument and return an observable that each item is produced
 in response to an item in the argumented observablr.
 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
Handling 
\emph on
state
\emph default
 is an important aspect in programming.
 State refers to what software remembers from past used to its future behavior.
 It is represented as changeable data, stored anywere, used by the applcation
 to determine its output.
 Basicly, variables that contain values represent an application state.
 Components with state are referred to as 
\emph on
stateful components.

\emph default
 A paradigm that formalizes and emphasizes stateful components that interact
 through directed and indirected messages is Object Oriented Programming
 (OOP).
 
\end_layout

\begin_layout Standard
Recently, a paradigm Functional Reactive Programming (FRP) becomes attractive
 in in focusing on network models.
 The variables are represented as nodes linked to each other propagating
 changes in repsonse to new input.
 The framework usualy 
\end_layout

\begin_layout Standard
OOP formalizes and emphasizes the idea of stateful components that interact
 through directed and indirected messages.
 Components-based applications are useful, and hand
\end_layout

\begin_layout Standard
State is an important aspect in applications.
 It can be managed as a centralized component.
 
\end_layout

\begin_layout Standard
In beceknd, stateless components are generally easier to manage.
 as they can be readily replicated across multiple servers without the need
 for complex synchronization or state sharing between instances.
 In backend, the state is the database.
\end_layout

\begin_layout Standard
State are sometimes managed in one component, the database
\end_layout

\begin_layout Standard
as they can be readily replicated across multiple servers without the need
 for complex synchronization or state sharing between instances.
\end_layout

\begin_layout Standard
as it is usualy distingwished between stateful and stateless components.
 
\end_layout

\begin_layout Standard
Components used to be called stateful in case that they manage a state
\end_layout

\begin_layout Standard
In microservices architecture, a key distinction is made between stateful
 and stateless components.
 Stateless components are generally easier to manage as they can be readily
 replicated across multiple servers without the need for complex synchronization
 or state sharing between instances.
 In micro-frontend architeture, managing state is one of the key chalenges.
 
\end_layout

\begin_layout Standard
In micro services, it is distingwished between stateful and stateless components.
 Components that are stateless, are easier as they are easily replicated
 across multiple servers, because there is no need to synchronize or share
 state between instances.
 In front end applications, micro frontends need to cope how to interact
 to manage state.
\end_layout

\begin_layout Standard
Basicly, variables that contain values represent an application state.
 
\end_layout

\begin_layout Standard
Simply, it is variables that hold values.
 
\end_layout

\begin_layout Standard
State is an important aspect for applications in all levels.
 In micro services, it is distingwished between stateful and stateless component
s.
 Components that are stateless, are easier as they are easily replicated
 across multiple servers, because there is no need to synchronize or share
 state between instances.
 In front end applications, micro frontends need to cope how to interact
 to manage state.
\end_layout

\begin_layout Standard
As microarchitecture evolves, enhancing the capabilities of stateful components
 is a natural progression.
 The paradigm that formalizes and emphasizes this idea is Object Oriented
 Programming (OOP).
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
is much more easy becauses it does not change behavior over time, and can
 be replicated without need to synchronize or share state between instances.
\end_layout

\begin_layout Standard
State is a very important aspect.
 In software design, it is often distingwished between statefull components
 and stateless ones.
 Stateless is much more easy becauses it does not change behavior over time,
 and can be replicated without need to synchronize or share state between
 instances.
\end_layout

\begin_layout Standard
Often state is represented as variables that hold values, but it refers
 to any data stored anywere used by the applcation to determine its output.
 Over time, applications' state are changed by updating 
\end_layout

\begin_layout Standard
It is desirable to harmonize the concept Reactive Variable in Object Oriented
 Programming (OOP).
 OOP formalizes and emphasizes the idea of stateful components that interact
 through directed and indirected messages.
 Components-based applications are useful, and hand
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In Reactive Programming, there is a research exploring programming models
 of networks of variables that are interconnected based on how their values
 should be inferred or derived from each other.
 Such a programming model affects the framework or the syntax to be clear
 and easy to develop compared to traditional, because the syntax says explicity
 what traditional been written implicity.
 For example, A:=B+C explcity declares the dependancy of A on B+C, while
 traditionaly we could only develop a process: 
\begin_inset Quotes eld
\end_inset

whenever B or C are updated the operation + is executed on the values that
 B and C contain, and update A with the result.
 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Standard
As implemented by many, the netwrok is implemented as a data strcuture in
 memory, such that an intermidate madiator manage the values according to
 the network.
 Another implementation category, is for distributed applications.
 Therefore, the programs are turned into farmewokrs like actor based model,
 such that messages are sent over a network, and need a deceltralized approach
 (here, madiator is not good).
 In another implementation, it is neither relay on a madiator, nor itended
 to distributed applications, however it is still decntralized by depending
 on the observer pattern.
 
\end_layout

\begin_layout Standard
Among many other challenges, we focus on three.
 First, cycles, when and how to break them to not infinitely continue the
 updates.
 Second, centraliztion madiator - coupling.
 Finaly, the obvious principle of code reuse, is not completlly achived
 for any application.
\end_layout

\begin_layout Standard
We turn reacticeX from 
\begin_inset Quotes eld
\end_inset

functions over streams
\begin_inset Quotes erd
\end_inset

 into such a network model, We implement A:=B as A.suscribe(B.next()).
 We build an online distirbuted algorithm
\end_layout

\begin_layout Standard
The core reusbability and decoupling 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In Reactive Programming, it has been presented that applications' state
 can be managed by a programming model of a network of variables connected
 to each other according to how they should be inferred from each other.
\end_layout

\begin_layout Standard
a programming model of a network-like has been presented a programming model
 such that variables are connected 
\end_layout

\begin_layout Standard
Many programming frameworks uses a programming model related to a network
 for managing , such that each node is a variable or a data store, and the
 edges represent 
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
A statement like A:=B+1 has diffrent distinct meaning across programming
 languages and frameworks.
 In the imperative paradigm, that is the traditional conventional way of
 programming, A is a 
\emph on
variable
\emph default
, which means a memory location, similar to a data store.
 The sign := is named 
\emph on
assignment
\emph default
, which means that the value from evaluating the right hand side is copied
 into A, such that A will contain that value.
 Rather, in constraints programming, the statement means that the framework
 will automaticaly adjust the values according to the statement as a constraint.
 In reactive programming and also in one-way dataflow constraints, it means
 that the left hand variable (in the statement, it is A) will continously
 be adjusted according to the right hand side.
\end_layout

\begin_layout Standard
The assignment in reactive programming harmonize two meanings.
 First, it binds a name to an expression 
\end_layout

\begin_layout Standard
—–
\end_layout

\begin_layout Standard
Reactive Variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) are like variables that abstract out repetetive code, related to their
 updates.
 For example, usualy in order that a variable A will continously contains
 B+C, we should update A in two code locations, of when B and C are updated.
 In contrast, using reactive variables, it is enough to just declare A:=B+C,
 while the actual updates are managed automatically.
 This is depicted in figure XXX.
 An input for B (B=1), then an input for C (C=2), in response A contain
 3.
\end_layout

\begin_layout Standard
One library mentioned as one that implements reactive variables is named
 ReactiveX.
 Actualy ReactiveX implements 
\emph on
observable streams
\emph default
 based on the observer (and more) design pattern.
 Observable streams are objects that contain a subscribers list, to which
 they emit items over time.
 With a form of reactive variables, the items are value changes.
 Often those objects are both observable streams and subscribers.
 In such cases, they emit value changes in response to changes in observable
 streams they are subcsribed to.
 This is applied using 
\emph on
operators
\emph default
.
 For example, given observable streams B and C, the operator CombineLatest
 in A = B.CombineLatest(C, (b, c) => b + c) establishes subscriptions to
 both B and C.
 Whenever either B or C emits a new value, the lambda expression (b, c)
 => b + c is executed.
 Here, b represents the latest emitted value from B, and c represents the
 latest value from C.
 The results are collected as a new observable stream A, such that each
 result is then emitted as the next value in A.
 Another operator named merge subscribed to two observable streams and produced
 an observable stream by passing any item from any of them.
\end_layout

\begin_layout Standard
Extending the concept to form reactive instance variables seems quit easy
 and powerfull for code reusability.
 Given RIVars A,B and C, where object X contains the A, in expressing X.A:=B+C,
 we achive code reuse, with the support for varying types for X.
 In inheritance, code reuse should be achived directly.
 For example, a subclass contains A:=B+C, while A is a member of its superclass.
\end_layout

\begin_layout Standard
However, this is tricky, since it is unclear what is this assignment actualy
 means.
 In functional programming , from where reactive variables have been branched,
 it is unabled to assign value, instead values are bound, without an ability
 to replace it.
 
\end_layout

\begin_layout Standard
in imperative paradigm an assignment means an update, or replace the previous
 value with a new one.
 
\end_layout

\begin_layout Standard
This focus on ReactiveX is since it uses OOP thst used to enhance code reusabili
ty.
 For example, the plugin architecture allows a single code product to perform
 various tasks by incorporating customized processes triggered by specific
 events.
 Another example is the reusability of GUI components, which saves developers
 from programming GUIs from scratch.
 We therefore need to use the observer pattern to perform RIVars and reuseabilit
y.
 
\end_layout

\begin_layout Standard
Code reuse in OOP is produced by inheritance and also by polymorphism.
 We start from polymorphism.
 Given RIVars A,B and C, where object X contains the A, in expressing X.A:=B+C,
 we hope to achive code reuse, with the support for varying types for X.
 In inheritance, code reuse should be achived directly.
 For example, a subclass contains A:=B+C, while A is a member of its superclass.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
OOP is associated to design patterns that improve code reuse.
 For example, using the plugin architeture, various applications can be
 performed by a code product with customized processes trigerred in certain
 events.
 Another example, is GUI components can be reused, rather than programming
 GUI from sctractch.
 The two examples are related to the observer pattern.
 This pattern perform creating objects named observables for whom other
 objects, named obsrvers can be subscribed.
 The observables calls the observers without determine their type or internal
 details.
 In this was, we create highly reusable code, as we can extend the observable
 be adding processes to be executed during (in certain events) its existing
 processes.
 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
Inspired from ReactiveX, 
\end_layout

\begin_layout Standard
In comparing the neat syntax against that of ReactiveX, 
\end_layout

\begin_layout Standard
ReactiveX has a verobe syntax.
 Instead of just :=, we need to the operator CombineLatest
\end_layout

\begin_layout Standard
by continuous associations
\end_layout

\begin_layout Standard
Subscribers are often also observable streams, that in our terms are reactive
 variables that 
\end_layout

\begin_layout Standard
For example, we can produce similar to A:=B+C by expressing A=B.CombineLatest(C,
 (b,c)=>b+c)).
 Whenever B or C 
\end_layout

\begin_layout Standard
given observable streams B and C 
\end_layout

\begin_layout Standard
with a verbose syntax.
 A formula A:=B+C is expresses A=B.CombineLatest(C, (b,c)=>b+c)) 
\end_layout

\begin_layout Standard
ReactiveX imeplemts actualy observable streams.
 This uses a concept harmonized several design patterns.
 
\end_layout

\begin_layout Standard
Therefore, it has a verbose langiage, for example, the neat formula A:=B+C
 in ReactiveX A=B.CombineLatest(C, (b,c)=>b+c))
\end_layout

\begin_layout Standard
In one popular library named ReactiveX, reactive variables are provided
 as observable streams.
 Observable streams are 
\end_layout

\begin_layout Standard
One interseting implementations for reactive variables are named Reactive
\end_layout

\begin_layout Standard
Nevertheless, in using the old OOP patterns, code reuse is highly performed.
 For example, using the plugin architeture, various applications can be
 performed by a code product with customized processes trigerred in certain
 events.
 Another example, is GUI components can be reused, rather than programming
 GUI from sctractch.
 The two examples are related to the observer pattern.
 This pattern perform creating objects named observables for whom other
 objects, named obsrvers can be subscribed.
 The observables calls the observers without determine their type or internal
 details.
 In this was, we create highly reusable code, as we can extend the observable
 be adding processes to be executed during (in certain events) its existing
 processes.
\end_layout

\begin_layout Standard
We focuse on ReactiveX, in our way to harmonize the concepts.
 ReactiveX provides concepts similar to reactive variables that is implemnted
 internaly using OOP patterns.
 It uses the observer pattern.
 An observer must have a method named 
\emph on
next.
 
\emph default
an observable calls its subscribers'
\emph on
 next
\emph default
 that informs them about a value change.
 For example, given A as an observable and B as an observer A will be subscribed
 like 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val+1))}$
\end_inset

.
 Very often, objects are both an observer and observable, therefore the
 executions of next, forward the changes for further objects.
 In the example, given B as both an observer and an observale, and another
 observer C, C will be subscribed to further forward the changes like 
\begin_inset Formula $\LSTINLINE{B.subscribe(val=>C.next(val+1))}$
\end_inset

.
\end_layout

\begin_layout Standard
objects often are both an observer and observable, therefore the executing
 of next, will forwars further subscribers.
\end_layout

\begin_layout Standard
One interestting implementation of reactive variables by using the observer
 and more OOP patterns is ReactiveX.
 In this library, an observer must have a method named 
\emph on
next
\emph default
.
 an observable is reactive variable, by executing its subscribers'
\emph on
 next
\emph default
 whenever it informs about a new value.
 objects often are both an observer and observable, therefore the executing
 of next, will forwars further subscribers.
 For example, given A as an observable and B as an observer A will be subscribed
 like 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val+1))}$
\end_inset

, so that whenever the next in A is exeuted, the next in B will exeuted.
 
\end_layout

\begin_layout Standard
Going further, various operations are implemnted to handle observables as
 values by functions, making them similar to the concept of reactive variables.
\end_layout

\begin_layout Standard
an operation named map has an observable argument and returns another observable
, that map each value of the argumented observable into another values in
 the returned observable.
\end_layout

\begin_layout Standard
An operators the uses these interfaces provides code style that is similar
 
\end_layout

\begin_layout Standard
This We declared an implementation similar to 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, becasue 
\end_layout

\begin_layout Standard
Reactive variables like asbtarction are introduced by using several OOP
 patterns.
\end_layout

\begin_layout Itemize
Explain X:=Y+Z, that it is instead of calling to calculate two times.
\end_layout

\begin_layout Itemize
Explain the code reuse perforned in using observer pattern
\end_layout

\begin_layout Itemize
Explain how reactive variables are implemented as observables streams, map
 and combine latest.
 how these operator works by subscribe
\end_layout

\begin_layout Itemize
the two methods are combined using Subscribe as an assignment operation.
\end_layout

\begin_layout Standard
—-
\end_layout

\begin_layout Standard
An assignment establishes a continuous association, while the left hand
 variable is accessed similar to while it is like an operation the left
 hand variable is like a dynamic type.
\end_layout

\begin_layout Standard
and also can be perfomed without to determine the left-hand 
\end_layout

\begin_layout Standard
We introduce a concept name reactive interface variables that harmonizes
 the two concepts.
 For example, A := B + C are performed as continuous association, and without
 to determine the type of A.
\end_layout

\begin_layout Standard
We introduce a concept name reactive interface variables that harmonizes
 the two concepts.
 We introduce an assignment operator that establishes a continuous association
 with the inheritance and polymorphism mechanisms
\end_layout

\begin_layout Standard
, and that are performed with the 
\end_layout

\begin_layout Standard
by introducing an assignment operator.
 Given reactive instance variables A,B and C, in performing A := B + C,
 we establish the continuous association
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
a sorting algorithm depends on a comparison function that is implemented
 differently according to the type.
\end_layout

\begin_layout Standard
An older concept for code reuse is the mechanisms of object-oriented programming
 (OOP), inheritance and polymorphism are such that developers can define
 logic once, even if it's used for various types.
 For example, a sorting algorithm depends on a comparison function that
 is implemented differently according to the type.
\end_layout

\begin_layout Standard
means that we can program code depending on operations without to learn
 about the implemetation.
 For example, A+B means to sum A and B as fit to their type.
\end_layout

\begin_layout Standard
, so that objects can be replaced.
 In this way, the code is written once, without to repeat the same logic
 for each conceret type.
 For example, 
\end_layout

\begin_layout Standard
, that code can depends on other code from its outer form, such that 
\end_layout

\begin_layout Standard
whenevr B or C is updates, A is updated according to the values they contain
 and according to the operator +.
\end_layout

\begin_layout Standard
In Object Oriented Programming (OOP), calling an operation is like sending
 a message, as the actual called method should be hidden from the callee.
 
\end_layout

\begin_layout Standard
Code reuse is a core principle in programming.
 For example, a execution call in Object Oriented Programming (OOP) is decoupled
 from the choose of the actual method been called, so that the logic will
 holds to diffrent methods implementations.
\end_layout

\begin_layout Standard
A good examples for code reuse is the inheritance and composition abstraction
 mechanisms.
 It is based on an 
\emph on
object
\emph default
 concept, that is a unit of variables bundled with set of operations, that
 can represent real world objects.
 Inheritance means to make an object that 
\emph on
is
\emph default
 another object with more variables and operations.
 Composition means to make object that 
\emph on
has
\emph default
 other objects, so that in its operation, it can call internaly to objects
 it has internaly.
 Code reuse stands in contrast to code duplication or redundancy, where
 the same functionality is implemented repeatedly.
 When code is duplicated, any changes or bug fixes need to be applied to
 each instance.
 This can lead to inconsistencies and maintenance headaches.
 By reusing code, modifications only need to be made in one place, ensuring
 consistency and reducing effort.
\end_layout

\begin_layout Standard
A concept named 
\emph on
reactive variable
\emph default
 provides also code reuse, in that it automaticaly update variables when
 needed.
 For example, given reactive variables A,B and C, performing A:=B+C makes
 that when either B or C is updated, A is updated to contain a value that
 is the sum of the values that B and C contain.
 
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In software programming, developers are sometimes encounter 
\emph on
cycles 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, 
\emph on
circular dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

 or similar.
 For variables, it means that a change in one variable (of its contained
 value) causes transitively, through a chain of changes, this same variable
 to change again.
 Typically, the flow continues, such that the second change produces a third
 change, etc.
 In the worst case, this chain continues endlessly, breaking programs unexpected
ly.
\end_layout

\begin_layout Standard
Consequently, software developers are often forced to break the cycles by
 creating hierarchical data models.
 A remarkable example is a birth of 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As described in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.clariontech.com/blog/mvc-vs-flux-vs-redux-the-real-differences
\end_layout

\end_inset


\end_layout

\end_inset

 In previous libraries that use MVC, models are updated according to the
 view and vice versa, sometimes mentioned as 
\emph on
multidirectional
\emph default
 dataflow, which means that data flows among components in multiple directions.
 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 provides an alternative approach that proposes a design that data flow
 in one direction, such that data flows from each component to its child
 components.
 This way protects developers from encounter cycles.
\end_layout

\begin_layout Standard
By far, the semantics given for cycles is 
\emph on
operational semantics
\emph default
.
 Operational semantics describes the behavior of a program in terms of the
 steps taken to execute it.
 To illustrate this concept, we will examine conventional methods for handling
 cycles within 
\family typewriter
Microsoft Excel
\family default
.
 There, cells can contain formulas that determine their values based on
 the values of other cells.
 These formulas reference other cells.
 For example, cell 
\begin_inset Formula $\LSTINLINE{A1}$
\end_inset

 can contain the formula 
\begin_inset Formula $\LSTINLINE{=B1+C1}$
\end_inset

.
 When a user updates the value in cell 
\begin_inset Formula $\LSTINLINE{B1}$
\end_inset

 or 
\begin_inset Formula $\LSTINLINE{C1}$
\end_inset

, the value in cell 
\begin_inset Formula $\LSTINLINE{A1}$
\end_inset

 will automatically recalculate to reflect the changes.
 Excel prohibits cycles.
 However, this can be changed by configuration.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-gb/office/change-formula-recalculation-iteration-
or-precision-in-excel-73fc7dac-91cf-4d36-86e8-67124f6bcce4
\end_layout

\end_inset

 If cycles are enabled, it should be customized how to break cycles.
 Two methods do exist to break cycles.
 The first one is stopping after a customized number of iterations.
 The second method is checking changes; if a value has not changed, or changed
 only less than a threshold, then it will continue to propagate.
\end_layout

\begin_layout Standard
In this thesis, we focus on introducing 
\emph on
denotational semantics
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which would provide a more abstract interpretation, more closed to problem
 domain than to solution domain.
 
\end_layout

\begin_layout Standard
This concept is equivalent to extract out 
\emph on
accidental
\emph default
 complexity.
 This concept refers to complexity that arises from the applications development
, rather than from the complexity of the business domain 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Since cycles will not be a concern of the implementation, it is expected
 that creation of at least some tools or real-life applications will be
 improved.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
In this thesis, we focus on introducing 
\emph on
denotational semantics
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which would provide a more abstract interpretation, more closed to problem
 domain than to solution domain.
 This concept is equivalent to extract out 
\emph on
accidental
\emph default
 complexity.
 This concept refers to complexity that arises from the applications development
 (rather than from the complexity of the business domain) 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Cycles have been considered as 
\emph on
accidental
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, while cycles are stopped from being a concern of the implementation.
 Since cycles will have an interpretation closed to users perspective, we
 would be more planned open to encounters with them in real life applications.
\end_layout

\begin_layout Plain Layout
Accidental complexity is complexity that is not of essential difficulty
 from the problem domain.
 
\end_layout

\begin_layout Plain Layout
We extract out cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
that is not of essential difficulty from the problem domain.
\end_layout

\begin_layout Plain Layout
Since we extract out the need to handle cycles as 
\emph on
accidental complexity.
\end_layout

\begin_layout Plain Layout
This concept is equivalent to extract out complexity that is not of essential
 difficulty from the problem domain.
 Cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
This difficulty is named 
\emph on
accidental.

\emph default
 because cycles have been presented as 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
named as
\emph on
 accidental
\emph default
, while essential
\end_layout

\begin_layout Plain Layout
distinguishing accidental from essential diculty
\end_layout

\begin_layout Plain Layout
In this way, cycles need not be 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 This concept refers to complexity that arises from the applications development
 (rather than from the complexity of the business domain) 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
 Since cycles will have an interpretation closed to users perspective, we
 would be more open to encounters with them in real life applications.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Standard
We introduce a framework where variables and dependencies from FRP are embedded
 into objects of OOP, constructing a 
\emph on
composite
\emph default
 
\emph on
graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 Each object represent one sub-graph of the composite.
 Our main contribution are in particular:
\end_layout

\begin_layout Itemize
Change propagation algorithm that support cycles.
\end_layout

\begin_layout Itemize
Change propagation algorithm
\end_layout

\begin_layout Standard
, such that each object refer to one of the sub-graphs where the that its
 composed sub-graphs are the objects that contain
\end_layout

\begin_layout Standard
We introduce a framework of a 
\emph on
composite graph
\emph default
 from constructing objects of OOP with variables and dependencies of FRP.
 Each object constructs a sub-graph, 
\end_layout

\begin_layout Standard
A composite graph is a graph composed of simpler graphs or sub-graphs.
 
\end_layout

\begin_layout Standard
harmonizing OOP with that is a graph composed of simpler graphs or sub-graphs,
 that contains the following 
\end_layout

\begin_layout Standard
We introduce a new paradigm named Non-Hierarchical FRP (NH-FRP), a dedicated
 concept named 
\series bold
Reactive Instance Variable
\series default
 ( 
\family typewriter
RIVar)
\end_layout

\begin_layout Itemize
We introduce a new variant of FRP named Non-Hierarchical FRP (NH-FRP), in
 which variables and dependencies form a 
\emph on
composite graph
\emph default
.
 A composite graph is a graph composed of simpler graphs or sub-graphs.
 In each of the sub-graphs, it is free to add edges without worrying about
 accidentally creating a cycle.
 This implies the separation of concerns principle, referring each sub-graph
 to represent a distinct concern.
 Accordingly, at a time, a single sub-graph can be observed without to observe
 any more nodes or vertices from other sub-graphs in the composite graph.
\end_layout

\begin_layout Itemize
We implement NH-FRP as a framework by harmonizing Object Oriented Programming
 (OOP) with Functional Reactive Programming
\begin_inset space ~
\end_inset

(FRP).
 We borrow 
\series bold
reactive variables
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 from FRP embedding them as 
\series bold
instance variables
\series default
 of OOP.
 This introduces a new concept named as 
\series bold
Reactive Instance Variable
\series default
, 
\family typewriter
RIVar
\family default
 for short.
 This new form of variables are used to create sub-graphs in the various
 objects composing the composite graphs.
\end_layout

\begin_layout Itemize
We provide a new programming language extension, by which applications would
 use the new framework.
 For 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we create a 
\family typewriter
nuget
\family default
 package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language, we create a 
\family typewriter
npm
\family default
 package called 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 We created for 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

, an integration to 
\begin_inset Formula $\NAME{React}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 hoping that it would be helpfull for real-life applications.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
and also a 
\family typewriter
npm
\family default
 package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 The extension exposes a few elements.
 First, RIVar as a type implemented as a class.
 Secondly, Lift 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 function for composing expressions.
 Finaly, an assignment operation implemented as a class method, for binding
 expressions to RIVars' instances.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
exploses a method named Set that implements the assignment operation.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
In the extension, RIVar is provided as a type implemented internaly as a
 class, RIVar exploses a method named Set that implements the assignment
 operation.
\end_layout

\begin_layout Plain Layout
we introduce a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
As a as a proof of concept, we introduce a small lightwight package called
 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

 for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and a similar also an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions also as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
We present also that the conceptual framework is feasible as a programming
 language extension.
 As a as a proof of concept.
 For the 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we introduce a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we introduce an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset

 In the two, RIVar is provided as 
\end_layout

\begin_layout Plain Layout
We also provide a concrete framework based on existing programming languages.
 An extension is created to the language that includes RIVar as a datatype,
 implemented internaly as a class.
 The assignment operation for RIVar objects is defined as a method.
 Finaly for enabling expressions of RIVars, a Lift function is added.
\end_layout

\begin_layout Plain Layout
Such extensions have been created as a proof of concept.
 For the 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, we offer a package called 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset

.
 For 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

, we provide an npm package named 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 functions as a state management solution that is integrated seamlessly
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout
————-
\end_layout

\begin_layout Plain Layout
We suggest this frameowrk
\end_layout

\begin_layout Plain Layout
OOP and FRP are harmonized such that each object contain a subgraph declared
 as in FRP.
 Object composition and inheritance
\end_layout

\begin_layout Plain Layout
The subgraphs are connected and form
\end_layout

\begin_layout Plain Layout
Composite graphs are created from referncing variables of other
\end_layout

\begin_layout Plain Layout
Objects compositions and inheritance 
\end_layout

\begin_layout Plain Layout
The subgraphs are composed in a composite graph, because variables are 
\end_layout

\begin_layout Plain Layout
variables are part of the object interface
\end_layout

\begin_layout Plain Layout
We introduce RIVar, that is Reactive Instance (or Interface) Variable, which
 harmonizes reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 Each object represent a subgraph, 
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 This will harmonize nicely the concepts reactive variable
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 and instance variable from the Object Oriented paradigm.
 For this paragraph, we call it simply variable.
 This new concept aims to enable a framework of building composite graphs
 of depedancies.
\end_layout

\begin_layout Plain Layout
Our goal is, that it will enable a framework that each object can contain
 variables and assignments.
\end_layout

\begin_layout Plain Layout
According to the new concept, the assignment operator
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 is re-defined, to bind the right-side expression to it without removing
 previous binding.
 The goal is to enable a framework that each object can contain variables
 and assignments.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
\end_layout

\begin_layout Plain Layout
RIVar is designed to be an observer of the expressions bound to it, which
 are observables.
\end_layout

\begin_layout Plain Layout
The bound expressions are managed localy, as the variable
\end_layout

\begin_layout Plain Layout
Our main contribution is a new concept named RIVar, that is Reactive Instance
 (or Interface) Variable.
 RIVar is a variable of a new generation, because it harmonizes features
 nicely.
 The assignment of RIVar binds the right-side expression to it without removing
 previous binding.
 This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enables a framework that each object can contain variables and assignments.
\end_layout

\begin_layout Plain Layout
decoupling, such that each object can have responsibility that consists
 of variables and assignments.
\end_layout

\begin_layout Plain Layout
This enable to assign from outside of objects or interfaces, so that their
 consumers can assign as their internal behavior.
\end_layout

\begin_layout Plain Layout
This enable to assign without being aware of other assignments.
 Therefore, assigning variables from outside of objects or interfaces is
 correct.
 This enable to design 
\end_layout

\begin_layout Plain Layout
We design and implement this as extensions.
\end_layout

\begin_layout Plain Layout
without to aware of other assignments.
\end_layout

\begin_layout Plain Layout
As its name, it is both reactive and associated to object, which means an
 automation in updates and decoupling.
\end_layout

\begin_layout Plain Layout
As its name, it is reactive variable, because its 
\end_layout

\begin_layout Plain Layout
For example, the assignment of RIVar bind the expression to it rather than
 change it.
 similar to the functional 
\end_layout

\begin_layout Plain Layout
The main contribution in this thesis, is in introducing a new method for
 applying separation of concerns.
 This is provided as a new framework that harmonizes concepts from FRP and
 OOP.
 From OOP, we gain objects reuse including composition, inheritance and
 polymorphism.
 From FRP, we gain explicit dataflow and referntial transparency.
 From this harmoniztion we invented a new concept named RIVar, i.e., reactive
 instance variable.
 reactive variables refer to variables in FRP.
 instance variables refer to variables associated to objects in OOP.
 For evaluation, we provide a case study of designing a small according
 to the new method, and compare its effectiveness with alternative designs.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
We evaluate this method by designing 
\end_layout

\begin_layout Plain Layout
The evaluation of this method 
\end_layout

\begin_layout Plain Layout
The new method is evaluated using a case study.
\end_layout

\begin_layout Plain Layout
in objects.
 like reactive variables, 
\end_layout

\begin_layout Plain Layout
such a variable is continously re-evaluated to its assigned expression
\end_layout

\begin_layout Plain Layout
One interseted concept 
\end_layout

\begin_layout Plain Layout
Harmonized from the two worlds, we form a new concept named reactive instance
 variables.
 reactive variable determine the explicit data flow in the code, and instance
 variable determinzes
\end_layout

\begin_layout Plain Layout
We provide a noval approach to cycles in software developments, and put
 it into practice.
 We introduce a framework, where each class of OOP contain a variables and
 formulas similar to determining variables in FRP.
 The variables and formulas are managed as a new noval variant of FRP named
 NH-FRP.
 We provide a real implementation of NH-FRP by programming extensions.
 We use a case study all over the thesis, by which we presnet an improveness
 by the new approach.
 
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
First, we provide a motivation problem, an poored design application due
 acycliclicity in depedancies.
 Then we explain NH-FRP and the framework...
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
and out of a problem that software solves, a concept that is often discussed
 in software development and design, an idea of abstraction and granularity.
\end_layout

\begin_layout Plain Layout
We name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges.
 When observing a sugraph, other subgraphs does exist, with common nodes
 (meaning that a node can be observed in diffrent subgraphs).
 When observing a sugraph, the other graphs are not observed.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout
In software development, the ability to zoom in and out on the problem that
 software solves is a concept often discussed in software development and
 design.
 This concept is closely related to the idea of abstraction and granularity.
 In diffrent prespectivs diffrent details are observed, ignoring other details.
 It is related to the seperation of concern principle, that the diffrent
 concern are handled independenctly, without to observe other concrens 
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
One concept named one way unindirectional dataflow, with its contrary, multi
 directional dataflow.
 This concept refer to directions of data flow among components.
 Normaly, components can interacts by calling each other, causing data to
 flow to all directions.
 Unindirectional dataflow comes as a better approach, by design one direction
 to the dataflow.
 For example, in react, data flows from parents to child componnts in the
 rendrig process.
 
\end_layout

\begin_layout Plain Layout
One-way unindirectional dataflow strict that data flows 
\end_layout

\begin_layout Plain Layout
In FRP, two opposing methods do exist about cycles.
 In one method, cycles are avoided, because the paradigm derived from the
 functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to the second method, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Sometimes, it is claimed that cycles should be avoided to achive predictability.
 For example, FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 forbidding cycles makes FRP unacceptably weak, because many applications
 have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
FRP is a research field used to provide predictable algorithms to propogate
 changes.
 The explicitness of the data dependencies and the namangement 
\end_layout

\begin_layout Plain Layout
In order to manage this inpredctable, the data dependencies graph are used
 to by acylic.
 The acylicy helps to provide efficient and predictable algorithm to propogate
 changes.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
For example
\end_layout

\begin_layout Plain Layout
Another approach used to avoid cycles.
 
\end_layout

\begin_layout Plain Layout
Executing an arbitary number of iterations might In FRP, various algorithms
 have been introduced, even 
\end_layout

\begin_layout Plain Layout
An example of preventing cilular references is in React that uses unindirectlion
al data flow to prevents cycles.
 
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming is a new paradigm based on the functional
 paradigm, where variables are defined in terms of other variables like
 functions are defined in terms of each other.
 This approach causes explicit dependencies graphs that are handled by the
 runtime, that update variables automaticaly similar to the behavior in
 Excel.
 For example A:=B+C means that B and C depends on A.
 I a grapg, each of the varibales are represented as nodes, and edges from
 A to B and C represent a dependancy that A depends on B and C.
 In a dataflow representation, there are edges from B and C to A to inform
 the direction of the data flow in runtime.
\end_layout

\begin_layout Plain Layout
In large scale applications, we name, 
\begin_inset Quotes eld
\end_inset

zooming in
\begin_inset Quotes erd
\end_inset

 when a subgraph is observed.
 A subgraph is a set of nodes with a set of edges, while other edges and
 nodes are hidden.
 The entire graph is a composite graph, and each time a distinct subgraph
 can be identified and handled independently.
 This is closly related to seperation of concerns, such that each concern
 is handled indepedently.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
that aims to solve complexity in programming, by explict data dependencies
\end_layout

\begin_layout Plain Layout
, where data dependencies are identified explicity to make the langiage
 
\end_layout

\begin_layout Plain Layout
It might be even limitations in provided tools to prevent 
\end_layout

\begin_layout Plain Layout
(available in 
\emph on
Microsoft Excel
\emph default
)
\begin_inset Foot
status open

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In frameworks like react, 
\end_layout

\begin_layout Plain Layout
Frameworks in which variables are expressed in terms of other variables
 
\end_layout

\begin_layout Plain Layout
Frameworks, data dependencies are expor
\end_layout

\begin_layout Plain Layout
There are two approaches: to break the cycles to not to create infinite
 loops or to not create cycles at all.
 We can learn from Angular, how to break cycles.
 
\end_layout

\begin_layout Plain Layout
Generaly, the approach is to avoid cycles or to break them to not create
 infinite loops.
 One example is redux
\end_layout

\begin_layout Plain Layout
break cycles and to avoid infinite loops.
 
\end_layout

\begin_layout Plain Layout
Many frameworks allow to declare 
\emph on
data dependencies
\emph default
 explicity, 
\end_layout

\begin_layout Plain Layout
In order to organazie the code to avoid such cycles, it is suggested to
 declare 
\emph on
data dependencies
\emph default
 explicity and to form acylclic graphs.
 Other than in event paradigm, that 
\end_layout

\begin_layout Plain Layout
and and again re-updated in another execution of this event handler, as
 a result from 
\end_layout

\begin_layout Plain Layout
Such a cycle in events leads to cycles in the vatiables
\end_layout

\begin_layout Plain Layout
Various paradigms, frameworks and libraries aims to provide high level abstracti
ons for managing state.
 
\end_layout

\begin_layout Plain Layout

\emph on
Cycles
\emph default
 can be a headache in application development, that a change in one variable
 causes transitively, through chain of changes, this same variable to again
 change its value.
 In another prespective, cycles accured in using events (or related patterns):
 each event handler can trigger more events, inawaring of the events from
 which they have been triggered, therefore an event handler might trigger
 an event from which it was originaly triggered.
\end_layout

\begin_layout Plain Layout
In a more higher level, variables depend on each othern
\end_layout

\begin_layout Plain Layout
In the Functional Reactive Programming, the graph by which the variables
 are affected each other is explicity declared.
 In FRP, there is no room that code inform changes in variables, so that
 other code will update other variables.
 Instead, the assignment statements initiate a relationship to continously
 update the variables.
\end_layout

\begin_layout Plain Layout
Declaring A:=B+C means that A depends on B and C, because its value 
\end_layout

\begin_layout Plain Layout
In order to avoid inpredictable executions or updates
\end_layout

\begin_layout Plain Layout
But we need to be more precize in our meaning for cycles.
 The first
\end_layout

\begin_layout Plain Layout
In order to completely understand cycles, we have to 
\end_layout

\begin_layout Plain Layout
Consequently, an event handler might be triggered indirectly from itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles because an event handler might be triggered
 indirectly from itself.
 But we need to be careful when we are talking about
\end_layout

\begin_layout Plain Layout
In such executions, an event handler can be triggered indirectly by itself.
\end_layout

\begin_layout Plain Layout
This causes sometimes to cycles, 
\end_layout

\begin_layout Plain Layout
as the same event handler can be trigerred therefore might trigger them
 again.
 
\end_layout

\begin_layout Plain Layout
FRP is a paradigm to express the flow directly.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
variables are like data store , holding values.
\end_layout

\begin_layout Plain Layout
the memory locations refered by names.
 Typicaly the variable
\end_layout

\begin_layout Plain Layout
————–
\end_layout

\begin_layout Paragraph
Variables and Reactivity
\end_layout

\begin_layout Plain Layout
In software programming, mutable variables refer to variables as memory
 locations that can be updated by the assignment operator, and can be read
 in order to update other variables accordingly.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

 to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 A subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The framework is extended to provide a mechanism to that variables will
 be updated according to other variables, 
\end_layout

\begin_layout Plain Layout
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>B=A)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In order to keep on consistency, variables should be updated whenever the
 other related variables changed.
\end_layout

\begin_layout Plain Layout
In case that the code is inaccesible, while 
\end_layout

\begin_layout Plain Layout
For achiving data syncroization, no mechanism inform potential readers of
 changes.
 For example, creating a varable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 derived from 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, by 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 
\end_layout

\begin_layout Plain Layout
two options are avilable.
 First, 
\end_layout

\begin_layout Plain Layout
We gradually identify abstractions for managing variables:
\end_layout

\begin_layout Itemize
Initially, code assigns values to variables, allowing other code to read
 them.
 For instance, 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 assigns a value to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, a subsequent 
\begin_inset Formula $\LSTINLINE{B=A}$
\end_inset

 reads the value from variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and assigns it to variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Itemize
Next, additional code is introduced to notify potential readers about changes.
 For example, 
\begin_inset Formula $\LSTINLINE{A=1;OnChangeA(A)}$
\end_inset

 notifies other parts of the system about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 Subsequently, another piece of code, 
\begin_inset Formula $\LSTINLINE{RegisterToChangeA(value=>...)}$
\end_inset

 registers to receive notifications about changes to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Itemize
Finally, these components are intertwined, enabling writing into a variable
 to automatically trigger other code to read the new values.
 For instance, declaring 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 establishes a continuous relationship between variables, so that when the
 code 
\begin_inset Formula $\LSTINLINE{A=1}$
\end_inset

 is executed, variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated automatically to reflect this new value.
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists 
\emph on
accidental
\emph default
 complexity, that does not the inherently complexity of the problem at hand.
 In the first abstraction, there is no mechanism to inform potential readers
 of changes.
 Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
 The second approach provide reactivity, by informing potential readers
 of changes.
 However, it requires to control when to inform readers, and for readers
 to inform which changes to subscribe to.
 This approach is difficult in high scale applications.
 Because, it is not always clear when to inform readers about changes, or
 for the readers when to subscribe to or unsubscribe from.
 The last approach abstract out the previous complexity, so that writing
 into variables triggers potential readers to read the changes.
\end_layout

\begin_layout Plain Layout
This thesis's contribution is providing even a more clean abstraction by
 abstracting out accidental 
\emph on
cycles
\emph default
.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presented, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 This thesis proposes a paradigm shift where cycles need not be detected,
 as they are supported and considered meaningful.
\end_layout

\begin_layout Plain Layout
We introduce this paradigm by adapting it to Object-Oriented Programming
 (OOP)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 and encapsulation.
 For instance,
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE{C.A}$
\end_inset

 refer to variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 associated with an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is a variable associated with the current class.
 Similarly, in inheritance, a behavior can be represented by the formula
 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is associated with the current class.
 According to the encapsulation principle, a class containing a formula
 treats it as private details, unknown to others.
 Indeed, it is unable to prevent creating cycles, but enables simplicity,
 as each class owns its own responsibility without concern for other responsibil
ities
\end_layout

\begin_layout Paragraph
Data Dependencies and Dataflow
\end_layout

\begin_layout Paragraph
Circular Dependencies
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
that the left hand variable 
\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\RIVar$
\end_inset

 stands for 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables,
\emph default
 being 
\emph on
reactive
\emph default
 variables and also 
\emph on
instance
\emph default
 variables (i.e., fields associated with objects).
 The name reactive refer to the contino 
\end_layout

\begin_layout Plain Layout
This enables creating formulas as 
\end_layout

\begin_layout Plain Layout
so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
This paradigm is based on Object Oriented Programming (OOP) with encapsulation.
 We name 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default

\begin_inset Formula $\RIVar$
\end_inset

 for short, being reactive variables and also instance variables (i.e., fields
 associated with objects), so that they can be associated externally like
 using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
that the software solves.
 
\end_layout

\begin_layout Plain Layout
Through those abstractions there exists a complexity that a variable change
 might indirectly result from itself.
 Simply depicted, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presents, 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is a transitive dependency of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, therefore a formula like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

, it is essential to ensure that the left hand variable is not a transitive
 dependency of any of the variables that the right hand expressions composed
 of.
 
\end_layout

\begin_layout Plain Layout
Depending on how users see the software, complexity is considered as 
\emph on
accidental
\emph default
 if it does not inherent in the problem that the software solves.
 
\end_layout

\begin_layout Plain Layout
We aims to adds required abstractions for abstracting out complexity related
 to cycles or loops.
\end_layout

\begin_layout Plain Layout
Depending on the problem, this complexity can inherent in the problem that
 the software solves as seen by the users, or accidental as it arises only
 through the implementation.
 Nevertheless, a variable change might indirectly result from itself is
 accidental, because 
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a new paradigm that aims to provide a high-level language where data
 dependencies are specified directly by the language, rather than relying
 on the traditional event-driven paradigm where developers manually manage
 variable values.
 For example, in the event-driven paradigm, variables 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
 each have a 
\family typewriter
change
\family default
 event to which event handlers are registered.
 Within these event handlers, code calculates the sum of the values contained
 in 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
, and then updates a variable, 
\family typewriter
A
\family default
, with that value.
 From an FRP perspective, this should be declared simply as 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 making the data dependencies explicit directly in the code.
 In this context variables are named 
\emph on
reactive variables
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
traditionaly named in some variations: 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 and also (like us) 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
We are advancing towards a new paradigm of 
\emph on
reactive instance
\emph default
 (or 
\emph on
interface
\emph default
)
\emph on
 variables, 
\emph default
named sometimes 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 
\begin_inset Formula $\RIVar$
\end_inset

s represent reactive variables and also instance variables (i.e., fields associate
d with objects), so that they can be associated externally like using 
\emph on
setters
\emph default
 in Object Oriented Programming (OOP).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/using-properties
\end_layout

\end_inset


\end_layout

\end_inset

 For example
\begin_inset space ~
\end_inset

(using class-based OOP), class contains a behavior of a formula 
\begin_inset Formula $\LSTINLINE{C.A:=B+1}$
\end_inset

, where 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 refer to reactive variables, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of (i.e., associated with) an object 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
 Similarly (using inheritance), a behavior of a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an instance variable of a parent class and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is an instance variable of the current class.
\end_layout

\begin_layout Plain Layout
Focusing on 
\begin_inset Formula $\RIVar$
\end_inset

, this thesis emphasizes 
\emph on
de-centralization
\emph default
.
 Analogous to OOP that used to model applications with classes and objects,
 many modern applications consist of components 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 Similarly, systems are often interconnected, functioning as a single cohesive
 unit with multiple subsystems (e.g., a Customer Relationship Management (CRM)
 system combined with an order processing system).
 (In FRP, most implementations use a centralized mechanism 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Even in harmonizing FRP with OOP 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

, there is coupling to a centralized component which handles calculations.
 Similarly, in GUI applications, there is widespread adoption of solutions
 like 
\begin_inset Formula $\NAME{Redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

 which provide centerlized state management
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.)
\end_layout

\begin_layout Plain Layout
The research direction focuses on de-centralization by enabling cycles in
 data dependencies.
 This approach stands in contrast to a conventional method of constructing
 hierarchical graphs, where variables are connected to the input elements,
 and subsequently variables depend on other variables, forming an acyclic
 dependency graph (DAG) 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 Additionally, the research direction diverges from the traditional perspective
 that regards cycles as merely an edge case 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In FRP, we say that, a variable depends on other variables, if changes in
 those variable propogate to the first.
 In FRP, various algorithm has been developed to automate the propagations.
 This automation
\end_layout

\begin_layout Plain Layout
FRP is a programming paradigm where specification of fields contents are
 decoupled from the way of how to apply it in runtime.
 The developers use a library that manage graphs,
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
State management is an aspect in front end development, responsible on updating
 fields according to other fields.
 The specifications of how to manage the updates are of various forms and
 patterns.
 One of the forms suggests high level specifications by lifting
\end_layout

\begin_layout Plain Layout
uses a concept that functions can be lifted
\end_layout

\begin_layout Plain Layout
One of the forms uses a concept, that similar to function over values (and
 variables that contain values) to function over fields.
 Then establish continous relationship instead of the traditional temporal
 assignment.
\end_layout

\begin_layout Plain Layout
between the function and the target variable.
\end_layout

\begin_layout Plain Layout
values and operations are lifted
\end_layout

\begin_layout Plain Layout
, rules and input over time.
 In response to an input, code is executed and update fields.
\end_layout

\begin_layout Plain Layout
There are several common abstractions (with variants) used for this task.
 events, streams, one-way constraints and two way constraints.
\end_layout

\begin_layout Plain Layout
————–
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
Reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 is a core concept in 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, including some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 Consider an example of reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the example, a formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, such that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In essence, operations (
\begin_inset Formula $\LSTINLINE +$
\end_inset

 in the example) are converted from operating over values to operate over
 reactive variables.
 Together, they compose expressions (
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 in the example), associated (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 in the example) with the left-hand reactive variable.
 Such an association establishes data dependencies, so that the left-hand
 variable depends on the variables in the right-hand side, and it is continuousl
y re-evaluated according to updates in the dependencies.
 Such a behavior of the continuously re-evaluations defines the variables
 (such as 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 in the example) to be reactive variables.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This can be applied to input fields in GUI applications.
 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 are one of such GUIs.
 Similar to reactive variables associated with expressions composed of other
 reactive variables, cells in 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

 contain formulas to determine values based on other cells.
 Also in other applications, GUI developers need often to develop behaviors
 similar to reactive variables (i.e., update fields values based on other
 values filled in the other fields).
 In modern frameworks, this is applied using 
\emph on
state management solutions
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\begin_layout Plain Layout
The research direction stems from an analysis of the impact of preventing
 cycles.
 When declaring new data dependencies, in order to avoid cycles, it is essential
 to ensure that transitive dependencies do not depend on the fields from
 which the new dependencies originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A possible reason for not being de-centralized, is because of unintended
 unacceptable feedback loops, i.e., a change in one field leads to a subsequent
 change that feeds back and affects the original field itself.
 When declaring new data dependencies, it is essential to ensure that transitive
 dependencies do not depend on the fields from which the new dependencies
 originate.
 Therefore, transitive dependencies should be reachable.
 For this reason, data dependencies are of a high cohesion for being managed
 in a centralized manner.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(composing many pieces of small functionality togather, might leads to huge
 complexety.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Accordingly,
\end_layout

\begin_layout Plain Layout
Besides the need to handle cycles, cycles are often treated only as an edge
 case.
 Typically, calculations are hierarchical, i.e., variables are connected to
 the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to avoid unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamically.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitrary break existing cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis focuses on enabling de-centralization by introducing an embedded
 support for cycles.
 We introduce a framework that classes of OOP contain reactive variables
 and also contain associations that establish data dependencies.
 Objects instantiated from these classes then manage updates privately based
 on the (private) data dependencies within their class.
 We introduce this framework, by defining a new concept named 
\family typewriter
Reactive Instance Variable
\family default
\emph on
,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short.
 According to its name, the new concept harmonizes 
\family typewriter
reactive variable
\family default
 of FRP with 
\family typewriter
instance variable
\family default
 of OOP.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This thesis defines 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, for breaking down code of reactive variables into objects.
 
\begin_inset Formula $\RIVar$
\end_inset

 is an harmonized concept of reactive variable and instance variable, because
 
\begin_inset Formula $\RIVar$
\end_inset

 is a reactive variable associated to objects of OOP.
 Over such reactive variables (
\begin_inset Formula $\RIVar$
\end_inset

s), this thesis introuduces a new variant for FRP named Non-Hierarchical
 FRP (NH-FRP) with an embedded support for cycles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
because objects can contain formulas as internal behavior and the updates
 in runtime are also managed privatly.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we introduce a new variant of FRP, named Non-Hierarchical
 FRP (NH-FRP), that indeed supports cycles.
 By using NH-FRP, reactive variables can be associated with objects as instance
 variables, which we name 
\emph on
reactive instance variables
\emph default
 (a 
\begin_inset Formula $\RIVar$
\end_inset

 in singular), while calculations over 
\begin_inset Formula $\RIVar$
\end_inset

s are managed as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
In the new variant, we use a propagation strategy, in which the propagated
 values are accompanied by timestamp data.
 According to the timestamp data, obsolete values from feedback loops are
 identified and blocked from passing forward.
 By using NH-FRP, reactive variables can be associated to objects, with
 the name 
\emph on
reactive instance variables
\emph default
 (a RIVar in singular), while also the calculations over them are managed
 as objects' internal behavior.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
To solve the problem we introduce Non Hirarchial FRP, a new varian;t of
 FRP that support cycles.
 This new variant consists of a propagation strategy, so that the propogated
 values are attached with data about their time, by whom absolete value
 from feedback loops are not passed forward.
\end_layout

\begin_layout Plain Layout
This new varaint enables cycles by embedding an algorithm, that each variable
 ignores absolete values.
\end_layout

\begin_layout Plain Layout
This new variant enables cycles by an approach, that each variable can depend
 on multiple sources, where each of the sources can update the variable
 on its updated value.
\end_layout

\begin_layout Plain Layout
For example, given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formulas 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A-1}$
\end_inset

 create associations, so that A
\end_layout

\begin_layout Plain Layout
associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is changed in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
In the context of FRP, Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 suggests an alternative mechanism the centerlized mechanism that have access
 to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
this includes two stages.
 First, a centerlized mechanism that have access to the entire dependancy
 graph.
 Second,
\end_layout

\begin_layout Plain Layout
FRP still does not provide a better solution in this aspect.
\end_layout

\begin_layout Plain Layout
In FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
 This is the state also in works that harmonizes FRP with OOP.
\end_layout

\begin_layout Plain Layout
Two stages do exist in the task: declaring the calculations and the runtime.
 For the two stages, the centerlization is unaccepted.
 In DFRP, there are decenterlized algorithms to decenterlzed in runtime
\end_layout

\begin_layout Plain Layout
.
 First to depedencies.
 The decenterlized implemention need
\end_layout

\begin_layout Plain Layout
A possible reason is that adding
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
Unfortunaly, the way the state is managed, does not stand with the standard
 to breaking down code into modules or objects.
 An example is a widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Similarly in FRP
\end_layout

\begin_layout Plain Layout
The centerlization includes the runtime and the code.
\end_layout

\begin_layout Plain Layout
The centerliation is applied in runtime, by a centerlized mechanism that
 have access to the entire dependancy graph.
 This has solution in the field of Distributed FRP 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
 For the centerliation in code, there is a problem
\end_layout

\begin_layout Plain Layout
In addition, when maintaining the code, adding a dependancy requires the
 check against transitive dependencies to not create cycles.
 means sometimes to check against unreachable classes or objects
\end_layout

\begin_layout Plain Layout
This problem is applied also in FRP: according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
The centerlization consists of two parts.
 First, in runtime, one centerlzed mechanism that access the ..
\end_layout

\begin_layout Plain Layout
second, in the code itself,
\end_layout

\begin_layout Plain Layout
The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\begin_layout Plain Layout
FRP aims to solve the difficulties in controlling the calculations.
 In the events driven paradigm updating a field might trigger a change event
 which trigger other updates and so on.
 In the worst case, the chain of updates can being an infinite loop of updates.
\end_layout

\begin_layout Plain Layout
Traditionaly, two strategies handle the problem.
 First, specifying calculations hierarchically, i.e., variables are connected
 to the input elements, and subsequently variables depend on other variables,
 forming an acyclic dependency graph (DAG).
 This fact is often mentioned in FRP.
 For example, Christopher at al 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 suggests an approach to keep from unintentional cycles.
 Gabriel at al 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 suggests an approach involving creating acyclic dependency graphs dynamicaly.
 Gregory at al 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 and Stephen at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special handling to arbitary break existing cycles.
 Overall, cycles are considered as an 
\emph on
edge-case
\emph default
, i.e., a special situation without a common sense solutions.
\end_layout

\begin_layout Plain Layout
The second strategy is centerlization.
 in front ends development there is widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
 Also in FRP, according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations depends on a centerlized mechanism that have
 access to the entire dependancy graph.
\end_layout

\begin_layout Plain Layout
This work is motivated
\end_layout

\begin_layout Plain Layout
Furtheremore, while keeping from undesirable cycles, dependencies must be
 reachable, leading again to centerlization.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The second strategy is centerlization.
 according to Dresler at al 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

, most of the implementations of FRP depends on a centerlized mechanism
 that have access to the entire dependancy graph.
 Also in front ends development there is a common sence to manage the caculation
s in a centerlized mannar since the widespread adoption of 
\begin_inset Formula $\NAME{redux}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://redux.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\begin_inset Formula $\NAME{redux}$
\end_inset

 stands for its commitment to predictability, achieved through its centralized
 architecture.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We focus on enabling calculation without those conditions.
 We adapt OOP, such that objects handle their calculation separately, and
 also that the objects contain calculations without ever knowing about other
 related calculations.
 In this new settings, we does not avoid cycles.
 The check against cycles requires that, whenever fields calculations are
 added, to check that the data dependency graph remains acyclic.
 The check against transitive dependencies means sometimes to check against
 unreachable classes or objects
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Generally, the graph is managed in a centerlized mannar.
\end_layout

\begin_layout Plain Layout
In order to implemented the reactive variables correctly, the graph is managed
 in a centerlized mannar, otherwize there might be inpredictable behavior.
\end_layout

\begin_layout Plain Layout
In order to improve the error-prone development of reactive variables or
 fields calculations,
\end_layout

\begin_layout Plain Layout
The development of fields calculations is error prone.
 Therefore
\end_layout

\begin_layout Plain Layout
The noval approach of FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Beside this approach, there is the event-driven approach that fit Object
 Oriented Orogramming (OOP).
 In this approach, components can be extended, to react to variables' updates.
 On top of this
\end_layout

\begin_layout Plain Layout
There is the event-driven programming by which developers have a complete
 control over the propagation order,
\end_layout

\begin_layout Plain Layout
Beside this approach, there are approaches that fit Object Oriented Orogramming
 (OOP).
 There is the event-driven programming by which developers have a complete
 control over the propagation order, but this is error-prone 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 There is also frameworks like 
\begin_inset Formula $\ReactiveX$
\end_inset

 that provide a more abstract approach, to function over streams of events,
 that are closely related to the reactive variables.
 There the developers can choose between several schedulers to indicate
 the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 is a library in 
\begin_inset Formula $\NAME{Scala}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.scala-lang.org/
\end_layout

\end_inset


\end_layout

\end_inset

 that allows reactive variables being within objects or classes, modeling
 the fields calculations as part of components.
 The library derives previous FRP implementations, which is designed to
 produce consistent behavior, by an algorithm that carefully determines
 the order in which to update the variables.
 Another library 
\begin_inset Formula $\ReactiveX$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 that has first introduced for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 but adopted for more programming languages, provides an an API based on
 some OOP design patterns, to treat variables as streams of their changes.
 This can also been considered as reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 which objects can contain.
\end_layout

\begin_layout Plain Layout
The the two have different approaches, which lead to different results.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 leading to 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, outdated values are filtered out.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
For example, when saying Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, there is no guarantee for 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 .
\end_layout

\begin_layout Plain Layout
We call them 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables remind fields in front-end applications, that are calculated
 according to other fields.
 In FRP, in order to create a variable that is automaticaly calculated according
 to other variables, it should be specified decleratively as a formula.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to change to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
(It might be challenging, to deal with the fields calculations that involve
 long chain of updates.
 The FRP paradigm makes this easier by allowing developers to explicitly
 declare data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating,bainomugisha2013survey"
literal "false"

\end_inset

.
 The left challenge is in managing the 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In applications that are composed of several components, changing the source
 code of one component might lead to subsequent changes in the source code
 of other components, meaning that the code of the component depends on
 the code of the other coomponents.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
an API based on some OOP design patterns, to treat variables as streams
 of their changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, abstracting
 components with fields.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefully determines the order in which
 to update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables as
 streams of their changes.
 Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 like in 
\emph on
Functional Programming
\emph default
, where we can combine small, simple functions to create more complex ones,
 by passing the output of one function as the input to the next.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
the tra of the declaring the data depedencies explicity, it should become
 easier.
\end_layout

\begin_layout Plain Layout
In the development of front-end and other reactive applications there are
 two dependencies types: data dependencies and source code depedencies,
 which should be organaized efficiently.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, there is an effort to make the data dependencies declared in the languages,
 instead that the developers need to understad the depedencies from the
 control of the programs.
 Traditionaly, it is hard to understand the dependencies, because it is
 spread over the event handlers.
\end_layout

\begin_layout Plain Layout
In the paradigm of OOP, there are abstraction mechanism to manage the source
 code dependencies.
 according to business needs, then changes in the code that handle data
 dependencies in one component might lead to require other components to
 be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

, lanigages has been deveoped that lift the assignment statements, to create
 data dependencies, so that the variables will continoue to update according
 to the depeodencies.
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
\end_layout

\begin_layout Plain Layout
Reactive variables have a special assignment operation (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 operator) that defines a 
\emph on
data
\emph default
 
\emph on
dependenc
\emph default
y: the target reactive variable depends on the variables in the expression.
 The expressions are 
\emph on
lifted 
\emph default
executed functions, so that the target reactive variable continuously contains
 the value derived from the values of the reactive variables it depends
 on.
 A propagation of changes starts whenever any of the variables get user
 input (
\begin_inset Formula $\LSTINLINE =$
\end_inset

 operator).
 This causes the dependencies to re-evaluate, which causes their dependencies
 to re-evaluate, and so on.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 , the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 associates 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 with the expression 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, and the value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 changes in response to any input provided to the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 Applications are usually composed of several or many components that runs
 in one or many hosts.
 In such settings, changes in the code that handle data dependencies in
 one component might lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
In the Object Oriented Paradigm (OOP) difrent parts of the application in
 the form of objects can be loosly coupled, even when they interacts in
 such a way that variable in one object depends on variables of other objects.
\end_layout

\begin_layout Plain Layout
applications are modeled as objects that the components can usesuggests
 to form applications by objects to be used model running components or
 that can extend and compose each other, that can react to
\end_layout

\begin_layout Plain Layout
In the events paradigm, it is hard to control what the data depedencies
 are, because logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s.
 In addition, if an application is composed of several components, according
 to business needs, then changes in the code that handle data dependencies
 in one component might lead to require other components to be changed according
ly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
it might be hard as every large application, that contains too much details
 to the developer think.
\end_layout

\begin_layout Plain Layout
the complex or huge logic, in the form of uge amount of data depedencies.
\end_layout

\begin_layout Plain Layout
the huge amount of data depedecies might be hard to manage as it is complex
 logic
\end_layout

\begin_layout Plain Layout
When dealing with a growing application that involves a long chain of updates,
 the implementation becomes challenging.
 The first difficulty is to control the data dependencies.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
 The event handling logic determines what happens when an event is triggered,
 and in this case, it sets the values of variables and updates their dependencie
s 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In FRP, the goal is that the developer has a langague to express the data
 dependenies directly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage the dependencies between code components.
 If the code that handles data dependencies handling involves several components
, they might become 
\emph on
coupled
\emph default
.
 If changes in one component lead to require other components to be changed
 accordingly, the first component depends on the second component 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
code changes.
 According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
The second difficulty is to manage code changes by managing 
\emph on
source code dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In the Object Oriented Programming, the applications parts has the form
 of objects.
\end_layout

\begin_layout Plain Layout
, that consume and extend each other, which are used to manage the code
 changes efficiently.
 The objects are used to sompose applications
\end_layout

\begin_layout Plain Layout
According to business needs and requirements, applications are composed
 from several components.
 Changes in the code that handle data dependencies in one component might
 lead to require other components to be changed accordingly.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.rescala-lang.com/
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 are two libraries that allow objects to contain reactive variables, although
 they have different focuses.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, which is designed to produce consistent
 behavior, by an algorithm that carefuly determines the order in which to
 update the variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 provides an API based on some OOP design patterns, to treat variables by
 streams of their changes.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the property of 
\emph on
compositionality
\emph default
 from the 
\emph on
Functional Paradigm
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: it is enabled to decouple formulas from the used
 reactive variables, to associate expressions to reactive variables from
 outside of objects, and that variables are updated directly by their dependenci
es (without a central madiator).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Itemize
An evaluation of procedural programming for achiving an alternative for
 data synchronization using a push model.
\end_layout

\begin_layout Itemize
We introduce an encapsulation method of bundling data dependencies utilized
 for data synchronization in a push model.
\end_layout

\begin_layout Itemize
We introduce a change propagation mechanism through sending and receiving
 messages (for being aligned with the encapsulation principle)
\end_layout

\begin_layout Itemize
We introduce a declerative language for specifing the bundles.
\end_layout

\begin_layout Itemize
We introduce a programming lanuage feautre (as an extension or library)
 for enabling the above concepts.
\end_layout

\begin_layout Itemize
We expand knowledge about cycles and loops in data synchronization.
\end_layout

\begin_layout Itemize
We introduce a feature 
\begin_inset Quotes eld
\end_inset

add filling option
\begin_inset Quotes erd
\end_inset

 beside the traditional feature 
\begin_inset Quotes eld
\end_inset

add computed field
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive variables reminds the functionality of fields calculations.
 Fields calculation is known from 
\begin_inset Formula $\NAME{Spreadsheets}$
\end_inset

, where cells, that represent the fields, can contain formulas to determine
 the value based on other cells.
\end_layout

\begin_layout Plain Layout
Reactive variables can be used to fields calculations, by connecting to
 visual fields.
\end_layout

\begin_layout Plain Layout
For instance, 
\begin_inset Formula $\NAME{MobX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://mobx.js.org/
\end_layout

\end_inset

 is a state management solution for 
\begin_inset Formula $\NAME{React}$
\end_inset


\end_layout

\begin_layout Plain Layout
applications, with the functionality like reactive variables.
\end_layout

\begin_layout Plain Layout
provides a framework to implement reactive variables
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout
as a 
\emph on
state management solution
\end_layout

\end_inset


\emph default
 to integrate with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Plain Layout
In the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 effort has been invested in implementing 
\emph on
reactive variables
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) to automate updates.
 Reactive variables are variables that are recaluclated in response and
 according to to dependant variables' updates, similar to cells containing
 formulas in spreadsheet applications.
 The variables can get input (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 operator) or be assigned (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 operator) with an expression consisting of a set of other reactive variables.
 The assigment defines that the value of the variable is set to the value
 of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Reactive-variables-basics-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B+1}
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changes in response to any input provided to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
In maintaining and updating the variables, we sometimes face an unpredictable
 behavior and even infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "hung2018architectural"
literal "false"

\end_inset

.
 The unpredictable behavior might exist especially when applications grow
 and have long chains of updates.
 Specificaly, when adding a functionality to update one variable, where
 that update is part of a long chains of updates, so it might fall into
 an endless loop.
\end_layout

\begin_layout Plain Layout
The complexity of this task has two parts.
 First, the difficulties to control the data dependencies implied implicity
 by event handling logic 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 In the events paradigm, the data dependencies are not explicit because
 they are not directly expressed in the code, but are instead implied by
 the event handling logic.
\end_layout

\begin_layout Plain Layout
The second complexity part is to separate the task into small manageable
 and independent tasks, for being in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second, we relate to the 
\emph on
Object Oriented Programming
\emph default
 (OOP) paradigm.
 This paradigm enables that different parts of the software, in the form
 of objects, are loosely coupled and do not depend on one another.
 This makes it easier to change objects without affecting the others.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 the reactive variables are part of the object interface, but implemented
 differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Plain Layout
We present a semantic framework that enables the separation of data dependency
 management within objects.
 At the core of this framework is the concept of a
\series bold
 Reactive Instance Variable
\series default
 (
\begin_inset Formula $\RIVar$
\end_inset

), which objects can expose in their interfaces.
 This separation encompasses both static code and runtime.
 In the static code, variables associated with objects can depend on other
 variables without considering hidden dependencies.
 In runtime, there is no need for a mediator as each variable directly updates
 its dependencies.
 On top of it, we provide implementations of our framework in both C# and
 JavaScript, along with a small application example.
\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Plain Layout
We first start with demonstrating the balance in the existing solutions,
 between predictable and decenterlzed solutions.
 Then we demonstrate our framework, an implementation.
 Finaly we compare
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start with deonstrating an example for an application, and dicuse the
 existing the challenges exsting in the exsiting approaches
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Background}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 presents a background about implementing FRP under the hood.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

presents an example to demonstrate the need for 
\begin_inset Formula $\RIVar$
\end_inset

s.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Method}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present the new variant of FRP, so that reactive variables will be able
 to be 
\begin_inset Formula $\RIVar$
\end_inset

s.
 In 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Evaluation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we compare the model against the other solutions and paradigms, in handling
 graphs and reducing code duplication.
 Then in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Implementation}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present 
\begin_inset Formula $\RIVarX$
\end_inset

 with an implementation to the example presented in 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cref{chap:Motivating-Example}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Problem"
plural "false"
caps "true"
noprefix "false"

\end_inset

 being the case study.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data depedencies from the whole objects
\end_layout

\begin_layout Plain Layout
separating data dependencies into distinct responsibilities,
\end_layout

\begin_layout Plain Layout
It is expected that applications be extended.
 However, when adding data dependencies, it might lead to an expected feedback
 loop.
\end_layout

\begin_layout Plain Layout
If we add or change the code of the data dependencies, it is expected how
 to reduce the needed changes.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
to separate the task into small manageable and independent tasks, for being
 in seperated loosly-coupled components.
 Typically components become coupled by affecting each other's state 
\begin_inset CommandInset citation
LatexCommand cite
key "jiang2020event"
literal "false"

\end_inset

, causing the task to be centralized.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first complexity type has the solution of reactive variables, in explicitly
 declaring the data dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
 The second type of complexity involves separating data dependencies into
 distinct responsibilities, allowing each responsibility to be managed individua
lly by a dedicated object.
\end_layout

\begin_layout Plain Layout
If a calculation is associated with a variable that has dependencies falling
 under a separate object, these dependencies are not considered during linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\REScala$
\end_inset

 and 
\begin_inset Formula $\ReactiveX$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 are two extension types, in which reactive variables are part of the object
 interface, but implemented differently.
 
\begin_inset Formula $\REScala$
\end_inset

 derives previous FRP implementations, in its functional style, and in using
 an algorithm that carefuly determines the order in which to update the
 variables.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 derives the observer pattern.
 The reactive variables are implemented as events streams or observables,
 subscribed to input and/or other reactive variables, to update their subscriber
s, in a form of an iterator.
\end_layout

\begin_layout Plain Layout
Both alternatives have their tradeoffs, which calls for an integration of
 their concepts.
 
\begin_inset Formula $\REScala$
\end_inset

 gives the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, meaning that the same input will produce consistently the same output.
 This property gives 
\begin_inset Formula $\REScala$
\end_inset

 the power from the functional paradigm, the property of 
\emph on
compositionality
\emph default
, to build bigger functions out of smaller ones.
 However, the updates are taken by a central madiator.
 
\begin_inset Formula $\ReactiveX$
\end_inset

 is good in seperation: It lets to decouple formulas from the used reactive
 variables, to associate expressions to reactive variables from outside
 of objects, and that variables are updated directly by their dependencies
 (without a central madiator).
\end_layout

\begin_layout Plain Layout
In this thesis, we use the approach from the second alternative and extend
 it to add benefits from the first alternative.
 The variables have the form of the events streams like 
\begin_inset Formula $\ReactiveX$
\end_inset

.
 But instead of the default behavior to pass immediately any value to subscriber
s, (and instead of a centerlized madiator used in 
\begin_inset Formula $\REScala$
\end_inset

 to consider the order of the updates), the variables consider the coming
 updates, properly ordering the updates to the subscribers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In front-end applications, 
\emph on
state management
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "youframeworkless"
literal "false"

\end_inset

 refers to the process of maintaining and updating variables.
 When certain fields need to be automatically populated based on other fields,
 developers create an implicit 
\emph on
data dependency graph
\emph default
.
 This graph ensures that updates to variables trigger recursive updates
 to dependent variables.
\end_layout

\begin_layout Plain Layout
The Functional Reactive Programming (FRP) paradigm offers an explicit approach
 to define these graphs, providing 
\emph on
predictability
\emph default
 through the use of 
\emph on
referentially transparent
\emph default
 pure functions.
 However, to maintain predictability, it is necessary for the graphs to
 be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
To ensure graph acyclicity, developers need to be aware of data dependencies
 and detect existing paths before introducing new formulas involving existing
 variables.
 If a cycle is detected, adding the new formula should be avoided to prevent
 cycle creation.
 For example, if there are already two formulas, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinline{Y:=Z+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Y:=Z+1}$
\end_inset

 and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Z:=X-1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{Z:=X-1}$
\end_inset

, and a developer intends to add a third formula 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{X:=Y+1}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{X:=Y+1}$
\end_inset

, they must examine all three formulas and identify any existing cycles
 among the nodes 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{X}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE X$
\end_inset

, 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
lstinline{Y}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Y$
\end_inset

, and 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Z}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE Z$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Our focus is on achieving
\emph on
 separation of concerns
\emph default
.
 If a calculation is associated with a variable that has dependencies falling
 under a separate concern, these dependencies are not considered during
 linking.
 Consequently, in such cases, the graph may not be acyclic.
\end_layout

\begin_layout Plain Layout
However, this thesis addresses the issue by allowing cycles, specifically
 those created from mutual recursions.
 Mutual recursions occur when reactive variables are defined in terms of
 each other.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
Therefore, in order to achive 
\emph on
separation of concerns
\emph default
, we provide a semantic framework that permits cycles in data dependencies
 by allowing nodes to receive inputs from multiple sources.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8}
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E}
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[<-, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Illustrating a directed graph with a cycle of directed edges (
\backslash
textbf{B} depends on 
\backslash
textbf{A} and so on) representing interdependent variables forming a cyclic
 relationship.} 
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.45
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout

      
\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout

      
\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

      {   
\end_layout

\begin_layout Plain Layout

        
\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\end_layout

\begin_layout Plain Layout

        
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      
\end_layout

\begin_layout Plain Layout

          arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      
\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout

      
\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{Illustrating the dataflow originating from an external input, which
 flows either directly or indirectly to one of the nodes within the cycle.}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:dataflow}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-to-multiple-assignment"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A cycle of variables.
\end_layout

\end_inset

Illustrating the relationship between cycles and variables with multiple
 sources.
 In a cycle of variables, it is a necessary outcome for at least one of
 the nodes to depend directly or indirectly on external input, in addition
 to the other nodes within the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
We focus on enabling FRP in OOP settings, so that it can be used across
 components.
 The point is that the visibilty of the elements can vary according to the
 organizations needs.
 The functions are defined over elements named 
\emph on
Reactive Instance Variable
\begin_inset space ~
\end_inset


\emph default
(
\begin_inset Formula $\RIVar$
\end_inset

s), as they are reactive variables that can be assciated to objects.
 Their public visibility only enables them to associate the calculation,
 without ever knowing about other related calculations.
 The second point is that the visibility of the calculations are kept also
 in runtime by avoiding a madiator or any centeral engine to handle the
 calculations.
 We keep it simple, that each update trigger the next one as a simple function
 call.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize
We name a concept 
\emph on
Reactive Instance Variable,
\emph default
 
\begin_inset Formula $\RIVar$
\end_inset

 for short, an harmonized concept of 
\emph on
reactive variable
\emph default
 with 
\emph on
instance variable
\emph default
.
\end_layout

\begin_layout Itemize
We introduce Non-Hierarchical FRP (NH-FRP), a new variant of FRP, that supports
 cycles.
\end_layout

\begin_layout Itemize
We introduce a new form of abstraction, that enables ...
\end_layout

\begin_layout Itemize
We introduce a method
\end_layout

\begin_layout Itemize
We provide 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 This provides also a state management solution.
\end_layout

\begin_layout Itemize
We introduce an abstraction mecainsm of 
\begin_inset Quotes eld
\end_inset

add filling options
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We introduce semantics for mutual recursions, which traditionally causes
 cycles or loops in the change propagation.
\end_layout

\begin_layout Itemize
We introduce an algorithm that handles mutual recursions.
\end_layout

\begin_layout Itemize
We create a simple framework for creating computed fields.
\end_layout

\begin_layout Itemize
We provide an implementation: 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

, a package with extensions for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language, and also 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 a package with extensions for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 The later is provided as a state management solution, that has integration
 with 
\begin_inset Formula $\NAME{React}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Outline.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present cycles as encountered in the field of reactive programming (includin
g events, dataflow and constraints).
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce our methodology leading to the new semantics.
\end_layout

\begin_layout Standard
list state of the art strategies for calculations input fields in GUI applicatio
ns.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we present aspects for enhancements in fields calculations.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we explain our approach and implementation.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Evaluation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we evaluate the approach.
 We explore architectural design options to the Drug Administration application
 and compare it to the one achived by our approach.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Related-Work"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we associate concepts in our approach to the previous paradigms.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusion"
plural "false"
caps "true"
noprefix "false"

\end_inset

 contains the conclusion and the future work.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we demonstrate traditional methods used to handle fields calculations and
 the options to devide them into components.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we define the problem we address, consisting the needed framework, and
 what blocks from having this.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we demonstrate our solution to this block.
 And provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 an implementation as a full semantic framework.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
