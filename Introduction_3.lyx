#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
Functional Reactive Programming
\emph default
 (FRP) 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional,elliott2009push"
literal "false"

\end_inset

 is a paradigm that abstracts away the need to update variables in response
 to other variables' updates.
 The main concept is 
\emph on
reactive variable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (with some variations also known as 
\emph on
behavior
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

, 
\emph on
signal
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

, 
\emph on
cell
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 and also
\emph on
 reactive value
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

).
 Reactive variables and 
\emph on
lifted
\emph default
 functions form expressions in order to assign to reactive variables.
 By an assignment, reactive variables become dependent on reactive variables
 containing in the input expressions.
 
\end_layout

\begin_layout Standard
Reactive variable is assigned by an expression consisting of a set of other
 reactive variables, consequently the value of the variable is set to the
 value of the expression, and continuously re-evaluated in response to changes
 in the value of any of the variables appearing in the expression.
 For example, given two reactive variables 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 associates the variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+1
\end_layout

\end_inset

, and the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 changes in response to any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black, label={A}] (A) at (0,5) {};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black ,label={B}] (B) at (3.5,5) {};     
\end_layout

\begin_layout Plain Layout


\backslash
draw[-{Triangle[scale=1]}] (A) -- (B); 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout


\backslash
caption{Dependency Graph: Modeling visually A:=B+1}  
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
————-
\end_layout

\begin_layout Standard
Various libraries enable the use of FRP with imperative code.
 For example REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

, which is an extension to Scala programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "odersky2008programming"
literal "false"

\end_inset

, enables converting between reactive variables and events.
 An additional library SignalJ 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

 includes an interface for reactive variables, with imperative events to
 respond once variables' values are changed.
 An API 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 for C# programming langauge 
\begin_inset CommandInset citation
LatexCommand cite
key "hejlsberg2008c"
literal "false"

\end_inset

 named ReactiveX 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{https://reactivex.io}
\end_layout

\end_inset

, adoped by other languages (e.g., RxJS in JavaScript) provides the reactive
 variable as an 
\emph on
event stream
\emph default
, which is an observable emitting values to subscribers, based on the 
\emph on
observer 
\emph default
and
\emph on
 iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, and also provides 
\emph on
operators
\emph default
 being functions over the streams.
\end_layout

\begin_layout Standard
However, integration of functional-reactive code with imperative code might
 contain circular dependencies causing infinite loops.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
 The problem might happen also in pure FRP (such as happens by imperative-based
 implementation), in case recursive definitions are presented.
 Even the simple formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A
\end_layout

\end_inset

 contain circular dependencies: the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is changed in response to any change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, while any change in the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 triggers a change of the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
(*** add existing solutions to circular dependencies?)
\end_layout

\begin_layout Standard
———–
\end_layout

\begin_layout Standard
(With the the traditional programming, in order to continously maintain
 data dependancy, developers use the 
\emph on
inversion of control
\emph default
 principle: 
\begin_inset Quotes eld
\end_inset

Don't call us, we'll call you
\begin_inset Quotes erd
\end_inset

: the variables are updated by a code registered to the other variable's
 OnChange events.
 This has the negative effect, that it is hard to follow the application
 logic, because the code textual order specified by the programmer does
 not reflect the data dependancies.)
\end_layout

\begin_layout Standard
(In contrast to FRP, with the traditional events-based programming it is
 hard to follow the application logic, because the code textual order specified
 by the programmer does not reflect the data dependancies.
 This what makes FRP so helpful and a promising research; that the code
 textual order declares the flow of data that is the application logic.)
\end_layout

\begin_layout Standard
The dominating category of software today is components-based applications.
 Components includes client-server components, micro-services 
\begin_inset CommandInset citation
LatexCommand cite
key "newman2021building"
literal "false"

\end_inset

, micro-frontends 
\begin_inset CommandInset citation
LatexCommand cite
key "Geers2020"
literal "false"

\end_inset

 and so on.
 In such applications, components' instances (including objects) coordinate
 their state using (variations of) the observer pattern.
 They therefore suffer from the same drawbacks that the observer pattern
 causes in monolith applications.
 components-based applications can clearly benefit from FRP.
 However, existing implementations of FRP either target specific kinds of
 components which avoid reactive variables in their interface, do not provide
 predictable value propagation, or require a third party that manages the
 whole components' state.
\end_layout

\begin_layout Standard
We propose 
\emph on
Reactive Instance Variable
\emph default
 (RIvar for short), by which we adapt the reactive variable to the world
 of objects.
 It renounces properties that are undesirable in components, such as global
 centralized knowledge about the topology of the dependency structure among
 reactive variables and a third party that coordinates the state, while
 giving 
\emph on
referential transparenc
\emph default
y 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 guarantee, such that 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

: 
\emph on
the same sequence of 
\emph default
(user)
\emph on
 events produces the same results, regardless of the timing of those events
\emph default
.
 To the best of our knowledge, such a solution has not been proposed before.
 The proposed abstraction thus enables to integrate FRP in the traditional
 semantics of the Object Oriented Programming (OOP) paradigm.
\end_layout

\begin_layout Section
Contribution
\end_layout

\begin_layout Itemize
We propose RIvar, being consistent with both 
\emph on
instance variables
\emph default
 from OOP and 
\emph on
reactive variables
\emph default
 from FRP.
\end_layout

\begin_layout Itemize
We characterize the design space of existing algorithms for change propagation,
 motivating the need for new algorithms that better suit to the new setting.
\end_layout

\begin_layout Itemize
We present an algorithm for RIvars.
 
\end_layout

\begin_layout Itemize
We present a reduction from the new algorithm to one traditional algorithm.
\end_layout

\begin_layout Itemize
We discuss a small-scale case study to indicate design improvements enabled
 by the proposed abstraction.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{Outline.}
\end_layout

\end_inset

 Chapter 3 presents a motivation example, Chapter 4 presents the proposed
 semantics, Chapter 5 uses the new semantics by implementing the new type
 
\emph on
RIvar
\emph default
 for C# programming language.
 Chapter 6 evaluate the results by the help of a prototype application.
\end_layout

\end_body
\end_document
