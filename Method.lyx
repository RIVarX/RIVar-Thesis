#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset

Approach and Implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Based on the concept that an observable stream represents a variable, each
 node in a dependancy graph would represent an observable stream.
 Each item of an observable stream, represents a 
\emph on
visit
\emph default
 of the propagation  algorithm in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
we relate introduce a sematics 
\end_layout

\begin_layout Plain Layout
We take the concept of observable streams for presenting variables.
 An observable stream consists of values or changes over time, as illustrated
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values"
plural "false"
caps "true"
noprefix "false"

\end_inset

, generated from events of UI elements.
 Furthermore, Each node in a dependancy graph can be represented as an observabl
e stream.
 Each Item represents a visit in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
We investigate a graph of the change propagation in case of 
\emph on
cyclical
\emph default
 propagation.
 Such a case is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The change propagation starts from an incoming edge (the dotted edge in
 the figure) into a node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure), that is the cycle's first node.
 Then, it continues through several edges and nodes until reaching again
 the first node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure) from another edge (in the figure, the edge from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 towards 
\begin_inset Formula $\LSTINLINE C$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$value$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We make a process similar to reverse engineering, i.e., we consider change
 propagation and inffer data dependencies that constructed it.
 As one of the nodes has two incoming edges, it must be one of two options.
 First, that the node represents an input variable which also connected
 to an expression.
 Second, that the node represents a variable that are connected to two expressio
ns simultaneously.
\end_layout

\begin_layout Standard
From this process, we introduce a new syntax for reactive variables, that
 multiple assignments are allowed, and also that an input variable can be
 assigned as well.
\end_layout

\begin_layout Section
Operation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We take the concept of reactive variables as observable streams mentioned
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 An observable stream is like a list, that it contains ordered items.
 It does not mean that the list is stored, it is only an abstraction.
 The list consists of the history of values that a variable have been contained.
 In order to get those values, consumers should perior to subscribe to the
 observable stream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
the
\emph on
 stream
\emph default
 abstraction 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 due to 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx is used as the core concept in a library named 
\begin_inset Formula $\NAME{Cycle.js}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://cycle.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

 for implementing front-end applications.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an alternative to the fields or variables manipulation, there is the
 strategy to model programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 by 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx initialy developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is available now for many programming languages,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Rx offers observable streams, which are objects that abstract collections
 for interested observers, passing their items to them by calling their
 next method (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 Reactive variables can be presented as observable streams 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 consists of the values or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events of UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variable value changes as an observable stream
\end_layout

\end_inset

Variable value changes as an observable stream.
 Variable 
\begin_inset Formula $A$
\end_inset

 changed to 
\begin_inset Formula $5$
\end_inset

 initially, then to 
\begin_inset Formula $3$
\end_inset

, and after a longer period, it changed to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
—
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Based on the 
\family typewriter
Observer
\family default
 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, variables, functions and assignments subscribe to each other (as the example
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and update each other (as the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This performs a dependancy graph, with a decentralized propagation  algorithm.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The sequence diagram in creating the subscriptions of the components of
 a formula
\end_layout

\end_inset

The sequence diagram in creating the subscriptions of the components of
 a formula.
 The diagram is for the formula illustrates 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 Each of the components of the formula is an object, which subscribes and/or
 being subscribed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{next(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{next(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{next(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{next(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{next(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the formula, utilizing the 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout
The assignment operator 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 is changed from the traditional meaning to initiate a variable according
 to the right-hand expression.
 Instead, it registers the left-hand variable to be updated to changes of
 the right-hand expression.
 This has in common with 
\emph on
one-way data binding
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Like in 
\family typewriter
Angular:
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
\end_layout

\end_inset

 and also with 
\emph on
one-way dataflow constraint
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, we add more two characteristics.
\end_layout

\begin_layout Itemize
The left-hand variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression (which means that the two
 sides are an 
\family typewriter
Observer
\family default
 and 
\family typewriter
Observable
\family default
 respectively).
 Since assignments behave like methods, it facilitates 
\emph on
dynamic dispatch.
 
\emph default
This mechanism is used for creating indirect interfaces, by which called
 methods are determined at runtime based on the objects' actual type.
 Likewise, clients would assign an object's variable without to determine
 the object's type.
\end_layout

\begin_layout Itemize
Also in raising the changes, the two sides interacts through an interface
 of the 
\family typewriter
Observer
\family default
 pattern.
 To clarify, this means there's no mediator used, no centralized data structure,
 no synchronization required, and it's not parallel execution.
 It's a straightforward function call.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Propagation Algorithm
\end_layout

\begin_layout Standard
We designed an algorithm based on simple functions calls (No mediator used,
 no centralized data structure, no synchronization required, and it's not
 parallel execution).
 The resulted propagation  is like depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 Each node represents a variable.
 Each traversal starts with an input at the node that represent the variable.
 Each directed edge represents a process that an update of one variable
 raised an update to a second variable.
 Visiting a node refers to its incoming edge.
 The similarity to DFS is because the nature of simple functions calls to
 recursively raise updates deeply in a deterministic execution order.
 
\end_layout

\begin_layout Standard
We apply an order over the values, to be used in each visit.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value
 and continue; otherwise, the value is absolete, the value is discarded
 and it backtracks.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The change propagation  is based on depth-first search (DFS) traversal,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 which recursively raises updates deeply in a deterministic execution order.
 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 The algorithm recursively raises updates deeply in a deterministic execution
 order.
 When it reaches an update that does not raised another update (a leaf)
 it backtracks.
 However, regarding re-visiting nodes, the backtracking process is less
 obvious.
 This is because reaching a node sometimes required a re-update and sometimes
 not.
 Nevertheless, the decision should be determined 
\emph on
localy
\emph default
, by the node being reached.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm recursively raise updates deeply in a deterministic execution
 order untill reaching , however the backtracking in our settings is less
 obvious.
\end_layout

\begin_layout Plain Layout
DFS algorithms explore paths as deeply as possible before backtracking and
 exploring other branches.
\end_layout

\end_inset

 In our setting, the backtracking process is less obvious.
 This is because reaching a node sometimes required a re-update and sometimes
 not.
 Nevertheless, the decision should be determined 
\emph on
localy
\emph default
, by the node being reached.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
However, it is not abvious to distingwish between the cases in runtime.
 The actions of raising an update is decoupled from the update itself.
 Therefore, in reaching a node, the algorithm should detemine if to backtrack
 without detemining details about the node from which
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sometimes it requires a re-update and sometimes not.
 In case of a feedback, it should backtrack.
 In case of a glitch, it should not backtrack
\end_layout

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 In our setting, the backtracking process is less obvious, because reaching
 a node sometimes required a re-update and sometimes not.
 It should backtrack in case of a feedback, but it should not
\end_layout

\begin_layout Plain Layout
In case that this is a feedback, it should backtrack.
 However, it might be that a node is updated several times following a problem
 named glitch.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Additionaly, our settings required decoupling by which it is unabled to
 distingwish between diffrent cases.
 Reaching a node is completely separated from leaving the previous node,
 because raising an update is decoupled from the update itself.
\end_layout

\begin_layout Plain Layout
(In case that this is a feedback, it should backtrack.
 However, it might be that a node is updated several times following a problem
 named glitch.
 In our setting, there is no way to distingwish between the cases, because
 raising an update is decoupled from the update itself.
 i.e., reaching a node is decoupled from leaving the previous node.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In our setting, in raising an update, no one know what cuased this re-update.
\end_layout

\begin_layout Plain Layout
However, in our settings, we the knowledge if a current visit is
\end_layout

\begin_layout Plain Layout
Unlike the basic algorithm that backtracking , the algorithm continue
\end_layout

\begin_layout Plain Layout
Feedback loops are represented as one of the forms that nodes are reached
 visiting again a node
\end_layout

\begin_layout Plain Layout
The algorithm is based on a depth-first search (DFS) traversal, rooted in
 the variable being updated.
 The process starts by that variable that update expressions that contain
 it.
 Then recursively each expression that is a nested expression, updates the
 expression that contains it.
 An expression that is of the top level, updates the variable to which it
 was assigned, which recursively starts such a process again rooted in the
 latter variable.
\end_layout

\begin_layout Plain Layout
The current assignment operator is its directed approach between the left-hand
 variable and the right-hand expression.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression will directly call to the left-hand variable.
 The directed calls in subscribe has a meaning to not depends on a madiator.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.
\end_layout

\begin_layout Plain Layout
By using observer and observables, the naive change propagation forms depth-firs
t search (DFS) traversal, rooted in the variable being updated.
 The process starts by that variable that update expressions that contain
 it.
 Then recursively each expression that is a nested expression, updates the
 expression that contains it.
 An expression that is of the top level, updates the variable to which it
 was assigned, which recursively starts such a process again.
\end_layout

\begin_layout Plain Layout
Illustrating as a graph, the traversal is depth-first search (DFS).
 Raising an update is equivilent to a visit in DFS.
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
We apply an order over the values.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value
 and continue; otherwise, the value is absolete, the value is discarded
 and it backtracks.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We apply an order over the values, by which feedback and absolete values
 will be discarded (therefore backtracking).
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to evaluate the recency of updated values against previously forwarded
 values, we establish an order relation between the whole values.
 We are dealing with a time-ordered stream of external events.
 Each event has a precise timestamp, guaranteeing a strict order with no
 concurrent events.
 The values provided from the external events are ordered according to them.
 Further values are ordered according to events by which they have been
 produced.
 
\end_layout

\begin_layout Standard
Each value produced directly by an external event, its position in the order
 is according to the location of the event.
 Each further value, the position of the value is according to a set of
 positions (timestamps), one from each event that the value derived its
 value from.
 For example, 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 that contain value 8 and 2 from timestamps 1 and 2 respectively.
 For simplicity the timetsamps are presented as sets, such that in the example
 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 contains {1} and {2} respectively.
 upon formula 
\begin_inset Formula $\LSTINLINE{Z=X*Y,Z}$
\end_inset

 will contain a value 16 and the corresponding timestamps are {1,2}.
 The sets of timestamps for the further values are resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Timestamps sets are used to determine the order.
 Each new event produces a value that is more recent that all the previous,
 therefore basicly a set that contains the recent timestamp is of the recent
 value.
 For example, {3} is more recent than {1,2}.
 However, this does not true, in case that a set is a superset of the other
 set.
 For example {1,2} and {1}.
 A superset does not inform that some data is absolete.
 Instead, it might inform a feedback.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Programming Language Extension
\end_layout

\begin_layout Standard
The concept can be implemented as an extension to existing programming languages
 on top of a library that provides observable streams.
 Such like, that an input control change events are composed into an observable
 stream
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, can a variable be represented as an observable stream.
 The observable stream represent the changes as items as illustrated in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Below is an overview of the core concepts, based on 
\begin_inset Formula $\ReactiveX$
\end_inset

 library for 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 programming language.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-3"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variable value changes as an observable stream
\end_layout

\end_inset

Variable value changes as an observable stream.
 Variable 
\begin_inset Formula $A$
\end_inset

 changed to 
\begin_inset Formula $5$
\end_inset

 initially, then to 
\begin_inset Formula $3$
\end_inset

, and after a longer period, it changed to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Timestamp
\end_layout

\begin_layout Standard
A timestamp is generated using a central counter that increments with each
 new input.
\end_layout

\begin_layout Paragraph
Signal
\end_layout

\begin_layout Standard
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class is implemented to represent a value (signal) that is attached with
 a set of timestamps.
 It derives from 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 and implement the method 
\begin_inset Formula $\LSTINLINE{CompareTo}$
\end_inset

 that contains the recency check.
\end_layout

\begin_layout Paragraph
Monotonic
\end_layout

\begin_layout Standard
\begin_inset Formula $\LSTINLINE{Monotonic}$
\end_inset

 is an extension method for observable stream of signals that skip absolete
 signals, based on the recency check.
\end_layout

\begin_layout Paragraph
RIVar
\end_layout

\begin_layout Standard
A variable is represented by 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

, which is both an observable stream and an observer.
 However, for making the library more friendly, a class 
\family typewriter
RIVar
\family default
 would be created.
\end_layout

\begin_layout Paragraph
Assignment
\end_layout

\begin_layout Standard
Two assignments types.
 First, the new assignment operation 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 is implemented as a method 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 (contained in 
\family typewriter
RIVar 
\family default
class or an extension method ).
 Second, 
\begin_inset Formula $\LSTINLINE =$
\end_inset

 represents a single input, represented by the method 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lift
\end_layout

\begin_layout Standard
Converts a function to be a higher order function by 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

.
 The role here is to create computed signals along with appropriate sets
 of timestamps.
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(We take the concept of reactive variables as observable streams.
 An observable stream is like a list, that it contains ordered items.
 It does not mean that the list is stored, it is only an abstraction like
 a list.
 The list consists of the history of values that a variable have been contained.
 In order to get those values, consumers should perior to subscribe to the
 observable stream.
\end_layout

\begin_layout Plain Layout
This concept comes with operators for tranforming those observable streams.
 One operator map maps each item according to a function given as an argument.
 Another operator CombineLatest works for two observable streams, mapping
 based on items from the two.
 These operators has s meaning like lifting, because they convert a function
 to be an 
\emph on
higher order function
\emph default
.
 Higher order functions executed upon reactive variables forms expressions
 that are observable streams.)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Based on the concept mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that an input control change events are composed into an observable stream,
 can a variable be represented as an observable stream.
 Therefrom, each node in the propagation  refers to an observable stream.
 Each item of an observable stream, refers to a 
\emph on
visit
\emph default
 of the propagation  algorithm in that node.
 Accordingly, a variable with multiple assignments represent an observable
 stream resulted from a 
\family typewriter
merge
\family default
 function, that is the whole updates collected from either directed updates
 from being an input variable or from any of the assigned expressions.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will refer to an observable stream produced by 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
merge
\family default
 is created incrementaly by introducing the assignment as an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
.
 For a formula 
\begin_inset Formula $\LSTINLINE{Var:=Expession}$
\end_inset

, it behaves like 
\begin_inset Formula $\LSTINLINE{Var=merge(Var,Expression)}$
\end_inset

.
 Namely, the (left hand) variable is added with the values from an observable
 stream produced by the right hand expression.
 For instance
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 With including also a subsequent statement 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
 Here, we will explain the conditions necessary to ensure that 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)}$
\end_inset

 is equivalent to 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2-1"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the equation 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 to be true, the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have two mathematics properties: commutativity and associativit
y.
 Commutativity means no order over the executions of the assignments statements
 (
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 behaves the same as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

).
 Associativity means no strictness regarding order of the evaluations, because
 rearranging the parentheses in an expression will not change the result.
 For example, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,merge(B,D))}$
\end_inset

.
 Regarding to mathematics, with both associativity and commutativity, we
 can be confident that the final result will always be the same, regardless
 of both the order of executions and the assignments statements.
\end_layout

\begin_layout Section
Empirical Validation
\end_layout

\begin_layout Subsection
First Validation
\end_layout

\begin_layout Standard
We implemented 
\family typewriter
RIVar
\family default
 as an extension 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 programming language, on top of Rx.
 Based on this, we created the 
\family typewriter
Drug Administration 
\family default
a desktop application (
\family typewriter
Windows Forms)
\family default
.
 We added the option to log the changes, and check the performed change
 propagation against various cenarios.
 One of them is presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In the example, there are three steps: setting Drug to 10, then Volume to
 100, and finally Rate to 5.
 Each step includes a timestamp for the events and a propagation to update
 other fields with the attached timestamp.
 In the first step, line 1 presents the setting, and then in line 2, Drug
 has an event with the value 10 and timestamp 1.
 The second step, line 3, presents the input, but only line 6 presents the
 event that Volume has the value 100 with timestamp 2.
 In between, there is line 5, which presents the event for concentration
 with value 0.1 and timestamps 1 and 2, as it is computed from the values
 of Drug and Volume, whose timestamps are now 1 and 2.
 This causes a redundant change event (that is ignored) presented in line
 4, where Volume's timestamp is also 1 and 2, because there is a dependency
 - Volume on Drug and Concentration.
 The order of the log is not entirely logical.
 The logging action is an event handler triggered according to the order
 of registrations.
 Therefore, the event in line 4 is caused by (and therefore occurs after)
 line 5.
 
\end_layout

\begin_layout Standard
The order of the log might not seem entirely reasonable at first glance.
 The event in line 4 is logged before the event in line 5, even though it
 is caused by (and therefore occurs after) line 5.
 This discrepancy occurs because the log action is an event handler triggered
 according to the order of registrations.
 The order of the log follows a post-order traversal on top of a traversal
 similar to Depth-First Search (DFS).
 In the second step, the traversal sequence is Volume (first visit) -> Concentra
tion -> Volume (second visit), while the log sequence is Volume (second
 visit) -> Concentration -> Volume (first visit).
\end_layout

\begin_layout Standard
The final step confirms the previous principles.
 In the next step, Rate has a timestamp of 3 with a value of 5.
 However, the log presents the post-order traversal caused by this.
 The change propagation is as follows: Rate (value 5, timestamp 3), Duration
 (value 20, timestamps 2 and 3 computed from Rate * Volume, 100 * 5), Dose
 (0.5 timestamp 1, 2, and 3 computed based on Duration (from it, there are
 timestamps 2 and 3) and Drug (from it, timestamp 1)), Duration (second
 visit, caused by Dose, ignored).
 The order of the log in post-order: Duration (value 20, timestamps 1, 2,
 and 3, second visit), Dose (value 0.5, timestamps 1, 2, and 3), Duration
 (value 20, timestamps 2 and 3, first visit), Rate (value 5, timestamp 3).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
1.
 Drug_Control:10
\end_layout

\begin_layout Plain Layout
2.
 Drug_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
3.
 Volume_Control:100
\end_layout

\begin_layout Plain Layout
4.
 Volume_Control: 100 <1,2>
\end_layout

\begin_layout Plain Layout
5.
 Concentration_Control: 0.1 <1,2>
\end_layout

\begin_layout Plain Layout
6.
 Volume_Control: 100 <2>
\end_layout

\begin_layout Plain Layout
7.
 Rate_Control:5
\end_layout

\begin_layout Plain Layout
8.
 Duration_Control: 20 <1,2,3>
\end_layout

\begin_layout Plain Layout
9.
 Dose_Control: 0.5 <1,2,3>
\end_layout

\begin_layout Plain Layout
10.
 Duration_Control: 20 <2,3>
\end_layout

\begin_layout Plain Layout
11.
 Rate_Control: 5 <3>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Log result for an execution of the Drug Administration application.
\end_layout

\end_inset

 The lines that does not end with angle brackets, inform change events directly
 set by the user.
 The angle bracket contains the timestamps, that are the order of the events
 that the value depends on.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Second Validation
\end_layout

\begin_layout Standard
We implemented 
\family typewriter
RIVar
\family default
 as an extension, 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 Based on this, we created the 
\family typewriter
Drug Administration
\family default
 as a static web page.
\end_layout

\begin_layout Standard
We created the 
\family typewriter
Drug Administration
\family default
 also with 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 (mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to compare with the implementation with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 The compare page is available online in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/tree/main/samples/drug-administration/compare/h
otdrink
\end_layout

\end_inset

.
 The two algorithms provide identical results in the propagation change.
 Both of the algorithms makes new input to override effects (input and computed
 values) of oldest input at the time of the input.
\end_layout

\begin_layout Subsubsection
Integration with React
\end_layout

\begin_layout Standard
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Plain Layout
A variable with multiple assignments is executed as subscribing to multiple
 observable streams and handle each emitted item by calling onNext on the
 observable stream that represents the assigned variable.
\end_layout

\begin_layout Plain Layout
Based on this concept, multiple assignments informs a 
\family typewriter
merge
\family default
 operation for multiple streams of values.
 We subscribe to multiple Observables and handle each emitted item by calling
 onNext on a designated Observable.
 Through this technique, we effectively perform an operation similar to
 the merge operator.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Inheritance
\end_layout

\begin_layout Description
Subtyping RIVar is part of the object interface.
\end_layout

\begin_layout Description
Subclassing because the semantics of the new assignment operation does not
 update, reassign or override.
 It 
\emph on
adds
\emph default
 a dependancy, such that the variable depends on the right-hand expression
 in addition to existing dependencies.
\end_layout

\begin_layout Description
Substitutability the superposition property.
\end_layout

\begin_layout Section
Cycles
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
Any method to keep from cycles or from lost accuracy through the chain of
 computations makes higher coupling than the method of this thesis.
 In a simpler example, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presents, C is a transitive dependency of A, therefore a formula like
 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like C:=A, it is essential to ensure that the left hand variable is not
 a transitive dependency (that can be located in another class) of any of
 the variables that the right hand expressions composed of.
 A similar check should be applied to ensure zero accuracy lost.
\end_layout

\begin_layout Plain Layout
Methods similar to this thesis' do allow cycles and stop the propagation
 change in runtime.
 (The first two options are available in 
\family typewriter
Microsoft Excel
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
When a value has not changed from the update, or changed only less than
 a threshold.
 This has been presented in the example.
\end_layout

\begin_layout Itemize
Letting to update several times, stopping after an arbitrary number of times.
 The number depends on the specific graph, which depends again on dependancies
 that can be specified in other classes.
\end_layout

\begin_layout Itemize
Checking the original triggering source.
 This again makes again coupling on parts that are not directly located
 in a current class.
\end_layout

\begin_layout Itemize
Centralized mechanism
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
we find that this node represent a variable that has been declared with
 a dependancy more that once.
 Specificaly, this informs one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
From investigating data flow from two distinct nodes, we determine a variable
 with 
\emph on
multiple assignment
\emph default
.
\end_layout

\begin_layout Plain Layout
We distingwish between two assignment types.
\end_layout

\begin_layout Plain Layout
Since a cycle's starting point has two incoming edges, it must be that one
 variable two dependancies have been declared or that
\end_layout

\begin_layout Plain Layout
, or that an input variable
\end_layout

\begin_layout Plain Layout
A cycle starts from the first incoming edge into the cycle starting point,
 then through several nodes untill reaching again the first node from another
 edge.
\end_layout

\begin_layout Plain Layout
Since a cycle's starting point has two incoming edges, it must be that two
 dependancies have been declared (
\end_layout

\begin_layout Plain Layout
it depends on
\end_layout

\begin_layout Plain Layout
using a process similar to reverse-engineering.
 Usually, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
In this chapter we figure out that cycles are belonged to a broader concept.
 In ilustrating a cycle, such as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start from an incoming edge into a node, that is a cycle's first node,
 then through several nodes untill reaching again the first node from another
 edge.
 The node that we started from, has two incoming edges.
\end_layout

\begin_layout Plain Layout
From this investigation, we determine that an existence of cycles means
 that variables depend on several expressions simultaneously.
 We present this using a process similar to reverse-engineering.
 Usualy, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
The employed strategy involves propagating each input through its data dependenc
ies until reaching points where the value from the propagation is no longer
 more up-to-date than the values of the reached variables at that time.
 For instance, when 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 receives an input, it propagates it to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 However, it does not subsequently propagate it back to 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The use of 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 is traditionally enabled to assign multiple times.
 The novelty is about 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 that the variable is associated to the expression without being able to
 remove this association.
 For instance, in a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present, it is valid to present also 
\begin_inset Formula $\LSTINLINE{A:=1}$
\end_inset

.
 This will propagate the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Similarly, the addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 is valid.
 In this case, including 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

 will result in the propagation of the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, and finally to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
The algorithm starts from the variable being updated, this causes expression
 to evaluate in a sequential order.
\end_layout

\begin_layout Plain Layout
Revaluation of an expression, can trigger more revaluations if this expression
 is nested
\end_layout

\begin_layout Plain Layout
The directed approach in raising updates, causes that the change propagation
 algorithm is depth-first search (DFS) traversal, rooted in the variable
 being updated.
\end_layout

\begin_layout Plain Layout
Updating a variable triggers
\end_layout

\begin_layout Plain Layout
An update process is a recursive process with a deterministic execution
 order
\end_layout

\begin_layout Plain Layout
The execution flow raised from an update, can be modeled as depth-first
 search (DFS) traversal over a graph.
 The nodes are the variable and functions.
 An update process is a recursive process, as it recursively trigger more
 updates.
 It starts from a single update in one variable.
 This raises evaluations to expression that consists that variable in a
 sequential order.
 Started from one expression, an expression is like a tree, as of an expression
 tree.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Started from the leaf in that local tree, it propagate up to the root of
 the expression, raising an update to a variable.
\end_layout

\begin_layout Plain Layout
.
 But the trversal is sequential
\end_layout

\begin_layout Plain Layout
Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes
\end_layout

\begin_layout Plain Layout
The graph consists of trees from the expression trees, but
\end_layout

\begin_layout Plain Layout
An expression tree can be represented as a graph, in which each vertex in
 the graph represents an operand or an operator.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Similarly, each vertex represents a variable or a function call.
 The DFS starts from a single update in one variable.
 Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes, untill recahing the end of the evaluation
 of the expression.
 At this stage, it raises an update, representing a visit in the node that
 represent the variable bsing updated.
\end_layout

\begin_layout Plain Layout
, which may recursively raise evaluations in case of nesting in the expressions.
 Expressions in the top level raises an update
\end_layout

\begin_layout Plain Layout
From an evaluation, other evaluations can be raised, in cased of nesting
 in expressions.
\end_layout

\begin_layout Plain Layout
edges represent variables and functions on expressions are represented
\end_layout

\begin_layout Plain Layout
an element within the expression.
 Elements are operators and variables
\end_layout

\begin_layout Plain Layout
The graph contains multiple sub-graphs, each
\end_layout

\begin_layout Plain Layout
As an expression tree, where each node represents an element within the
 expression, are all the
\end_layout

\begin_layout Plain Layout
and lifted function are represented as nodes, and during
\end_layout

\begin_layout Plain Layout
It starts from a single update in one variable, this raises evaluation to
 expressions that consists that variable in a sequential order.
 Starting from one, this evaluation raises an update for another variable
 and recursivly continue in this process
\end_layout

\begin_layout Plain Layout
According to the new assignment operator, the execution flow is determined
 by a series of updates, as as update is one with a push notification that
 triggers
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Several assignments to a single variable, will create several subscriptions,
 and this accomplish a similar effect to a 
\family typewriter
merge
\family default
 over sterams.
 For example, (A.subscribe(x => B.onNext(x)) and C.subscribe(x => B.onNext(x)))
 accomplish a similar effect to B=merge(A,C).
\end_layout

\begin_layout Plain Layout
—————-
\end_layout

\begin_layout Plain Layout
Reactive Instance variable (RIVar) refers to reactive variables on top of
 the observer pattern, or similar to simple events programming.
 An assignment has a meaning of registration to changes.
 For example, A statement like X:=Y is a short expression for Y.OnChange+=e=>X.Cha
nge(e=>e.Value).
 This produces as being accessed through an interface.
 Therefore, we name it also Reactive Interface Variable.
\end_layout

\begin_layout Section
propagation  Algorithm
\end_layout

\begin_layout Subsection
Depth-First Search (DFS)
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Subsection
Ordering and Filtering Mechanism
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for events propagation
, such that each event handler modifies a variable and subsequently triggers
 another event.
 Each handler evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the DFS algorithm produced by events propagation, the enhanced
 algorithm applies an order over the values and uses its for a filtering
 mechanism.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
In order to evaluate the recency of updated values against previously forwarded
 values, we establish an order relation between the whole values.
 We assume external events as a stream, without simultaneous events.
 The values provided from the external events are ordered according to them.
 Further values are ordered according to events by which they have been
 produced.
\end_layout

\begin_layout Plain Layout
Each value produced directly by an external event, its position in the order
 is according to the location of the event.
 Each further value, the position of the value is according to a set of
 positions (timestamps), one from each event that the value derived its
 value from.
 For example, X and Y that contain value 8 and 2 from timestamps 1 and 2
 respectively.
 For simplicity the timetsamps are presented as sets, such that in the example
 X and Y contains {1} and {2} respectively.
 upon formula Z = X*Y, Z will contain a value 16 and the corresponding timestamp
s are {1,2}.
 The sets of timestamps for the further values are resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
\end_layout

\begin_layout Plain Layout
Timestamps sets are used to determine the order.
 Each new event produces a value that is more recent that all the previous,
 therefore basicly a set that contains the recent timestamp is of the recent
 value.
 For example, {3} is more recent than {1,2}.
 However, this does not true, in case that a set is a superset of the other
 set.
 For example {1,2} and {1}.
 The reason is that {1,2} refers to value that is a feedback.
 Therefore, always a subset determines a recent value.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Leveraging the concept of indirect function calls as a depth-first search
 (DFS), we propose a propagation algorithm where each event handler modifies
 a variable and subsequently triggers another event.
 To ensure the correct operation of this algorithm, several key characteristics
 must be addressed.
 Before delving into the specifics of our novel algorithm, we outline these
 essential characteristics:
\end_layout

\begin_layout Description
DFS-Based: The algorithm operates within the framework of a DFS traversal
 over the graph of event handlers.
\end_layout

\begin_layout Description
Decentralized: The algorithm is inherently decentralized, with no centralized
 authority governing the order of updates.
\end_layout

\begin_layout Description
Online: The algorithm functions in an online manner, processing each input
 as it arrives and making decisions dynamically, in contrast to offline
 algorithms that operate on a complete dataset.
\end_layout

\begin_layout Paragraph*
The Algorithm
\end_layout

\begin_layout Plain Layout
On the DFS we add a If the updated value is deemed more relevant, it replaces
 the stored value; otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for event propagation
 in reactive systems.
 This algorithm incorporates a value comparison mechanism within each event
 handler to ensure that only the most up-to-date or relevant values are
 propagated through the system.
 Specifically, each handler evaluates the recency or relevance of the updated
 value against any previously forwarded values, using criteria such as timestamp
, priority, or domain-specific heuristics.
 If the updated value is deemed more relevant, it replaces the stored value;
 otherwise, it is discarded.
 This mechanism ensures data integrity and prevents outdated information
 from propagating through the system.
\end_layout

\begin_layout Plain Layout
We add a 
\emph on
compare
\emph default
 action that checks whether a valuen is more up-to-date than the previous
 forwarded value.
\end_layout

\begin_layout Plain Layout
We implement the change propagation on top of the default change propagation
  of Rx.
 This propagation consists of synchronously respond to notifications by
 passing them forward.
 This propagation consists of a traversal in the form of depth-first search
 (DFS) algorithm.
 In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D))}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D))}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Itemize
The right-hand expression raises changes to the left-hand variable.
 To clarify, this means there's no mediator used, no centralized data structure,
 no synchronization required, and it's not parallel execution.
 It's a straightforward function call.
 The interaction should
\end_layout

\begin_layout Itemize
This is our essential requirement from OOP prespective.
 The design of OOP is for modeling like the real-world, such that each object
 manages its own logic, rather than a centralized object that manages the
 whole state.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm recursively raises updates deeply in a deterministic execution
 order.
\end_layout

\begin_layout Plain Layout
When it reaches an update that does not raised another update (a leaf) it
 backtracks.
 In case of revisiting a node, it should backtrack in case that it is a
 
\emph on
feedback
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Paragraph
From Multiple Assignments to Merging Streams
\end_layout

\begin_layout Plain Layout
Multiple assignments would be applied by using streams.
 Similar to sampling a real world variable by several sensors, can a variable
 being streamed from several expressions.
 This informs a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation over streams.
 Basicly (without cycles), whenever new item is created from any of the
 streams, it is added to the merged stream.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Illustrated using a marble diagram: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/documentation/operators/merge.html
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
The variable itself is also an input variable.
 Therefore, the items would be created in addition to the existing items.
 For instance, as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 merges the items of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 into 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Paragraph
From propagation  Change to Streams
\end_layout

\begin_layout Plain Layout
We refer to feedback as redundant updates similar to 
\emph on
glitches
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 Change propagation  is like a graph traversal or a tree traversal.
 The nodes represent the variables, and a visit refers to raising an update
 to a variable.
 Glitches refers to several visits caused by a single input event.
\end_layout

\begin_layout Plain Layout
In our design, the change propagation is based on depth-first search (DFS)
 traversal,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 rooted in the variable from which there was an an input event.
 The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1972depth"
literal "false"

\end_inset

 of the vertices reached during the traversal.
 Nodes with more than one incoming edge means the glitches.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Glitches are actuly several updates of the same time that called in
\end_layout

\begin_layout Plain Layout
simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
a chain of changes caused from a single input event would be considered
 as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Using this abstraciton, the cycles is presented by items that the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation
\end_layout

\begin_layout Plain Layout
Morever, an item would be created if and only if the stream does not contain
 an item 
\emph on
at its time
\emph default
.
\end_layout

\begin_layout Plain Layout
The time is derived from the time of the input events.
 Therefore.
 a chain of changes caused from a single input event would be considered
 as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
An Interpretation Process
\end_layout

\begin_layout Plain Layout
The outcome is created incrementaly by introducing the assignment as an
 
\emph on
accumulation
\emph default
 
\emph on
merge.
 
\emph default
For instance
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 With including also a subsequent statement 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
 From these statements, it should be garantee that 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
For the equation 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 to be true, the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have two mathematics properties: commutativity and associativit
y.
 Commutativity means no order over the executions of the assignments statements
 ( 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 behaves the same as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

).
 Associativity means no strictness regarding order of the evaluations, because
 rearranging the parentheses in an expression will not change the result.
 For example, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,merge(B,D))}$
\end_inset

.
 Regarding to mathematics, with both associativity and commutativity, we
 can be confident that the final result will always be the same, regardless
 of both the order of executions and the assignments statements.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Ordering
\end_layout

\begin_layout Plain Layout
The merge
\end_layout

\begin_layout Plain Layout
The propoation change is similar to a graph traversal, and it
\end_layout

\begin_layout Plain Layout
The stream abstracts time implicity by ordering items 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

, while it is derived from graph traversal order
\end_layout

\begin_layout Plain Layout
The order is derived from the traversals order of the propagation  change
 processes.
 In case of several visits at the same node
\end_layout

\begin_layout Plain Layout
In contrast, a chain of changes caused from a single input event would be
 considered as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation should discard those redandant items that are of the same time,
 but do not contain fresh information.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are several related perspectives upon the new assignment semantics
 and the concept of created cycles:
\end_layout

\begin_layout Itemize
Ignoring Feedback Values with Timestamps: This approach suggests utilizing
 timestamps to distinguish outdated feedback values and prioritize newer
 ones, essentially ignoring the older ones.
 
\end_layout

\begin_layout Itemize
Assignment as a Merge Operator: This perspective views the assignment operation
 as a merge function, implying the combination of different values or states.
 
\end_layout

\begin_layout Itemize
Cycles as a Subset of Dependency Conflicts: This viewpoint suggests that
 cycles represent a specific type of conflict that can arise within dependencies.
\end_layout

\begin_layout Plain Layout
In exploring the new asThere are several related perspectives upon the new
 assignment semantics and the concept of created cycles:
\end_layout

\begin_layout Itemize
Ignoring Feedback Values with Timestamps: This approach suggests utilizing
 timestamps to distinguish outdated feedback values and prioritize newer
 ones, essentially ignoring the older ones.
 
\end_layout

\begin_layout Itemize
Assignment as a Merge Operator: This perspective views the assignment operation
 as a merge function, implying the combination of different values or states.
 
\end_layout

\begin_layout Itemize
Cycles as a Subset of Dependency Conflicts: This viewpoint suggests that
 cycles represent a specific type of conflict that can arise within dependencies.
\end_layout

\begin_layout Plain Layout
In exploring the new assignment semantics and created cycles, there are
 several related presectives.
 First, using timestamps to ignore feedback values.
 Second, that the assignment behaves as a merge opeator.
 Third, that cycles is a sub case of conflicts in dependencies.
\end_layout

\begin_layout Plain Layout
The very first concept is the new assignment operator.
 The assignment means that the right-hand expression is an observable, to
 which the variable is registered.
 Since registration facilitates 
\emph on
dynamic dispatch
\emph default
 for assigning variable through an interface.
 
\end_layout

\begin_layout Plain Layout
However, the special about the current assignment operator is its directed
 approach between the left-hand variable and the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 Additionaly, directed calls from the right-hand expression to the left-hand
 variable should be directed without paralilism mechanism for achieving
 a deterministic execution order.
\end_layout

\begin_layout Plain Layout
The introduced assignment means that the left-hand variable subscribes to
 the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 
\end_layout

\begin_layout Plain Layout
It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.signment semantics and created cycles,
 there are several related presectives.
 First, using timestamps to ignore feedback values.
 Second, that the assignment behaves as a merge opeator.
 Third, that cycles is a sub case of conflicts in dependencies.
\end_layout

\begin_layout Plain Layout
The very first concept is the new assignment operator.
 The assignment means that the right-hand expression is an observable, to
 which the variable is registered.
 Since registration facilitates 
\emph on
dynamic dispatch
\emph default
 for assigning variable through an interface.
 
\end_layout

\begin_layout Plain Layout
However, the special about the current assignment operator is its directed
 approach between the left-hand variable and the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 Additionaly, directed calls from the right-hand expression to the left-hand
 variable should be directed without paralilism mechanism for achieving
 a deterministic execution order.
\end_layout

\begin_layout Plain Layout
The introduced assignment means that the left-hand variable subscribes to
 the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 
\end_layout

\begin_layout Plain Layout
It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Framework
\end_layout

\begin_layout Plain Layout
We take the concept of reactive variables as observable streams.
 An observable stream is like a list, that it contains ordered items.
 It does not mean that the list is stored, it is only an abstraction.
 The list consists of the history of values that a variable have been contained.
 In order to get those values, consumers should perior to subscribe to the
 observable stream.
\end_layout

\begin_layout Plain Layout
This concept comes with operators for tranforming those observable streams.
 One operator map maps each item according to a function given as an argument.
 Another operator CombineLatest works for two observable streams, mapping
 based on items from the two.
 These operators has s meaning like lifting, because they convert a function
 to be an 
\emph on
higher order function
\emph default
.
 Higher order functions executed upon reactive variables forms expressions
 that are observable streams.
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Plain Layout
Variable that is re-assigned over time can be modelled as stream, that in
 each update there is a new item, of the new value representing the updated
 value at that instant.
 reactive variable means that update of that variable raises indirectly
 a continuation action based on the new value.
 Such an update may be called as
\emph on
 update with a push notification
\emph default
.
 In other words, 
\emph on
update with a push notification
\emph default
 means that not only the variable contained the new value instead of the
 previous value, but also that it raises interested parties about the change.
 We refer to variables as an object in the world, that exposes operation
 
\emph on
assign
\emph default
 (with :=) for an update, and 
\emph on
subscribe 
\emph default
for registration for push notifications.
\end_layout

\begin_layout Paragraph
Lifted Functions
\end_layout

\begin_layout Plain Layout
Variable expressions can also be modeled as streams, where each evaluation
 produces a new item representing the updated value at that instant.
 Evaluations are raised as push notifications from updaing variables.
 For this purpose, 
\family typewriter
Lift
\family default
 operation is needed that converts functions for creating such expressions.
 For example, 
\begin_inset Formula $\LSTINLINE+$
\end_inset

 as a function of values, can be lifted.
 The lifted 
\begin_inset Formula $\LSTINLINE+$
\end_inset

 are used over variables, creating an expression 
\begin_inset Formula $\LSTINLINE{A+B}$
\end_inset

 .
 The expression is evaluated whenever either 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 or 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An expression is evaluated by
\end_layout

\begin_layout Plain Layout
Each update in any of the variables raises an evaluation each evalution
 a new item is created of the value, at the time of after the evaluation.
\end_layout

\begin_layout Plain Layout
Lift is an operation that creates functions to operate on variables from
 simple functions.
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of (variables
 and output of the latter funcions) .
\end_layout

\begin_layout Plain Layout
, and recursovely to function over the result of those functions.
 The lifted function makes that each update in any of the variables raises
 an evaluation to the function over values based on the new value.
 This
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of variables
 that creates streams.
 Each update in any of the variables raises an evaluation to the function
 over values based on the new value.
 For each evalution a new item is created of the value, at the time of after
 the evaluation.
 The lifted functions can further be used to be applied on results of other
 lifted functions.
 Therefore, the functions subscribe to streams and create an output streams,
 such that each item in any of the input stream raises an item in the output
 stream.
\end_layout

\begin_layout Plain Layout
items of the stream contained the values from those evaluations according
\end_layout

\begin_layout Plain Layout
The streams items contain the values evaluated
\end_layout

\begin_layout Plain Layout
Each function is converted into function that 
\emph on
subscribe
\emph default
 to variables and
\end_layout

\begin_layout Plain Layout
Lift is an operation that create functions that create stream of values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(the background: variable that re-assign over time can be modelled as stream
 over time, that in each update there is a new item at that time, that is
 the new value.
 reactive variable: if an update of that variable raises indirectly a continuati
on action based on the new value.
 update with a push notification means that not only the variable contained
 the new value instead of the previous value, but also that it raises interested
 parties about the change.
 )
\end_layout

\begin_layout Plain Layout
(introduction: variable is an object)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Assignment
\end_layout

\begin_layout Plain Layout
As referred in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, in order to enable dynamic dispatch, the assignment operator is different
 from the traditional meaning 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 which initiate a variable according to the right-hand expression.
 Instead it registers the left-hand variable to be updated to changes of
 the right-hand expression.
 This has in common with one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This also has in common with constraints programming with the name one-way
 dataflow constraint
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
However, in our setting the updates are handled directly.
 The right-hand expression will directly call to the left-hand variable.
 To clarify, this means there's no mediator used, no synchronization required,
 and it's not parallel execution.
 It's a straightforward function call.
 This will provide a deterministic execution order
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Plain Layout
We implemented the concept as extensions to existing programming languages
 on top of Rx.
 Specifically, we implemented the 
\begin_inset Formula $\NAME{nuget}$
\end_inset

 package 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and an 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 (Using observable streams facilitates binding with the UI, when a UI change
 event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.)
\end_layout

\begin_layout Plain Layout
We implement a filtering mechanism, where the variables and the expressions
 over them does not propagate values that are less updated that the existing
 once.
 To do this, we create a wrapper to variables: the 
\begin_inset Formula $\RIVar$
\end_inset

 datatype, which is a shortcut for reactive instance variable.
 We also create a wrapper to the expressions: the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function (
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

) .
 Both pass values while filtering out obsolete values.
 The values are wrapped by objects of the 
\begin_inset Formula $\LSTINLINE{signal}$
\end_inset

 type (or 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) implementing the classic comparable interface (according to 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) by timestamps as mentioned in in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Order-Model"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function is similar to 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 that it creates an observable stream from input observable streams.
 Whenever any of the input stream has a new item, a new item is created
 to the output stream.
 However, in contrast to the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function creates an observable streams that is 
\emph on
strictly increasing sequence
\emph default
: it only passes an item to the output stream if it is greater (i.e., newer)
 than an item that previously passed.
 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\RIVar$
\end_inset

 type is derived from the 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

), which implements an observable stream.
 The 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) method is the implementation of the operator 
\begin_inset Formula $\LSTINLINE=$
\end_inset

, and for the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

, we implement a new custom method, we call it 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 In the 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 method, there are subscriptions to the two sides, and each item in the
 right side, is compared to the last item in the stream of the variable
 in the left side.
 If it is new, it will publish it by calling on its 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 This is like applying the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the right-hand side of the operator is merged with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
\end_layout

\begin_layout Plain Layout
By using the extension, 
\begin_inset Formula $\LSTINLINE{A.set(Lift(Inc,B))}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, while 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

 represent the function 
\begin_inset Formula $\LSTINLINE{Inc(x)=x+1}$
\end_inset

.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator observes both the 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 operator and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 These established connections are then utilized for change propagation,
 interacting with the connected user interface (UI) fields.
\end_layout

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Integration
\end_layout

\begin_layout Plain Layout
As 
\begin_inset Formula $\RIVar$
\end_inset

s consist of observable streams we facilitate binding with the UI.
 Once a UI change event occurs, it adds an event to the stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 In this way, we created a .NET Windows Forms application, a web application,
 and an HTML page (available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

).
 Similarly, it should be easy to integrate with various development environments.
\end_layout

\begin_layout Plain Layout
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
In the new approach, an assignment
\emph on
 adds a dependency
\emph default
.
 A variable (
\family typewriter
RIVar
\family default
) can be assigned multiple times, and in each time the variable depends
 on a new expression in addition to existing dependencies.
 This leads that a single variable can be updated from several expressions.
 Additionally, all the variables are input variables that can be updated
 directly.
\end_layout

\begin_layout Standard
Practically, assignment would be an operation that performs that
\emph on
 the left-hand variable subscribes to the right-hand expression, such that
 the right-hand expression calls to the left-hand variable to update it
\emph default
.
 By using this technique, we create an effect similar to 
\family typewriter
merge 
\family default
function over streams of values.
 The order of the values would be according to the order of the input events.
 From the user pespective any input would propogate changes while overriding
 oldest values.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
 
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are 
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
