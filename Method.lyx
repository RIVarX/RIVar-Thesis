#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset

Non-Hierarchical FRP
\end_layout

\begin_layout Standard
This chapter introduces the concept and an implementation of 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
 
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are 
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
â€”-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In NH-FRP, cycles are supported by enabling defining variables in terms
 of one another (named 
\family typewriter
mutual recursion
\family default
).
 For instance, if 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and also 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 depends on 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are included in the code, which means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is defined in term of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 and vice versa.
 The employed strategy involves propagating each input through its data
 dependencies until reaching the points where the value is no longer more
 up-to-date than the existing one.
 For instance, when 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 receives an input, it propagates it to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 However, it does not subsequently propagate it back to 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Standard
This propagation strategy affects the syntax to be different than in traditional
 FRP specifications: in order that values will be propagated through the
 data dependencies of a cycle, one of the nodes of the cycle, must have
 two incoming edges: first, from being connected to the cycle, and the second,
 by which there are values propagated into the cycle.
 Such an example is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Hence, the syntax should support this settings, that each node can have
 more than one incoming edges.
\end_layout

\begin_layout Standard
For this reason, the syntax permits a variable that has already been assigned
 using 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 to also be get input (using 
\begin_inset Formula $\LSTINLINE =$
\end_inset

), and also to be assigned again using 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

.
 The use of 
\begin_inset Formula $\LSTINLINE =$
\end_inset

 is traditionally enabled to assign multiple times.
 The novelty is about 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 that the variable is associated to the expression without being able to
 remove this association.
 For instance, in a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present, it is valid to present also 
\begin_inset Formula $\LSTINLINE{A:=1}$
\end_inset

.
 This will propagate the value 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Similarly, the addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 is valid.
 In this case, including 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

 will result in the propagation of the value 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, and finally to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The node that has two incoming edges represents a variable with two assignments.
 As a result, variables can be assigned multiple times, and continously
 re-evaluated according to the most recent value.
\end_layout

\begin_layout Plain Layout
In order for values to be propagated through the data dependencies of a
 cycle, one of the variables within the cycle must be assigned twice: first,
 the assignment that connects the variable to the cycle, and the second,
 by which there are values propagated into the cycle.
 This is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the illustration, the nodes represent the variables, and the edges illustrat
es the flow of the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 
\end_layout

\begin_layout Plain Layout
The first node has two incoming edges that represent the two assignments.
 As a result, variables can be assigned multiple times, and continously
 re-evaluated according to the most recent value.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The meaning given for the phenomenon of a variable are assigned multiple
 times, that it is sampled by various options from the environment.
 The variables are continuously re-evaluated according to the most recent
 value, from any of the assigned expressions or input.
 For example, if the application contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

, executing 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B:=3}$
\end_inset

, causes 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to contain 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

,
\begin_inset Formula $\LSTINLINE 2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE 3$
\end_inset

.
\end_layout

\begin_layout Standard
In addition to the operational semantics we started with, we propose the
 incorporation of a denotational semantics.
 The assigned expression and the target variable are streams, such that
 the items from the stream of the assigned expression, are merged into the
 stream of the variable.
 Hence, the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 means an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
 operator over streams.
 For instance (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 Subsequent statements, such as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, which means 
\begin_inset Formula $\LSTINLINE{A=merge(A,D)}$
\end_inset

 extends the concept to being 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
\end_layout

\begin_layout Standard
In another point of view, finally the outcome of each variable consists
 of a stream that is the result of a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function across the assigned expressions, in addition to its original initial
 stream.
 As in the example, in the application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, with executed 
\begin_inset Formula $\LSTINLINE{D=1}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A=2}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{B=3}$
\end_inset

, means three streams that are merged into the stream of 
\begin_inset Formula $\LSTINLINE 1$
\end_inset

,
\begin_inset Formula $\LSTINLINE 2$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE 3$
\end_inset

.
 Accordingly, observing the stream of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 actually observes the stream of 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
This point of view leads that there are no order over the executions of
 the statements of 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

.
 In executing these statements, the right-hand side of the operator is merged
 with the stream on the left-hand side of the operator, and stores the merged
 result back in the left-hand side variable.
 While in runtime, each value from any of the streams are propagated into
 the variable.
 We formulate it that in an application that contains 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Order-Model"

\end_inset

The Runtime
\end_layout

\begin_layout Standard
In order to compare the values, whether a value is more current than the
 previous one, we introduce the following order model.
 We start from the sequential change events, that causes the order over
 these first values.
 Each value is derived from a set of events, so also from their time, or
 their locations in the order.
 As in the examples in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a value that is directly triggered by an event is mapped to its timestamp.
 A value that is derived from other values is mapped to a timestamps set
 resulted from the 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation on the timestamps of the values it is derived from.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Subsequently, it is possible to compare each value tuple.
 As seen in the examples in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, if the value is derived from newer events, it still can be a stale value.
 A newer value must be one that overrides the effects of a variable's previous
 value.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Programming Language Extensions
\end_layout

\begin_layout Standard
We implemented NH-FRP as extensions to existing programming languages.
 Specifically, we implemented the 
\begin_inset Formula $\NAME{nuget}$
\end_inset

 package 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and an 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 (Using observable streams facilitates binding with the UI, when a UI change
 event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.)
\end_layout

\begin_layout Standard
We implement a filtering mechanism, where the variables and the expressions
 over them does not propagate values that are less updated that the existing
 once.
 To do this, we create a wrapper to variables: the 
\begin_inset Formula $\RIVar$
\end_inset

 datatype, which is a shortcut for reactive instance variable.
 We also create a wrapper to the expressions: the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function (
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

) .
 Both pass values while filtering out obsolete values.
 The values are wrapped by objects of the 
\begin_inset Formula $\LSTINLINE{signal}$
\end_inset

 type (or 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) implementing the classic comparable interface (according to 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) by timestamps as mentioned in in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Order-Model"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function is similar to 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 that it creates an observable stream from input observable streams.
 Whenever any of the input stream has a new item, a new item is created
 to the output stream.
 However, in contrast to the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function creates an observable streams that is 
\emph on
strictly increasing sequence
\emph default
, It only passes an item to the output stream if it is greater (i.e., newer)
 than the item that previously passed.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\RIVar$
\end_inset

 type is derived from the 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

), which implements an observable stream.
 The 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) method is the implementation of the operator 
\begin_inset Formula $\LSTINLINE =$
\end_inset

, and for the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

, we implement a new custom method, we call it 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 In the 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 method, there are subscriptions to the two sides, and each item in the
 right side, is compared to the last item in the stream of the variable
 in the left side.
 If it is new, it will publish it by calling on its 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 This is like applying the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the right-hand side of the operator is merged with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
\end_layout

\begin_layout Standard
By using the extension, 
\begin_inset Formula $\LSTINLINE{A.set(Lift(Inc,B))}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, while 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

 represent the function 
\begin_inset Formula $\LSTINLINE{Inc(x)=x+1}$
\end_inset

.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator observes both the 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 operator and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 These established connections are then utilized for change propagation,
 interacting with the connected user interface (UI) fields.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The sequence diagram in creating the subscriptions of the components of
 a formula
\end_layout

\end_inset

The sequence diagram in creating the subscriptions of the components of
 a formula.
 The diagram is for the formula illustrates 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 Each of the components of the formula is an object, which subscribes and/or
 being subscribed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{next(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{next(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{next(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{next(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{next(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the formula, utilizing the 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Integration
\end_layout

\begin_layout Standard
As 
\begin_inset Formula $\RIVar$
\end_inset

s consist of observable streams we facilitate binding with the UI.
 Once a UI change event occurs, it adds an event to the stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 In this way, we created a .NET Windows Forms application, a web application,
 and an HTML page (available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

).
 Similarly, it should be easy to integrate with various development environments.
\end_layout

\begin_layout Standard
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
