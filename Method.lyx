#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Approach
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset


\end_layout

\begin_layout Standard
In our approach, each object contains 
\emph on
calculations
\emph default
 that involve variables it directly holds, as well as variables from other
 objects it contains or variables from its parent object.
 These calculations are similar to establishing reactive variables because
 they establish dependencies.
 However, unlike reactive variables, calculations can establish dependencies
 on existing variables.
 This approach is illustrated by the drug administration example involving
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
 According to the relationships ilustrated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can contain calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

.
 And 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 can contain calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PumpCode"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In this way, developers can specify the behavior of objects, implicitly
 creating a data dependency graph.
 The dependency graphs from the objects are then combined to form the overall
 dependency graph.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  IBag TheBag|
\backslash
label{line:TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:RIVars}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Pseudo Code.
\end_layout

\end_inset

Drug Administration Pseudo Code.
 Illustrating the code of the classes to specify the behavior of objects.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:formula,line:formula2,line:formula3}
\end_layout

\end_inset

 represent the calculations that initiate the data dependencies.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In our approach, each object contains 
\emph on
calculations
\emph default
 that involve variables it directly holds, as well as variables from other
 objects it contains or variables from its parent object.
 Calculations are similar to establishing reactive variables, because they
 establish dependencies.
 However, unlike reactive variables, calculations can establish dependencies
 to existing variables.
 This approach are illustrated by the drug adminstration example.
 The example consists of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 objects illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 can contain calculations invovlve 
\begin_inset ERT
status open

\begin_layout Plain Layout

Drug
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Volume
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Concentration
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

Pump
\end_layout

\end_inset

 can contain calculations involve its variables: 
\begin_inset ERT
status open

\begin_layout Plain Layout

Dose
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

Rate
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Duration
\end_layout

\end_inset

, and also the 
\begin_inset ERT
status open

\begin_layout Plain Layout

Drug
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

Volume
\end_layout

\end_inset

 of the instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout

Bag
\end_layout

\end_inset

.
 In this way, developers can specify the objects behavior, creating implicity
 a 
\emph on
data dependency graph, 
\emph default
while the dependency graphs from the objects are combined to form the overall
 dependency graph.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration }
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration Class Diagram.
\end_layout

\end_inset

Drug Administration Class Diagram.
 illustrating the access relationships between the Bag and Pump classes.
 Bag can perform calculations involving Drug, Volume, and Concentration
 variables.
 Pump can perform calculations involving its variables: Dose, Rate, and
 Duration, as well as the Drug and Volume variables of the Bag instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The objective of this study is to ensure that the individual behaviors of
 smaller objects are preserved when constructing larger composite objects.
 To achieve this, we address the unexpected feedback loops caused by dependencie
s.
 In the provided example, the graph exhibits a cycle involving the nodes
 duration, volume, and drug (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If updates to variables result in recursive updates to dependent variables,
 it creates a feedback loop where the calculated values are fed back as
 new inputs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mutual recursion created in runtime from created dependency graphs within
 independent components.
\end_layout

\end_inset

Mutual recursion created in runtime from created dependency graphs within
 Bag and Pump.
 The nodes Volume, Drug, and Duration that are interconnected through the
 edges represent the mutual recursion.
 The solid edges denote dependencies initiated within the Pump instance,
 while dotted edges indicate dependencies initiated within the Bag instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
delete: 
\end_layout

\begin_layout Plain Layout
We address cycles created from mutual recursions, where reactive variables
 are defined in terms of each other.
 ???????
\end_layout

\begin_layout Plain Layout
One of the nodes must be connected to a node from outside of the cycle or
 to a 
\end_layout

\begin_layout Plain Layout
As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-to-multiple-assignment"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there must be a node among the constituents of the cycle that depends
 on a node originating from outside the cycle or receives updates from external
 input.
 This node is connected to multiple sources, including the node that links
 it to the cycle and a node or input from outside the cycle.
\end_layout

\begin_layout Plain Layout
——-
\end_layout

\begin_layout Plain Layout
In our approach components can be interconnected, by fields 
\end_layout

\begin_layout Plain Layout
We address the functionality to calculate fields based on other fields,
 by a framework that is based on OOP and FRP.
 The framework consists of objects that contain reactive variables.
 The ssignment operaotr 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 establishes a data dependency like FRP to be continually updated according
 to an expression.
 However, unlike FRP, our approach allows multiple assignments to the same
 variable without replacing or overriding the previous assignment.
\end_layout

\begin_layout Plain Layout
Like OOP, we have objects inheritace and objects composition.
 In both cases, we can assign
\end_layout

\begin_layout Plain Layout
Each component defines its own private dependency graph according to its
 specified behavior.
 However, during runtime, the dependency graphs from the components are
 combined to form the overall dependency graph.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis addresses the complex data dependencies that arise in component-base
d UI applications, particularly those involving mutual recursion.
 We utilize the frameworks of OOP and FRP.
 Subsequently, we define 
\begin_inset Formula $\RIVar$
\end_inset

, which stands for 
\series bold
Reactive Instance Variable
\series default
, to specify the data dependencies in a similar fashion to how reactive
 variables operate in FRP and how instance variables are accessed from outside
 of objects.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:VariantFRP"

\end_inset

Introduction to a New Variant of FRP
\end_layout

\begin_layout Standard
Our approach incorporates an assignment operator, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

, which links a variable to be continually updated according to an expression,
 similar to traditional FRP implementations.
 However, unlike FRP, our approach allows multiple assignments to the same
 variable without replacing or overriding the previous assignment.
\end_layout

\begin_layout Standard
In order to support multiple assignments, we employ a methodology that involves
 the variable inferring its value over time from various streams of samples.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a variable can be represented by an events stream, in which the items
 represent the variable's updates.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Eevent stream.
\end_layout

\end_inset

Illustrating an event stream that represents the changes in the values of
 variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 over time.
 Based on the illustration, it can be observed that variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 changed to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{5}
\end_layout

\end_inset

 initially, then to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{3}
\end_layout

\end_inset

, and after a longer period, it changed to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{2}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using this representation, a variable with multiple assignments is interpreted
 as a merge operator over the variable and assigned expressions in the various
 statements.
 For instance, if we have two statements, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D}
\end_layout

\end_inset

, it is interepted as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{merge(A,B,D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The assignment operator is an accumulation operator, which means it merges
 the stream on the right-hand side of the operator with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
 For example, the statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset

 can be interpreted as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(A,B)}
\end_layout

\end_inset

.
 Subsequent assignment statements will cause the variable to continue accumulati
ng.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

Illustrating the variables' low-level stream of values that are merged into
 one stream.
 
\backslash
lstinline{A} and 
\backslash
lstinline{B} are two variables that have samples of the same real-world
 variable.
 Therefore, 
\backslash
lstinline{A:=B} is interpreted as 
\backslash
lstinline{A=merge(A,B)}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The merge operation is associative, meaning that it can be applied in any
 order without changing the final result.
 Therefore, merging multiple streams using assignment statements is equivalent
 to executing an n-array merge on the streams of the variable and assigned
 expressions.
 For example, if we have add the assignment statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D}
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 accumulates to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{merge(merge(A,B),D)}
\end_layout

\end_inset

, which is equivalent to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{merge(A,B,D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
The Framework
\end_layout

\begin_layout Plain Layout
Thanks to the new variant of FRP, we can introduce 
\begin_inset Formula $\RIVar$
\end_inset

, which is the name for reactive instance variables.
 Similar to reactive variables, they are automatically updated based on
 their dependencies.
 Similar to instance variables, they are part of the objects, and therefore
 services can make these variables available in their interfaces for their
 clients to use.
 Subclasses can also use the variables belonging to their superclass via
 the specialization interface 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

.
 This concept leads us to a new framework that extends the traditional OOP.
\end_layout

\begin_layout Plain Layout
With this new framework, developers can model domain business concepts that
 are connected to graphical user interfaces (GUIs).
 As illustrated in the drug administration example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), real-world entities can be represented by objects, and their attributes
 can be represented by 
\begin_inset Formula $\RIVar$
\end_inset

s.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode"
plural "false"
caps "true"
noprefix "false"

\end_inset

, objects' classes can contain assignments in their definitions to continuously
 calculate 
\begin_inset Formula $\RIVar$
\end_inset

s.
 The assignments are part of the objects' internal behavior, which connects
 the public 
\begin_inset Formula $\RIVar$
\end_inset

s.
 The values of the attributes are stored within observable streams, which
 serve as a lower-level representation off 
\begin_inset Formula $\RIVar$
\end_inset

s.
 The input streams can be connected to user interface change events, and
 output streams can trigger field updates that display the calculated values
 from the model.
\end_layout

\begin_layout Plain Layout
The framework empowers OOP framework with enhanced extensibility.
 The unique concept of assignments adding the source to the variable, and
 allowing assignments to be hidden, results in an "extend only" operator.
 This is particularly evident in the inheritance mechanism, where subclasses
 only extend their input stream by inheriting assignments assigned to their
 superclass's reactive instance variables.
 This approach avoids the "fragile base class" issue, where changes in the
 implementation or behavior of a superclass inadvertently affect the behavior
 of its subclasses, even if the subclasses were not intended to be modified.
 Similarly, objects can expose reactive instance variables, and in a composition
, the functionality of objects is only extended.
 Overall, the introduction of this assignment operator has the potential
 to develop software that is open to extensions and closed to modifications,
 aligning with the principles of the Open-Closed Principle (OCP).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We seperate the drug administration UI component into two distinct components:
 the pump and the bag.
 This enhances modularity and code reuse.
 The bag component encapsulates the drug, volume, and concentration fields,
 while the pump component incorporates an instance of the bag along with
 the dose, rate, and duration fields.
 This separation allows for the creation of different variants of the drug
 administration without duplicating the entire component.
 For instance, we can create two types of bags: one with concentration and
 one without.
 By duplicating only the bag, we minimize code redundancy, simplifying future
 changes.
 Otherwise, duplicating the entire component would necessitate making updates
 in multiple places whenever changes are required in the pump.
\end_layout

\begin_layout Plain Layout
The required behavior is similar to behavior produced by reactive variables.
 For example, "Concentration" field, which denotes the drug amount per unit
 volume, should be recalculated in response to changes in the values of
 "Amount" and "Volume".
 To maintain the specified design, each component must implement its own
 internal coherence behavior.
 For instance, within the pump component, we explicitly state that the amount
 of the bag should be recalculated based on the dose and duration values.
 Meanwhile, other specifications that are internally related to the bag
 component remain hidden, such as the concentration being recalculated in
 response to updates in the "Amount" and "Volume" fields.
\end_layout

\begin_layout Plain Layout
By specifying behavior similar to reactive variables, we establish a dependency
 graph.
 For instance, when we specify that the Volume field should update based
 on "concentration" and "drug", we create a dependency where the volume
 depends on the "concentration" and "drug".
 Similary, the pump exhibits a behavior where the duration depends on the
 volume, and the bag's drug depends on the duration.
 Each component defines its own private dependency graph according to its
 specified behavior.
 However, during runtime, the dependency graphs from the components are
 combined to form the overall dependency graph.
 
\end_layout

\begin_layout Plain Layout
This graph contains a cycle through the nodes duration, volume and drug
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This might lead to a feedback loop, where value that are calculated is
 feed as a new input.
 In contrast, we expect that the compoistion leads to building larger components
 from smaller ones while preserving their individual behaviors.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 class contains the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

.
 The class contains a formula (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:formula}
\end_layout

\end_inset

) defining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to be re-evaluated whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 is updated.
 Then once an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 is created (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:ctor}
\end_layout

\end_inset

), any change to its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 causes its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to re-evaluate.
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Specialization-Interface"
plural "false"
caps "true"
noprefix "false"

\end_inset

, class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 extends 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 and adds the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug:=Dose*Duration}
\end_layout

\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Specialization-Interface"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we illustrates 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 by composition.
 In the example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 is assigned from outside of the object.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration:=Drug/VolumeOfFluid |
\backslash
label{line:formula}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main(){
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration() |
\backslash
label{line:ctor}| 
\end_layout

\begin_layout Plain Layout

administration.Drug=50
\end_layout

\begin_layout Plain Layout

administration.Volume=100 // administration.Concentration=0.5
\end_layout

\begin_layout Plain Layout

administration.Drug=25  // administration.Concentration=0.25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 class contains the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

.
 The class contains a formula (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:formula}
\end_layout

\end_inset

) defining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to be re-evaluated whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 is updated.
 Then once an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 is created (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:ctor}
\end_layout

\end_inset

), any change to its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 causes its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to re-evaluate.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration {
\end_layout

\begin_layout Plain Layout

  IDrugAdministration drugAdministration
\end_layout

\begin_layout Plain Layout

  ExtendedDrugAdministration(DrugAdministration drugAdministration){ 
\end_layout

\begin_layout Plain Layout

    this.drugAdministration=drugAdministration
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  drugAdministration.Drug:= drugAdministration.Concentration*drugAdministration.Vol
umeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Service-Interface"

\end_inset

 An example to a variable that is assigned externally by an expression.
 The instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 has a variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 which is assigned externaly to be updated according to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration:DrugAdministration {
\end_layout

\begin_layout Plain Layout

  RIVar<double> Dose, Rate, Duration
\end_layout

\begin_layout Plain Layout

  Drug:=Dose*Duration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Specialization-Interface"

\end_inset

An example of a subclass that assigns variables that belonged to the superclass.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 assigns variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 belonging to its superclass 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Change Propagation
\end_layout

\begin_layout Standard
The variables are independent objects that update each other directly, without
 any intermediaries involved.
 Each observable variable triggers its corresponding observer variable,
 which notifies its subscribers, and so on.
 This might lead to infinite loops caused by cycles or errors resulting
 from outdated values.
 Therefore, we establish a predictable order for updates and ensure that
 the observer doesn't process outdated events.
\end_layout

\begin_layout Subsection
Stale Values
\end_layout

\begin_layout Standard
The process of variables independently responding to changes by passing
 them forward can occasionally result in the propagation of stale values.
 This traversal can be likened to a depth-first search (DFS) algorithm,
 where a change event initiates a sequence of computations in a depth-first
 order.
 Consequently, certain nodes may be visited multiple times, with some of
 these visits involving outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the spanning tree, resulting from a change event, contains nodes with more
 than one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values, which
 are referred to as glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 The multiple incoming edges of a node represent 
\emph on
simultaneous events
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, indicating that they occurred at the same time as a result of a single
 event.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{next(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{next(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B:=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C:=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D:=B+C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents sequence diagram depicts the DFS traversal
 during the evaluation process that results from updating the variable 
\backslash
lstinline{A}.
 In (
\backslash
subref{fig:graph}) the corresponding spanning graph is shown.
 The traversal order of the graph is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}), but the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Additionally, simultaneous events also occur in supporting cycles.
 As we explained, in a cycle, there should be a node that depends on an
 external input, in addition to its dependencies on nodes within the cycle.
 According to the principles we presented, the merge function should be
 applied, combining updates from both sources.
 Therefore, this particular node should be the first to receive an update
 caused by itself.
 It is expected that it should not propagate this stale update forward.
 This principle is further illustrated by an example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-merge-produce-concurrent-events"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events"

\end_inset

Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Order Model
\end_layout

\begin_layout Standard
The incoming values have an order that is derived from external input events.
 Each value is derived from a set of values that originates from these external
 events.
 Any binary operator, as well as the assignment operator, can either block
 or pass incoming events based on a comparison procedure that takes into
 account the timestamps of the originating events.
\end_layout

\begin_layout Standard
The procedure starts with the external input sequence being provided with
 an attached timestamp (an incremental natural number).
 Each generated value carries a set of the timestamps of the input events
 it was derived from (
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 This is done by producing timestamps from the union operation on the timestamps
 of the values it was generated from.
 The comparison itself considers the events' sets, similar to the examples
 shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset

This table illustrates a process for obtaining a set of timestamps for values.
 The process is shown in the rows of the table.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset

These examples demonstrate how to compare values associated with the timestamps
 of their original events.
 Each line represents two sets of values and their relationship.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus) at (2,5) {+1}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (2,3) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,1) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Equal) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Formula-Graph-2variables-1"

\end_inset

Formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 over reactive variables A and B
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-1"

\end_inset

Evaluating the formula A:=B+1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{OnNext(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{OnNext(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{OnNext(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{OnNext(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{OnNext(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-1"

\end_inset

Propogation on the formula A:=B+1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Consistency
\end_layout

\begin_layout Standard
The evaluation model dictates that any subsequent value, whether from calculatio
ns or external input, overrides the effects of a variable's previous value,
 which refers to the values in the updates caused by that value.
 This ensures that all variables remain consistent based on the latest specified
 values.
 However, if a defined formula relies on input variables that have not been
 updated to the same extent as the variable in question, the application
 will become inconsistent with the formula.
 Therefore, consistency is only guaranteed for formulas whose input variables
 contain the latest values.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
Our approach focuses on completely separating data dependencies into different
 concerns.
 We identified the problem as stemming from the integration between FRP
 and OOP, specifically in the contract of reactive variable assignment.
 To address this problem, we developed a new variant of FRP that satisfies
 three key requirements and enables the desired settings:
\end_layout

\begin_layout Itemize
Support for complex data dependencies that arise when linking calculations
 to the objects' variables.
\end_layout

\begin_layout Itemize
Avoid coupling to a specific architectural design with a bottleneck of another
 component that has access to the objects' internal state, we adopted a
 "no-mediator" approach where each variable updates its dependencies.
\end_layout

\begin_layout Itemize
Maintaining the property of 
\emph on
predictability
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In the original FRP, predictability is achieved through a property known
 as functional purity, which ensures that the output of a function depends
 solely on its input and not on any external factors.
 In our variant of FRP, we maintain this property by guaranteeing that "the
 same sequence of events produces the same results, regardless of the timing
 of those events" 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\end_body
\end_document
