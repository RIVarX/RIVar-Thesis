#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Approach
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\RIVar}{\myName{RIVar}}
{\mathbf{RIVar}}
\end_inset


\end_layout

\begin_layout Standard
The present challenge can be represented as a means of integrating the Object-Or
iented Programming (OOP) and Functional Reactive Programming (FRP) paradigms.
 Reactive variables, as part of an object's interface, can be linked to
 external calculations without considering hidden dependencies.
 These dependencies may arise from other calculations linked to the object's
 variables by other concerns, whether within the object itself or among
 other consumers, as is currently the case.
 We define such variables type with the name 
\begin_inset Formula $\RIVar$
\end_inset

, which is an abbreviation for
\series bold
 Reactive Instance Variable
\series default
.
 This type represents both a 
\emph on
reactive
\emph default
 and an 
\emph on
instance
\emph default
 variable.
\end_layout

\begin_layout Standard
In order to achieve the goal, we developed a new variant of FRP that addresses
 three key requirements.
 First, the new variant enables support data dependencies that arise when
 linking calculations to the objects' variables.
 Second, to avoid coupling to a specific architectural design with a bottleneck
 of another component that has access to the objects' internal state, we
 adopted a "no-mediator" approach where each variable updates its dependencies.
 Third, we ensured that the new variant maintains the desirable property
 of 
\emph on
predictability
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In the original FRP, predictability is achieved through a property known
 as functional purity, which ensures that the output of a function depends
 solely on its input and not on any external factors.
 In our variant of FRP, we maintain this property by guaranteeing that "the
 same sequence of events produces the same results, regardless of the timing
 of those events" 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Introduction to the New Variant of FRP
\end_layout

\begin_layout Standard
Our noval approach, or the unique feature about the new variant, is about
 the assginment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

.
 The new variant enables multiple assigment to the same variable.
 This means that an assignment refers to adding more source to get values
 to the variable.
 
\end_layout

\begin_layout Standard
The methodology used to determine variable values relies on multiple sources,
 which are situated at a lower level of variable abstraction.
 These observable streams of values represent the variable's fluctuations
 in value.
 Therefore, when a variable has more than one source, it implies that there
 are several streams of samples that contribute to inferring its values.
 This is similar to the scenario where multiple devices sample a single
 real-world variable.
 Consequently, the assignment operator can function as a merge function
 over these streams.
\end_layout

\begin_layout Standard
Esch case of several assignments is interepted as a merge operator over
 the variable and assigned expressions in the various statements.
 For example, the two statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D+1}
\end_layout

\end_inset

 means produces the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{merge(A,B+C,D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
In our new variant, the assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 has a unique capability of allowing multiple assignments to a single variable.
 As a result, the variable integrates the newly assigned expression as an
 additional source for determining its values, and dynamically utilizes
 all available sources over time.
 
\end_layout

\begin_layout Plain Layout
The underlying principle lies in the lower level of abstraction of the variables
, where the variable's values are represented by an observable stream of
 values.
 Thus, if a variable has multiple sources, it implies that there are several
 streams of samples contributing to inferring its values, similar to the
 scenario where several devices sample a single real-world variable.
 As a result, the assignment operator can operate as a merge function over
 these streams.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
less technical version:
\end_layout

\begin_layout Plain Layout
The methodology used to determine variable values relies on multiple sources,
 which are situated at a lower level of variable abstraction.
 These observable streams of values represent the variable's fluctuations
 in value.
 Therefore, when a variable has more than one source, it implies that there
 are several streams of samples that contribute to inferring its values.
 This is similar to the scenario where multiple devices sample a single
 real-world variable.
 Consequently, the assignment operator can function as a merge function
 over these streams.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
When multiple assignments are made to a variable, they are treated as a
 single assignment operator for the variable and the expressions in the
 various statements.
 For example, the statements 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D+1}
\end_layout

\end_inset

 together produce the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{"="(A,B+C,D)}
\end_layout

\end_inset

.
 This n-ary assignment operator is equivalent to the composite of the binary
 assignments accumulating.
 For instance, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 refers to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{"="(A,B+C)}
\end_layout

\end_inset

, and then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D}
\end_layout

\end_inset

 accumulates the meaning to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{"="("="(A,B+C),D)}
\end_layout

\end_inset

, and this is equivalent to the flattened version 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{"="(A,B+C,D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {Source A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {Source B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {Variable};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-1"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

Marble diagram of a merge operation for inferring variable values from two
 sources
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
old draft
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
Our new variant has a unique feature related to the assignment operator
 
\backslash
lstinline{:=}.
 With this new variant, multiple assignments can be made to the same variable.
 This means that when an assignment is made, an additional source is added
 to the variable to obtain its values.
 The variable uses the various sources of values and uses them to infer
 its values over time.
\end_layout

\begin_layout Plain Layout
When multiple assignments are made, they are treated as a single assignment
 operator for the variable and the expressions in the various statements.
 For example, the two statements 
\backslash
lstinline{A:=B+C} and 
\backslash
lstinline{A:=D+1} produce the function 
\backslash
lstinline{"="(A,B+C,D)}.
 The n-ary assignment operator is equivalent to a composite of several binary
 assignments.
 For instance, 
\backslash
lstinline{"="(A,(B+C),D)} behaves the same as 
\backslash
lstinline{"="("="(A,B+C),D)}.
 Thus, 
\backslash
lstinline{A:=B+C} refers to 
\backslash
lstinline{"="(A,B+C)}, and then 
\backslash
lstinline{A:=D} accumulates the meaning to 
\backslash
lstinline{"="("="(A,B+C),D)}.
\end_layout

\begin_layout Plain Layout
To provide values, the principal used relies on several sources and is based
 on the lower-level abstraction of the variable.
 The low-level abstraction of a variable is an observable stream of values
 that represents its varying value.
 Therefore, a variable with multiple sources implies having several streams
 of samples that contribute to inferring its values.
 This is similar to situations where several devices sample a single real-world
 variable.
 Consequently, the assignment operator can function as a merge function
 over the streams.
 So, 
\backslash
lstinline{"="("="(A,B+C),D)} is actualy 
\backslash
lstinline{"merge"("merge"(A,B+C),D)}
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
Our noval approach, or the unique feature about the new variant, is about
 the assginment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

.
 The new variant enables multiple assigment to the same variable.
 This means that an assignment refers to adding more source to get values
 to the variable.
 The variable subscribes to the sources of values, and uses all of them
 to inffer its values over time.
\end_layout

\begin_layout Plain Layout
The case of several assignments is interepted as a single assignment operator
 over the variable and assigned expressions in the various statements.
 For example, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:assigmentOperator"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two statements of a FRP application 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D+1}
\end_layout

\end_inset

, produces the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C),D)}
\end_layout

\end_inset

.
 The n-ary assignment operator should be equivalent to a composite of several
 binary assignments.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,(B+C),D)}
\end_layout

\end_inset

 behaves the same as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C),D)}
\end_layout

\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:assigmentMutipleLevel"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 In this sense, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 referes to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C)}
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D}
\end_layout

\end_inset

 accumulates the meaning to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C),D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
The used principal to provide values are based on the several sources, lies
 on the lower level abstraction of the variables.
 variable’s low level abstraction is an observable stream of values represeting
 its varying value.
 Accordingly, a variable with more than one source refers to having several
 streams of samples contributing to inferre its values.
 This is similar to situations when several devices sample a single real-world
 variable.
 As a result, the assingment operator can operate as a merge function over
 the streams.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The new variant of FRP introduces a mechanism where variables supply values
 to their subscribers.
 Subscribers receive values via the equal sign operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

 and can utilize the assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 to link calculations to obtain values based on the specified expression.
 By subscribing to a variable, the assignment operator updates it according
 to the provided expression, which represents a function over the variables
 and delivers values to the subscribers.
\end_layout

\begin_layout Plain Layout
The new variant enables multiple assigment to the same variable.
 This means that an assignment refers to adding more source to get values
 to the variable.
 The variable subscribes to the sources of values, and uses all of them
 to inffer its values over time.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Drafts
\end_layout

\begin_layout Plain Layout
The assignment's first type relates (subscribes) the variable to be updated
 (directly, without a madiator) according to the specified formula.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
The variables provide values to subscribers.
 They recive values by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

, and mainly use an assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 that links calculations to receive values based on that calculation.
 The assignment relates (subscribes) the variable to be updated according
 to the specified expression.
 An expressions are functions over the variables, providing values to the
 subscribers.
\end_layout

\begin_layout Plain Layout
In executing a formula, we say that the formula is added to the existing
 formulas that the runtime maintains.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
Such variable type can receive input by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

, and has an assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 that links calculations to receive inputs based on that calculation.
 Services can make these variables available for their clients to use, and
 subclasses can use the variables belonging to their superclass through
 a specialization interface.
 Since one variable can be used by many clients or subclasses, it can have
 multiple assignments.
\end_layout

\begin_layout Plain Layout
With the capability of multiple assignments, it is possible to create formulas
 that accommodate large and complex data dependencies.
 As a formula is executed, it is incorporated into the existing formulas
 that the runtime manages.
 The semantics that the assgiment adds the formula to the existing formulas
 to maintain , fits well with the conceptual specialization (subtyping)
 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

, making the derived class only extending the base class.
\end_layout

\begin_layout Plain Layout
By enabling multiple assignments, formulas can be created, even in the presence
 of large and complex data dependencies.
 In executing a formula, we say that the formula is added to the existing
 formulas that the runtime maintains.
 The semantics to add the formula, fits well with the conceptual specialization
 (subtyping) 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

, making the derived class only extending the base class.
\end_layout

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
Such variable type can provide values to subscribers based on given input.
 It receives input by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

, and has an assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 that links calculations to receive inputs based on that calculation.
 The assignment subscribes the variable to be updated (directly, without
 a madiator) according to the specified expression.
\end_layout

\begin_layout Plain Layout
Services can make these variables available for their clients to use, and
 subclasses can use the variables belonging to their superclass through
 a specialization interface.
 Since one variable can be used by many clients or subclasses, it can have
 multiple assignments.
\end_layout

\begin_layout Plain Layout
The assignment relates (subscribes) the variable to be updated (directly,
 without a madiator) according to the specified formula.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
Such variable type can receive input by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{=}
\end_layout

\end_inset

, and has an assignment operator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{:=}
\end_layout

\end_inset

 that links calculations to receive inputs based on that calculation.
 Services can make these variables available for their clients to use, and
 subclasses can use the variables belonging to their superclass through
 a specialization interface.
 Since one variable can be used by many clients or subclasses, it can have
 multiple links to multiple calculations, providing it with multiple sources
 to receive input.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Integration of the New Variant of FRP in Object-Oriented Programming
\end_layout

\begin_layout Standard
The semantics to add the formula, fits well with the conceptual specialization
 (subtyping) 
\begin_inset CommandInset citation
LatexCommand cite
key "taivalsaari1996notion"
literal "false"

\end_inset

, making the derived class only extending the base class.
\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
Services can make these variables available for their clients to use, and
 subclasses can use the variables belonging to their superclass through
 a specialization interface.
 Since one variable can be used by many clients or subclasses, it can have
 multiple assignments.
\end_layout

\begin_layout Standard
——-
\end_layout

\begin_layout Standard
Since one variable can be used by many clients or subclasses, it can have
 multiple links to multiple calculations, providing it with multiple sources
 to receive input.
\end_layout

\begin_layout Subsection
???
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 class contains the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

.
 The class contains a formula (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:formula}
\end_layout

\end_inset

) defining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to be re-evaluated whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 is updated.
 Then once an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 is created (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:ctor}
\end_layout

\end_inset

), any change to its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 causes its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to re-evaluate.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Specialization-Interface"
plural "false"
caps "false"
noprefix "false"

\end_inset

, class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 extends 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 and adds the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug:=Dose*Duration}
\end_layout

\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Specialization-Interface"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we illustrates 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 by composition.
 In the example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 is assigned from outside of the object.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class DrugAdministration{
\end_layout

\begin_layout Plain Layout

  RIVar<double> Drug, Volume
\end_layout

\begin_layout Plain Layout

  RIVar<double> Concentration:=Drug/VolumeOfFluid |
\backslash
label{line:formula}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main(){
\end_layout

\begin_layout Plain Layout

DrugAdministration administration=new DrugAdministration() |
\backslash
label{line:ctor}| 
\end_layout

\begin_layout Plain Layout

administration.Drug=50
\end_layout

\begin_layout Plain Layout

administration.Volume=100 // administration.Concentration=0.5
\end_layout

\begin_layout Plain Layout

administration.Drug=25  // administration.Concentration=0.25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 class contains the variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

.
 The class contains a formula (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:formula}
\end_layout

\end_inset

) defining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to be re-evaluated whenever 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 is updated.
 Then once an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 is created (
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:ctor}
\end_layout

\end_inset

), any change to its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Volume}
\end_layout

\end_inset

 causes its 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 to re-evaluate.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration {
\end_layout

\begin_layout Plain Layout

  IDrugAdministration drugAdministration
\end_layout

\begin_layout Plain Layout

  ExtendedDrugAdministration(DrugAdministration drugAdministration){ 
\end_layout

\begin_layout Plain Layout

    this.drugAdministration=drugAdministration
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  drugAdministration.Drug:= drugAdministration.Concentration*drugAdministration.Vol
umeOfFluid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Service-Interface"

\end_inset

 An example to a variable that is assigned externally by an expression.
 The instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

 has a variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 which is assigned externaly to be updated according to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class ExtendedDrugAdministration:DrugAdministration {
\end_layout

\begin_layout Plain Layout

  RIVar<double> Dose, Rate, Duration
\end_layout

\begin_layout Plain Layout

  Drug:=Dose*Duration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Specialization-Interface"

\end_inset

An example of a subclass that assigns variables that belonged to the superclass.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{ExtendedDrugAdministration}
\end_layout

\end_inset

 assigns variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 belonging to its superclass 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{DrugAdministration}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Evaluation Model
\end_layout

\begin_layout Standard
The evaluation model used in this study is based on the push-based evaluation
 model, which is commonly used in reactive programming and implemented by
 ReactiveX.
 This model uses the observer pattern and synchronized calls to propagate
 updates through a chain of computations.
 The push-based evaluation model can be viewed as a depth-first search (DFS)
 algorithm, where updates or events are propagated through the chain of
 computations in a depth-first order.
 In this model, each computation is executed before its dependencies, ensuring
 that computations are executed in the correct order and the results are
 available to their dependents when needed.
 The dependencies between computations are defined by the data flow graph
 of the program or system, and the updates are propagated through this graph
 in a depth-first order.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced evaluation method is based on the push based evaluation model,
 as it is implemented by ReactiveX.
 It uses the observer pattern with synchronized calls as its underlying
 model for propagating updates through a chain of computations.
 The push based evaulation model can be seen as a depth-first search (DFS)
 propagation algorithm, in the sense that updates or events are propagated
 through a chain of computations in a depth-first order.
\end_layout

\begin_layout Plain Layout
In a DFS traversal, the algorithm explores as far as possible along each
 branch before backtracking.
 Similarly, in a push-based evaluation model, the updates or events are
 propagated through the chain of computations in a depth-first order, meaning
 that each computation is executed before its dependencies.
 This ensures that the computations are executed in the correct order, and
 that the results of each computation are available to its dependents when
 they are needed.
\end_layout

\begin_layout Plain Layout
In this sense, the push-based evaluation model used in reactive programming
 can be seen as a variation of the DFS algorithm, where the dependencies
 between computations are defined by the data flow graph of the program
 or system, and the updates or events are propagated through this graph
 in a depth-first order.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
——-
\end_layout

\begin_layout Standard
Executing the assignment statements accumulates merged streams.
 The execution is sequentially, with the imperative style, line by line.
 For example, the statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 is executed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(A,B+C)}
\end_layout

\end_inset

.
 The next statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D+1}
\end_layout

\end_inset

 is executed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(A,D+1)}
\end_layout

\end_inset

 according to the current value of A.
 So that the execution if the two statements behaves as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(merge(A,B+C),D+1)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Executing the merge, is not by creating a new stream to produce values whenever
 there is a value in any of the two sources.
 Instead, as seen in the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Recursive-Merge-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we use the existing stream of the variable, and produce the merge by 
\begin_inset Quotes eld
\end_inset

adding
\begin_inset Quotes erd
\end_inset

 the missing values according to the other source.
 In order to add the missing values, the assignment/merge operator need
 to track the two sources, and do comparison according to our model of order.
\end_layout

\begin_layout Standard
(That's correct.
 The merge operator is a functional operator that combines multiple streams
 into a single stream.
 It takes multiple source observables and subscribes to all of them, forwarding
 the emitted values from all of them into a single output observable.
 On the other hand, using a Subject to implement the same behavior is an
 imperative approach that involves calling onNext on the subject to emit
 values from the various streams, and then subscribing to the subject to
 receive the merged output.
\end_layout

\begin_layout Standard
While both approaches can achieve the same result, the functional approach
 with merge is often preferred as it promotes a more declarative programming
 style and can simplify the code by abstracting away the low-level details
 of merging streams.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Recursive-Merge-1"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=merge(A,B)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
———
\end_layout

\begin_layout Standard
The n-ary assignment operator should be equivalent to a composite of several
 binary assignments.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,(B+C),D)}
\end_layout

\end_inset

 behaves the same as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C),D)}
\end_layout

\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:assigmentMutipleLevel"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 In this sense, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 referes to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C)}
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D}
\end_layout

\end_inset

 accumulates the meaning to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

(A,B+C),D)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (1,1) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (3,1) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (5,1) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (D) at (7,1) {D};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus) at (4,3) {+}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus1) at (6,3) {+1}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (4,5) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal2) at (4,7) {=};     
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout


\backslash
path (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path (C) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path (D) edge  (Plus1);
\end_layout

\begin_layout Plain Layout


\backslash
path (A) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path (Equal) edge  (Equal2);
\end_layout

\begin_layout Plain Layout


\backslash
path (Plus1) edge  (Equal2);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:assigmentMutipleLevel"

\end_inset

A composition of binary assignments
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to the FRP application, there is also the 
\emph on
FRP application consumer
\emph default
, unless it, the FRP application is useless
\emph on
.
 
\emph default
The FRP application is effectful only when it is connected to external events
 of inputs, and also the external events of outputs are observed.
 So, the role of the FRP application consumer is to trigger events, feeding
 the reactive variables with values, and observe the reactive variables
 by being subscribed to their events.
\end_layout

\begin_layout Standard
In this scope, we just use statements of the form 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Var=input}
\end_layout

\end_inset

 to trigger a single event of an external input.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=1}
\end_layout

\end_inset

 refers to that the reactive variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 has just being updated by an external input to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{1}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Execution Model
\begin_inset CommandInset label
LatexCommand label
name "subsec:Execution-Model"

\end_inset


\end_layout

\begin_layout Standard
An external input, caused a variable's value to change, causes a depth-first
 search (DFS) traversal on the graph starting from this variable's node.
 In the traversal, the dependant variables would update according to the
 new input.
 
\end_layout

\begin_layout Standard
The DFS traversal is caused by synchronous calls process: whenever an element's
 value is changed, it makes recursive synchronous calls to elements depending
 on it, calculating their new values.
\end_layout

\begin_layout Standard
The result of a DFS of the graph can be described in terms of a spanning
 tree of the vertices reached during the search.
 The traversal and updates are simple while edges are 
\emph on
tree edges
\emph default
, however we should consider also the 
\emph on
special
\emph default
 edges (back edges, cross edges and forward edges).
 Reactive variables will always be visited through tree edges going from
 an assignment, so we should consider only assignments and operators.
\end_layout

\begin_layout Standard
For operators, the special edges reminds the glitch issue 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 The root element's change causes two (or more) visits in the elements that
 have the special edge, while only the last produced a correct calculation.
 However if the graph contains cycles, it is not simple to identify what
 is the last visit.
 So, we use a 
\emph on
model of order
\emph default
 and will ignore visits with less updated value than the existing one.
\end_layout

\begin_layout Standard
For assignments, in the first glance it does not make sence having a special
 edge, because it seems to be defined conflicts.
 However, as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:assignment-special-edge"
plural "false"
caps "true"
noprefix "false"

\end_inset

, any element in the spanning graph is supposed to depend on other variables
 from the graph.
 That's why each visit represents not only the current external input but
 also the preceding external inputs affected the other dependant variables.
 According to the model of order, the visit representing the latest external
 inputs, should be the correct calculation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black,dashed] (B) at (1,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black,dashed] (C) at (5,7) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (op1) at (2,5) {+};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (op2) at (4,5) {+};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (eq) at (3,3) {=};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]},dashed] (B) edge  (op1);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]},dashed] (C) edge  (op2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (op1);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (A) edge  (op2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (op1) edge  (eq);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}, color=blue] (op2) edge  (eq);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout

*Dotted Lines (in contrast to the solid lines) refers to that it is not
 part of the spanning graph of the vertices reached during the search.
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:assignment-special-edge"

\end_inset

A special edge in DFS to an assignment element
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The Model of Order
\begin_inset CommandInset label
LatexCommand label
name "sec:Order-Model"

\end_inset


\end_layout

\begin_layout Standard
The external events are sequential.
 Each event has a timestamp (an incremental natural number) as X, Y and
 D in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Then a value inferred by other values has several timestamps, the ones
 that the value is based on (Z1 and Z2 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Transitively, a value derived from other values has the timestamps produced
 from the union operation on the timestamps of the values it is derived
 from (V in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 For the sake of simplicity, timestamps are uniformely represented as sets
 containing one or more timestamps.
 
\end_layout

\begin_layout Standard
Any value can be compared against any other value according to their timestamps
 set.
 Greater timestamps, as the first two lines in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 are indicators to more recent events.
 However, if the set is a superset, as in the third line in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, then it is a recursive update, so considered as not being more updated.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V=Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value=25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
timestamps: {1,2,3}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset

Values' Timestamps
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset

Comparing Timestamps Set
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Computation with the Stream Model
\begin_inset CommandInset label
LatexCommand label
name "sec:stream"

\end_inset


\end_layout

\begin_layout Standard
Essentiality there are two principals.
 First, variable's low level abstraction is an observable stream of values
 represeting its varying value.
 Second, a single variable can have several sources (from being an input
 variable while having one or more assignments, or just from having several
 assignments).
\end_layout

\begin_layout Subsection
Observable Stream
\end_layout

\begin_layout Standard
In addition to the reactive variable's continuous abstraction, there is
 also the discrete stream abstraction.
 Because even when a reactive variable represents a real-world variable
 in high level, in computers reactive variables' actual values cannot continuous
ly provided.
 For example, temperature depends on an actual stream of discrete events,
 being sampled by a thermometer.
\end_layout

\begin_layout Standard
Similary in UI applications, the logic may be in terms of continuously update
 fields according to other fields.
 Many times, UI application observe fields’ change events, once a value
 is changed, dependant fields are calculated and presented.
 The fields change events feed reactive variables (as observable variables),
 and the fields updates are from subscribing to reactive variables (as latent
 variables).
\end_layout

\begin_layout Standard
A reactive variable, and any other element in the FRP application, is a
 stream of values represeting its varying value.
 The stream can be described as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The x axis represents the time, and whenever the value is changed, there
 is a circle with the new value.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values"

\end_inset

Illustrating a stream of values representing the varying value of a variable.
 The axis represents the time, and whenever the value is changed, there
 is a circle with the new value.
 The visualized stream presents a variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 updated to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{5}
\end_layout

\end_inset

, then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{3}
\end_layout

\end_inset

, then after a longer period 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{2}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Several Sources
\end_layout

\begin_layout Standard
A variable with more than one source refers to having several streams of
 samples contributing to inferre its values.
 This is similar to situations when several devices sample a single real-world
 variable.
\end_layout

\begin_layout Standard
In this thesis, the values are inferred according to the time: whenever
 a new value exists in any of the sources, the value would be propagated
 to the target variable.
 Taking values from several sources according to the time, is equivalent
 to the merge function over streams ( as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {Source A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {Source B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {Variable};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

A variable varying value inffered from several sources.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The assignment element is a function over streams that should produce a
 single stream, with the meaning of inferring the value, by merging the
 streams.
 Therfore, the assignment element will be referred to, as the 
\emph on
merge
\emph default
 function.
\end_layout

\begin_layout Subsection
Execution Model
\end_layout

\begin_layout Standard
The elements of the FRP application, as an events stream, or an observable,
 emits values to subscribers 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, based on the 
\emph on
observer
\emph default
 and 
\emph on
iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 Each operator and assignment provides its subscribers 
\emph on
a single values stream based on several values streams
\emph default
 which it is subscribed to.
 It tracks its input values from the inputs streams it is subscribed to,
 calculating and 
\emph on
deciding
\emph default
 what values to notify its subscribers; some inputs might be with an incorrect
 order or redundant updates due to cycles or glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
There are two stages.
 First, evaluating the statements.
 Second, reacting to the FRP application consumer, i.e., updating and triggering
 variables according to external events.
 In the first stage of evaluation, the elements subscribe to each other
 according to the problem described.
 In the second stage, the connected elements update each other, by calling
 each other's OnNext, whenever they need to update.
 For example, the statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+1}
\end_layout

\end_inset

 described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Formula-Graph-2variables"
plural "false"
caps "true"
noprefix "false"

\end_inset

, is evaluated as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula"
plural "false"
caps "true"
noprefix "false"

\end_inset

, then as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the"
plural "false"
caps "true"
noprefix "false"

\end_inset

, when the UI updates B with the value 2 causing the elements update each
 other.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (2,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus) at (2,5) {+1}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (2,3) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,1) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Equal) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Formula-Graph-2variables"

\end_inset

Formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+1
\end_layout

\end_inset

 over reactive variables A and B
\end_layout

\end_inset


\end_layout

\end_inset

, and 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula"

\end_inset

Evaluating the formula A:=B+1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{OnNext(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{OnNext(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{OnNext(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{OnNext(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{OnNext(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the"

\end_inset

Propogation on the formula A:=B+1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Executing the Assignments
\end_layout

\begin_layout Standard
Executing the assignment statements accumulates merged streams.
 The execution is sequentially, with the imperative style, line by line.
 For example, the statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

 is executed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(A,B+C)}
\end_layout

\end_inset

.
 The next statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=D+1}
\end_layout

\end_inset

 is executed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(A,D+1)}
\end_layout

\end_inset

 according to the current value of A.
 So that the execution if the two statements behaves as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=merge(merge(A,B+C),D+1)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Executing the merge, is not by creating a new stream to produce values whenever
 there is a value in any of the two sources.
 Instead, as seen in the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Recursive-Merge"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we use the existing stream of the variable, and produce the merge by 
\begin_inset Quotes eld
\end_inset

adding
\begin_inset Quotes erd
\end_inset

 the missing values according to the other source.
 In order to add the missing values, the assignment/merge operator need
 to track the two sources, and do comparison according to our model of order.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Recursive-Merge"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=merge(A,B)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
According to our approach, the variables are interacted by traditional messages
 from the objects containing them.
 Therefore, in the implemented solution of FRP, a mediator is not allowed.
 Instead, we use a push model, such that a variable synchronously calls
 its derived variables whenever it has a new value.
 In addition, any dependency produced from any formula, is supported.
\end_layout

\begin_layout Standard
In order to cover all types of dependency graphs, we provide semantics to
 the assignment operator.
 An assignment refers to adding more source to get values to the variable,
 therefore a variable inffer its values over time from all the sources provided.
 As a result, the assignments and operators have a similarity in that they
 may produce a single stream by several input streams.
\end_layout

\begin_layout Standard
We provide an order model to handle the time issue, because the 
\emph on
visit time
\emph default
 of the DFS traversal is insufficient for visits caused from the same event
 (simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

).
 Therefore, values are attached with information to discover their time.
 
\end_layout

\begin_layout Standard
We use the order model as the algorithm used in the assignment operator,
 how to choose the values among the input streams.
 Consequently, whenever there is a new value from any of the sources, it
 is pushed to the target variable.
 This makes the similarity stronger between the assignments and operators.
\end_layout

\end_body
\end_document
