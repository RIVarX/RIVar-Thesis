#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset

Methodology
\end_layout

\begin_layout Section
Language Elements
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Standard
Variable that is re-assigned over time can be modelled as stream, that in
 each update there is a new item, of the new value representing the updated
 value at that instant.
 reactive variable means that update of that variable raises indirectly
 a continuation action based on the new value.
 Such an update may be called as
\emph on
 update with a push notification
\emph default
.
 In other words, 
\emph on
update with a push notification
\emph default
 means that not only the variable contained the new value instead of the
 previous value, but also that it raises interested parties about the change.
 We refer to variables as an object in the world, that exposes operation
 
\emph on
assign
\emph default
 (with :=) for an update, and 
\emph on
subscribe 
\emph default
for registration for push notifications.
\end_layout

\begin_layout Paragraph
Lifted Functions
\end_layout

\begin_layout Standard
Variable expressions can also be modeled as streams, where each evaluation
 produces a new item representing the updated value at that instant.
 Evaluations are raised as push notifications from updaing variables.
 For this purpose, 
\family typewriter
Lift
\family default
 operation is needed that converts functions for creating such expressions.
 For example, 
\begin_inset Formula $\LSTINLINE +$
\end_inset

 as a function of values, can be lifted.
 The lifted 
\begin_inset Formula $\LSTINLINE +$
\end_inset

 are used over variables, creating an expression 
\begin_inset Formula $\LSTINLINE{A+B}$
\end_inset

 .
 The expression is evaluated whenever either 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 or 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An expression is evaluated by 
\end_layout

\begin_layout Plain Layout
Each update in any of the variables raises an evaluation each evalution
 a new item is created of the value, at the time of after the evaluation.
\end_layout

\begin_layout Plain Layout
Lift is an operation that creates functions to operate on variables from
 simple functions.
 
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of (variables
 and output of the latter funcions) .
\end_layout

\begin_layout Plain Layout
, and recursovely to function over the result of those functions.
 The lifted function makes that each update in any of the variables raises
 an evaluation to the function over values based on the new value.
 This 
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of variables
 that creates streams.
 Each update in any of the variables raises an evaluation to the function
 over values based on the new value.
 For each evalution a new item is created of the value, at the time of after
 the evaluation.
 The lifted functions can further be used to be applied on results of other
 lifted functions.
 Therefore, the functions subscribe to streams and create an output streams,
 such that each item in any of the input stream raises an item in the output
 stream.
\end_layout

\begin_layout Plain Layout
items of the stream contained the values from those evaluations according
\end_layout

\begin_layout Plain Layout
The streams items contain the values evaluated 
\end_layout

\begin_layout Plain Layout
Each function is converted into function that 
\emph on
subscribe
\emph default
 to variables and 
\end_layout

\begin_layout Plain Layout
Lift is an operation that create functions that create stream of values
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(the background: variable that re-assign over time can be modelled as stream
 over time, that in each update there is a new item at that time, that is
 the new value.
 reactive variable: if an update of that variable raises indirectly a continuati
on action based on the new value.
 update with a push notification means that not only the variable contained
 the new value instead of the previous value, but also that it raises interested
 parties about the change.
 )
\end_layout

\begin_layout Plain Layout
(introduction: variable is an object)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Assignment
\end_layout

\begin_layout Standard
We introduce an assignment operator, that rather than initiating a variable
 according to the right-hand expression, will register the left-hand variable
 to be updated to changes of the right-hand expression.
 This has in common with one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This also has in common with constraints programming with the name one-way
 dataflow constraint
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
However, the special about the current assignment operator is its directed
 approach between the left-hand variable and the right-hand expression.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression will directly call to the left-hand variable.
 The directed calls in subscribe has a meaning to not depends on a madiator.
 It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.
\end_layout

\begin_layout Section
Propagation Algorithm
\end_layout

\begin_layout Standard
Based on the DFS algorithm, we apply an order over the values, by which
 feedback and absolete values will be discarded.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\begin_layout Standard
In order to evaluate the recency of updated values against previously forwarded
 values, we establish an order relation between the whole values.
 We assume external events as a stream, without simultaneous events.
 The values provided from the external events are ordered according to them.
 Further values are ordered according to events by which they have been
 produced.
 
\end_layout

\begin_layout Standard
Each value produced directly by an external event, its position in the order
 is according to the location of the event.
 Each further value, the position of the value is according to a set of
 positions (timestamps), one from each event that the value derived its
 value from.
 For example, X and Y that contain value 8 and 2 from timestamps 1 and 2
 respectively.
 For simplicity the timetsamps are presented as sets, such that in the example
 X and Y contains {1} and {2} respectively.
 upon formula Z = X*Y, Z will contain a value 16 and the corresponding timestamp
s are {1,2}.
 The sets of timestamps for the further values are resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Timestamps sets are used to determine the order.
 Each new event produces a value that is more recent that all the previous,
 therefore basicly a set that contains the recent timestamp is of the recent
 value.
 For example, {3} is more recent than {1,2}.
 However, this does not true, in case that a set is a superset of the other
 set.
 For example {1,2} and {1}.
 The reason is that {1,2} refers to value that is a feedback.
 Therefore, always a subset determines a recent value.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a "greater"
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
The algorithm starts from the variable being updated, this causes expression
 to evaluate in a sequential order.
\end_layout

\begin_layout Plain Layout
Revaluation of an expression, can trigger more revaluations if this expression
 is nested
\end_layout

\begin_layout Plain Layout
The directed approach in raising updates, causes that the change propagation
 algorithm is depth-first search (DFS) traversal, rooted in the variable
 being updated.
\end_layout

\begin_layout Plain Layout
Updating a variable triggers 
\end_layout

\begin_layout Plain Layout
An update process is a recursive process with a deterministic execution
 order
\end_layout

\begin_layout Plain Layout
The execution flow raised from an update, can be modeled as depth-first
 search (DFS) traversal over a graph.
 The nodes are the variable and functions.
 An update process is a recursive process, as it recursively trigger more
 updates.
 It starts from a single update in one variable.
 This raises evaluations to expression that consists that variable in a
 sequential order.
 Started from one expression, an expression is like a tree, as of an expression
 tree.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Started from the leaf in that local tree, it propagate up to the root of
 the expression, raising an update to a variable.
 
\end_layout

\begin_layout Plain Layout
.
 But the trversal is sequential
\end_layout

\begin_layout Plain Layout
Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes
\end_layout

\begin_layout Plain Layout
The graph consists of trees from the expression trees, but 
\end_layout

\begin_layout Plain Layout
An expression tree can be represented as a graph, in which each vertex in
 the graph represents an operand or an operator.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Similarly, each vertex represents a variable or a function call.
 The DFS starts from a single update in one variable.
 Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes, untill recahing the end of the evaluation
 of the expression.
 At this stage, it raises an update, representing a visit in the node that
 represent the variable bsing updated.
\end_layout

\begin_layout Plain Layout
, which may recursively raise evaluations in case of nesting in the expressions.
 Expressions in the top level raises an update 
\end_layout

\begin_layout Plain Layout
From an evaluation, other evaluations can be raised, in cased of nesting
 in expressions.
 
\end_layout

\begin_layout Plain Layout
edges represent variables and functions on expressions are represented 
\end_layout

\begin_layout Plain Layout
an element within the expression.
 Elements are operators and variables
\end_layout

\begin_layout Plain Layout
The graph contains multiple sub-graphs, each 
\end_layout

\begin_layout Plain Layout
As an expression tree, where each node represents an element within the
 expression, are all the 
\end_layout

\begin_layout Plain Layout
and lifted function are represented as nodes, and during
\end_layout

\begin_layout Plain Layout
It starts from a single update in one variable, this raises evaluation to
 expressions that consists that variable in a sequential order.
 Starting from one, this evaluation raises an update for another variable
 and recursivly continue in this process
\end_layout

\begin_layout Plain Layout
According to the new assignment operator, the execution flow is determined
 by a series of updates, as as update is one with a push notification that
 triggers 
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Several assignments to a single variable, will create several subscriptions,
 and this accomplish a similar effect to a 
\family typewriter
merge
\family default
 over sterams.
 For example, (A.subscribe(x => B.onNext(x)) and C.subscribe(x => B.onNext(x)))
 accomplish a similar effect to B=merge(A,C).
\end_layout

\begin_layout Plain Layout
—————-
\end_layout

\begin_layout Plain Layout
Reactive Instance variable (RIVar) refers to reactive variables on top of
 the observer pattern, or similar to simple events programming.
 An assignment has a meaning of registration to changes.
 For example, A statement like X:=Y is a short expression for Y.OnChange+=e=>X.Cha
nge(e=>e.Value).
 This produces as being accessed through an interface.
 Therefore, we name it also Reactive Interface Variable.
\end_layout

\begin_layout Section
Propogation Algorithm
\end_layout

\begin_layout Subsection
Depth-First Search (DFS)
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Subsection
Ordering and Filtering Mechanism
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for events propagation
, such that each event handler modifies a variable and subsequently triggers
 another event.
 Each handler evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the DFS algorithm produced by events propagation, the enhanced
 algorithm applies an order over the values and uses its for a filtering
 mechanism.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
In order to evaluate the recency of updated values against previously forwarded
 values, we establish an order relation between the whole values.
 We assume external events as a stream, without simultaneous events.
 The values provided from the external events are ordered according to them.
 Further values are ordered according to events by which they have been
 produced.
 
\end_layout

\begin_layout Plain Layout
Each value produced directly by an external event, its position in the order
 is according to the location of the event.
 Each further value, the position of the value is according to a set of
 positions (timestamps), one from each event that the value derived its
 value from.
 For example, X and Y that contain value 8 and 2 from timestamps 1 and 2
 respectively.
 For simplicity the timetsamps are presented as sets, such that in the example
 X and Y contains {1} and {2} respectively.
 upon formula Z = X*Y, Z will contain a value 16 and the corresponding timestamp
s are {1,2}.
 The sets of timestamps for the further values are resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
\end_layout

\begin_layout Plain Layout
Timestamps sets are used to determine the order.
 Each new event produces a value that is more recent that all the previous,
 therefore basicly a set that contains the recent timestamp is of the recent
 value.
 For example, {3} is more recent than {1,2}.
 However, this does not true, in case that a set is a superset of the other
 set.
 For example {1,2} and {1}.
 The reason is that {1,2} refers to value that is a feedback.
 Therefore, always a subset determines a recent value.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Leveraging the concept of indirect function calls as a depth-first search
 (DFS), we propose a propagation algorithm where each event handler modifies
 a variable and subsequently triggers another event.
 To ensure the correct operation of this algorithm, several key characteristics
 must be addressed.
 Before delving into the specifics of our novel algorithm, we outline these
 essential characteristics:
\end_layout

\begin_layout Description
DFS-Based: The algorithm operates within the framework of a DFS traversal
 over the graph of event handlers.
\end_layout

\begin_layout Description
Decentralized: The algorithm is inherently decentralized, with no centralized
 authority governing the order of updates.
\end_layout

\begin_layout Description
Online: The algorithm functions in an online manner, processing each input
 as it arrives and making decisions dynamically, in contrast to offline
 algorithms that operate on a complete dataset.
\end_layout

\begin_layout Paragraph*
The Algorithm
\end_layout

\begin_layout Plain Layout
On the DFS we add a If the updated value is deemed more relevant, it replaces
 the stored value; otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for event propagation
 in reactive systems.
 This algorithm incorporates a value comparison mechanism within each event
 handler to ensure that only the most up-to-date or relevant values are
 propagated through the system.
 Specifically, each handler evaluates the recency or relevance of the updated
 value against any previously forwarded values, using criteria such as timestamp
, priority, or domain-specific heuristics.
 If the updated value is deemed more relevant, it replaces the stored value;
 otherwise, it is discarded.
 This mechanism ensures data integrity and prevents outdated information
 from propagating through the system.
\end_layout

\begin_layout Plain Layout
We add a 
\emph on
compare
\emph default
 action that checks whether a valuen is more up-to-date than the previous
 forwarded value.
\end_layout

\begin_layout Plain Layout
We implement the change propagation on top of the default change propogation
 of Rx.
 This propagation consists of synchronously respond to notifications by
 passing them forward.
 This propagation consists of a traversal in the form of depth-first search
 (DFS) algorithm.
 In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We implemented the concept as extensions to existing programming languages
 on top of Rx.
 Specifically, we implemented the 
\begin_inset Formula $\NAME{nuget}$
\end_inset

 package 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and an 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 (Using observable streams facilitates binding with the UI, when a UI change
 event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.)
\end_layout

\begin_layout Standard
We implement a filtering mechanism, where the variables and the expressions
 over them does not propagate values that are less updated that the existing
 once.
 To do this, we create a wrapper to variables: the 
\begin_inset Formula $\RIVar$
\end_inset

 datatype, which is a shortcut for reactive instance variable.
 We also create a wrapper to the expressions: the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function (
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

) .
 Both pass values while filtering out obsolete values.
 The values are wrapped by objects of the 
\begin_inset Formula $\LSTINLINE{signal}$
\end_inset

 type (or 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) implementing the classic comparable interface (according to 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) by timestamps as mentioned in in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Order-Model"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function is similar to 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 that it creates an observable stream from input observable streams.
 Whenever any of the input stream has a new item, a new item is created
 to the output stream.
 However, in contrast to the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function creates an observable streams that is 
\emph on
strictly increasing sequence
\emph default
: it only passes an item to the output stream if it is greater (i.e., newer)
 than an item that previously passed.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\RIVar$
\end_inset

 type is derived from the 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

), which implements an observable stream.
 The 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) method is the implementation of the operator 
\begin_inset Formula $\LSTINLINE =$
\end_inset

, and for the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

, we implement a new custom method, we call it 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 In the 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 method, there are subscriptions to the two sides, and each item in the
 right side, is compared to the last item in the stream of the variable
 in the left side.
 If it is new, it will publish it by calling on its 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 This is like applying the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the right-hand side of the operator is merged with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
\end_layout

\begin_layout Standard
By using the extension, 
\begin_inset Formula $\LSTINLINE{A.set(Lift(Inc,B))}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, while 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

 represent the function 
\begin_inset Formula $\LSTINLINE{Inc(x)=x+1}$
\end_inset

.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator observes both the 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 operator and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 These established connections are then utilized for change propagation,
 interacting with the connected user interface (UI) fields.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The sequence diagram in creating the subscriptions of the components of
 a formula
\end_layout

\end_inset

The sequence diagram in creating the subscriptions of the components of
 a formula.
 The diagram is for the formula illustrates 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 Each of the components of the formula is an object, which subscribes and/or
 being subscribed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{next(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{next(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{next(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{next(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{next(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the formula, utilizing the 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Integration
\end_layout

\begin_layout Standard
As 
\begin_inset Formula $\RIVar$
\end_inset

s consist of observable streams we facilitate binding with the UI.
 Once a UI change event occurs, it adds an event to the stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 In this way, we created a .NET Windows Forms application, a web application,
 and an HTML page (available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

).
 Similarly, it should be easy to integrate with various development environments.
\end_layout

\begin_layout Standard
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
 
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are 
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
