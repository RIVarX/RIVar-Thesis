#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Method"

\end_inset

Approach and Implementation
\end_layout

\begin_layout Standard
The approach presented in the thesis is based on defining a new concept
 called 
\emph on
reactive instance variable
\emph default
.
 A reactive instance variable represents a variable at a high level of abstracti
on, incorporating features of both instance variables from OOP and reactive
 variables from FRP.
\end_layout

\begin_layout Standard
A key characteristic that distinguishes a reactive instance variable from
 implementations of reactive variables in FRP is that it's not possible
 to discern from its interface whether it's an input variable or a variable
 computed from other variables.
 In this respect, a reactive instance variable resembles an instance variable.
 This characteristic allows for dependency on a variable without being dependent
 on the implementation details related to the source of the variable's values.
\end_layout

\begin_layout Standard
Another characteristic of a reactive instance variable is its implementation
 as an object in OOP (rather than a simple value).
 A reactive instance variable is an object contained within another object.
 For example, a "Person" object can contain a reactive instance variable
 "Age." Reactive instance variables can be included in objects of different
 classes.
 For instance, the reactive instance variable "Age" from the "Creature"
 class can be used for various implementations such as "Animal," "Person,"
 etc.
\end_layout

\begin_layout Standard
The operators of a reactive instance variable are defined as actions, similar
 to properties
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-stru
cts/properties
\end_layout

\end_inset


\end_layout

\end_inset

 in the 
\family typewriter
C#
\family default
 programming language.
 When reading from or writing to a reactive instance variable, the operation
 appears as a regular variable read or assignment, such as 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 However, in reality, calls are made to special methods (accessors), namely
 the appropriate setter and getter.
 In implementing the approach, the operations may be regular operations.
 The cost is that syntax is like calling operations instead of assigning
 variables.
 For example, 
\begin_inset Formula $\LSTINLINE{A.Set(B)}$
\end_inset

 (while 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 represents an assignment operation) instead of 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
\end_layout

\begin_layout Standard
A reactive instance variable supports two types of assignment operators
 (or actions), denoted by 
\begin_inset Formula $:=$
\end_inset

 and 
\begin_inset Formula $=$
\end_inset

.
\end_layout

\begin_layout Enumerate
A value assignment operator (
\begin_inset Formula $=$
\end_inset

) that is similar to the assignment operator of an instance variable.
 This operator is also similar to feeding input in FRP.
\end_layout

\begin_layout Enumerate
A reactive assignment (
\begin_inset Formula $:=$
\end_inset

) that resembles to the sign that binds an expression to variable in FRP.
 By this operator, value assignment messages would be sent according to
 relevant changes.
\end_layout

\begin_layout Standard
Some research facts about these definitions:
\end_layout

\begin_layout Enumerate
The use of the symbols 
\begin_inset Formula $:=$
\end_inset

 and 
\begin_inset Formula $=$
\end_inset

 appears in reactive programming literature, originating from constraint
 programming 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset

.
\end_layout

\begin_layout Enumerate
In FRP, there is a unified notation (
\begin_inset Formula $=$
\end_inset

) for both meanings 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Enumerate
FRP is originated from functional programming, where there is no assignment
 operator.
 Accordingly, in FRP, defining a reactive variable is similar to defining
 a function, and the equal sign represents the link between the function's
 name and its body.
\end_layout

\begin_layout Enumerate
One research direction in FRP is the possibility of being 
\emph on
transparent
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "meyerovichflapjax"
literal "false"

\end_inset

(also called 
\emph on
implicit lifting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

), where the compiler automatically interprets assignment statements at
 a higher level of abstraction.
 This means that the conversion between the two levels of abstraction is
 implicit in the code.
 Accordingly, the same symbol is used to represent both types of assignment.
\end_layout

\begin_layout Enumerate
As seen in 
\family typewriter
REScala
\family default
, 
\family typewriter
ReactiveX
\family default
, and other frameworks, it remains common practice to distinguish syntactically
 between input feeding and definitions that drive automatic computations.
 However, these distinctions did not formalize them (as the current formalizatio
n) as separate operator types or distinct forms of assignment.
\end_layout

\begin_layout Standard
Change propagation is achieved through a design pattern 
\family typewriter
Observer
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

 (An example is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 For each reactive assignment, the left-hand variable acts like an 
\family typewriter
Observable
\family default
 while the left-hand variable acts like 
\family typewriter
Observer
\family default
 that observes it.
 That is, if a value changes in the left-hand expression a value assignment
 message is sent to the left-hand variable.
 The variables also act like 
\family typewriter
Observables
\family default
, with all the expressions the variable is in acting as 
\family typewriter
Observers
\family default
 that observe it.
 Here too, when there is a change in the value of variable, it sends messages
 to expressions it is in.
 This means that change propagation is a process in which variables and
 expressions receive messages when the value of an element they depends
 on has been replaced, and also send messages to elements that depend upon
 them when their value changes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{Subscribe}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluating-the-formula-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The sequence diagram in creating the subscriptions of the components of
 a reactive assignment.
\end_layout

\end_inset

The sequence diagram in creating the subscriptions of the components of
 a reactive assignment.
 The diagram is for the reactive assignment illustrates 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 Each of the components of the reactive assignment is an object, which subscribe
s and/or being subscribed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{E}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{A}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{eq}{:=}{}  
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{B}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Exp}{B+1}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{E}{value(2)}{B}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{B}{value(2)}{Exp}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Exp}{value(3)}{eq}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{eq}{value(3)}{A}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{A}{value(3)}{E}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}    
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}  
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Propogation-on-the-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
A propagation change in established connections of the formula 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset


\end_layout

\end_inset

A propagation change in established connections of the reactive assignment
 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

.
 The sequence diagram illustrates an interaction among the components involved
 in the reactive assignment, calling value assignment.
 The sequence starts with the UI field triggering an event, emitting the
 value 2.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This change is propagated based on the established subscriptions, as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout
The assignment operator 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 is changed from the traditional meaning to initiate a variable according
 to the right-hand expression.
 Instead, it registers the left-hand variable to be updated to changes of
 the right-hand expression.
 This has in common with 
\emph on
one-way data binding
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Like in 
\family typewriter
Angular:
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
\end_layout

\end_inset

 and also with 
\emph on
one-way dataflow constraint
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, we add more two characteristics.
\end_layout

\begin_layout Itemize
The left-hand variable 
\emph on
subscribes
\emph default
 to get changes from the right-hand expression (which means that the two
 sides are an 
\family typewriter
Observer
\family default
 and 
\family typewriter
Observable
\family default
 respectively).
 Since assignments behave like methods, it facilitates 
\emph on
dynamic dispatch.
 
\emph default
This mechanism is used for creating indirect interfaces, by which called
 methods are determined at runtime based on the objects' actual type.
 Likewise, clients would assign an object's variable without to determine
 the object's type.
\end_layout

\begin_layout Itemize
Also in raising the changes, the two sides interacts through an interface
 of the 
\family typewriter
Observer
\family default
 pattern.
 To clarify, this means there's no mediator used, no centralized data structure,
 no synchronization required, and it's not parallel execution.
 It's a straightforward function call.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For each reactive assignment, the left-hand variable receive value assignment
 messages when changes happen in the left-hand expression.
 These messages are in addition to other messages it already receives.
 As a result, the reactive assignment operation does not 
\emph on
modify
\emph default
 behavior, but 
\emph on
extend
\emph default
 it.
 This behavior aligns with the concept of inheritance.
 
\end_layout

\begin_layout Standard
In implementation inheritance, it's possible to perform reactive assignments
 to reactive instance variables belonging to classes higher up in the inheritanc
e hierarchy.
 Similarly, in composition, reactive assignments can be made to reactive
 instance variables of inner objects.
 Polymorphism can also be achieved, allowing uniform access to reactive
 instance variables of objects of different types based on an interface
 of a specific base class.
\end_layout

\begin_layout Paragraph
Examples
\end_layout

\begin_layout Subparagraph
Implementation Inheritance
\end_layout

\begin_layout Standard
The 
\family typewriter
DrugAdministration
\family default
 class contains the reactive instance variables 
\family typewriter
Drug
\family default
, 
\family typewriter
Volume
\family default
, and 
\family typewriter
Concentration
\family default
.
 The constructor of the class includes the reactive assignment 
\begin_inset Formula $\LSTINLINE{Drug:=Concentration/Volume}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
DrugAdministration2
\family default
 class is a subclass that contains the reactive instance variables 
\family typewriter
Dose
\family default
, 
\family typewriter
Rate
\family default
, and 
\family typewriter
Duration
\family default
.
 The constructor of the 
\family typewriter
DrugAdministration2
\family default
 class includes the assignment 
\begin_inset Formula $\LSTINLINE{Drug:=Dose*Duration}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Composition
\end_layout

\begin_layout Standard
The 
\family typewriter
Bag
\family default
 class contains the reactive instance variables 
\family typewriter
Drug
\family default
, 
\family typewriter
Volume
\family default
, and 
\family typewriter
Concentration
\family default
.
 The constructor of the class includes the reactive assignment 
\begin_inset Formula $\LSTINLINE{Drug:=Concentration/Volume}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
Pump
\family default
 class contains a field called 
\family typewriter
TheBag
\family default
 of type 
\family typewriter
Bag
\family default
.
 The 
\family typewriter
Pump
\family default
 class also contains the reactive instance variables 
\family typewriter
Dose
\family default
, 
\family typewriter
Rate
\family default
, and 
\family typewriter
Duration
\family default
.
 The constructor of the 
\family typewriter
Pump
\family default
 class includes the reactive assignment 
\begin_inset Formula $\LSTINLINE{TheBag.Drug:=Dose*Duration}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Polymorphism
\end_layout

\begin_layout Standard
As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the class 
\family typewriter
IBag
\family default
 (which can be purely abstract) contains pure virtual methods (accessors)
 for reading the reactive instance variables 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
 (and without 
\family typewriter
Concentration
\family default
).
 The constructor of the class includes 
\begin_inset Formula $\LSTINLINE{Drug:=Concentration/Volume}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
Pump
\family default
 class contains a field 
\family typewriter
TheBag
\family default
 of type 
\family typewriter
IBag
\family default
.
 The 
\family typewriter
Pump
\family default
 class also contains (in addition to the 
\family typewriter
TheBag
\family default
 field) the reactive instance variables 
\family typewriter
Dose
\family default
, Rate, and Duration.
 The constructor of the 
\family typewriter
Pump
\family default
 class includes 
\begin_inset Formula $\LSTINLINE{TheBag.Drug:=Dose*Duration}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
Bag
\family default
 class is a subclass of 
\family typewriter
IBag
\family default
, containing 
\family typewriter
Drug
\family default
, 
\family typewriter
Volume
\family default
, and 
\family typewriter
Concentration
\family default
.
 Additionally, the class overrides the virtual methods for 
\family typewriter
Drug
\family default
 and 
\family typewriter
Volume
\family default
 defined in the 
\family typewriter
IBag
\family default
 class, returning the corresponding reactive instance variables.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Based on the concept that an observable stream represents a variable, each
 node in a dependancy graph would represent an observable stream.
 Each item of an observable stream, represents a 
\emph on
visit
\emph default
 of the propagation  algorithm in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
we relate introduce a sematics 
\end_layout

\begin_layout Plain Layout
We take the concept of observable streams for presenting variables.
 An observable stream consists of values or changes over time, as illustrated
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values"
plural "false"
caps "true"
noprefix "false"

\end_inset

, generated from events of UI elements.
 Furthermore, Each node in a dependancy graph can be represented as an observabl
e stream.
 Each Item represents a visit in that node.
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Change Propagation Algorithm
\end_layout

\begin_layout Standard
The observer design pattern used for change propagation resembling a Depth-First
 Search (DFS) algorithm, 
\begin_inset Quotes eld
\end_inset

traversaling
\begin_inset Quotes erd
\end_inset

 one branch of dependencies deeply before backtracking.
 But this approach has a drawback of outdated values through a three different
 ways:
\end_layout

\begin_layout Itemize
Glitch: The value was calculated based on outdated values 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
Feedback: The value was calculated as a result of the previous value of
 the same variable (due to a loop), as in the example in the introduction.
\end_layout

\begin_layout Itemize
Multiple Assignments: When there are multiple assignments to the same variable,
 where at least one of them is a reactive assignment, value assignment messages
 are received from multiple sources.
\end_layout

\begin_layout Paragraph
Glitch
\end_layout

\begin_layout Standard
Given the reactive assignment statements:
\begin_inset Formula $\LSTINLINE{Concentration:=Drug/Volume}$
\end_inset

 (in 
\family typewriter
Bag
\family default
), and 
\begin_inset Formula $\LSTINLINE{Volume:=Duration*Rate}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug:=Duration*Dose}$
\end_inset

 in 
\family typewriter
Pump
\family default
.
 The propagation can be according to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:DrugAdministrationGlitch"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\family typewriter
Duration
\family default
 is propagated to 
\family typewriter
Drug
\family default
, and from there to 
\family typewriter
Concentration
\family default
, then propagated from 
\family typewriter
Duration
\family default
 to 
\family typewriter
Volume
\family default
 and from there again to 
\family typewriter
Concentration
\family default
.
 The first of the two updates is called a Glitch because it relies on outdated
 values that represents 
\family typewriter
Drug
\family default
.
 This means that a certain variable may be updated several times, and only
 the last of them will be the correct update.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance=2cm]
\end_layout

\begin_layout Plain Layout

  
\backslash
node (X) [circle, draw] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y1) [circle, draw, below left of=X] {Y1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y2) [circle, draw, below right of=X] {Y2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Z) [circle, draw, below right of=Y1] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->] (X) -- node[above left] {Duration} (Y1);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->] (X) -- node[above right] {Drug} (Y2);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->, dotted] (Y1) -- node[below left] {Volume} (Z);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [->, dotted] (Y2) -- node[below right] {Concentration} (Z);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DrugAdministrationGlitch"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Glitch Example in Drug Administration Application.
\end_layout

\end_inset

Glitch Example in Drug Administration Application.
 The solid edges denote dataflow (raising changes) within a 
\family typewriter
Pump
\family default
 instance while dotted edges indicate dataflow within a 
\family typewriter
Bag
\family default
 instance.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Standard
It is important to distinguish between two types of graphs.
 One graph describes the dependencies between variables, and the other graph
 describes the propagation of changes or the dataflow.
 In the dataflow graph, edges describe the direction of the flow or propagation.
 In the dependency graph, the direction of the edges is reversed, more similar
 to the way dependencies are defined in UML (Unified Modeling Language).
 For example, if we define 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, then 
\family typewriter
A
\family default
 depends on 
\family typewriter
B
\family default
, meaning there's an edge 
\begin_inset Formula $A\rightarrow B$
\end_inset

, while the dataflow has an edge from 
\family typewriter
B
\family default
 to 
\family typewriter
A
\family default
, meaning 
\begin_inset Formula $A\leftarrow B$
\end_inset

.
 Using these graphs, we can expand our understanding of feedback loops.
\end_layout

\begin_layout Standard
Feedback occurs when a cycle is created in the change propagation process.
 The process starts with an edge entering a certain vertex and returning
 to the same vertex from another edge.
 This means that a certain variable is updated, which triggers a chain of
 updates that eventually leads to another update of the same variable.
 In other words, there are two incoming edges to the vertex.
\end_layout

\begin_layout Standard
For example, given 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, then A depends on 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

 and receives updates from it.
 But 
\family typewriter
A
\family default
 can also receive input.
 Therefore, in change propagation, it has two incoming edges.
 Similarly, 
\family typewriter
A
\family default
 can depend on two expressions according to two different formulas.
\end_layout

\begin_layout Standard
This means that a reactive instance variable can depend on multiple different
 expressions, such that a message that arrived as a result of one reactive
 assignment statement led to a propagation chain until it eventually led
 to a message as a result of a second reactive assignment statement.
 Similarly, it is possible that a value assignment statement led the update
 chain until it eventually led to a message as a result of a reactive assignment
 statement.
\end_layout

\begin_layout Paragraph
Multiple Assignments
\end_layout

\begin_layout Standard
As a result of supporting cycles, it is necessary to support the syntax
 and semantics of multiple assignments.
 Examples of the syntax appear under implementation inheritance and composition;
 there are two reactive assignments to the reactive instance variable 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 The first statement is 
\begin_inset Formula $\LSTINLINE{Drug:=Concentration/Volume}$
\end_inset

 and the second statement is 
\begin_inset Formula $\LSTINLINE{Drug:=Dose*Duration}$
\end_inset

.
\end_layout

\begin_layout Standard
To determine the value of a variable appearing on the left-hand side of
 multiple reactive assignment statements, it is necessary to consider the
 issue of shared memory.
 When different code segments share memory, two code segments can write
 to the same variable.
 And when the value is read, the value is determined by the last code segment
 that ran.
 That is, the state of the variables changes over time, and its value is
 determined according to the time at which each line of code was executed.
\end_layout

\begin_layout Standard
A streams model is an alternative solution to the problem 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 (of variable assignments by different code segments running at different
 points in time).
 A stream is a list of values over time, similar to components "flowing"
 in a pipe.
 However, in the streams model, the unresolved problem is the merge problem.
 When there are streams from different sources, it is unclear how to merge
 them into one stream.
 The merge problem presented also in FRP as the problem on how to determine
 predictable order over values that are considered as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Supporting the syntax and semantics of multiple assignments means to address
 a sub-problem.
 For a set of reactive assignment statements, a variable can receive messages
 from multiple left-hand expressions according to reactive assignment statements
 for which it is the left-hand side variable.
 This means to merge streams of values from multiple sources.
 Regarding user input, it's not that different, input also serves as another
 source of values for merging.
 Supporting the syntax and semantics of multiple assignments require semantics
 like sampling values of a single variable from multiple sources.
 Just like the general merge problem, it requires to address the problem
 of how to manage the order of the values produced from the messages from
 the whole sources.
 
\end_layout

\begin_layout Subsection
The Order Relation
\end_layout

\begin_layout Standard
Assuming that the input values constitute an ordered set, any two values
 can be compared based on the input values under whose influence they were
 generated.
 Each input value has a timestamp based on its position in the ordered set.
 Each value has an associated set of timestamps, representing the timestamps
 of the input values that influenced its generation.
 The timestamp set of a value is calculated by performing a union operation
 on the timestamp sets of the values from which it is derived.
 The timestamp set of a value is calculated by performing a union operation
 on the timestamp sets of the values from which it is derived.
\end_layout

\begin_layout Standard
For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:timestamps-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "change_propogation_order_relation_example"
plural "false"
caps "true"
noprefix "false"

\end_inset

), let 
\begin_inset Formula $Y$
\end_inset

, 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 be variables containing 
\begin_inset Formula $8$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $1$
\end_inset

, respectively, from three input events corresponding to timestamps 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, respectively.
 Let 
\begin_inset Formula $Z_{1}$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $16$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $Z_{1}=X*Y$
\end_inset

.
 The value 
\begin_inset Formula $16$
\end_inset

 is influenced by the values 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $8$
\end_inset

, whose timestamps are 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $2$
\end_inset

.
 Therefore, the corresponding timestamp for the value 16 is the set 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

.
 Let 
\begin_inset Formula $Z_{2}$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $9$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $Z_{2}=X+D$
\end_inset

, with the corresponding timestamp 
\begin_inset Formula $\left\{ 1,3\right\} $
\end_inset

.
 Let 
\begin_inset Formula $V$
\end_inset

 be a variable that contains the value 
\begin_inset Formula $25$
\end_inset

 according to the reactive assignment statement 
\begin_inset Formula $V=Z_{1}+Z_{2}$
\end_inset

, with the corresponding timestamp 
\begin_inset Formula $\left\{ 1,2,3\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variable + Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Timestamps Set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D (external input)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z1 = X*Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Z2 = X+D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V = Z1+Z2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:timestamps-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mapping between values and sets of timestamps.
\end_layout

\end_inset

Mapping between values and sets of timestamps.
 The first three rows represent events that produce new values, followed
 by calculations based on those changes.
 When a value is calculated, a set is generated by taking the union of the
 input values' sets.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename example_change_propogation-removebg-preview.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "change_propogation_order_relation_example"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Change Propagation with Order Relation.
\end_layout

\end_inset

Change Propagation with Order Relation.
 The nodes represent variables and expressions.
 Edges represent value assignment messages.
 Each incoming edge is labeled with timestamps of the value of the message.
 The dotted edge represents a feedback loop.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The order relation between any pair 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 of values is determined by the timestamps of the values.
 Ostensibly, if there is a newer timestamp in the set of 
\begin_inset Formula $X$
\end_inset

, then 
\begin_inset Formula $X>Y$
\end_inset

.
 However, this check is insufficient due to feedback loops.
 If the set of timestamps of 
\begin_inset Formula $X$
\end_inset

 is a subset of the set of timestamps of 
\begin_inset Formula $Y$
\end_inset

, then 
\begin_inset Formula $X>Y$
\end_inset

 even if 
\begin_inset Formula $Y$
\end_inset

 has a newer timestamp.
 For example (presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparing-Timestamps-Set-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), adding to the aforementioned example the reactive assignment statement
 
\begin_inset Formula $X:=Z_{1}/Y$
\end_inset

.
 The value of 
\begin_inset Formula $X$
\end_inset

 is calculated from 
\begin_inset Formula $Z_{1}$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

, whose timestamps are 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

 and 
\begin_inset Formula $\left\{ 2\right\} $
\end_inset

 respectively, and therefore the timestamps of 
\begin_inset Formula $X$
\end_inset

 according to this statement are 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

.
 Recall that the value of 
\begin_inset Formula $X$
\end_inset

 according to the input has timestamp 
\begin_inset Formula $\left\{ 1\right\} $
\end_inset

, and although 
\begin_inset Formula $\left\{ 1,2\right\} $
\end_inset

 has a newer timestamp, the relation is 
\begin_inset Formula $\left\{ 1\right\} >\left\{ 1,2\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operand 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,3}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{1,2}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparing-Timestamps-Set-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparing the order of the values, based on their set of timetsamps.
\end_layout

\end_inset

Comparing the order of the values, based on their set of timetsamps.
 Each line represents two values that are compared.
 The cells in the columns of the operands, contain the timestamps of the
 values, that are used in the comparison
\begin_inset Note Note
status open

\begin_layout Plain Layout
according to their timetsamps.
 Generally, a greater timestamp indicates a newer event, which means a greater
 value.
 However, a superset is considered "less than" a subset in this case, and
 this is a critical point to note.
 This is because the value is generated recursively and there is no timestamp
 indicating a stale value in the subset.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We investigate a graph of a cyclical propagation change.
 Such a case is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The propagation starts from an incoming edge (the dotted edge in the figure)
 into a node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure), that is the cycle's first node.
 Then, it continues through several edges and nodes until reaching again
 the first node (
\begin_inset Formula $\LSTINLINE C$
\end_inset

 in the figure) from another edge (in the figure, the edge from 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 towards 
\begin_inset Formula $\LSTINLINE C$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$value$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dataflow_to_cycle-1-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dataflow into and through a cycle.
\end_layout

\end_inset

Dataflow into and through a cycle.
 The nodes represent the variables, and the edges illustrate the flow of
 the data.
 Values caused by inputs are propagated through the nodes of the cycle.
 Node 
\begin_inset Formula $C$
\end_inset

 has two incoming edges: the first connects it to the cycle, and the second
 is from where values are propagated into the cycle.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We make a process similar to reverse engineering, i.e., we consider change
 propagation and inffer data dependencies that constructed it.
 As one of the nodes has two incoming edges, it must be one of two options.
 First, that the node represents an input variable which also connected
 to an expression.
 Second, that the node represents a variable that are connected to two expressio
ns simultaneously.
\end_layout

\begin_layout Plain Layout
From this process we introduce syntax for data dependencies, that multiple
 assignments (
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

) are allowed, and without differentiating input variables.
 From this syntax the following code is correct.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}[numbers=none]  
\end_layout

\begin_layout Plain Layout

A:=B+C //assignments means as data dependencies
\end_layout

\begin_layout Plain Layout

A:=D+E //assignments means as data dependencies
\end_layout

\begin_layout Plain Layout

A=1 // input
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Plain Layout
Every update in the system is of type 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 contains a 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 field that holds the new value according to the update.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is a generic variable, where the type of 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 is only determined when an instance of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is created.
 A comparison function between a pair of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 instances is implemented within the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class.
 In the 
\family typewriter
C#
\family default
 implementation, the 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 class also inherits from the 
\begin_inset Formula $\LSTINLINE{IComparable}$
\end_inset

 interface, and then the comparison function is the 
\begin_inset Formula $\LSTINLINE{Compare}$
\end_inset

 function of the interface.
\end_layout

\begin_layout Plain Layout
An instance of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 contains an array of numbers used in comparisons.
 Timestamps are determined by a static 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 variable.
 Each time a 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 indicating an external event is created, the 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

 is incremented by 1, and the timestamp of the new 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is set to the new value of the 
\begin_inset Formula $\LSTINLINE{Counter}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
For this purpose, 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 has a constructor that receives the 
\begin_inset Formula $\LSTINLINE{Value}$
\end_inset

 as a parameter and defines the timestamp array to be of size 1 with the
 new timestamp.
 For a calculated value, there is an additional constructor that also receives
 the array of numbers representing the timestamps as a parameter.
\end_layout

\begin_layout Plain Layout
The calculation of the timestamp set of a computed 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 is performed by a 
\family typewriter
union
\family default
 operation on the timestamp sets of the values from which it is calculated.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation with Streams
\end_layout

\begin_layout Standard
The approach is implemented using 
\emph on
stream
\emph default
 abstraction.
 A stream is an entity with items along a timeline.
 A reactive instance variable is represented by a stream where each item
 is an update or a new value of the variable at the point in time corresponding
 to the item.
 Therefore, in the Depth-First Search
\begin_inset space ~
\end_inset

(DFS) algorithm used for change propagation, each visit to a node is an
 item in the stream.
 The implementation addresses the issue that in some visits, the value is
 outdated, and thus removes it from the stream.
\end_layout

\begin_layout Subsection
Implementation Details
\end_layout

\begin_layout Standard
As part of the thesis, we implemented two similar libraries: 
\family typewriter
RIVarX
\family default
 in 
\family typewriter
C#
\family default
 and 
\family typewriter
rivarjs
\family default
 in 
\family typewriter
JavaScript
\family default

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
which are based on the 
\begin_inset Formula $Observable$
\end_inset

 approach provided by 
\family typewriter
ReactiveX
\family default
.
\end_layout

\end_inset

.
 The library 
\family typewriter
RIVarX
\family default
 depends on the library 
\family typewriter
Rx.Net
\family default
 (that implements 
\family typewriter
ReactiveX
\family default
) and 
\family typewriter
rivarjs
\family default
 depends on 
\family typewriter
RxJS
\family default
.
 In 
\family typewriter
rivarjs
\family default
, the core consists of three short files.
 The longest file contains 60 lines of code, including blank lines and comments.
 The other two files contain about 42 lines of code each.
 Based on these results, it is easy to assume that implementing the approach
 using streams is easy to perform in other environments and programming
 languages.
\end_layout

\begin_layout Paragraph
Signal
\end_layout

\begin_layout Standard
Every update in the system is of type 
\begin_inset Formula $Signal$
\end_inset

.
 A 
\begin_inset Formula $Signal$
\end_inset

 contains a 
\begin_inset Formula $Value$
\end_inset

 field that holds the new value according to the update.
 
\begin_inset Formula $Signal$
\end_inset

 is a generic variable, where the type of 
\begin_inset Formula $Value$
\end_inset

 is determined only when a 
\begin_inset Formula $Signal$
\end_inset

 instance (signal) is defined.
 A comparison function between a pair of 
\begin_inset Formula $Signal$
\end_inset

 instances is implemented within the 
\begin_inset Formula $Signal$
\end_inset

 class.
 In the 
\family typewriter
C#
\family default
 implementation, the 
\begin_inset Formula $Signal$
\end_inset

 class also inherits from the 
\begin_inset Formula $IComparable$
\end_inset

 interface, and then the comparison function is the 
\begin_inset Formula $Compare$
\end_inset

 function of the interface.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $Signal$
\end_inset

 class contains a field of an array of numbers used for the comparison.
 Timestamps are determined by a static 
\begin_inset Formula $Counter$
\end_inset

 variable.
 Each time a 
\begin_inset Formula $Signal$
\end_inset

 instance representing an external event is created, 
\begin_inset Formula $Counter$
\end_inset

 is incremented by 
\begin_inset Formula $1$
\end_inset

, and the timestamp of the new signal is set to the updated 
\begin_inset Formula $Counter$
\end_inset

 value.
 For this purpose, the 
\begin_inset Formula $Signal$
\end_inset

 class has a constructor that takes the value as a parameter and initializes
 the timestamp array with a size of 
\begin_inset Formula $1$
\end_inset

, containing the new timestamp.
 For a computed value, there is an additional constructor that also takes
 an array of numbers representing the timestamps as a parameter.
 The set of timestamps for a computed signal is calculated by performing
 a 
\begin_inset Formula $union$
\end_inset

 operation on the sets of timestamps of the values from which it is derived.
\end_layout

\begin_layout Standard
In the 
\family typewriter
C#
\family default
 implementation of 
\family typewriter
RIVarX
\family default
, an implicit conversion operator is implemented, allowing automatic conversion
 between a value and a 
\begin_inset Formula $Signal$
\end_inset

 containing that value.
 This enables the language to continue using regular values.
 Thus, for a reactive instance variable A, one can perform 
\begin_inset Formula $A.OnNext(3)$
\end_inset

 instead of 
\begin_inset Formula $A.OnNext(newSignal(3))$
\end_inset

.
 This capability is specific to typed languages.
\end_layout

\begin_layout Paragraph
Monotonic Signal Streams
\end_layout

\begin_layout Standard
We implement streams of 
\begin_inset Formula $Signal$
\end_inset

s and ensure that the resulting sequence is monotonic, meaning each signal
 is greater (according to the comparison defined between signals) than its
 predecessor.
 We define an extension function called 
\begin_inset Formula $Monotonic$
\end_inset

 such that, given a stream 
\begin_inset Formula $X$
\end_inset

, one can use the expression 
\begin_inset Formula $X.Monotonic()$
\end_inset

 to obtain a monotonic stream by discarding any value that, when compared
 to its predecessor, is found to be smaller.
\end_layout

\begin_layout Standard
The implementation of the 
\begin_inset Formula $Monotonic$
\end_inset

 operation utilizes a straightforward combination of operators.
 Employing the 
\begin_inset Formula $Scan$
\end_inset

 operator, values are replaced with their preceding value if they are found
 to be smaller.
 For each value, a comparison is made with the value from the previous iteration.
 If the current value is greater, it is designated as the value for the
 subsequent iteration; otherwise, the value from the previous iteration
 is retained.
 The stream returned by the Scan operator is then subjected to the 
\begin_inset Formula $DistinctUntilChanged$
\end_inset

 operator, which ensures that consecutive items in the sequence are not
 repeated.
 This effectively removes the redundant items introduced by the Scan operator,
 which were intended to replace items smaller than their predecessors.
\end_layout

\begin_layout Paragraph
Reactive instance variable
\end_layout

\begin_layout Standard
Reactive instance variables can be implemented using a 
\begin_inset Formula $Subject$
\end_inset

 in the following ways: (1) defining reactive instance variables as instances
 of 
\begin_inset Formula $Subject$
\end_inset

; (2) creating a class 
\begin_inset Formula $RIVar$
\end_inset

 that inherits from 
\begin_inset Formula $Subject$
\end_inset

 (this is the approach used in 
\family typewriter
rivarjs
\family default
); and (3) creating a class 
\begin_inset Formula $RIVar$
\end_inset

 that is a 
\emph on
decorator
\emph default
 of 
\begin_inset Formula $Subject$
\end_inset

 (this is the approach used in 
\family typewriter
RIVarX
\family default
).
 
\end_layout

\begin_layout Paragraph
Expressions
\end_layout

\begin_layout Standard
For creating expressions over reactive instance variables, operators are
 used similar to as in 
\family typewriter
ReactiveX
\family default
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $CombineLatest$
\end_inset

: Creates a new stream from two existing streams.
 Whenever a new item is received in either of the streams, 
\begin_inset Formula $CombineLatest$
\end_inset

 takes the latest item from each stream and produces a new item in the new
 stream, based on some computation.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Select$
\end_inset

 (or 
\begin_inset Formula $map$
\end_inset

): Creates a new stream from an existing stream.
 For each item in the original stream, 
\begin_inset Formula $Select$
\end_inset

 performs some computation and produces a new item in the new stream, at
 the same time.
\end_layout

\begin_layout Standard
The implementation defines a 
\begin_inset Formula $Lift$
\end_inset

 function to enable a higher level of abstraction for constructing expressions
 over reactive instance variables.
 The implementation of 
\begin_inset Formula $Lift$
\end_inset

 features the following characteristics:
\end_layout

\begin_layout Itemize
Stream handling is internal: streams are handled internally within the implement
ation.
 Usage does not require explicit knowledge or handling of streams, thus
 achieving a higher level of abstraction.
 
\end_layout

\begin_layout Itemize
Signal-based computation: When generating a computed value, a new signal
 is produced with the computed value and the corresponding timestamps.
\end_layout

\begin_layout Itemize
Monotonicity enforcement: The implementation ensures the monotonicity of
 the streams.
\end_layout

\begin_layout Standard
\begin_inset Formula $Lift$
\end_inset

 is a function that takes reactive instance variables and a function over
 values as parameters, producing a corresponding stream.
 The name 
\begin_inset Formula $Lift$
\end_inset

 conveys the semantic meaning of raising the level of abstraction.
 For reactive instance variables 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 in the JavaScript-based rivarjs, the expression 
\begin_inset Formula $lift((x,y)=>x*y,X,Y)$
\end_inset

 is semantically equivalent to the expression 
\begin_inset Formula $X*Y$
\end_inset

.
\end_layout

\begin_layout Paragraph
Reactive Assignment
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $Set$
\end_inset

 operation is designed to implement the reactive assignment to the reactive
 instance variable.
 The operation should resemble a regular assignment statement: for a reactive
 instance variable 
\begin_inset Formula $X$
\end_inset

 and an expression 
\begin_inset Formula $Expression$
\end_inset

, the expression 
\begin_inset Formula $X.Set(Expression)$
\end_inset

 denotes 
\begin_inset Formula $X:=Expression$
\end_inset

.
\end_layout

\begin_layout Standard
Given the three ways to implement reactive instance variables using 
\begin_inset Formula $Subject$
\end_inset

, the implementation of the 
\begin_inset Formula $Set$
\end_inset

 operation varies: (1) 
\begin_inset Formula $RIVar$
\end_inset

 as a subclass of 
\begin_inset Formula $Subject$
\end_inset

 (
\family typewriter
rivarjs
\family default
): 
\begin_inset Formula $Set$
\end_inset

 is a method within the 
\begin_inset Formula $RIVar$
\end_inset

 class.
 (2) 
\begin_inset Formula $RIVar$
\end_inset

 as a decorator of 
\begin_inset Formula $Subject$
\end_inset

 (
\family typewriter
RIVarX
\family default
): 
\begin_inset Formula $Set$
\end_inset

 is implemented as an extension function of 
\begin_inset Formula $Subject$
\end_inset

.
 (3) Reactive instance variables as direct instances of 
\begin_inset Formula $Subject$
\end_inset

: 
\begin_inset Formula $Set$
\end_inset

 is likely a method of the 
\begin_inset Formula $Subject$
\end_inset

 class itself.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
When 
\begin_inset Formula $Set$
\end_inset

 is invoked, the argument contains a stream of signals (i.e., instances of
 
\begin_inset Formula $Signal$
\end_inset

 class) representing the stream of expression values over time.
 The 
\begin_inset Formula $Set$
\end_inset

 operation triggers propagation from the argument stream to the stream of
 the reactive instance variable.
 The stream of a reactive instance variable is the 
\begin_inset Formula $Subject$
\end_inset

, and changes are propagated to it by invoking its 
\begin_inset Formula $OnNext$
\end_inset

 method.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $OnNext$
\end_inset

 method is invoked when a signal is identified as being greater than all
 preceding signals in the Subject.
 To achieve this, a stream of changes is defined.
 This stream of changes is created using the 
\begin_inset Formula $WithLatestFrom$
\end_inset

 operator on both the 
\begin_inset Formula $Subject$
\end_inset

 stream and the expression stream.
 This operator produces a stream where, each time there is a new item in
 the expression stream, an item is created containing both this new item
 and the latest item from the Subject stream.
 For each such pair, a check is performed to determine if the signal from
 the expression is greater than the signal from the Subject.
 Whenever it is determined that the new signal is indeed greater, the 
\begin_inset Formula $OnNext$
\end_inset

 method is invoked with this signal.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $Set$
\end_inset

 operation takes a stream of signals as an argument, representing the expression
 values over time.
 This operation propagates values from the input stream to the stream of
 the reactive instance variable.
 A reactive instance variable's stream is represented by a subject (an instance
 of 
\begin_inset Formula $Subject$
\end_inset

).
 To propagate changes to the stream and update the variable's value, the
 
\begin_inset Formula $OnNext$
\end_inset

 method of the subject is invoked, but only when a new signal is received
 that is greater than all preceding signals.
\end_layout

\begin_layout Standard
For example, consider a reactive instance variable 
\begin_inset Formula $X$
\end_inset

 that is set to the expression 
\begin_inset Formula $Y+Z$
\end_inset

, where 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 are also reactive variables.
 The expression 
\begin_inset Formula $X.Set(Y+Z)$
\end_inset

 creates a stream of signals representing the values of 
\begin_inset Formula $Y+Z$
\end_inset

 over time.
 The 
\begin_inset Formula $Set$
\end_inset

 operation propagates these values to the stream of 
\begin_inset Formula $X$
\end_inset

 using 
\begin_inset Formula $OnNext$
\end_inset

, but only when the expression 
\begin_inset Formula $Y+Z$
\end_inset

 produces a greater signal.
\end_layout

\begin_layout Standard
To ensure that 
\begin_inset Formula $OnNext$
\end_inset

 is invoked only for greater signals, a stream of changes is defined using
 the 
\begin_inset Formula $WithLatestFrom$
\end_inset

 operator.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://reactivex.io/documentation/operators/combinelatest.html
\end_layout

\end_inset


\end_layout

\end_inset

 This operator takes the subject stream and the expression stream as input
 and produces a new stream where each item is a pair containing the latest
 item from the subject stream (the current value of the variable) and the
 new item from the expression stream (the newly received value).
 For each pair, the new signal is compared to the previous signal.
 If the new signal is "greater," then 
\begin_inset Formula $OnNext$
\end_inset

 is invoked with this signal.
\end_layout

\begin_layout Standard
To illustrate, suppose the subject stream contains the signals 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, and 
\begin_inset Formula $C$
\end_inset

 (For the emxaple, each signal is a single uppercase letter, and the comparison
 is alphabetical), and the expression stream emits the signals 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

, and 
\begin_inset Formula $A$
\end_inset

.
 The 
\begin_inset Formula $WithLatestFrom$
\end_inset

 operator will produce the stream of pairs 
\begin_inset Formula $\left(B,C\right)$
\end_inset

, 
\begin_inset Formula $\left(D,C\right)$
\end_inset

, and 
\begin_inset Formula $\left(A,D\right)$
\end_inset

.
 For each pair, the first signal is compared to the second.
 In this case, 
\begin_inset Formula $B$
\end_inset

 is not greater than 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 is greater than 
\begin_inset Formula $C$
\end_inset

, and 
\begin_inset Formula $A$
\end_inset

 is not greater than 
\begin_inset Formula $D$
\end_inset

.
 Therefore, only the signal 
\begin_inset Formula $D$
\end_inset

 will trigger the invocation of 
\begin_inset Formula $OnNext$
\end_inset

 and be propagated further in the variable's stream.
\end_layout

\begin_layout Standard
This process ensures that 
\begin_inset Formula $OnNext$
\end_inset

 is invoked only for greater signals according to the comparison function,
 maintaining the desired monotonicity of the stream.
\end_layout

\begin_layout Paragraph
Summary 
\end_layout

\begin_layout Standard
A reactive instance variable is implemented by using 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

.
 The value assignment operator is represented by the 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 operation.
 The reactive assignment operator is implemented as a new operation called
 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 that takes a parameter specifying the expression on the right-hand side
 of the assignment.
 The capability to construct expressions is implemented through a 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 operation.
 Each value or update is represented by a new type called 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

.
\end_layout

\begin_layout Subsection
Usage
\end_layout

\begin_layout Standard
Usage is straightforward.
  As class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:bag_code_rivarjs"
plural "false"
caps "true"
noprefix "false"

\end_inset

, any class can contain reactive instance variables and reactive assignments.
 Reactive instance variables are created by declaring instance variables
 of type 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 and initializing them.
 The reactive assignments are created by using 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

) and 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

) methods.
 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 functions over a simple function and the 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 instances.
 This expression is sent as an argument to 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 function associated with a 
\begin_inset Formula $\LSTINLINE{RIVar}$
\end_inset

 that represents the left-hand variable.
 
\end_layout

\begin_layout Standard
Classes with reactive instance variables and reactive assignments can be
 initiated and used by connecting to the reactive instance variables.
 For example, a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance can be created by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{const bag = new Bag()}$
\end_layout

\end_inset

.
 Later, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(new Signal(100))}$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.volume.next(new Signal(200))}$
\end_layout

\end_inset

 is like 
\begin_inset Formula $\LSTINLINE{bag.amount=100}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{bag.volume=200}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Explicit use of 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 can be confusing.
 An implicit conversion operator
\emph on

\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-
defined-conversion-operators
\end_layout

\end_inset


\end_layout

\end_inset


\emph default
 is implemented within 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 for ease of use.
 Therefore, explicit use of Signal is not required.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(100)}$
\end_layout

\end_inset

 can be written instead of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
LSTINLINE{bag.amount.next(new Signal(100))}$
\end_layout

\end_inset

.
 The value 100 is automatically converted to a new signal.
 This simplifies the syntax and makes the code cleaner.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

import { RIVar, lift } from 'rivarjs';
\end_layout

\begin_layout Plain Layout

const div = (x, y) => (x / y).toFixed(2);
\end_layout

\begin_layout Plain Layout

const mul = (x, y) => x * y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Bag {
\end_layout

\begin_layout Plain Layout

  constructor() {
\end_layout

\begin_layout Plain Layout

    this.amount = new RIVar();
\end_layout

\begin_layout Plain Layout

    this.volume = new RIVar();
\end_layout

\begin_layout Plain Layout

    this.concentration = new RIVar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    this.concentration.set(lift(div, this.amount, this.volume));
\end_layout

\begin_layout Plain Layout

    this.amount.set(lift(mul, this.concentration, this.volume));
\end_layout

\begin_layout Plain Layout

    this.volume.set(lift(div, this.amount, this.concentration));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bag_code_rivarjs"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
JavaScript
\family default
 and 
\family typewriter
rivarjs
\family default
.
\end_layout

\end_inset

Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
JavaScript
\family default
 and 
\family typewriter
rivarjs
\family default
.
 
\begin_inset Formula $\LSTINLINE{amount}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{concentration}$
\end_inset

 are reactive instance variables.
 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 is the reactive assignment operation.
 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 is an extension method for creating expressions.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public class Bag
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Amount { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Volume { get; set; } = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

        public RIVar<decimal> Concentration { get; set; } = new RIVar<decimal>()
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public Bag()
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Concentration.Set(Amount.Div(Volume));
\end_layout

\begin_layout Plain Layout

            Amount.Set(Concentration.Mul(Volume));
\end_layout

\begin_layout Plain Layout

            Volume.Set(Amount.Div(Concentration));
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   public static class Operators
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        static decimal DIVOverValues(decimal operand1, decimal operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            return operand1 / operand2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public static Expression<decimal> Div(this RIVar<decimal> operand1,
 RIVar<decimal> operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            return SignalExtension.Lift(DIVOverValues, operand1, operand2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public static Expression<decimal> Mul(this RIVar<decimal> operand1,
 RIVar<decimal> operand2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Func<decimal, decimal, decimal> mul = (x, y) => x * y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            return mul.Lift(operand1, operand2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bag_code_rivarx"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and 
\family typewriter
RIVarX
\family default
.
\end_layout

\end_inset

Code of class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 using 
\family typewriter
C#
\family default
 and RIVarX.
 
\begin_inset Formula $\LSTINLINE{Amount}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 are reactive instance variables.
 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 is the reactive assignment operation.
 
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 is an method for creating expressions.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Integration
\end_layout

\begin_layout Standard
Reactive instance variables are fed by events from UI controls, such as
 the OnChange event of a text box, and feed these controls by updating propertie
s like the text property.
\end_layout

\begin_layout Standard
It's crucial to prevent the creation of loops.
 While the thesis approach addresses loops in reactive assignments, loops
 can still occur when interacting with UI controls.
 For example, if a change in a reactive variable updates a control's property,
 triggering an event that in turn updates the variable, an infinite loop
 may arise.
\end_layout

\begin_layout Paragraph
Integration with React
\end_layout

\begin_layout Standard
Another challenge is whether and how integration with existing reactive
 libraries can be achieved.
 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 is a component built in 
\family typewriter
React
\family default
 and included in the 
\family typewriter
rivarjs
\family default
 library.
 It utilizes a 
\family typewriter
React
\family default
 design pattern called 
\family typewriter
Function as a Child Component
\family default
.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component in 
\family typewriter
JSX
\family default
 accepts a 
\family typewriter
prop
\family default
 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 to establish a connection with a 
\begin_inset Formula $\RIVar$
\end_inset

 instance.
 Additionally, a function that receives change and value as arguments and
 returns 
\family typewriter
JSX
\family default
 is nested within the component.
\end_layout

\begin_layout Standard
When defining the component, value is used to display the current value,
 and change is used to signal a change in the value.
 For example, in an 
\family typewriter
HTML
\family default
 input element, the 
\begin_inset Formula $\LSTINLINE{\text{onChange}}$
\end_inset

 event triggers the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 function, and the value attribute is set to the current value of the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Standard
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-3"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the 
\family typewriter
Drug Administration
\family default
 application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Paragraph
Empirical Validation
\end_layout

\begin_layout Standard
We implemented 
\family typewriter
RIVar
\family default
 as an extension 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 programming language, on top of 
\family typewriter
ReactiveX
\family default
.
 Based on this, we created the 
\family typewriter
Drug Administration 
\family default
a desktop application (
\family typewriter
Windows Forms)
\family default
.
 We added the option to log the changes, and check the performed change
 propagation against various cenarios.
 One of them is presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In the example, there are three steps: setting Drug to 10, then Volume to
 100, and finally Rate to 5.
 Each step includes a timestamp for the events and a propagation to update
 other fields with the attached timestamp.
 In the first step, line 1 presents the setting, and then in line 2, Drug
 has an event with the value 10 and timestamp 1.
 The second step, line 3, presents the input, but only line 6 presents the
 event that Volume has the value 100 with timestamp 2.
 In between, there is line 5, which presents the event for concentration
 with value 0.1 and timestamps 1 and 2, as it is computed from the values
 of Drug and Volume, whose timestamps are now 1 and 2.
 This causes a redundant change event (that is ignored) presented in line
 4, where Volume's timestamp is also 1 and 2, because there is a dependency
 - Volume on Drug and Concentration.
 The order of the log is not entirely logical.
 The logging action is an event handler triggered according to the order
 of registrations.
 Therefore, the event in line 4 is caused by (and therefore occurs after)
 line 5.
 
\end_layout

\begin_layout Standard
The order of the log might not seem entirely reasonable at first glance.
 The event in line 4 is logged before the event in line 5, even though it
 is caused by (and therefore occurs after) line 5.
 This discrepancy occurs because the log action is an event handler triggered
 according to the order of registrations.
 The order of the log follows a post-order traversal on top of a traversal
 similar to Depth-First Search (DFS).
 In the second step, the traversal sequence is Volume (first visit) -> Concentra
tion -> Volume (second visit), while the log sequence is Volume (second
 visit) -> Concentration -> Volume (first visit).
\end_layout

\begin_layout Standard
The final step confirms the previous principles.
 In the next step, Rate has a timestamp of 3 with a value of 5.
 However, the log presents the post-order traversal caused by this.
 The change propagation is as follows: Rate (value 5, timestamp 3), Duration
 (value 20, timestamps 2 and 3 computed from Volume/Rate, 100 / 5), Dose
 (0.5 timestamp 1, 2, and 3 computed based on Duration (from it, there are
 timestamps 2 and 3) and Drug (from it, timestamp 1)), Duration (second
 visit, caused by Dose, ignored).
 The order of the log in post-order: Duration (value 20, timestamps 1, 2,
 and 3, second visit), Dose (value 0.5, timestamps 1, 2, and 3), Duration
 (value 20, timestamps 2 and 3, first visit), Rate (value 5, timestamp 3).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
1.
 Drug_Control:10
\end_layout

\begin_layout Plain Layout
2.
 Drug_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
3.
 Volume_Control:100
\end_layout

\begin_layout Plain Layout
4.
 Volume_Control: 100 <1,2>
\end_layout

\begin_layout Plain Layout
5.
 Concentration_Control: 0.1 <1,2>
\end_layout

\begin_layout Plain Layout
6.
 Volume_Control: 100 <2>
\end_layout

\begin_layout Plain Layout
7.
 Rate_Control:5
\end_layout

\begin_layout Plain Layout
8.
 Duration_Control: 20 <1,2,3>
\end_layout

\begin_layout Plain Layout
9.
 Dose_Control: 0.5 <1,2,3>
\end_layout

\begin_layout Plain Layout
10.
 Duration_Control: 20 <2,3>
\end_layout

\begin_layout Plain Layout
11.
 Rate_Control: 5 <3>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Log result for an execution of the Drug Administration application.
\end_layout

\end_inset

Log result for an execution of the Drug Administration application.
 The lines that does not end with angle brackets, inform change events directly
 set by the user.
 The angle bracket contains the timestamps, that are the order of the events
 that the value depends on.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename DFS_Validation.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DFS_Validation-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Visualizing Change Propagation for a Scenario in Drug Administration Application.
\end_layout

\end_inset

Visualizing Change Propagation for a Scenario in Drug Administration Application.
 The graph illustrates the propagation of changes after setting the "Rate"
 variable to 5, where "Drug" and "Volume" have already been set to 10 and
 100, respectively.
 The circles represent variables, squares represent expressions assigned
 to them.
 Edges represent the propagation of values, with each edge labeled by the
 value and its corresponding timestamps.
 The primary propagation path is highlighted in bold, while redundant propagatio
n is indicated by dotted lines.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Analytic Proof
\end_layout

\begin_layout Standard
A 
\emph on
stream
\emph default
 and a 
\emph on
merge
\emph default
 operator are used to implement the approach.
 A stream is an entity that has items along a timeline.
 A reactive instance variable is represented by a stream where each item
 is an update or a new value of the variable at the point in time corresponding
 to the item.
 Therefore, in the Depth First Search (DFS) algorithm used to propagate
 the changes, each visit to a node is an item in the stream.
 The implementation of the approach handles the fact that in some of the
 visits the value is found to be outdated, and then the item should not
 be in the stream.
\end_layout

\begin_layout Standard
The merge operator is intended to implement the semantics of sampling values
 of a variable which may have more than one source.
 As mentioned, each variable can appear on the left-hand side of multiple
 reactive assignments and value assignments, and it should receive value
 assignment messages from the multiple left-hand expressions as well as
 from the input feeds.
 Formally,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for a variable 
\backslash
(X
\backslash
) and a set of variables 
\backslash
(V = 
\backslash
{ V_1, V_2,...
 V_n
\backslash
}
\backslash
), and reactive assignments such that for each 
\backslash
(V_i
\backslash
) in 
\backslash
(V
\backslash
) there is a reactive assignment 
\backslash
(X := V_i
\backslash
) then, 
\backslash
(X
\backslash
) is assigned with 
\backslash
(merge(X, V_1, V_2,...
 V_n)
\backslash
).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The meaning is created incrementaly by introducing the assignment as an
 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
.
 For a formula 
\begin_inset Formula $\LSTINLINE{Var:=Expession}$
\end_inset

, it behaves like 
\begin_inset Formula $\LSTINLINE{Var=merge(Var,Expression)}$
\end_inset

.
 Namely, the (left hand) variable is added with the values from an observable
 stream produced by the right hand expression.
 For instance
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 With including also a subsequent statement 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
 Here, we will explain the conditions necessary to ensure that 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)}$
\end_inset

 is equivalent to 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2-1-1"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the equation 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 to be true, the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have two mathematics properties: commutativity and associativit
y.
 Commutativity means no order over the executions of the assignments statements
 (
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 behaves the same as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

).
 Associativity means no strictness regarding order of the evaluations, because
 rearranging the parentheses in an expression will not change the result.
 For example, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,merge(B,D))}$
\end_inset

.
 Regarding to mathematics, with both associativity and commutativity, we
 can be confident that the final result will always be the same, regardless
 of both the order of executions and the assignments statements.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
the
\emph on
 stream
\emph default
 abstraction 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 due to 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx was initially developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is now available for many programming languages, such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx is used as the core concept in a library named 
\begin_inset Formula $\NAME{Cycle.js}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://cycle.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

 for implementing front-end applications.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an alternative to the fields or variables manipulation, there is the
 strategy to model programs by 
\emph on
streams
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 This approach has recently become popular 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

 by 
\emph on
Reactive Extensions
\emph default
 (
\begin_inset Formula $\ReactiveX$
\end_inset

 or Rx).
 Rx initialy developed for 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

 and is available now for many programming languages,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\begin_inset Formula $\NAME{RxJS}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rxjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mikkonen2007using"
literal "false"

\end_inset

.
 Rx offers 
\emph on
observable streams
\emph default
, which are objects that abstract collections for interested observers,
 passing their items to them by calling their 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://learn.microsoft.com/en-us/dotnet/csharp/
\end_layout

\end_inset


\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Rx offers observable streams, which are objects that abstract collections
 for interested observers, passing their items to them by calling their
 next method (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 Reactive variables can be presented as observable streams 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 consists of the values or changes over time, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The values can be generated from events of UI elements.
 Then functions like 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 create observables whose items are generated based on the values of input
 observables.
 For example, if we have 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

, each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Finally, by subscribing to the resulting observables, UI elements can be
 updated.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (1,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (2,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streams-of-values-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variable value changes as an observable stream
\end_layout

\end_inset

Variable value changes as an observable stream.
 Variable 
\begin_inset Formula $A$
\end_inset

 changed to 
\begin_inset Formula $5$
\end_inset

 initially, then to 
\begin_inset Formula $3$
\end_inset

, and after a longer period, it changed to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
—
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The change propagation is based on depth-first search (DFS) traversal,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 which recursively raises updates deeply in a deterministic execution order.
 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 The algorithm recursively raises updates deeply in a deterministic execution
 order.
 When it reaches an update that does not raised another update (a leaf)
 it backtracks.
 However, regarding re-visiting nodes, the backtracking process is less
 obvious.
 This is because reaching a node sometimes required a re-update and sometimes
 not.
 Nevertheless, the decision should be determined 
\emph on
localy
\emph default
, by the node being reached.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm recursively raise updates deeply in a deterministic execution
 order untill reaching , however the backtracking in our settings is less
 obvious.
\end_layout

\begin_layout Plain Layout
DFS algorithms explore paths as deeply as possible before backtracking and
 exploring other branches.
\end_layout

\end_inset

 In our setting, the backtracking process is less obvious.
 This is because reaching a node sometimes required a re-update and sometimes
 not.
 Nevertheless, the decision should be determined 
\emph on
localy
\emph default
, by the node being reached.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
However, it is not abvious to distingwish between the cases in runtime.
 The actions of raising an update is decoupled from the update itself.
 Therefore, in reaching a node, the algorithm should detemine if to backtrack
 without detemining details about the node from which
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sometimes it requires a re-update and sometimes not.
 In case of a feedback, it should backtrack.
 In case of a glitch, it should not backtrack
\end_layout

\begin_layout Plain Layout
The algorithm is based on a sequential depth-first search (DFS) traversal.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 The nodes represent the variables, and a directed edge refer to a process
 that an update of one variable raised an update to a second variable.
 In our setting, the backtracking process is less obvious, because reaching
 a node sometimes required a re-update and sometimes not.
 It should backtrack in case of a feedback, but it should not
\end_layout

\begin_layout Plain Layout
In case that this is a feedback, it should backtrack.
 However, it might be that a node is updated several times following a problem
 named glitch.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Additionaly, our settings required decoupling by which it is unabled to
 distingwish between diffrent cases.
 Reaching a node is completely separated from leaving the previous node,
 because raising an update is decoupled from the update itself.
\end_layout

\begin_layout Plain Layout
(In case that this is a feedback, it should backtrack.
 However, it might be that a node is updated several times following a problem
 named glitch.
 In our setting, there is no way to distingwish between the cases, because
 raising an update is decoupled from the update itself.
 i.e., reaching a node is decoupled from leaving the previous node.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In our setting, in raising an update, no one know what cuased this re-update.
\end_layout

\begin_layout Plain Layout
However, in our settings, we the knowledge if a current visit is
\end_layout

\begin_layout Plain Layout
Unlike the basic algorithm that backtracking , the algorithm continue
\end_layout

\begin_layout Plain Layout
Feedback loops are represented as one of the forms that nodes are reached
 visiting again a node
\end_layout

\begin_layout Plain Layout
The algorithm is based on a depth-first search (DFS) traversal, rooted in
 the variable being updated.
 The process starts by that variable that update expressions that contain
 it.
 Then recursively each expression that is a nested expression, updates the
 expression that contains it.
 An expression that is of the top level, updates the variable to which it
 was assigned, which recursively starts such a process again rooted in the
 latter variable.
\end_layout

\begin_layout Plain Layout
The current assignment operator is its directed approach between the left-hand
 variable and the right-hand expression.
 The left-hand variable subscribes to the right-hand expression.
 The right-hand expression will directly call to the left-hand variable.
 The directed calls in subscribe has a meaning to not depends on a madiator.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.
\end_layout

\begin_layout Plain Layout
By using observer and observables, the naive change propagation forms depth-firs
t search (DFS) traversal, rooted in the variable being updated.
 The process starts by that variable that update expressions that contain
 it.
 Then recursively each expression that is a nested expression, updates the
 expression that contains it.
 An expression that is of the top level, updates the variable to which it
 was assigned, which recursively starts such a process again.
\end_layout

\begin_layout Plain Layout
Illustrating as a graph, the traversal is depth-first search (DFS).
 Raising an update is equivilent to a visit in DFS.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We apply an order over the values.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value
 and continue; otherwise, the value is absolete, the value is discarded
 and it backtracks.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We apply an order over the values, by which feedback and absolete values
 will be discarded (therefore backtracking).
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Operation
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(We take the concept of reactive variables as observable streams.
 An observable stream is like a list, that it contains ordered items.
 It does not mean that the list is stored, it is only an abstraction like
 a list.
 The list consists of the history of values that a variable have been contained.
 In order to get those values, consumers should perior to subscribe to the
 observable stream.
\end_layout

\begin_layout Plain Layout
This concept comes with operators for tranforming those observable streams.
 One operator map maps each item according to a function given as an argument.
 Another operator CombineLatest works for two observable streams, mapping
 based on items from the two.
 These operators has s meaning like lifting, because they convert a function
 to be an 
\emph on
higher order function
\emph default
.
 Higher order functions executed upon reactive variables forms expressions
 that are observable streams.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the concept mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, that an input control change events are composed into an observable stream,
 can a variable be represented as an observable stream.
 Therefrom, each node in the propagation  refers to an observable stream.
 Each item of an observable stream, refers to a 
\emph on
visit
\emph default
 of the propagation  algorithm in that node.
 Accordingly, a variable with multiple assignments represent an observable
 stream resulted from a 
\family typewriter
merge
\family default
 function, that is the whole updates collected from either directed updates
 from being an input variable or from any of the assigned expressions.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will refer to an observable stream produced by 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
The 
\family typewriter
merge
\family default
 is created incrementaly by introducing the assignment as an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
.
 For a formula 
\begin_inset Formula $\LSTINLINE{Var:=Expession}$
\end_inset

, it behaves like 
\begin_inset Formula $\LSTINLINE{Var=merge(Var,Expression)}$
\end_inset

.
 Namely, the (left hand) variable is added with the values from an observable
 stream produced by the right hand expression.
 For instance
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 With including also a subsequent statement 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
 Here, we will explain the conditions necessary to ensure that 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)}$
\end_inset

 is equivalent to 
\begin_inset Formula $\LSTINLINE{merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2-2-1"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
For the equation 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 to be true, the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have two mathematics properties: commutativity and associativit
y.
 Commutativity means no order over the executions of the assignments statements
 (
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 behaves the same as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

).
 Associativity means no strictness regarding order of the evaluations, because
 rearranging the parentheses in an expression will not change the result.
 For example, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,merge(B,D))}$
\end_inset

.
 Regarding to mathematics, with both associativity and commutativity, we
 can be confident that the final result will always be the same, regardless
 of both the order of executions and the assignments statements.
\end_layout

\begin_layout Section
Empirical Validation
\end_layout

\begin_layout Subsection
Implementation in C#
\end_layout

\begin_layout Plain Layout
We implemented 
\family typewriter
RIVar
\family default
 as an extension 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 programming language, on top of 
\family typewriter
ReactiveX
\family default
.
 Based on this, we created the 
\family typewriter
Drug Administration 
\family default
a desktop application (
\family typewriter
Windows Forms)
\family default
.
 We added the option to log the changes, and check the performed change
 propagation against various cenarios.
 One of them is presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In the example, there are three steps: setting Drug to 10, then Volume to
 100, and finally Rate to 5.
 Each step includes a timestamp for the events and a propagation to update
 other fields with the attached timestamp.
 In the first step, line 1 presents the setting, and then in line 2, Drug
 has an event with the value 10 and timestamp 1.
 The second step, line 3, presents the input, but only line 6 presents the
 event that Volume has the value 100 with timestamp 2.
 In between, there is line 5, which presents the event for concentration
 with value 0.1 and timestamps 1 and 2, as it is computed from the values
 of Drug and Volume, whose timestamps are now 1 and 2.
 This causes a redundant change event (that is ignored) presented in line
 4, where Volume's timestamp is also 1 and 2, because there is a dependency
 - Volume on Drug and Concentration.
 The order of the log is not entirely logical.
 The logging action is an event handler triggered according to the order
 of registrations.
 Therefore, the event in line 4 is caused by (and therefore occurs after)
 line 5.
 
\end_layout

\begin_layout Plain Layout
The order of the log might not seem entirely reasonable at first glance.
 The event in line 4 is logged before the event in line 5, even though it
 is caused by (and therefore occurs after) line 5.
 This discrepancy occurs because the log action is an event handler triggered
 according to the order of registrations.
 The order of the log follows a post-order traversal on top of a traversal
 similar to Depth-First Search (DFS).
 In the second step, the traversal sequence is Volume (first visit) -> Concentra
tion -> Volume (second visit), while the log sequence is Volume (second
 visit) -> Concentration -> Volume (first visit).
\end_layout

\begin_layout Plain Layout
The final step confirms the previous principles.
 In the next step, Rate has a timestamp of 3 with a value of 5.
 However, the log presents the post-order traversal caused by this.
 The change propagation is as follows: Rate (value 5, timestamp 3), Duration
 (value 20, timestamps 2 and 3 computed from Volume/Rate, 100 / 5), Dose
 (0.5 timestamp 1, 2, and 3 computed based on Duration (from it, there are
 timestamps 2 and 3) and Drug (from it, timestamp 1)), Duration (second
 visit, caused by Dose, ignored).
 The order of the log in post-order: Duration (value 20, timestamps 1, 2,
 and 3, second visit), Dose (value 0.5, timestamps 1, 2, and 3), Duration
 (value 20, timestamps 2 and 3, first visit), Rate (value 5, timestamp 3).
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
1.
 Drug_Control:10
\end_layout

\begin_layout Plain Layout
2.
 Drug_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
3.
 Volume_Control:100
\end_layout

\begin_layout Plain Layout
4.
 Volume_Control: 100 <1,2>
\end_layout

\begin_layout Plain Layout
5.
 Concentration_Control: 0.1 <1,2>
\end_layout

\begin_layout Plain Layout
6.
 Volume_Control: 100 <2>
\end_layout

\begin_layout Plain Layout
7.
 Rate_Control:5
\end_layout

\begin_layout Plain Layout
8.
 Duration_Control: 20 <1,2,3>
\end_layout

\begin_layout Plain Layout
9.
 Dose_Control: 0.5 <1,2,3>
\end_layout

\begin_layout Plain Layout
10.
 Duration_Control: 20 <2,3>
\end_layout

\begin_layout Plain Layout
11.
 Rate_Control: 5 <3>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1-1-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Log result for an execution of the Drug Administration application.
\end_layout

\end_inset

Log result for an execution of the Drug Administration application.
 The lines that does not end with angle brackets, inform change events directly
 set by the user.
 The angle bracket contains the timestamps, that are the order of the events
 that the value depends on.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename DFS_Validation.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DFS_Validation"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Visualizing Change Propagation for a Scenario in Drug Administration Application.
\end_layout

\end_inset

Visualizing Change Propagation for a Scenario in Drug Administration Application.
 The graph illustrates the propagation of changes after setting the "Rate"
 variable to 5, where "Drug" and "Volume" have already been set to 10 and
 100, respectively.
 The circles represent variables, squares represent expressions assigned
 to them.
 Edges represent the propagation of values, with each edge labeled by the
 value and its corresponding timestamps.
 The primary propagation path is highlighted in bold, while redundant propagatio
n is indicated by dotted lines.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation in JavaScript
\end_layout

\begin_layout Plain Layout
The motivation for implementing this approach in 
\family typewriter
JavaScript
\family default
 is to make it accessible to the JavaScript community, which plays a crucial
 role in front-end development.
\end_layout

\begin_layout Plain Layout
We implemented 
\family typewriter
RIVar
\family default
 as an extension, 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

 programming language.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 Based on this, we created the 
\family typewriter
Drug Administration
\family default
 as a static web page.
\end_layout

\begin_layout Plain Layout
We created the 
\family typewriter
Drug Administration
\family default
 also with 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 (mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to compare with the implementation with 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 The compare page is available online in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/tree/main/samples/drug-administration/compare/h
otdrink
\end_layout

\end_inset

.
 The two algorithms provide identical results in the propagation change.
 Both of the algorithms makes new input to override effects (input and computed
 values) of oldest input at the time of the input.
\end_layout

\begin_layout Subsubsection
Integration with React
\end_layout

\begin_layout Plain Layout
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Plain Layout
A variable with multiple assignments is executed as subscribing to multiple
 observable streams and handle each emitted item by calling onNext on the
 observable stream that represents the assigned variable.
\end_layout

\begin_layout Plain Layout
Based on this concept, multiple assignments informs a 
\family typewriter
merge
\family default
 operation for multiple streams of values.
 We subscribe to multiple Observables and handle each emitted item by calling
 onNext on a designated Observable.
 Through this technique, we effectively perform an operation similar to
 the merge operator.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Inheritance
\end_layout

\begin_layout Description
Subtyping RIVar is part of the object interface.
\end_layout

\begin_layout Description
Subclassing because the semantics of the new assignment operation does not
 update, reassign or override.
 It 
\emph on
adds
\emph default
 a dependancy, such that the variable depends on the right-hand expression
 in addition to existing dependencies.
\end_layout

\begin_layout Description
Substitutability the superposition property.
\end_layout

\begin_layout Section
Cycles
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
Any method to keep from cycles or from lost accuracy through the chain of
 computations makes higher coupling than the method of this thesis.
 In a simpler example, if 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=C}$
\end_inset

 are presents, C is a transitive dependency of A, therefore a formula like
 
\begin_inset Formula $\LSTINLINE{C:=A}$
\end_inset

 makes a cycle.
 In order to avoid cycles creation, before adding any piece of functionality
 like C:=A, it is essential to ensure that the left hand variable is not
 a transitive dependency (that can be located in another class) of any of
 the variables that the right hand expressions composed of.
 A similar check should be applied to ensure zero accuracy lost.
\end_layout

\begin_layout Plain Layout
Methods similar to this thesis' do allow cycles and stop the propagation
 change in runtime.
 (The first two options are available in 
\family typewriter
Microsoft Excel
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
When a value has not changed from the update, or changed only less than
 a threshold.
 This has been presented in the example.
\end_layout

\begin_layout Itemize
Letting to update several times, stopping after an arbitrary number of times.
 The number depends on the specific graph, which depends again on dependancies
 that can be specified in other classes.
\end_layout

\begin_layout Itemize
Checking the original triggering source.
 This again makes again coupling on parts that are not directly located
 in a current class.
\end_layout

\begin_layout Itemize
Centralized mechanism
\end_layout

\begin_layout Plain Layout
———
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
we find that this node represent a variable that has been declared with
 a dependancy more that once.
 Specificaly, this informs one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
From investigating data flow from two distinct nodes, we determine a variable
 with 
\emph on
multiple assignment
\emph default
.
\end_layout

\begin_layout Plain Layout
We distingwish between two assignment types.
\end_layout

\begin_layout Plain Layout
Since a cycle's starting point has two incoming edges, it must be that one
 variable two dependancies have been declared or that
\end_layout

\begin_layout Plain Layout
, or that an input variable
\end_layout

\begin_layout Plain Layout
A cycle starts from the first incoming edge into the cycle starting point,
 then through several nodes untill reaching again the first node from another
 edge.
\end_layout

\begin_layout Plain Layout
Since a cycle's starting point has two incoming edges, it must be that two
 dependancies have been declared (
\end_layout

\begin_layout Plain Layout
it depends on
\end_layout

\begin_layout Plain Layout
using a process similar to reverse-engineering.
 Usually, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
In this chapter we figure out that cycles are belonged to a broader concept.
 In ilustrating a cycle, such as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:dataflow_to_cycle-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start from an incoming edge into a node, that is a cycle's first node,
 then through several nodes untill reaching again the first node from another
 edge.
 The node that we started from, has two incoming edges.
\end_layout

\begin_layout Plain Layout
From this investigation, we determine that an existence of cycles means
 that variables depend on several expressions simultaneously.
 We present this using a process similar to reverse-engineering.
 Usualy, we first declare a data dependancy, and then we determine a dataflow.
 For example, declaring a dependancy A:=B means that A depends on B (A->B),
 therefore the data flows from B to A.
 Here we take a reveresed process, a process similar to reverse-engineering:
 we find the variables' dependencies from which this dataflow was constructed.
 For example, an edge from B towards A indicates that A depends on B by
 a formula like A:=B.
 Consequently, a cycle's starting point, which is a node with two incoming
 edges, inform one of two cases.
 First, a variable that is an input variable that also depends on an expression.
 For instance, both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present and 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is an input variable.
 Second, a variable that depends on two expressions simultaneously.
 An example for this case, is an addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 to the previous example, while 
\begin_inset Formula $\LSTINLINE C$
\end_inset

 is the input variable.
\end_layout

\begin_layout Plain Layout
The employed strategy involves propagating each input through its data dependenc
ies until reaching points where the value from the propagation is no longer
 more up-to-date than the values of the reached variables at that time.
 For instance, when 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 receives an input, it propagates it to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 However, it does not subsequently propagate it back to 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The use of 
\begin_inset Formula $\LSTINLINE=$
\end_inset

 is traditionally enabled to assign multiple times.
 The novelty is about 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

 that the variable is associated to the expression without being able to
 remove this association.
 For instance, in a scenario where both 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{B:=A}$
\end_inset

 are present, it is valid to present also 
\begin_inset Formula $\LSTINLINE{A:=1}$
\end_inset

.
 This will propagate the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 Similarly, the addition of 
\begin_inset Formula $\LSTINLINE{A:=C}$
\end_inset

 is valid.
 In this case, including 
\begin_inset Formula $\LSTINLINE{C:=1}$
\end_inset

 will result in the propagation of the value 
\begin_inset Formula $\LSTINLINE1$
\end_inset

 through 
\begin_inset Formula $\LSTINLINE C$
\end_inset

, 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, and finally to 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
The algorithm starts from the variable being updated, this causes expression
 to evaluate in a sequential order.
\end_layout

\begin_layout Plain Layout
Revaluation of an expression, can trigger more revaluations if this expression
 is nested
\end_layout

\begin_layout Plain Layout
The directed approach in raising updates, causes that the change propagation
 algorithm is depth-first search (DFS) traversal, rooted in the variable
 being updated.
\end_layout

\begin_layout Plain Layout
Updating a variable triggers
\end_layout

\begin_layout Plain Layout
An update process is a recursive process with a deterministic execution
 order
\end_layout

\begin_layout Plain Layout
The execution flow raised from an update, can be modeled as depth-first
 search (DFS) traversal over a graph.
 The nodes are the variable and functions.
 An update process is a recursive process, as it recursively trigger more
 updates.
 It starts from a single update in one variable.
 This raises evaluations to expression that consists that variable in a
 sequential order.
 Started from one expression, an expression is like a tree, as of an expression
 tree.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Started from the leaf in that local tree, it propagate up to the root of
 the expression, raising an update to a variable.
\end_layout

\begin_layout Plain Layout
.
 But the trversal is sequential
\end_layout

\begin_layout Plain Layout
Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes
\end_layout

\begin_layout Plain Layout
The graph consists of trees from the expression trees, but
\end_layout

\begin_layout Plain Layout
An expression tree can be represented as a graph, in which each vertex in
 the graph represents an operand or an operator.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.geeksforgeeks.org/expression-tree/
\end_layout

\end_inset


\end_layout

\end_inset

 Similarly, each vertex represents a variable or a function call.
 The DFS starts from a single update in one variable.
 Then, each raised evaluation represents a visit in a node of a function
 call.
 In case of nesting in expressions, the flowes continue with further evaluations
 representing visits in further nodes, untill recahing the end of the evaluation
 of the expression.
 At this stage, it raises an update, representing a visit in the node that
 represent the variable bsing updated.
\end_layout

\begin_layout Plain Layout
, which may recursively raise evaluations in case of nesting in the expressions.
 Expressions in the top level raises an update
\end_layout

\begin_layout Plain Layout
From an evaluation, other evaluations can be raised, in cased of nesting
 in expressions.
\end_layout

\begin_layout Plain Layout
edges represent variables and functions on expressions are represented
\end_layout

\begin_layout Plain Layout
an element within the expression.
 Elements are operators and variables
\end_layout

\begin_layout Plain Layout
The graph contains multiple sub-graphs, each
\end_layout

\begin_layout Plain Layout
As an expression tree, where each node represents an element within the
 expression, are all the
\end_layout

\begin_layout Plain Layout
and lifted function are represented as nodes, and during
\end_layout

\begin_layout Plain Layout
It starts from a single update in one variable, this raises evaluation to
 expressions that consists that variable in a sequential order.
 Starting from one, this evaluation raises an update for another variable
 and recursivly continue in this process
\end_layout

\begin_layout Plain Layout
According to the new assignment operator, the execution flow is determined
 by a series of updates, as as update is one with a push notification that
 triggers
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Several assignments to a single variable, will create several subscriptions,
 and this accomplish a similar effect to a 
\family typewriter
merge
\family default
 over sterams.
 For example, (A.subscribe(x => B.onNext(x)) and C.subscribe(x => B.onNext(x)))
 accomplish a similar effect to B=merge(A,C).
\end_layout

\begin_layout Plain Layout
—————-
\end_layout

\begin_layout Plain Layout
Reactive Instance variable (RIVar) refers to reactive variables on top of
 the observer pattern, or similar to simple events programming.
 An assignment has a meaning of registration to changes.
 For example, A statement like X:=Y is a short expression for Y.OnChange+=e=>X.Cha
nge(e=>e.Value).
 This produces as being accessed through an interface.
 Therefore, we name it also Reactive Interface Variable.
\end_layout

\begin_layout Section
propagation Algorithm
\end_layout

\begin_layout Subsection
Depth-First Search (DFS)
\end_layout

\begin_layout Plain Layout
In event-driven systems, the execution flow is often determined by a series
 of indirect function calls triggered by events and handled by corresponding
 event handlers.
 This dynamic (in case that events are processed sequentially) can be modeled
 as a depth-first search (DFS) traversal over a graph representing the program's
 control flow.
\end_layout

\begin_layout Plain Layout
In this graph representation, nodes denote either event handlers or the
 initial trigger (e.g., a user input event).
 A directed edge from a node u to a node v signifies that the execution
 of u can lead to the invocation of v.
 Notably, we abstract away the explicit representation of events, focusing
 solely on the handlers they activate.
 This simplification allows us to directly visualize the chain of execution
 initiated by the triggering event.
\end_layout

\begin_layout Plain Layout
When an event occurs, it serves as the root of the DFS traversal.
 The corresponding event handler is then invoked, marking the first step
 in the exploration.
 If this handler, in turn, triggers further events, the traversal proceeds
 along the outgoing edges, activating the associated handlers in a depth-first
 manner.
 This process continues until a leaf node is reached, representing a handler
 that does not trigger any further events.
\end_layout

\begin_layout Subsection
Ordering and Filtering Mechanism
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for events propagation
, such that each event handler modifies a variable and subsequently triggers
 another event.
 Each handler evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the DFS algorithm produced by events propagation, the enhanced
 algorithm applies an order over the values and uses its for a filtering
 mechanism.
 In each visit, it evaluates the recency of the updated value against previously
 forwarded values.
 If the updated value is deemed more recent, it replaces the stored value;
 otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
In order to evaluate the recency of updated values against previously forwarded
 values, we establish an order relation between the whole values.
 We assume external events as a stream, without simultaneous events.
 The values provided from the external events are ordered according to them.
 Further values are ordered according to events by which they have been
 produced.
\end_layout

\begin_layout Plain Layout
Each value produced directly by an external event, its position in the order
 is according to the location of the event.
 Each further value, the position of the value is according to a set of
 positions (timestamps), one from each event that the value derived its
 value from.
 For example, X and Y that contain value 8 and 2 from timestamps 1 and 2
 respectively.
 For simplicity the timetsamps are presented as sets, such that in the example
 X and Y contains {1} and {2} respectively.
 upon formula Z = X*Y, Z will contain a value 16 and the corresponding timestamp
s are {1,2}.
 The sets of timestamps for the further values are resulted from a 
\begin_inset Formula $\LSTINLINE{union}$
\end_inset

 operation upon the sets of timestamps of the values, it is derived from.
\end_layout

\begin_layout Plain Layout
Timestamps sets are used to determine the order.
 Each new event produces a value that is more recent that all the previous,
 therefore basicly a set that contains the recent timestamp is of the recent
 value.
 For example, {3} is more recent than {1,2}.
 However, this does not true, in case that a set is a superset of the other
 set.
 For example {1,2} and {1}.
 The reason is that {1,2} refers to value that is a feedback.
 Therefore, always a subset determines a recent value.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Leveraging the concept of indirect function calls as a depth-first search
 (DFS), we propose a propagation algorithm where each event handler modifies
 a variable and subsequently triggers another event.
 To ensure the correct operation of this algorithm, several key characteristics
 must be addressed.
 Before delving into the specifics of our novel algorithm, we outline these
 essential characteristics:
\end_layout

\begin_layout Description
DFS-Based: The algorithm operates within the framework of a DFS traversal
 over the graph of event handlers.
\end_layout

\begin_layout Description
Decentralized: The algorithm is inherently decentralized, with no centralized
 authority governing the order of updates.
\end_layout

\begin_layout Description
Online: The algorithm functions in an online manner, processing each input
 as it arrives and making decisions dynamically, in contrast to offline
 algorithms that operate on a complete dataset.
\end_layout

\begin_layout Paragraph*
The Algorithm
\end_layout

\begin_layout Plain Layout
On the DFS we add a If the updated value is deemed more relevant, it replaces
 the stored value; otherwise, it is discarded.
\end_layout

\begin_layout Plain Layout
We propose an enhanced depth-first search (DFS) algorithm for event propagation
 in reactive systems.
 This algorithm incorporates a value comparison mechanism within each event
 handler to ensure that only the most up-to-date or relevant values are
 propagated through the system.
 Specifically, each handler evaluates the recency or relevance of the updated
 value against any previously forwarded values, using criteria such as timestamp
, priority, or domain-specific heuristics.
 If the updated value is deemed more relevant, it replaces the stored value;
 otherwise, it is discarded.
 This mechanism ensures data integrity and prevents outdated information
 from propagating through the system.
\end_layout

\begin_layout Plain Layout
We add a 
\emph on
compare
\emph default
 action that checks whether a valuen is more up-to-date than the previous
 forwarded value.
\end_layout

\begin_layout Plain Layout
We implement the change propagation on top of the default change propagation
 of Rx.
 This propagation consists of synchronously respond to notifications by
 passing them forward.
 This propagation consists of a traversal in the form of depth-first search
 (DFS) algorithm.
 In responding to a notification, we add a 
\emph on
compare
\emph default
 action, that checks whether a value from the notification is more up-to-date
 than the previous forwarded value.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D))}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have several properties to ensure predictable behavior.
 One important property is associativity, which means 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=(merge(A,B,D))}$
\end_inset

 Other desirable properties include commutativity (order doesn't matter),
 idempotence (applying multiple times has the same effect as once), and
 monotonicity (preserving a specific order).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Itemize
The right-hand expression raises changes to the left-hand variable.
 To clarify, this means there's no mediator used, no centralized data structure,
 no synchronization required, and it's not parallel execution.
 It's a straightforward function call.
 The interaction should
\end_layout

\begin_layout Itemize
This is our essential requirement from OOP prespective.
 The design of OOP is for modeling like the real-world, such that each object
 manages its own logic, rather than a centralized object that manages the
 whole state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm recursively raises updates deeply in a deterministic execution
 order.
\end_layout

\begin_layout Plain Layout
When it reaches an update that does not raised another update (a leaf) it
 backtracks.
 In case of revisiting a node, it should backtrack in case that it is a
 
\emph on
feedback
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Paragraph
From Multiple Assignments to Merging Streams
\end_layout

\begin_layout Plain Layout
Multiple assignments would be applied by using streams.
 Similar to sampling a real world variable by several sensors, can a variable
 being streamed from several expressions.
 This informs a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation over streams.
 Basicly (without cycles), whenever new item is created from any of the
 streams, it is added to the merged stream.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Illustrated using a marble diagram: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://reactivex.io/documentation/operators/merge.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The variable itself is also an input variable.
 Therefore, the items would be created in addition to the existing items.
 For instance, as depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 merges the items of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 into 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
\end_layout

\begin_layout Paragraph
From propagation Change to Streams
\end_layout

\begin_layout Plain Layout
We refer to feedback as redundant updates similar to 
\emph on
glitches
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 Change propagation is like a graph traversal or a tree traversal.
 The nodes represent the variables, and a visit refers to raising an update
 to a variable.
 Glitches refers to several visits caused by a single input event.
\end_layout

\begin_layout Plain Layout
In our design, the change propagation is based on depth-first search (DFS)
 traversal,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Depth-first_search
\end_layout

\end_inset


\end_layout

\end_inset

 rooted in the variable from which there was an an input event.
 The DFS algorithm can be described in terms of its result.
 This has the form of a
\emph on
 spanning tree
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1972depth"
literal "false"

\end_inset

 of the vertices reached during the traversal.
 Nodes with more than one incoming edge means the glitches.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Glitches are actuly several updates of the same time that called in
\end_layout

\begin_layout Plain Layout
simultaneous events 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset


\end_layout

\begin_layout Plain Layout
a chain of changes caused from a single input event would be considered
 as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Using this abstraciton, the cycles is presented by items that the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation
\end_layout

\begin_layout Plain Layout
Morever, an item would be created if and only if the stream does not contain
 an item 
\emph on
at its time
\emph default
.
\end_layout

\begin_layout Plain Layout
The time is derived from the time of the input events.
 Therefore.
 a chain of changes caused from a single input event would be considered
 as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
An Interpretation Process
\end_layout

\begin_layout Plain Layout
The outcome is created incrementaly by introducing the assignment as an
 
\emph on
accumulation
\emph default
 
\emph on
merge.
 
\emph default
For instance
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
 With including also a subsequent statement 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
 From these statements, it should be garantee that 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
For the equation 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,B,D)}$
\end_inset

 to be true, the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function should have two mathematics properties: commutativity and associativit
y.
 Commutativity means no order over the executions of the assignments statements
 ( 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 behaves the same as 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 and then 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

).
 Associativity means no strictness regarding order of the evaluations, because
 rearranging the parentheses in an expression will not change the result.
 For example, 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(A,merge(B,D))}$
\end_inset

.
 Regarding to mathematics, with both associativity and commutativity, we
 can be confident that the final result will always be the same, regardless
 of both the order of executions and the assignments statements.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Ordering
\end_layout

\begin_layout Plain Layout
The merge
\end_layout

\begin_layout Plain Layout
The propoation change is similar to a graph traversal, and it
\end_layout

\begin_layout Plain Layout
The stream abstracts time implicity by ordering items 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

, while it is derived from graph traversal order
\end_layout

\begin_layout Plain Layout
The order is derived from the traversals order of the propagation change
 processes.
 In case of several visits at the same node
\end_layout

\begin_layout Plain Layout
In contrast, a chain of changes caused from a single input event would be
 considered as of the same time 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation should discard those redandant items that are of the same time,
 but do not contain fresh information.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are several related perspectives upon the new assignment semantics
 and the concept of created cycles:
\end_layout

\begin_layout Itemize
Ignoring Feedback Values with Timestamps: This approach suggests utilizing
 timestamps to distinguish outdated feedback values and prioritize newer
 ones, essentially ignoring the older ones.
\end_layout

\begin_layout Itemize
Assignment as a Merge Operator: This perspective views the assignment operation
 as a merge function, implying the combination of different values or states.
\end_layout

\begin_layout Itemize
Cycles as a Subset of Dependency Conflicts: This viewpoint suggests that
 cycles represent a specific type of conflict that can arise within dependencies.
\end_layout

\begin_layout Plain Layout
In exploring the new asThere are several related perspectives upon the new
 assignment semantics and the concept of created cycles:
\end_layout

\begin_layout Itemize
Ignoring Feedback Values with Timestamps: This approach suggests utilizing
 timestamps to distinguish outdated feedback values and prioritize newer
 ones, essentially ignoring the older ones.
\end_layout

\begin_layout Itemize
Assignment as a Merge Operator: This perspective views the assignment operation
 as a merge function, implying the combination of different values or states.
\end_layout

\begin_layout Itemize
Cycles as a Subset of Dependency Conflicts: This viewpoint suggests that
 cycles represent a specific type of conflict that can arise within dependencies.
\end_layout

\begin_layout Plain Layout
In exploring the new assignment semantics and created cycles, there are
 several related presectives.
 First, using timestamps to ignore feedback values.
 Second, that the assignment behaves as a merge opeator.
 Third, that cycles is a sub case of conflicts in dependencies.
\end_layout

\begin_layout Plain Layout
The very first concept is the new assignment operator.
 The assignment means that the right-hand expression is an observable, to
 which the variable is registered.
 Since registration facilitates 
\emph on
dynamic dispatch
\emph default
 for assigning variable through an interface.
\end_layout

\begin_layout Plain Layout
However, the special about the current assignment operator is its directed
 approach between the left-hand variable and the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 Additionaly, directed calls from the right-hand expression to the left-hand
 variable should be directed without paralilism mechanism for achieving
 a deterministic execution order.
\end_layout

\begin_layout Plain Layout
The introduced assignment means that the left-hand variable subscribes to
 the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
\end_layout

\begin_layout Plain Layout
It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.signment semantics and created cycles,
 there are several related presectives.
 First, using timestamps to ignore feedback values.
 Second, that the assignment behaves as a merge opeator.
 Third, that cycles is a sub case of conflicts in dependencies.
\end_layout

\begin_layout Plain Layout
The very first concept is the new assignment operator.
 The assignment means that the right-hand expression is an observable, to
 which the variable is registered.
 Since registration facilitates 
\emph on
dynamic dispatch
\emph default
 for assigning variable through an interface.
\end_layout

\begin_layout Plain Layout
However, the special about the current assignment operator is its directed
 approach between the left-hand variable and the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
 Additionaly, directed calls from the right-hand expression to the left-hand
 variable should be directed without paralilism mechanism for achieving
 a deterministic execution order.
\end_layout

\begin_layout Plain Layout
The introduced assignment means that the left-hand variable subscribes to
 the right-hand expression.
 The right-hand expression will directly call to the left-hand variable,
 to not depend on a madiator.
\end_layout

\begin_layout Plain Layout
It facilitates dynamic dispatch, such that the actual left-hand variable
 is determined at runtime.
 The directed calls from the right-hand expression to the left-hand variable
 is for achieving a deterministic execution order.
 Consequently, The propagation algorithm is a depth-first search (DFS) traversal
, rooted in the variable being updated.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Framework
\end_layout

\begin_layout Plain Layout
We take the concept of reactive variables as observable streams.
 An observable stream is like a list, that it contains ordered items.
 It does not mean that the list is stored, it is only an abstraction.
 The list consists of the history of values that a variable have been contained.
 In order to get those values, consumers should perior to subscribe to the
 observable stream.
\end_layout

\begin_layout Plain Layout
This concept comes with operators for tranforming those observable streams.
 One operator map maps each item according to a function given as an argument.
 Another operator CombineLatest works for two observable streams, mapping
 based on items from the two.
 These operators has s meaning like lifting, because they convert a function
 to be an 
\emph on
higher order function
\emph default
.
 Higher order functions executed upon reactive variables forms expressions
 that are observable streams.
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Plain Layout
Variable that is re-assigned over time can be modelled as stream, that in
 each update there is a new item, of the new value representing the updated
 value at that instant.
 reactive variable means that update of that variable raises indirectly
 a continuation action based on the new value.
 Such an update may be called as
\emph on
 update with a push notification
\emph default
.
 In other words, 
\emph on
update with a push notification
\emph default
 means that not only the variable contained the new value instead of the
 previous value, but also that it raises interested parties about the change.
 We refer to variables as an object in the world, that exposes operation
 
\emph on
assign
\emph default
 (with :=) for an update, and 
\emph on
subscribe 
\emph default
for registration for push notifications.
\end_layout

\begin_layout Paragraph
Lifted Functions
\end_layout

\begin_layout Plain Layout
Variable expressions can also be modeled as streams, where each evaluation
 produces a new item representing the updated value at that instant.
 Evaluations are raised as push notifications from updaing variables.
 For this purpose, 
\family typewriter
Lift
\family default
 operation is needed that converts functions for creating such expressions.
 For example, 
\begin_inset Formula $\LSTINLINE+$
\end_inset

 as a function of values, can be lifted.
 The lifted 
\begin_inset Formula $\LSTINLINE+$
\end_inset

 are used over variables, creating an expression 
\begin_inset Formula $\LSTINLINE{A+B}$
\end_inset

 .
 The expression is evaluated whenever either 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 or 
\begin_inset Formula $\LSTINLINE B$
\end_inset

 is updated.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An expression is evaluated by
\end_layout

\begin_layout Plain Layout
Each update in any of the variables raises an evaluation each evalution
 a new item is created of the value, at the time of after the evaluation.
\end_layout

\begin_layout Plain Layout
Lift is an operation that creates functions to operate on variables from
 simple functions.
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of (variables
 and output of the latter funcions) .
\end_layout

\begin_layout Plain Layout
, and recursovely to function over the result of those functions.
 The lifted function makes that each update in any of the variables raises
 an evaluation to the function over values based on the new value.
 This
\end_layout

\begin_layout Plain Layout
Lift is a function that convert functions over values to functions of variables
 that creates streams.
 Each update in any of the variables raises an evaluation to the function
 over values based on the new value.
 For each evalution a new item is created of the value, at the time of after
 the evaluation.
 The lifted functions can further be used to be applied on results of other
 lifted functions.
 Therefore, the functions subscribe to streams and create an output streams,
 such that each item in any of the input stream raises an item in the output
 stream.
\end_layout

\begin_layout Plain Layout
items of the stream contained the values from those evaluations according
\end_layout

\begin_layout Plain Layout
The streams items contain the values evaluated
\end_layout

\begin_layout Plain Layout
Each function is converted into function that 
\emph on
subscribe
\emph default
 to variables and
\end_layout

\begin_layout Plain Layout
Lift is an operation that create functions that create stream of values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(the background: variable that re-assign over time can be modelled as stream
 over time, that in each update there is a new item at that time, that is
 the new value.
 reactive variable: if an update of that variable raises indirectly a continuati
on action based on the new value.
 update with a push notification means that not only the variable contained
 the new value instead of the previous value, but also that it raises interested
 parties about the change.
 )
\end_layout

\begin_layout Plain Layout
(introduction: variable is an object)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Assignment
\end_layout

\begin_layout Plain Layout
As referred in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, in order to enable dynamic dispatch, the assignment operator is different
 from the traditional meaning 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 which initiate a variable according to the right-hand expression.
 Instead it registers the left-hand variable to be updated to changes of
 the right-hand expression.
 This has in common with one-way data binding.
 For example, in 
\family typewriter
Angular
\family default
 <h2 innerHTML="{{ text }}"></h2> innerHTML is updated in reponse to changes
 in text.
 This also has in common with constraints programming with the name one-way
 dataflow constraint
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
However, in our setting the updates are handled directly.
 The right-hand expression will directly call to the left-hand variable.
 To clarify, this means there's no mediator used, no synchronization required,
 and it's not parallel execution.
 It's a straightforward function call.
 This will provide a deterministic execution order
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Plain Layout
We implemented the concept as extensions to existing programming languages
 on top of Rx.
 Specifically, we implemented the 
\begin_inset Formula $\NAME{nuget}$
\end_inset

 package 
\begin_inset Formula $\NAME{RIVarX}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.nuget.org/packages/RIvar.RIvarX
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{C\#}$
\end_inset

 and an 
\begin_inset Formula $\NAME{npm}$
\end_inset

 package 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.npmjs.com/package/rivarjs
\end_layout

\end_inset


\end_layout

\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 We depend on observable streams, specificaly given by 
\begin_inset Formula $\ReactiveX$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

 and 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 for 
\begin_inset Formula $\NAME{JavaScript}$
\end_inset

.
 (Using observable streams facilitates binding with the UI, when a UI change
 event occurs, it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.)
\end_layout

\begin_layout Plain Layout
We implement a filtering mechanism, where the variables and the expressions
 over them does not propagate values that are less updated that the existing
 once.
 To do this, we create a wrapper to variables: the 
\begin_inset Formula $\RIVar$
\end_inset

 datatype, which is a shortcut for reactive instance variable.
 We also create a wrapper to the expressions: the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function (
\begin_inset Formula $\LSTINLINE{Lift}$
\end_inset

 in 
\begin_inset Formula $\LSTINLINE{C\#}$
\end_inset

) .
 Both pass values while filtering out obsolete values.
 The values are wrapped by objects of the 
\begin_inset Formula $\LSTINLINE{signal}$
\end_inset

 type (or 
\begin_inset Formula $\LSTINLINE{Signal}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) implementing the classic comparable interface (according to 
\begin_inset Formula $\LSTINLINE{IComperable}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) by timestamps as mentioned in in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Order-Model"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function is similar to 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 that it creates an observable stream from input observable streams.
 Whenever any of the input stream has a new item, a new item is created
 to the output stream.
 However, in contrast to the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{lift}$
\end_inset

 function creates an observable streams that is 
\emph on
strictly increasing sequence
\emph default
: it only passes an item to the output stream if it is greater (i.e., newer)
 than an item that previously passed.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\RIVar$
\end_inset

 type is derived from the 
\begin_inset Formula $\LSTINLINE{subject}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Subject}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

), which implements an observable stream.
 The 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{OnNext}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

) method is the implementation of the operator 
\begin_inset Formula $\LSTINLINE=$
\end_inset

, and for the operator 
\begin_inset Formula $\LSTINLINE{:=}$
\end_inset

, we implement a new custom method, we call it 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 (or 
\begin_inset Formula $\LSTINLINE{Set}$
\end_inset

 in 
\begin_inset Formula $\NAME{C\#}$
\end_inset

).
 In the 
\begin_inset Formula $\LSTINLINE{set}$
\end_inset

 method, there are subscriptions to the two sides, and each item in the
 right side, is compared to the last item in the stream of the variable
 in the left side.
 If it is new, it will publish it by calling on its 
\begin_inset Formula $\LSTINLINE{next}$
\end_inset

.
 This is like applying the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 function mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the right-hand side of the operator is merged with the stream on the
 left-hand side of the operator, and stores the merged result back in the
 left-hand side variable.
\end_layout

\begin_layout Plain Layout
By using the extension, 
\begin_inset Formula $\LSTINLINE{A.set(Lift(Inc,B))}$
\end_inset

 means 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

, while 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

 represent the function 
\begin_inset Formula $\LSTINLINE{Inc(x)=x+1}$
\end_inset

.
 As illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Evaluating-the-formula-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Propogation-on-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the operator 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 (representing 
\begin_inset Formula $\LSTINLINE{Inc}$
\end_inset

) observes the variable 
\begin_inset Formula $\LSTINLINE B$
\end_inset

, and the assignment operator observes both the 
\begin_inset Formula $\LSTINLINE{+1}$
\end_inset

 operator and the variable 
\begin_inset Formula $\LSTINLINE A$
\end_inset

.
 These established connections are then utilized for change propagation,
 interacting with the connected user interface (UI) fields.
\end_layout

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Integration
\end_layout

\begin_layout Plain Layout
As 
\begin_inset Formula $\RIVar$
\end_inset

s consist of observable streams we facilitate binding with the UI.
 Once a UI change event occurs, it adds an event to the stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
 In this way, we created a .NET Windows Forms application, a web application,
 and an HTML page (available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX
\end_layout

\end_inset

).
 Similarly, it should be easy to integrate with various development environments.
\end_layout

\begin_layout Plain Layout
In addition, we have developed 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, a 
\begin_inset Formula $\NAME{React}$
\end_inset

 component, designed for visualizing a 
\begin_inset Formula $\RIVar$
\end_inset

.
 Similar to a reactive variable that recalculates based on changes in its
 dependencies, 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 component re-renders the view in response to changes in the associated
 
\begin_inset Formula $\RIVar$
\end_inset

.
\end_layout

\begin_layout Plain Layout
To utilize 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, developers need to specify the 
\begin_inset Formula $\LSTINLINE{prop}$
\end_inset

 named 
\begin_inset Formula $\LSTINLINE{rivar}$
\end_inset

 with the 
\begin_inset Formula $\RIVar$
\end_inset

 and a nested element to define the view.
 The nested element is specified as a function of 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 and a 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method, allowing it to collect user input values and display calculated
 values.
 For example as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:rivarview-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in the case of a visual element representing Drug Administration Amount,
 the 
\begin_inset Formula $\LSTINLINE{value}$
\end_inset

 property is set to the input value, and the 
\begin_inset Formula $\LSTINLINE{change}$
\end_inset

 method is called within the event handler of the 
\begin_inset Formula $\LSTINLINE{onChange}$
\end_inset

 event.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

  <RIVarView rivar={bag.Amount}>
\end_layout

\begin_layout Plain Layout

        {({ value, change }) => {
\end_layout

\begin_layout Plain Layout

          return <input
\end_layout

\begin_layout Plain Layout

            type="number"
\end_layout

\begin_layout Plain Layout

            value={value}
\end_layout

\begin_layout Plain Layout

            onChange={(event) => change(event.target.value)}
\end_layout

\begin_layout Plain Layout

          />;
\end_layout

\begin_layout Plain Layout

        }}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rivarview-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application
\end_layout

\end_inset

Code example for using 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

 in 
\begin_inset Formula $\NAME{React}$
\end_inset

 application.
 The specified element is part of a larger BagComponent to the bag's amount.
 The prop rivar is given with the RIVar or the bags amount.
 The netsetd slement is a function with the arguments value and cahnge,
 the function returns a react component view as a function of the value
 and cahnge arguments.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Using the added 
\begin_inset Formula $\LSTINLINE{RIVarView}$
\end_inset

, it becomes easier to create the Drug Administration example as illustrated
 in n 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:react_micro_frontends-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 According to the example, the resulting framework allows the declaration
 of backend logic and frontend components without needing to be aware of
 interactions, neither between the backend objects nor between the backend
 objects and the frontend components.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class App extends Component {
\end_layout

\begin_layout Plain Layout

  constructor(props) {
\end_layout

\begin_layout Plain Layout

    super(props);
\end_layout

\begin_layout Plain Layout

    this.bag = new Bag();
\end_layout

\begin_layout Plain Layout

    this.pump = new Pump(this.bag);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render() {
\end_layout

\begin_layout Plain Layout

    return (
\end_layout

\begin_layout Plain Layout

      <div>
\end_layout

\begin_layout Plain Layout

        <BagComponent bag={this.bag} />
\end_layout

\begin_layout Plain Layout

        <PumpComponent pump={this.pump}/>
\end_layout

\begin_layout Plain Layout

      </div>
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:code}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag UI] (C)
 {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 UI] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag] (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump]
 (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center} 
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:runtime}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:micro_front_ends}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:react_micro_frontends-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Design for the drug administration application.
\end_layout

\end_inset

Design for the drug administration application.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 presents the static code in 
\begin_inset Formula $\NAME{React}$
\end_inset

 that bootstraps the components, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

 presents the runtime components with the interaction channels.
 
\begin_inset Formula $\LSTINLINE{BagComponent}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{PumpComponent}$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:code})
\end_layout

\end_inset

 represent the UI components of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that are illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:runtime})
\end_layout

\end_inset

.
 In the interaction channel between 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 the 
\begin_inset Formula $\RIVar$
\end_inset

s update each other according to the calculations.
 In the interaction channel between each of them to the corresponding UI
 component, there is a binding between each of the 
\begin_inset Formula $\RIVar$
\end_inset

s to the corresponding input element, such that when a UI change event occurs,
 it adds an event to the variable stream.
 Conversely, when a new event appears in the stream, it triggers a corresponding
 change in the UI.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
In the new approach, an assignment
\emph on
 adds a dependency
\emph default
.
 A variable (
\family typewriter
RIVar
\family default
) can be assigned multiple times, and in each time the variable depends
 on a new expression in addition to existing dependencies.
 This leads that a single variable can be updated from several expressions.
 Additionally, all the variables are input variables that can be updated
 directly.
\end_layout

\begin_layout Standard
Practically, assignment would be an operation that performs that
\emph on
 the left-hand variable subscribes to the right-hand expression, such that
 the right-hand expression calls to the left-hand variable to update it
\emph default
.
 By using this technique, we create an effect similar to 
\family typewriter
merge 
\family default
function over streams of values.
 The order of the values would be according to the order of the input events.
 From the user pespective any input would propogate changes while overriding
 oldest values.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 Upon such variables we identify a novel variation of FRP called 
\family typewriter
Non-Hierarchical FRP
\family default
 (NH-FRP).
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where objects can contain
\end_layout

\begin_layout Plain Layout
that provides a new type of abstraction.
\end_layout

\begin_layout Plain Layout
This chapter introduces the concept and implementation of
\family typewriter
 Non-Hierarchical FRP
\family default
 (NH-FRP), a new variant of FRP for data dependencies over reactive instance
 variables.
\end_layout

\begin_layout Plain Layout
The reactive instance variables are part of object's interface with the
 encapsulation feature for related data dependencies.
 
\end_layout

\begin_layout Plain Layout
Reactive instance variables refer to a concept of decentralizing reactive
 variables management, because they are reactive variables associated to
 objects.
 For this settings we customize a noval variant of FRP, named
\family typewriter
 Non-Hierarchical FRP
\begin_inset space ~
\end_inset


\family default
(NH-FRP), in which the static code and the runtime preserve on objects isolation.
\end_layout

\begin_layout Plain Layout
Reactive instance variables embody the idea of decentralizing the management
 of reactive variables, as they contain in objects.
 For this settings, we customize a novel variation of FRP called Non-Hierarchica
l FRP (NH-FRP), in which code and runtime are 
\end_layout

\begin_layout Plain Layout
where the static code and runtime maintain isolation on objects.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
