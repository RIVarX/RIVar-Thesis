#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{algorithm,algpseudocode}
\usepackage{pgf-umlsd}
\usepackage{listings}
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, numberfirstline=true, firstnumber=1, stepnumber=1}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Problem"

\end_inset

Problem
\end_layout

\begin_layout Standard
In this section, we present complexity derived from the cycles problem.
 During this presentation, we use an application named 
\family typewriter
Drug Administration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A small part from Order Entry in 
\family typewriter
MetaVision
\family default
, an healthcare system provided by 
\family typewriter
iMDsoft
\family default
.
\end_layout

\end_inset

 
\family default
illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for clinicians to document medications amounts, consisting six fields:
 Drug, Volume, Concentration, Rate, Dose and Duration.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c c c| }    
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Drug & Concentration & Volume 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
framebox(35,15){
\backslash
textit{100}} & 
\backslash
framebox(35,15){
\backslash
textit{0.33}} & 
\backslash
framebox(35,15){300} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

 Dose & Duration & Rate 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

 
\backslash
framebox(35,15){10} & 
\backslash
framebox(35,15){10} & 
\backslash
framebox(35,15){
\backslash
textit{30}} 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

Drug Administration, contains the following fields:
\end_layout

\begin_layout Plain Layout


\backslash
begin{description}      
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Drug
\begin_inset Quotes erd
\end_inset

] relates to amount of medication/drug administered to a patient, (e.g.
 20 mg).
    
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Volume
\begin_inset Quotes erd
\end_inset

] relates to Infusion fluid volume.
 An Infusion injects the medication into the patients body, by mixing the
 Drug with fluids (e.g., 20 ml).
 
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Concentration
\begin_inset Quotes erd
\end_inset

] amount of the 
\backslash
textbf{Drug} per 
\backslash
textbf{Volume} (e.g.
 0.5 mg/ml).
  
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Rate
\begin_inset Quotes erd
\end_inset

] relates to 
\backslash
textbf{Volume} flow administered into the patients body per time unit (e.g.,
 20 ml per hour).
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Dose
\begin_inset Quotes erd
\end_inset

 (or Dosage)] 
\backslash
textbf{Drug} administered into the patients body per time unit (e.g., 20 mg
 per hour).
\end_layout

\begin_layout Plain Layout


\backslash
item[
\begin_inset Quotes eld
\end_inset

Duration
\begin_inset Quotes erd
\end_inset

] relates to the duration from starting the injection until stopping it.
  
\end_layout

\begin_layout Plain Layout


\backslash
end{description}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-calculations-1-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Drug Administration.
\end_layout

\end_inset

 Drug Administration.
 The fields are illustrated with example values, in case the user sets Volume,
 Dose and Duration.
 The fields Drug, Concentration, and Volume are displayed in italic typeface
 to indicate that these values are calculated based on the set values.
\begin_inset Note Note
status open

\begin_layout Plain Layout
User interface component for drug administration.
 The upper panel represents the bag component, and the lower panel represents
 the pump component.
 The fields are illustrated with example values, in case the user sets Volume,
 Dose and Duration.
 The fields Drug, Concentration, and Volume are displayed in italic typeface
 to indicate that these values are calculated based on the set values.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Drug relates to amount of medication/drug administered to a patient, (e.g.
 20 mg).
\end_layout

\begin_layout Description
Volume relates to Infusion fluid volume.
 An Infusion injects the medication into the patients body, by mixing the
 
\series bold
Drug
\series default
 with fluids (e.g., 20 ml).
\end_layout

\begin_layout Description
Concentration amount of the 
\series bold
Drug
\series default
 per 
\series bold
Volume
\series default
 (e.g.
 0.5 mg/ml).
\end_layout

\begin_layout Description
Rate relates to 
\series bold
Volume
\series default
 flow administered into the patients body per time unit (e.g., 20 ml per hour).
\end_layout

\begin_layout Description
Dose (or Dosage) 
\series bold
Drug
\series default
 administered into the patients body per time unit (e.g., 20 mg per hour).
\end_layout

\begin_layout Description
Duration relates to the duration from starting the injection until stopping
 it.
\end_layout

\begin_layout Section
Acyclicity as Nonfunctional Requirement
\end_layout

\begin_layout Standard

\emph on
Avoiding cycles
\emph default
 applies a nonfunctional requirement
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Cycles has been called 
\emph on
accidental recursion
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Accidental means complexity that is not inherent in the problem that the
 software solves (as seen by the users) but rather undesirably forced from
 the implementation 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
\end_layout

\end_inset

 (i.e., requirement that is not the essential requirements as seen by users)
 that causes complexity in code (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Complexity-in-Code"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and bad impact on the user experience (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:User-Experience"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In contrast to our thesis approach that results cycles,
\end_layout

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
In this section, we present challenges caused from the need to keep on the
 acylicity
\end_layout

\begin_layout Plain Layout
An acyclic dependencies graph
\end_layout

\begin_layout Plain Layout
From our prespective, a centeral problem in software prgramming, and specificaly
 in handling state, is in hadnling cycles.
 In the following we present a case study named Drug Administration, with
 an acylic appraoch.
\end_layout

\begin_layout Itemize
The event-driven paradigm is error-prone because it is difficult to manage
 state in the various event handlers
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "maier2010deprecating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
FRP essentially provides only hierarchical data dependencies, where each
 variable is either an input or computed
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, in the current application, all fields should be editable while
 also being computed according to other fields if they are edited.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Constraint systems are not modular 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

, thus not extendable.
\end_layout

\begin_layout Plain Layout
In this section, we investigate a case study, named Drug Administration.
 We present a solution that uses hierarchical data dependencies, and then
 the challenge in our thesis.
\end_layout

\begin_layout Plain Layout
(to improve from the limited DAG, birth (דלונ) in the procedual programming.
 find solution to cycles.)
\end_layout

\begin_layout Plain Layout
This thesis' focus on feasibility for scalable technalogies of components.
 Current components technalogy includes: micro-services, micro-frontends,
 react components and so on.
 Even though they are popular, they does provide a scalable solution for
 
\emph on
state
\emph default
.
 State refers to what software remembers from past used to its future behavior.
 Basicly, it is variables that contain values, but not only them.
 State refers to any changeable data, stored anywere, used to determine
 output.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Code Reuse/Scaleability/user friendliness
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Object-Oriented Programming (OOP) has been a cornerstone of software development
 for decades, offering mechanisms like inheritance and composition to promote
 code reuse.
 However, as you've pointed out, the issue of repetitive variable updates
 remains a challenge.
 Repetitive variable updates are solved in paradigms outside of OOP.
\end_layout

\begin_layout Plain Layout
In this section we present a case study and analyse an example to show dificulti
es in code reuse within
\end_layout

\begin_layout Plain Layout
an hirarchial model of computations an example to present a lack of resuability
 in programing hirarchial calcuations.
\end_layout

\begin_layout Plain Layout
It is an abvoisous principle, the importance for code reuseability.
\end_layout

\begin_layout Plain Layout
Functional Reactive Programming (FRP) with its advantages is inheredly support
 cases of acylic data dependencies.
 In the other side, software complexity ...
\end_layout

\begin_layout Plain Layout
code repeition (and its bad impact)
\end_layout

\begin_layout Itemize
start with the example
\end_layout

\begin_layout Itemize
no cycle and ceteral mechanism problem
\end_layout

\begin_layout Itemize
RIVar concept
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Many abstractions have been invented over the years to abstract out complexity
 involves in handling variables.
 Its main issue, is that it is hard to reason about the containing value,
 how and why a variable contains the value it contains.
\end_layout

\begin_layout Itemize
Do not make code duplication.
 This will reduce the chances that logic will be inconsistent.
\end_layout

\begin_layout Itemize
Make bounderies (class, module etc.).
 This makes predictability to who made the updates.
\end_layout

\begin_layout Itemize
Make dependencies explicit.
 This will make it easier to find what code did update variables.
\end_layout

\begin_layout Itemize
Control.
 Following the code with a debugger line by line, provide a positive effect.
\end_layout

\begin_layout Itemize
Reproducable or predictability, such that the results is consistent over
 the executions.
 This helps to learn from re-executing, with debugging, or with some changes
 to evaluate the diffrence and analyse the behavior.
\end_layout

\begin_layout Plain Layout
Beside the complexity in development, it is challenged to perform good results
 in the perfomance (speed, running time).
\end_layout

\begin_layout Itemize
calculations.
 make a procedure that find the value/data according to other data (that
 change)
\end_layout

\begin_layout Itemize
updates.
 inform others that data has changed.
 For example, visual elements.
\end_layout

\begin_layout Itemize
comparations.
 for reducing the other elements, compare the value agant the revious, to
 perform action only if realy changed.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Complexity-in-Code"

\end_inset

Complexity in Code
\end_layout

\begin_layout Standard
The code behind 
\family typewriter
Drug Administration
\family default
 consists of fields calculations.
 According to which fields that a user fills, an appropiate process of computati
ons is executed.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation-1-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is depicted a prototype for a 
\begin_inset Formula $\LSTINLINE{calculate}$
\end_inset

 procedure.
 This procedure is called whenever any if the fields is edited, for recomputing
 fields' values according to the edited fields' values.
 In the code, there are branches identified by sets of fields that had been
 edited.
 In each branch, the code consist of a process of computations according
 to the fields that were edited.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:first_if}
\end_layout

\end_inset

 is related to a use-case that Dose, Duration and Volume are edited.
 In such a case the values for Drug, Concentration and then Rate are computed.
 
\end_layout

\begin_layout Standard
Over the branches there are overlaps in the computations.
 For example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume2}
\end_layout

\end_inset

 compute Concentration based on Drug and Volume.
 However, the order of the computations are diffrent, causing the need to
 make the code repetitions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

If edited triple is of Dose,  Duration, and Volume  |
\backslash
label{line:first_if}|
\end_layout

\begin_layout Plain Layout

  Drug = Dose*Duration
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/Volume |
\backslash
label{line:concentrationByDrugAndVolume1}|
\end_layout

\begin_layout Plain Layout

  Rate = Volume/Duration
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Drug, Dose, and Rate
\end_layout

\begin_layout Plain Layout

  Duration = Drug/Dose
\end_layout

\begin_layout Plain Layout

  Volume = Duration*Rate 
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/Volume |
\backslash
label{line:concentrationByDrugAndVolume2}|
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Concentration,  Volume, and Duration
\end_layout

\begin_layout Plain Layout

  Drug = Volume*Concentration
\end_layout

\begin_layout Plain Layout

  Rate = Volume/Duration 
\end_layout

\begin_layout Plain Layout

  Dose = Drug/Duration
\end_layout

\begin_layout Plain Layout

End If
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Centerlized-Calculation-1-3"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug administration calculation.
\end_layout

\end_inset

Drug administration calculation.
 The code shows how to calculate the values of the fields based on different
 combinations of three input fields.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This issue becomes more pronounced as the application expands in response
 to customer requests for new features.
 For example, field 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 is added to the 
\family typewriter
Order Entry
\family default
 example.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 indicates whether the application should trigger an alert for abnormal
 medication amounts.
 Accordingly, whenever 
\family typewriter
Drug
\family default
 is updated, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 should be updated as well.
 This require adding the update five times according to five ways to how
 the value of 
\family typewriter
Drug
\family default
 is determine.
\end_layout

\begin_layout Itemize
The 
\family typewriter
Drug
\family default
's value can be fill directly, 
\end_layout

\begin_layout Itemize
If a user fill 
\family typewriter
Volume
\family default
 and 
\family typewriter
Concentration
\family default
, the value of 
\family typewriter
Drug
\family default
 should be computed from the values of 
\family typewriter
Volume
\family default
 and 
\family typewriter
Concentration
\family default
.
\end_layout

\begin_layout Itemize
The value of volume might be computed in case that a user fill 
\family typewriter
Duration
\family default
 and 
\family typewriter
Dose
\family default
.
 In such a case, the values of 
\family typewriter
Duration
\family default
 and 
\family typewriter
Rate
\family default
 are sed to determine the value of 
\family typewriter
Volume
\family default
, then this value with the value filled in 
\family typewriter
Concentration
\family default
 are used to compute 
\family typewriter
Drug
\family default
.
\end_layout

\begin_layout Itemize
If a user fill 
\family typewriter
Dose
\family default
 and 
\family typewriter
Duration
\family default
, The drug values si computed by them
\end_layout

\begin_layout Itemize
if 
\family typewriter
Volume
\family default
, 
\family typewriter
Rate
\family default
 and 
\family typewriter
Dose
\family default
 are filled, then 
\family typewriter
Volume
\family default
 and 
\family typewriter
Rate
\family default
 is used to determine value for 
\family typewriter
Duarion
\family default
, which then is used with 
\family typewriter
Dose
\family default
 to determine a value for 
\family typewriter
Drug
\family default
.
\end_layout

\begin_layout Standard
If, in a small application, a single addition is replicated fivefold, managing
 such additions becomes daunting in larger applications.
 The process of locating and updating various sections of the code demands
 time and effort.
 Furthermore, after dealing with such an addition, the code becomes multiplied,
 resulting in future additions and updates becoming more challenging.
 The repetition causes difficulties in changing functionality, leading to
 resistance against modifications.
 This resistance means there is no room for enhancement in the application.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:User-Experience"

\end_inset

User Experience
\end_layout

\begin_layout Standard
The design by procsses sometimes leaks into GUI experience, in explicity
 define use-cases mapped to each process.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The Order Entry has six numeric fields, presented in the beginning of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, with various options to fill them.
 For example, there are two options to define the drug quantities: either
 by 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

 or by 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In the first option, 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 is calculated based on 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in the second option, 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 is calculated based on the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
locker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:180:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
openedlocker}[1]{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

    % Draw the body of the lock
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (0,0) rectangle (#1,#1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the shackle (the curved part of the lock)
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (#1, #1) arc (0:130:#1/2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c c c| }  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{ordering style }  
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{3}{ |l|}{
\backslash
framebox(130,15){set Dose and Rate {$
\backslash
nabla$}}}
\end_layout

\begin_layout Plain Layout

 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Drug & Concentration & Volume 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} & 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

 Dose & Duration & Rate 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

 
\backslash
framebox(35,15){ } 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
locker{0.25}}& 
\backslash
framebox(35,15){} 
\backslash
framebox(10,15){
\backslash
openedlocker{0.25}} 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Order-Entry-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug Administration - Full Version.
\end_layout

\end_inset

 At the top, there is the Ordering Style field, represented by a combobox,
 where users can select from the available options.
 Below this, each field consists of a label above its name, an area to display
 its value, and a lock icon on its right.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ordering Style
\end_layout

\begin_layout Standard
Before editing the numeric fields, it is required to select an option from
 a 
\family typewriter
select
\family default
 element named 
\family typewriter
ordering style
\family default
.
 One option is 
\family typewriter
set concentraion and volume
\family default
, another option is 
\family typewriter
set dose and rate
\family default
.
 According to the selected option, fields become editable or readonly, controlin
g the calculations directions.
 If the user selects 
\family typewriter
set concentraion and volume
\family default
, those fields become editable, and the other fields will be calculated
 accordingly.
 If the user selects 
\family typewriter
set dose and rate
\family default
, those fields become editable, and the other fields will be calculated
 accordingly.
 
\end_layout

\begin_layout Paragraph
Lockers
\end_layout

\begin_layout Standard
Additionaly, there are elements named 
\family typewriter
locker
\family default
 used to 
\emph on
lock
\emph default
 or 
\emph on
unlock
\emph default
 fields.
 Locking means that the field's value would be calculated according to other
 fields' values, whereas unlocking means that the field becomes editable.
 The lockers are similar to toggle buttons, each click changes from the
 previous state locked from being unlocked and vice versa.
 Among the six fields, three of the fields should be set by the user and
 the others should be calculated.
 Therefore, unlocking one field causes another field to be locked instead.
 Selecting 
\family typewriter
ordering style
\family default
 initiates the state of the lockers, for each field whether it is locked
 or unlocked.
 Fields that are editable according to the selected ordering style, cannot
 be locked.
 For example, if the selected ordering style is 
\family typewriter
set concentration and volume
\family default
, concentration and volume are unlocked, and it is unabled to lock them.
\end_layout

\begin_layout Paragraph
Templates
\end_layout

\begin_layout Standard
In MetaVision, customers often does not directly uses the 
\family typewriter
Order Entry
\family default
.
 Instead they use templates, that contain pre filled values, a setup to
 specific cenarios.
 In this way, users should search and find for each specific use-case, for
 the the specific needed setup.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——————-
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
We compare several implementations of the Order Entry, by considering cognitive
 loads for both users and developers.
 For users, reducing cognitive loads means creating less complex window,
 a window that is easier to use.
 For developers, reducing cognitive load means simple code that is easy
 to change and extend.
 The latter may improve user experience as well, because it enables to make
 fast changes according to customers' feedback.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
This chapter focuses on evaluating our de-centralization approach for improving
 user experience.
 We use the Order Entry application mentioned throughout this thesis.
 We created it with the name Drug Administration according to this thesis'
 approach.
 We also created a similar application as an excel file (spreadsheet) to
 ilustrate the application code as reactive variables.
 In addition, we created the Drug Administration as a constraints system
 using 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
ordering style
\family default
 and the 
\family typewriter
lockers
\family default
 are needed for controling the calculations, however they increase mental
 effort and processing capacity needed for using the 
\family typewriter
Order Entry
\family default
.
 Templates aims to help the customer against these issues.
 However, in using templates, users might be overwhelmed in 
\emph on
navigations
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "roman2017navigation"
literal "false"

\end_inset

 in the search of the specifc setup for the specific use-case.
\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
The nonfunctional requirement of avoiding cycles negatively impacts software
 development in multiple ways.
 It hinders code reuse, as common calculations appear in different orders
 across various processes.
 Additionally, it leads to usability issues.
 Users are promted to specify input for fields they are not familiar or
 navigate through multiple general cases to locate the relevant one.
\end_layout

\begin_layout Section
Complex Systems and Feedback Loops
\end_layout

\begin_layout Standard
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Component breakdown, a cornerstone of software development, doesn't always
 equate to overall application simplicity.
 
\end_layout

\begin_layout Standard
Furthermore, components-based application are sometimes very similar to
 
\emph on
complex systems.

\emph default
 Systems, therefore also applcations, that composed of many components are
 complex if their behavior are not predictable by looking at each of their
 individual component separately.
 
\end_layout

\begin_layout Standard
non complex applications are those that satisfies the 
\emph on
superposition property
\emph default
.
 The superposition property means lineraity, i.e., for a set of components
 the sum of behaviors from each of the components seperatedly are equal
 to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
In the research of compex systems it has been explained that the non linear
 behavior is caused from 
\emph on
feedback loops
\emph default
.
 Feedback loops are very similar to loops existed in programming components-base
d applications.
 Feedback loop means that an effect in one component, produces a chain of
 effects through several components, which again produce affect on the first
 component (therefore the name, feed back), which sometimes lead to continue
 the chain, sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
As an alternative for the Drug Administration implementation, we introduce
 a design based on OOP.
 We declare class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 We declare also class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that represents a Pump that is connected to a patient to infuse a bag over
 time.
 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contains a field 
\begin_inset Formula $\LSTINLINE{TheBag}$
\end_inset

 referencing to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

.
 In addition, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contains fields Dose, Rate and Duration.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration |
\backslash
label{line:PumpCode_RIVars1}|
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:PumpCode_formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable TheBag|
\backslash
label{line:PumpCode_TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:PumpCode_RIVars2}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:PumpCode_formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:PumpCode_formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset


\end_layout

\end_inset

Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
Cref{line:PumpCode_formula,line:PumpCode_formula2,line:PumpCode_formula3}
\end_layout

\end_inset

 represent the needed calculations.
 The calculations involves the instance variables declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_RIVars1,line:PumpCode_RIVars2}
\end_layout

\end_inset

.
 In 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, the calculations involve variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, which is declared in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_TheBag}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Additionaly, we implement a behavior.
 For simplicity, we uses the syntax of an assignment operator, meaning to
 register the left-hand variable to be updated to changes of the right-hand
 expression.
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 contains Volume:=Concentration*Drug such that Volume will be recalculated
 depending on Concentration and Drug.
 Likewise, class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contains Duration:=Rate*Volume and also TheBag.Drug:=Dose*Duration.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

class Bag
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable Drug, Volume, Concentration |
\backslash
label{line:PumpCode_RIVars1}|
\end_layout

\begin_layout Plain Layout

  Volume:=Concentration*Drug |
\backslash
label{line:PumpCode_formula3}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Variable TheBag|
\backslash
label{line:PumpCode_TheBag}|
\end_layout

\begin_layout Plain Layout

  Variable Duration, Dose, Rate|
\backslash
label{line:PumpCode_RIVars2}|
\end_layout

\begin_layout Plain Layout

  TheBag.Drug:=Dose*Duration  |
\backslash
label{line:PumpCode_formula}|
\end_layout

\begin_layout Plain Layout

  Duration:=Rate*Volume |
\backslash
label{line:PumpCode_formula2}|
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PumpCode-2"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset


\end_layout

\end_inset

Pseudo code of the calculations in the classes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
Cref{line:PumpCode_formula,line:PumpCode_formula2,line:PumpCode_formula3}
\end_layout

\end_inset

 represent the needed calculations.
 The calculations involves the instance variables declared in 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_RIVars1,line:PumpCode_RIVars2}
\end_layout

\end_inset

.
 In 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, the calculations involve variables of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, which is declared in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cref{line:PumpCode_TheBag}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In illustrating the dependencies, or flowes of changes there is a cycle
 involving the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Naively, this results an infinite loop.
 
\end_layout

\begin_layout Standard
Furthermore, even a single redundant update can be undesirable.
 For example as the example (illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

), an update of Drug of a Bag (instances, but we skip saying that for fast
 reading), that causes Pump to update Dose, then Rate, then Volume, then
 Concentration, and then it comes back to 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

.
 This is an unitended feedback loop.
 even in case that the interaction did not started with 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, there might be an unidented update of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 though an update of another field that causes 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

 it updated with a rounded value 0.33 that is computed from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}      
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{VolumeOfFluid=300}{Bag}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Concentration=0.33}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Drug=99}{Bag}{}  
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Rate=30}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}        
\end_layout

\begin_layout Plain Layout


\backslash
end{call}   
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Unpredictable-Calculation-3"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Unexpected Feedback Loop: Unintended Override of User Input
\end_layout

\end_inset

Sequence diagram illustrating the interactions between the User Interface
\begin_inset space ~
\end_inset

(UI), 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 objects.
 Initially, the UI sets the value of 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 to 100.
 However, due to the complex interactions and dependencies between the objects,
 the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 value undergoes modifications and eventually gets updated to 99.
 This unintended alteration exemplifies the challenge posed by feedback
 loops, which can result unintended override of user input.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[node distance=3cm, 
\end_layout

\begin_layout Plain Layout

                      ByPumpEdge/.style={draw=black,<-},
\end_layout

\begin_layout Plain Layout

                      ByBagEdge/.style={draw=black,<-, dashed},
\end_layout

\begin_layout Plain Layout

                      >=latex]
\end_layout

\begin_layout Plain Layout

    % Nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node (concentration) [circle, draw] at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (concentration.south) {concentration};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (volume) [circle, draw, below left of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (volume.south) {volume};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (drug) [circle, draw, below right of=concentration] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (drug.south) {drug};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (dose) [circle, draw, below of=drug] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (dose.south) {dose};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (rate) [circle, draw, below of=volume] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (rate.south) {rate};
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
node (duration) [circle, draw, below right of=rate] {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[below] at (duration.south) {duration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Edges
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (rate) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (volume) -- (duration);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (duration) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByPumpEdge] (dose) -- (drug);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (concentration) -- (volume);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[ByBagEdge] (drug) -- (volume);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycleByComponents-2"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
\end_layout

\end_inset

Mutual recursion in runtime from combined dependency graphs of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instances.
 The solid edges denote dependencies initiated within the 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 instance, while dotted edges indicate dependencies initiated within the
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance.
 In the graph created, the nodes 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

 are interconnected through the edges, representing the mutual recursion.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 This points on complexity that is not resolved by 
\emph on
divide and conquer
\emph default
, with a mean of components-based application.
 This has a similtary with 
\emph on
complex systems,
\emph default
 researched outside of software development.
 that composed of many components
\end_layout

\begin_layout Plain Layout
components- Composing applications from decoupled components 
\end_layout

\begin_layout Plain Layout
From this defintion, it seems Devide and qonquesr 
\end_layout

\begin_layout Plain Layout
Additionaly, outside of software development, 
\emph on
complex systems
\emph default
 refer to a related concept.
\end_layout

\begin_layout Plain Layout
specific systems that composed of many components.(, where 
\begin_inset Quotes eld
\end_inset

wholes that are more than the sum of their parts
\begin_inset Quotes erd
\end_inset

.
 This is similar to component-based applications, in cases when behavior
 is not predictable by looking at each of its individual component separately.)
\end_layout

\begin_layout Plain Layout
Cycles is related to complexity.
 Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 One 
\begin_inset Quotes eld
\end_inset

suprising ways
\begin_inset Quotes erd
\end_inset

 is probabaly 
\emph on
accidental recursion
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Accidental means complexity that is not inherent in the problem that the
 software solves (as seen by the users) but rather undesirably forced from
 the implementation 
\begin_inset CommandInset citation
LatexCommand cite
key "moseley2006out"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In essence, as specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "true"
noprefix "false"

\end_inset

, adding a single formula, might lead to a cycle in the dependencies which
 causes unexpected feedback loop, which means that the application becomes
 like complex systems.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Outside of software development, 
\emph on
complex systems
\emph default
 refer to specific systems that composed of many components.(, where 
\begin_inset Quotes eld
\end_inset

wholes that are more than the sum of their parts
\begin_inset Quotes erd
\end_inset

.
 This is similar to component-based applications, in cases when behavior
 is not predictable by looking at each of its individual component separately.)
\end_layout

\begin_layout Subsection
Superposition Property
\end_layout

\begin_layout Plain Layout
The superposition property means lineraity, i.e., for a set of components
 the sum of behaviors from each of the components seperatedly are equal
 to the sum produced from the behavior produced tegather.
 The behavior of component 
\begin_inset Formula $x$
\end_inset

 is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where its behavior represent the updates in its variables according phenomena.
 For example, any given pair of components 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, superposition property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
\end_layout

\begin_layout Subsection
Feedback Loops
\end_layout

\begin_layout Plain Layout
In complex systems, the behavior is not linear because components affects
 each other producing sometimes 
\emph on
feedback loops
\emph default
.
 Feedback loop means that an effect in one component, produces a chain of
 effects through several components, which again produce affect on the first
 component (therefore the name, feed back), which sometimes lead to continue
 the chain, sometimes leading the chain to not finish endlessly.
 From prespective of data or variables, a change in one variable causes
 transitively (through chain of changes) this same variable to again change
 its value causing again waves of changes.
\end_layout

\begin_layout Subsection
Complexity in programming
\end_layout

\begin_layout Plain Layout
Complexity in software development sometimes refers to 
\begin_inset Quotes eld
\end_inset

too many details for a human brain to manage without help.
 Overlooking just one small detail results in programs that may seem to
 work, but fail in surprising ways
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 In essence, as specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Introduction"
plural "false"
caps "true"
noprefix "false"

\end_inset

, adding a single formula, might lead to a cycle in the dependencies which
 causes unexpected feedback loop, which means that the application becomes
 like complex systems.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
—
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
recursion calls might produce unpredictability in contrast to the promise
 in FRP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This opens a challenge that a variable can be assigned multiple times, being
 bound to several expressions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For users it is also bad, since they are promted to specify input for fields
 they are not familiar with, or (or and) to discover a needed case against
 multiple general cases.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Finally, users are promted to specify input for fields they are not familiar.
 Default values do not address this issue adequately, as they are typically
 based on the general case rather than the specific input provided.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Plain Layout
real applications: integration between...
\end_layout

\begin_layout Plain Layout
code reuse
\end_layout

\begin_layout Itemize
code reuse
\end_layout

\begin_layout Itemize
fast add fields and computations
\end_layout

\begin_layout Itemize
fast delivery
\end_layout

\begin_layout Itemize
based on hosted programming langauge
\end_layout

\begin_layout Itemize
easy integration
\end_layout

\begin_layout Itemize
correct and fast updates
\end_layout

\begin_layout Itemize
decentralization
\end_layout

\begin_layout Itemize
efficietnly dependancy management
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Subsubsection*
Depedencies
\end_layout

\begin_layout Itemize
data depedencies
\end_layout

\begin_layout Itemize
source code depedancies
\end_layout

\begin_layout Subsubsection*
Abstraction
\end_layout

\begin_layout Plain Layout
Reactive instance variables has three abstraction levels.
\end_layout

\begin_layout Paragraph*
variable
\end_layout

\begin_layout Plain Layout
in the highest level reactive instance variable, represents a variable from
 the real world.
\end_layout

\begin_layout Paragraph*
stream
\end_layout

\begin_layout Plain Layout
in the mid level, reactive instance variable represent stream of values
 over time.
\end_layout

\begin_layout Paragraph*
event
\end_layout

\begin_layout Plain Layout
in the lowest level, reactive instance variable represent events triggered
 from external phenomena, e.g., change event from input control in a GUI.
\end_layout

\begin_layout Plain Layout
(The concept reactive instance variable harmonizes reactivity and dynamicity.
 Reactivity means like reactive variables that fields' updates trigger subsequen
t updates or that the fields are updates as reaction to other updates.
 Dynamicity means that the actual chain of updates are known only runtime.)
\end_layout

\begin_layout Plain Layout
Consider a framework, that objects (specicifed by classes) simulate real
 world objects, and their fields simulate the real variable of the real
 world objects.
 For example, consider the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Such applications are complex, since during the interaction, there might
 be unexpected feedback loops.
 The calculations defined in the objects create data dependency graphs.
 These dependancy graphs from the objects are then combined to form the
 overall dependancy graph.
 The graph might contains cycles which leads to the unexpected feedback
 loops.
 For instance, in the Drug Administration, the graph exhibits a cycle involving
 the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 This can potentially result an unexpected infinite loop, however even a
 single redundant update can be undesirable.
 If the feedback loop causes a variable to be updated, it can potentially
 override previous valid values, as the example illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Like this example, many other applications inherently support cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Another significant reason is to advance the flexibility in programming
 to design objects and components with well-defined responsibilities that
 align with changeable business needs.
 We focus on adding data dependencies to existing fields, unawaring of other
 data dependencies, because they are part of other components and related
 to other responsibilities.
 For example, a subclass that can access to fields 
\begin_inset Formula $\LSTINLINE X$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE Y$
\end_inset

 of its parent, adding there the calculation 
\begin_inset Formula $\LSTINLINE{X:=Y}$
\end_inset

.
 This might create a cycle in the data dependencies, because in the parent
 class, there might be a hidden calculation 
\begin_inset Formula $\LSTINLINE{Y:=X}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 Feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is defined as a system that its behavior as a whole is not
 predictable by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
The concept reactive instance variable harmonizes reactivity and dynamicity.
 Reactivity means like reactive variables that fields' updates trigger subsequen
t updates or that the fields are updates as reaction to other updates.
 Dynamicity means that the actual chain of updates are known only runtime.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 Feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is defined as a system that its behavior as a whole is not
 predictable by looking at each of its individual component separatedly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
Complex Systems and OOP are related, because both of them are used for modeling
 real world phenomena.
 However, while complex systems are related to when behavior as a whole
 is not predictable by looking at each of its individual component separatedly,
 OOP is known as a aradigm to create predictable applications, such that
 changing code in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
\end_layout

\begin_layout Plain Layout
We use OOP to simulate real-world but not the complexity of it.
 We adopt OOP to create predictable applications, such that changing code
 in one class has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
In order to find a resolution to cycles in data depedancies we consider
 feedback loops of complex systems.
 feedback loops (such that a change in one variable leads to a subsequent
 change that feeds back and affects the original variable itself.) is an
 inhereted property of complex systems, this is a core reason for making
 them complex.
 Complex system is a system that its behavior as a whole is not predictable
 by looking at each of its individual component separatedly.
 In the real world
\end_layout

\begin_layout Plain Layout
OOP is a paradigmbbo= to simulate complex systems.
 However, beside the use of OOP to simulate complex systems, OOP is used
 to create predictable applications, such that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
We introduce a framework, that objects (specicifed by classes) simulate
 real world objects, and their fields simulate the real variable of the
 real world objects.
 Phenomena from the real world, causes updates to fields that represent
 them.
 In our context, phenomena is produced by user interactions that fill values
 into input controls of a GUI.
 Once a field is updated, other fields are updated accordingly, making the
 whole values be consistent and simluate the variables they represent.
 Such framework do not simulate the complex interactions of the real world
 complex systems, therefore being complex is not a necessary condition.
 In the following, we introduce a method, that changing code in one class
 has minimum affect on other classes.
\end_layout

\begin_layout Plain Layout
To ilustrate the method, we introduce an example upon the 
\family typewriter
Order Entry
\family default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Motivation"
plural "false"
caps "true"
noprefix "false"

\end_inset

 (visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Class 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 represents a bag with fields Drug, Volume and Concentration.
 Class 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 represents a Pump that is connected to a patient to infuse a bag over time.
 Therefore it contains a reference to an instance of a 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and also contains fields Dose, Rate and Duration.
 It should be noted, that 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a relation to only Drug and Volume of its 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance, to make them consistent with the values of Dose and Rate.
 Therefore, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 has a fields type as 
\begin_inset Formula $\LSTINLINE{IBag}$
\end_inset

 that contains only Drug and Volume.
 This example ilustrates a composition, but in inheritance it is very similar,
 and can be applied as well.
\end_layout

\begin_layout Plain Layout
Before introducing the method, it should be noted that the introduced framework
 traditionaly seems as an inherettnly farmework to creating complex systems,
 because interactions between objects might cuase unintended feedback loops,
 or at least unintended updates.
 Consider that an update of Drug of a Bag (insatnces, but we skip saying
 that for short), that causes Pump to update Dose, then Rate, then Volume,
 then Concentration, and then it comes back to Drug.
 This is an unitended feedback loop.
 even in case that the interaction did not started with Drug, there might
 be an unidented update of Drug though an update of another field that causes
 Drug to re-compute even when it did not need to.
 This update might override by mistake a previous value.
 Consider (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

) that concentration it updated with a rounded value 0.33 that is computed
 from 100/300.
 This causes that a recomputation for Drug is of 0.33*300 which produces
 99, while this value has been created from 100, but only lost accuracy
 through the chain of computations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Reactive Instance Variables
\end_layout

\begin_layout Plain Layout
In the new approach, classes of OOP can contain reactive variables and associati
ons that establish data dependencies.
 This forms an interested framework, where classes can contain associations
 with fields according to their interface (i.e., the outer form), and without
 to be aware of other associations.
 We created an example for the 
\family typewriter
Order Entry
\family default
.
 In the example, 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 composes 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 with fields and relationships ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 contains calculations involving 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Concentration}$
\end_inset

, and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 contains calculations involving its variables: 
\begin_inset Formula $\LSTINLINE{Dose}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Rate}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, as well as the 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 of the 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 instance it contains.
 The calculations are defined by formulas as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:PumpCode-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, for the variables to recalculate according to changes in other variables.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A software application might be considered a 
\emph on
complex system
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://uwaterloo.ca/complexity-innovation/about/what-are-complex-systems
\end_layout

\end_inset

, when the behavior of the application as a whole might not be fully predictable
 by looking at each of its individual component separately.
 Instead, it's the interactions and dependencies between these components
 that give rise to the overall behavior and emergent properties of the applicati
on.
 The core reason for this inpredictability is the existense of 
\emph on
feedback loops
\emph default
, where the output or result of a process influences the initial input of
 that same process.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We focus on specific applications that the interactions are of variables
 values.
\end_layout

\begin_layout Plain Layout
/components consists of interacted objects.
 Each object contains calculations, that a change in one variable leads
 to a subsequent changes in other variables
\end_layout

\begin_layout Plain Layout
We focus on applications that consists of where each object contains 
\emph on
fields
\emph default
 and 
\emph on
calculations
\emph default
, with the relationships enabled in the OOP paradigm.
 Fields are similar to the objects attributes, but have chrachtisics similar
 to reactive variables.
 Accordignly, the calculations are formed like in FRP, in declaring pure
 functions over the fields, with the meaning of data dependencies.
\end_layout

\begin_layout Plain Layout
In handling applications' variables, the complexity and feedback loops are
 unexpected, where a change in one variable leads to a subsequent change
 that feeds back and affects the original variable itself.
 Therefore, we create a framework and semantics, to enable
\end_layout

\begin_layout Plain Layout
However, if we suppose an order for the value changes, then the values to
 feed back is not new, so it shuld not feedback.
 In addition, in the representation of variables as streams, can be used
 to provide predictability.
\end_layout

\begin_layout Plain Layout
each variable cosists of values over time, as a stream.
\end_layout

\begin_layout Plain Layout
Our approach contains two parts to
\end_layout

\begin_layout Plain Layout
However, we find that variables can be considered as streams that are predictabl
e according to
\end_layout

\begin_layout Plain Layout
we find that the change to feed back can be
\end_layout

\begin_layout Plain Layout
think that it should be predictable, so that each variable has a stream
 of its values over time, that is calculated by
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We creates a framework to use the recommended practices: designing of multiple
 objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that the separation to responsibilities are alligned to the changeable
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 With the various seperation options, the 
\emph on
superposition
\emph default
 property ensures that the behaviors produced by smaller objects are preserved
 when constructing larger composite objects.
 Formally, the behavior of a class is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 represents an instance of the class.
 For any given pair of classes 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, this property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 We specificaly focus on the challenge named 
\emph on
unexpected feedback loop
\emph default
,
\emph on
 
\emph default
where objects that have an effect from the environment causes a chain of
 effects which causes again an effect as the original one.
\end_layout

\begin_layout Plain Layout
We specificaly focus on the problem of unexpected feedback loops or redundant
 updates
\end_layout

\begin_layout Plain Layout
We do not have yet the mechanism to how to sum the behavior of a classes,
 however we do recognize unexpected feedback loops of redundant updates
 pose a challenge to achieving this property.
\end_layout

\begin_layout Plain Layout
However, in the context of calculations, redundant updates pose a challenge
 to achieving this property.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The inefficiency in the implemenations fields calculations experienced by
 legacy applications in the market lies in the time-consuming process of
 implementing changes.
 One contributing factor is the limited cognitive capacity of developers
 when it comes to analyzing the extensive details within the application
 source code, dealing with large code bases and code repetition.
 To address this, recommended practices emphasize the design of multiple
 objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Furthermore, the separation to responsibilities should be alligned to the
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Morever, The calculations within an object involve variables it directly
 holds, as well as variables from other objects it contains, or variables
 from its parent objects.
 This might create cycles in the data dependencies that leads to unexpected
 feedback loops that a change in one variable leads to a subsequent change
 that feeds back and affects the original variable itself.
\end_layout

\begin_layout Plain Layout
As a result, the defined behavior of objects, creates data dependency graphs
 being combined into the overall dependency graph.
 In this settings, feedback loops are unexpected: a change in one variable
 leads to a subsequent change that feeds back and affects the original variable
 itself.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Specificaly, we consider objects with the relationships enabled in OOP,
 where each object contains 
\emph on
fields
\emph default
 and 
\emph on
calculations
\emph default
.
 Fields are similar to the objects attributes, but have chrachtisics similar
 to reactive variables.
 Accordignly, the calculations are formed like in FRP, in declaring pure
 functions over the fields, with the meaning of data dependencies.
 For instance, the Drug Administration can be composed of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

, with fields and relationships ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The calculations within an object involve variables it directly holds, as
 well as variables from other objects it contains, or variables from its
 parent objects.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
As mentioned, during the interaction, there might be unexpected feedback
 loops.
 The associations defined in the objects create data dependency graphs.
 These dependancy graphs from the objects are then combined to form the
 overall dependancy graph.
 The graph might contains cycles which leads to the unexpected feedback
 loops.
 For instance, in the 
\family typewriter
Order Entry
\family default
, the graph exhibits a cycle involving the nodes 
\begin_inset Formula $\LSTINLINE{Duration}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{Volume}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{Drug}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycleByComponents-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Such cycles might potentially result like the mentioned unexpected infinite
 loops.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In contrast, the 
\emph on
superposition
\emph default
 property ensures that the behaviors produced by smaller objects are preserved
 when constructing larger composite objects.
 Formally, the behavior of a class is denoted as 
\begin_inset Formula $B(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 represents an instance of the class.
 For any given pair of classes 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, this property ensures that 
\begin_inset Formula $B(x_{1}+x_{2})=B(x_{1})+B(x_{2})$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In the new approach, cycles are essential for software development.
 Like in the 
\family typewriter
Order Entry
\family default
 application, there are many other applications that inherently support
 cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 However, the significant reason is to advance the flexibility in programming
 to design objects and components with well-defined responsibilities that
 align with changeable business needs.
 We focus on adding data dependencies to existing fields, unawaring of other
 data dependencies, because they are part of other components and related
 to other responsibilities.
 For example, a subclass that can access to fields 
\begin_inset Formula $\LSTINLINE X$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE Y$
\end_inset

 of its parent, adding there the calculation 
\begin_inset Formula $\LSTINLINE{X:=Y}$
\end_inset

.
 This might create a cycle in the data dependencies, because in the parent
 class, there might be a hidden calculation 
\begin_inset Formula $\LSTINLINE{Y:=X}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We borrow the 
\emph on
superposition
\emph default
 property from the field of complex systems.
 This property ensures that the behaviors produced by smaller objects are
 preserved when constructing larger composite objects.
 It is used to sum the behaviors.
 If the behavior of a class is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 represents an instance of the class, then for any given pair of classes
 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, this property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 We consider the behavior by counting the number of updates to the objects'
 variables as the phenomena, according to the sampling of variables from
 the environment.
 For instance, in the Drug Administration, an instance of 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that contains an instance of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 produce an exact amount of updates to the variables, the sum of the amounts
 from the individuals.
 We can illustrate examples by marble diagrams.
 The user set the Dose, Drug and Volume, the bag produce an update to the
 concentration...
\end_layout

\begin_layout Plain Layout
If an update is an effect from the objects interaction
\end_layout

\begin_layout Plain Layout
Even when updates are affected by the iteraction, we consider the update
\end_layout

\begin_layout Plain Layout
Even though an update in one causes to update
\end_layout

\begin_layout Plain Layout
according to from them both.
 The fact that they affect each other, does not break the principal, because
 if
\end_layout

\begin_layout Plain Layout
For instance, in the Drug Administration, an instance of 
\begin_inset Formula $\LSTINLINE{Pump}$
\end_inset

 that contains an instance of 
\begin_inset Formula $\LSTINLINE{Bag}$
\end_inset

 produce an exact amount of updates to the variables, the sum of the amounts
 from the individuals.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We need that the adding of data dependencies should be enabled in the subclasses
 and composites.
\end_layout

\begin_layout Plain Layout
The abstraction mechanisms that can be suggested to not clone components
 are the inheritance and composition from the OOP paradigm.
\end_layout

\begin_layout Plain Layout
Enabling the framework with a
\end_layout

\begin_layout Plain Layout
This framework with the enabled 
\emph on
superposition
\emph default
 property provides a new platform to use the recommended practices: designing
 of multiple objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that the separation to responsibilities are alligned to the changeable
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
We need that
\end_layout

\begin_layout Plain Layout
The above cause a paradox, in the one hand, the framework gives the option
 to clean code, but in the other hand, it cause infinite loops.
\end_layout

\begin_layout Plain Layout
In contrast to the inpredictable, we can handle the cycles to achive the
 superpositio property
\end_layout

\begin_layout Plain Layout
This framework aims to use the recommended practices: designing of multiple
 objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that the separation to responsibilities are alligned to the changeable
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
With the various seperation options, the 
\emph on
superposition
\emph default
 property ensures that the behaviors produced by smaller objects are preserved
 when constructing larger composite objects.
 Formally, the behavior of a class is denoted as 
\begin_inset Formula $F(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 represents an instance of the class.
 For any given pair of classes 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, this property ensures that 
\begin_inset Formula $F(x_{1}+x_{2})=F(x_{1})+F(x_{2})$
\end_inset

.
 We specificaly focus on the challenge named 
\emph on
unexpected feedback loop
\emph default
,
\emph on
 
\emph default
where objects that have an effect from the environment causes a chain of
 effects which causes again an effect as the original one.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use of reactive instance variables, embodies a paradigm shift aimed at supplanti
ng conventional procedural programming methodologies.
 The advantage and disadvantage in reactive instance variables is that origin
 of updates is, or should be, invisible.
 
\end_layout

\begin_layout Plain Layout
On one hand, invisibility of an origin of an update process constitutes
 a significant advantage.
 This feature facilitates the implementation of the separation of concerns
 principle, enabling decoupling of functional dependency from its constituents
 (i.e., reactive instance variables that composes the mentioned functional
 dependency).
 Instead, reactive instance variables reacts autonomously to external events
 or to updates of dependant reactive instance variables.
\end_layout

\begin_layout Plain Layout
However, this advantage is counterbalanced by a fundamental drawback: the
 potential for unpredictability arising from recursive interactions.
 In scenarios where reactive instance variables indirectly update themselves,
 the system's behavior becomes inherently unpredictable, posing challenges
 to comprehension and potentially compromising system stability.
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
Reactivity is a mechanism to replace tradiiotnal procedural programming.
 The advantage and disadvantage in reactivity is that the caller is, or
 should be, invisible.
 The advantage is the mechanism for applying seperation of concerns, because
 the functionality is decoupled from the caller, but instead behave in a
 fashion of reacting to external events.
 The disadvantage is inpredictability comin from cases when the caller indirectl
y calls to itself.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It is evident that whenever additional sources of values are required for
 the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 variable, it becomes necessary to update the assignment of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 variable.
 Overlooking such updates leads to inconsistencies between the values of
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
In order to enhance the Order Entry, it should be easy to make changes according
 to feedback from users.
 However, even in the small size Drug Administration, adding a single field
 requires adding it 5 times.
 
\end_layout

\begin_layout Plain Layout
The Drug Administration support several use-cases.
 For example, the user selects 
\begin_inset Quotes eld
\end_inset

set concentration and volume
\begin_inset Quotes erd
\end_inset

 and lock the Dose.
 In this case, Drug is computed from concentration and volume.
 The user can also lock volume, so that the volume will be computed according
 to the rate, and then the drug is computed from the concentration and volume.
 The are 5 diffrent options to how Drug is computed.
\end_layout

\begin_layout Plain Layout
In the Order Entry, there is a concept, we named 
\emph on
alter
\emph default
, that the user should be protected from documenting abnormal medication
 amount.
 If we add field Alert, to be calculated according to Drug, the code should
 be specified 5 times, according to the amount of options.
\end_layout

\begin_layout Plain Layout
If we add a field named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 indicates whether the application should trigger an alert for abnormal
 medication amounts.
 A formula is employed to establish a relationship between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

, enabling the automatic determination of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Alert}
\end_layout

\end_inset

 based on the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Amount}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
Adding a field that its value depend on the value of Drug, requires 
\end_layout

\begin_layout Plain Layout
In order to enhance the Order Entry, it should be easy to make changes according
 to feedback from users.
 However, even in The Drug Administration 
\end_layout

\begin_layout Plain Layout
However, even in the small example of the Drug Administration, changes seems
 hard.
\end_layout

\begin_layout Plain Layout
In implementing the Drug Administration, there are multiple use cases to
 handle.
 
\end_layout

\begin_layout Plain Layout
Regarding the 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 redandancy, the developers need to provide the application fast.
 In order to enhance the Order Entry, it should be easy to make changes
 according to feedback from users.
 However, even in the small example of the Drug Administration, changes
 seems hard.
\end_layout

\begin_layout Plain Layout
Considering a procedural solution, a procedure 
\begin_inset Formula $\LSTINLINE{calculate}$
\end_inset

, depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, keeps values of the fields consistent, .
 This procedure is called whenever the user updates the value of any of
 the fields.
 Depending on the fields that the user edits, the other fields are calculated.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume2}
\end_layout

\end_inset

 are the same.
\end_layout

\begin_layout Plain Layout
Beside the issue that values are calculated, even when their fields are
 unchanged, statements are repeated.
 as seen in 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
The code repetition reduces the user experience.
 In order to enhance the Order Entry, it should be easy to make changes
 according to feedback from users.
 However, code repetition makes the changes be difficult, because code repetitio
n leads to continue the repetition also in the changes.
 This expands the change be repaeted accoding to the existing repetition.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

If edited triple is of Dose,  Duration, and Volume
\end_layout

\begin_layout Plain Layout

  Drug = Dose*Duration
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/Volume |
\backslash
label{line:concentrationByDrugAndVolume1}|
\end_layout

\begin_layout Plain Layout

  Rate = Volume/Duration
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Drug, Dose, and Rate
\end_layout

\begin_layout Plain Layout

  Duration = Drug/Dose
\end_layout

\begin_layout Plain Layout

  Volume = Duration*Rate 
\end_layout

\begin_layout Plain Layout

  Concentration = Drug/Volume |
\backslash
label{line:concentrationByDrugAndVolume2}|
\end_layout

\begin_layout Plain Layout

Else If edited triple is of Concentration,  Volume, and Duration
\end_layout

\begin_layout Plain Layout

  Drug = Volume*Concentration
\end_layout

\begin_layout Plain Layout

  Rate = Volume/Duration 
\end_layout

\begin_layout Plain Layout

  Dose = Drug/Duration
\end_layout

\begin_layout Plain Layout

End If
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Centerlized-Calculation-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drug administration calculation.
\end_layout

\end_inset

Drug administration calculation.
 The code shows how to calculate the values of the fields based on different
 combinations of three input fields.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The add of the elements increaes the Cognitive load not only for the users
 but also for the developers.
 ForAny Redandant element 
\end_layout

\begin_layout Plain Layout
To ensure a positive user experience, UX researchers must gather continuous
 feedback from the application's users.
 They should conduct A/B testing by creating multiple variants for a single
 feature and analyze the best one based on the statistical results collected
 from the users 
\begin_inset CommandInset citation
LatexCommand cite
key "hartson2012ux"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
However, in traditional applications, it is difficult to make UX processes.
 This is because that over time, the applications code become hard to change,
 or that it takes more time to do the changes 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 We face procedural programming with long chain of updates, where changing
 the source code of one component might lead to subsequent changes in the
 source code of other components, producing long chain of code updates.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In one of the approaches, the delivery speed is improved by seperating the
 applications for small size components.
 However, as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

, new calculations for existing fields (establishing dependencies to update
 fields based on changes in other fields) are required to be in the same
 component to ensure that the calculations are correct, that there are no
 cycles, or that cycles are handled correctly.
 (in order to establish transitive dependencies, if we should ensure that
 there is no cycle, we should stay in the same component)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Over the frameworks, it is challenged to coordinate the field calculation
 behaviors, particularly when establishing dependencies to update fields
 based on changes in other fields.
 This process requires careful consideration of transitive dependencies.
 Otherwise, unintentional recursion can lead to unexpected updates.
 For predictable addition of calculations, it is required that they be in
 the same class or component to ensure that the calculations are correct,
 that there are no cycles, or that cycles are handled correctly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Plain Layout
This thesis is motivated by the necessity to enhance the calculation mechanism
 in the field in three aspects: (1) adding redundant filling options, (2)
 reducing cognitive loads caused by extra fields and navigations resulting
 from poor designs, and finally, (3) improving delivery speed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Adding redundancies in the user interfaces have the cost of the need to
 keep on the consistency of the values according to the user input.
 However, according to the exploration, this might require redundancies
 in the code, with the cost of the need to keep on its consistency.
 This problem leads us to reduce redundancies in the user interfaces, although
 it may improve their usability.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, that the developers need to keep on its consistency
\end_layout

\begin_layout Plain Layout
An efficient mechanism promotes the use of redundancies in the user interfaces.
 However this causes the time-consuming process of implementing changes.
 One contributing factor is the limited cognitive capacity of developers
 when it comes to analyzing the extensive details within the application
 source code.
 Another factor is the need to keep on the rules consistency, in case that
 the coded rules are repeated.
 The two factors depend on code repetition which might always exist.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There are some reasons to list in favor of redundancies.
 Generaly, human brain consider wgited information.
 sats 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 is diffrent that sayg 
\begin_inset Quotes eld
\end_inset

no no
\begin_inset Quotes erd
\end_inset

.
 In addition, we have mutiple channels of information, and we use the one
 that is easier for us in the specific case.
 For instance, in Drug Administration with the fields 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 Sometimes it is easier to administaer the drug by the volume and concentration.
 Then he or she need to calculate the values for the drug to get the desired
 concentration.
 
\end_layout

\begin_layout Plain Layout
In addition, the people are difffrent.
 There are people taht some chanels are waeker than the other chanel.
 That people find it easier to use one channel more the other.
 We used to validate ouself by the use of the diffrent chanels with cross
 checking.
\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
For instance, in Drug Administration, there are drugs, where it is easier
 to set the 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in others it is easier to set by the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In case that there are only the fields for 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, for a desired 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 the user need to calculate what values to fill.
\end_layout

\begin_layout Plain Layout
Actualy we recognize the technalogy SSOT
\end_layout

\begin_layout Plain Layout
Humans have much more complex brain, that takes decision based on weights
 data.
 Says 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 in human is not the same as saying 
\begin_inset Quotes eld
\end_inset

no no
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
which works resulary against need Redundancies by nature.
\end_layout

\begin_layout Plain Layout
We need sometimes to repeat messages
\end_layout

\begin_layout Plain Layout
In front ends the two sides should interact
\end_layout

\begin_layout Plain Layout
For computers, Redundancies in data might lead to inconsistency, because
 
\end_layout

\begin_layout Plain Layout
Redundancies in front ends applications might lead to Cognitive loads, 
\end_layout

\begin_layout Plain Layout
Redundancies in front ends applications improves the usability, because
 the user is not enforced to one strict representation.
 For instance, in Drug Administration, there are drugs, where it is easier
 to set the 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, while in others it is easier to set by the 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

.
 In case that there are only the fields for 
\begin_inset Formula $\NAME{Drug}$
\end_inset

 and 
\begin_inset Formula $\NAME{Volume}$
\end_inset

, for a desired 
\begin_inset Formula $\NAME{Concentration}$
\end_inset

 the user need to calculate what values to fill.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As from this exploration, we could not provide one single source of truth
 for the organization's business logic, because we could not prevent the
 repetition of business logic.
\end_layout

\begin_layout Plain Layout
In the explored architectural designs, we could not provide one single source
 of truth for the organization's business logic, because we could not prevent
 the repetition of business logic.
 We recognize in the exploration three patterns of code duplication.
 First, calling to update variables in various locations, such as in response
 to events.
 Second, multiple variables to represent a single real-world variable.
 Finaly, cloning code to not affect existing clients.
 
\end_layout

\begin_layout Section
Code Reuse
\end_layout

\begin_layout Plain Layout
we recognize in the exploration three patterns of code duplication.
 First, calling to update variables in various locations, such as in response
 to events.
 Second, multiple variables to represent a single real-world variable.
 Finaly, cloning code to not affect existing clients.
\end_layout

\begin_layout Plain Layout
The abstraction mechanisms that can be suggested to not clone components
 are the inheritance and composition from the OOP paradigm.
 However, as it has long been recognized 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

, there is a challenge in managing data dependencies between parent and
 child classes (similary is the case in composition).
 When classes and their subclasses maintain their own variables, there is
 a risk of 
\emph on
object re-entrance
\emph default
, where an object indirectly calls another object that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 
\end_layout

\begin_layout Plain Layout
To avoid such problems, developers need to carefully define contracts between
 classes and their subclasses, to the consumers of services or any components-ba
sed technalogy.
\end_layout

\begin_layout Plain Layout
It is recommeneded to design them with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities will be aligned with the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Our approach effectively addresses the issue of inheritance 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, which has long been recognized as a challenge in managing data dependencies
 between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

.
 When classes and their subclasses maintain their own variables, there is
 a risk of 
\emph on
object re-entrance
\emph default
, where an object indirectly calls another object that then calls it back.
 In subsequent calls, the variables may be inconsistent because the execution
 has not finished.
 To avoid such problems, developers need to carefully define contracts between
 classes and their subclasses.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Plain Layout
In the explored architectural designs, we could not prevent the repetition
 of business logic.
 This means that there is no one single source of truth for the organization's
 business logic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Reusable components reduce code redandcy in case of creating applications
 based on existing ones.
\end_layout

\begin_layout Plain Layout
Therefore, it is highly preferable to design reusable components.
 This is where our framework, with its dedicated propagation algorithm,
 outperforms constraint systems for GUI.
 We have specifically created examples
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RivkaAltshuler/RIvar
\end_layout

\end_inset


\end_layout

\end_inset

 for reusable classes and user controls.
 In contrast, when using Hotdrink, we generate a single block of code that
 is managed by a centralized algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An efficient mechanism need to inherently support for developing business
 rules without repetition, as a 
\emph on
single source of truth
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The programming paradigms inherently lack robust support for developing
 business rules without repetition.
 Consequently, it is challenged to establish a single source of truth for
 business rules.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The programming paradigms do not inherently offer robust support for developing
 business rules without repetition.
 Consequently, the organizations lack the option to establis a 
\emph on
single source of truth
\emph default
 for them.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The programming paradigms inherently lack robust support for developing
 the business rules as a unified source of truth.
\end_layout

\begin_layout Plain Layout
Developing the business rules as a 
\emph on
single source of truth
\emph default
 is not basicly supported by the programming paradigms.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
According to our exploration, by the modeling tools offered by programming
 paradigms, it 
\end_layout

\begin_layout Plain Layout
In our exploration we failed to develop 
\end_layout

\begin_layout Plain Layout
According to our exploration, the modeling tools offered by programming
 paradigms
\end_layout

\begin_layout Plain Layout
None of the used modeling tools offered by programming paradigms, could
 develop the business rules as a 
\emph on
single source of truth.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the various modeling options, we could not prevented from repeating business
 logic.
 This means, no one 
\emph on
single source of truth
\emph default
 (SSOT) for the organizations' business logic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
might lead to an infinite loop.
 We mentioned this in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in the term of accidental recursions.
 For example, if we need to add the functionality that 
\begin_inset Formula $\LSTINLINE{X:=Y}$
\end_inset


\end_layout

\begin_layout Plain Layout
In adding a calculation such as 
\begin_inset Formula $\LSTINLINE{X:=Y}$
\end_inset

, there might be that this addition causes a cycle in the dependencies.
\end_layout

\begin_layout Plain Layout
it can be done by creating a new component that inherits the existing one
 and 
\end_layout

\begin_layout Plain Layout
without modifying or impacting the existing clients.
 
\end_layout

\begin_layout Plain Layout
that the busines changes requires in case that the busines clients need
 we do not need to change existing components.
\end_layout

\begin_layout Plain Layout
Instead of cloning components, 
\end_layout

\begin_layout Plain Layout
In order to to provide a component, that is based on existing component
 without modifying or impacting the existing clients, with an added calculation,
 for example, 
\begin_inset Formula $\LSTINLINE{X:=Y}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Essentially in FRP, 
\end_layout

\begin_layout Plain Layout
In case that we have a component with a variable
\end_layout

\begin_layout Plain Layout
Inheritance is the concept to always enable to provide a component that
 is based on existing component without modifying or impacting the existing
 clients.
 
\end_layout

\begin_layout Plain Layout
If the business needs, to always enable to inherit components without to
 affect exsting clients.
\end_layout

\begin_layout Plain Layout
It might be the business needs, to always enable to inherit components without
 to affect exsting clients.
 In cases that there is no support to do the inheritance, this has the side
 effect of cloning components.
\end_layout

\begin_layout Plain Layout
Essentially, in order to support to enable always to inherit components,
 we need to enable adding a source of values to an existing variable.
\end_layout

\begin_layout Plain Layout
Essentially, there is a problem to always enable to inherit components.
 
\end_layout

\begin_layout Plain Layout
In case that there exists a component with ex, with a variable or a field
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
It is the recommended practices to design of multiple objects and components
 with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities be alligned to the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
 It might be the business needs, to always enable to inherit components
 without to affect exsting clients.
 This has the side effect of cloning components.
\end_layout

\begin_layout Plain Layout
————
\end_layout

\begin_layout Plain Layout
In the model of constraints, cloning a component is the only way to provide
 a component based on existing component without modifying impacting the
 existing clients.
\end_layout

\begin_layout Plain Layout
We need to create components based others without modifying impacting the
 existing clients.
\end_layout

\begin_layout Plain Layout
Recommended practices emphasize the design of multiple objects and components
 with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Furthermore, the separation to responsibilities should be alligned to the
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
We need to create components based others without modifying impacting the
 existing clients.
\end_layout

\begin_layout Plain Layout
The most important aspect, is that we can inherit existing components, not
 cloning them.
 For this reason, we find that the model of constraints, altough that it
 provides SSOT for the business logic, it is unless there is the need to
 clone the entire application.
 
\end_layout

\begin_layout Plain Layout
The created components by the use of Hotdrink cannot be inherited.
 Similary
\end_layout

\begin_layout Plain Layout
In case that we has 
\end_layout

\begin_layout Plain Layout
we need to create components based others without modifying impacting the
 existing clients.
 We need also to not clone and create the changes, because 
\end_layout

\begin_layout Plain Layout
Recommended practices emphasize the design of multiple objects and components
 with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Furthermore, the separation to responsibilities should be alligned to the
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
It is the business needs to create components based others without modifying
 impacting the existing clients.
 It is the busines needs to not clone and create the changes, because 
\end_layout

\begin_layout Plain Layout
In the case of Hotdrink, that we cannot we need to clone the existing codebase
 and then making the necessary changes to the new application.The business
 needs is to not 
\end_layout

\begin_layout Plain Layout
According to the business needs, if there is a component, that has usages/client
s, we do not want to change it to not impact the existing usages.
 
\end_layout

\begin_layout Plain Layout
———–
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the time-consuming process of implementing changes.
 Repeating on code resists against the code changes for two reasons: First,
 because efforts need to be keep on the rules consistency.
 Second, it adds more lines of code to the application.
 In the explored designs, we tried to not repeating on the business logic.
 Unfortunatly, even for this basic sample application, the exploration did
 not suggested an architetural design with a single source of truth to the
 business rules.
\end_layout

\begin_layout Plain Layout
Throughout the exploration, we find that In spreadsheets, it save from repeating
 to call functions to update variables as done traditionaly.
 furthrenore, in constraints, it save from repeating variables.
 However, it might worth nothing, if it leads to clone an entire component
 or application.
 if we need to create another application based on an existing one without
 modifying impacting the existing clients, we need to clone the existing
 codebase and then making the necessary changes to the new application.
\end_layout

\begin_layout Plain Layout
The recommended practices emphasize the design of multiple objects or components
 with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, and that the separation to responsibilities be alligned to the business
 needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the explored designs, we tried to not repeating on the business logic.
 This is because code repetition leads to inefficiency.
\end_layout

\begin_layout Plain Layout
In spreadsheets, it save from repeating to call functions to update variables
 as done traditionaly.
 furthrenore, in constraints, it save from repeating variables.
\end_layout

\begin_layout Plain Layout
———-
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the time-consuming process of implementing changes.
 Repeating on code resists against the code changes for two reasons: First,
 because efforts need to be keep on the rules consistency.
 Second, it adds more lines of code to the application.
 However, Even for this basic sample application, the exploration did not
 suggested an architetural design with a single source of truth to the business
 rules.
 
\end_layout

\begin_layout Plain Layout
—————
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the time-consuming process of implementing changes.
 The effort to change consists of analyzing or understanding the application
 source code, and also keeping on the consistency of the logic.
\end_layout

\begin_layout Plain Layout
Even for this basic sample application, the exploration did not suggested
 an architetural design with a single source of truth to the business rules.
 The repeatition resists against the code changes for two reasons.
 First, because efforts need to be keep on the rules consistency.
 Second, it adds more lines of code to the application.
\end_layout

\begin_layout Plain Layout
——
\end_layout

\begin_layout Plain Layout
The inefficiency experienced by legacy applications in the market lies in
 the time-consuming process of implementing changes.
 One contributing factor is the limited cognitive capacity of developers
 when it comes to analyzing the extensive details within the application
 source code.
 However, even for this basic sample application, the exploration did not
 suggested an architetural design with a single source of truth to the business
 rules.
\end_layout

\begin_layout Plain Layout
In the explored design options, we could not created a single source of
 truth to the business rules.
\end_layout

\begin_layout Plain Layout
throughout the exploration, we recognize the avaiable mechanisms to not
 repeat on code.
 The concept used in spreadsheets are trending now.
 It save from repeating to call functions to update variables as done traditiona
ly.
 
\end_layout

\begin_layout Plain Layout
n spreadsheets, it save from repeating to call functions to update variables
 as done traditionaly.
 furthrenore, in constraints, it save from repeating variables.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To address this, recommended practices emphasize the design of multiple
 objects and components with well-defined responsibilities 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Furthermore, the separation to responsibilities should be alligned to the
 business needs 
\begin_inset CommandInset citation
LatexCommand cite
key "evans2004domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Cloning
\end_layout

\begin_layout Plain Layout
that there exists a compoent, and we need changes, so we clone it, to not
 impact existing users.
\end_layout

\begin_layout Subsection
Cloning
\end_layout

\begin_layout Plain Layout
It is very basic in programming, the concept to extend existing applications
 without to modify them, to not impact existing usages.
 For this reason, the events paradigm are common.
 Applications expose events, to execute things as part of internal executions.
\end_layout

\begin_layout Plain Layout
This is usualy done by exposing events,
\end_layout

\begin_layout Plain Layout
In order to extend an exsting application instead of creating another applicatio
n
\end_layout

\begin_layout Plain Layout
If there is a need to 
\end_layout

\begin_layout Plain Layout
An application or component that need a change.
 If
\end_layout

\begin_layout Plain Layout
If we need to create another application based on an this one without modifying
 impacting the existing clients, we need to clone the existing codebase
 and then making the necessary changes to the new application.
\end_layout

\begin_layout Plain Layout
If an exsting
\end_layout

\begin_layout Plain Layout
When we say 
\emph on
cloning
\emph default
, we mean that there exists a certain application or component, that has
 existing clients.
 
\end_layout

\begin_layout Plain Layout
the events paradigm should help to extend existing applications
\end_layout

\begin_layout Plain Layout
In the explored design options, we could not prevented from repeating business
 logic.
 This has the meaning, that there is no one single source of truth for the
 organizations' business logic.
 
\end_layout

\begin_layout Plain Layout
In the basic procedural programming, 
\end_layout

\begin_layout Plain Layout
The exploed design options use the avable abstractions mechanisms that reduce
 one
\end_layout

\begin_layout Plain Layout
When we use an abstraction mechanism, 
\end_layout

\begin_layout Plain Layout
We use abstraction mechanism
\end_layout

\begin_layout Plain Layout
In the basic procedural programming, we recognize the repeat of 
\end_layout

\begin_layout Plain Layout
We recognize three types of repeation, that we recognize.
 First, 
\end_layout

\begin_layout Section
Reactive Programming
\end_layout

\begin_layout Plain Layout
However, also in using 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Alternatives
\end_layout

\begin_layout Plain Layout
One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, the visual fields can be connected to reactive variables.
 In frameworks such as React, the view can be continuously updated by the
 framework.
\end_layout

\begin_layout Plain Layout
The drug administration application contain fields, in such that a field
 is sometimes useful to fill it directly by the user, while the same field
 can be usefull to be computed according to ther fields that the user filled.
 However, reactive variables are classified into input and output categories.
 In spreadsheet, a cell can either contain a formula or a value.
 Similary in MobX, the property can have either an observable annotation
 or computed annotation.
 typicaly, there is a need to duplicate fields or sets of related fields.
 For example, making several drug administration forms.
 The user then should choose the needed form, before filling the form out.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the existing mechanisms, maintaining functionality becomes challenging
 when there is a significant number of calculations involved, especially
 that the codebase grows with repeated code segments.
 For instance, as illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, if the dose, duration, and volume have changed, then the drug, concentration,
 and rate are calculated.
 If the drug, dose, and rate have changed, then the duration, volume, and
 concentration are calculated, and so on.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Spreadsheets is a popular application that provide a limited functionality
 to fields calculations.
 Each cell, representing a field, can contain either a formula or a value.
 However, this leads to duplication, as in the drug administration, it leads
 to implement several modes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
available in https://github.com/RIVarX/Evaluation/blob/main/duplicate_solutions.xl
sx
\end_layout

\end_inset

.
 In the first mode, users set the concentration, volume, and duration, and
 the other fields are calculated.
 In the second mode, users set the dose, rate, and duration, and once again,
 the other fields are calculated.
 This pattern can continue for additional modes, adding redundancy across
 the different modes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Unpredictable Calculation
\end_layout

\begin_layout Plain Layout
In the original application, the calculation is centerlized.
 Whenever a user sets a new value to any of the fields, a calculation procedure
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Centerlized-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

) is executed.
 The procedure consists of branches according to the user-cases, in each
 branch there are three values being used to calculate the other values.
 
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Plain Layout
We tried to seperate an application unsuccessfully.
 The calculations are defined separately in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 Also the runtime is seperated, managing the updates on top of the objects'
 interactions (standard calls).
 But the resulted calculations does not fit the requirements.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The following UI application (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations"
plural "false"
caps "true"
noprefix "false"

\end_inset

) handles drug administration.
 It observes the fields' change events, once a value is changed, dependant
 fields are calculated and presented.
 The application is a prototype of a small part from an existing application.
 The goal is to reduce the complexity existing in the traditional application.
\end_layout

\begin_layout Plain Layout
In order to simplify the application, we seperate the model to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Also the UI is seperated to micro-frontends 
\begin_inset CommandInset citation
LatexCommand cite
key "peltonen2021motivations"
literal "false"

\end_inset

 respectively.
 The architectural design is illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 refers to giving 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}'s content
\end_layout

\end_inset

.
 injecting medicines into a patient's bloodstream.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, inner sep=0pt, label=center:Bag micro-frontend]
 (C) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,3.5) (4,5.5)}, xshift=6cm, inner sep=0pt, label=center:Pump
 micro-frontend] (D) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, inner sep=0pt, label=center:Bag Domain Object]
 (A) {};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, fit={(0,0) (4,2)}, xshift=6cm, inner sep=0pt, label=center:Pump
 Domain Object] (B) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(B) node[anchor=south,inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (A)--(C) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (D)--(B) node[inner sep=2pt,midway] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Design of the drug administration application, showcasing observer interaction
 through dashed lines.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Drug Administration Data Model
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 refers to a medical device used to deliver fluids with medication into
 a patient’s body in a controlled manner.
 Accordingly, we model 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 class with contained 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 representing the connected bag, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 relates to amount of medication administered to a patient, (e.g.
 100 mg).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 relates to the fluid volume mixed with the drug (e.g., 300 ml).
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains the data related to giving the bag's content over time.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

 relates to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 flow administered into the patient’s body per time unit (e.g., 30 ml per
 hour).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 relates to the dosage, which is the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 administered into the patient’s body per time unit (e.g., 10 mg per hour).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 relates to the duration from starting the injection until stopping it.
 According to the architectural design and as visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the fields in the user interface can trigger changes to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 which trigger changes also to the bag.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 interacts with the bag indirectly using an interface.
\end_layout

\begin_layout Plain Layout
In order to achive our goal to seperate the drug administration model, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 and its bag will be loosely coupled.
 The bag will be defined as an interface, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 will only send messages to it, to update 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

.
 Such as example is visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Calculation-spread-over-objects-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 send a message to the bag, it should not be aware of any internal information
 related to the bag.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

, in addition to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

, contains also 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

 relating to the amount of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 per 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 (e.g.
 0.33 mg/ml).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 should not be aware of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Concentration}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 interacts with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 by the interface it is implemented, named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 The data model and the relationships are visualized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-3"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}   
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Calculation-spread-over-objects-1"

\end_inset

Calculation procedure spread over seperated objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In order to update existing fields according to other fields, we need
\end_layout

\begin_layout Plain Layout
Front ends applications typicaly invovles behavior like reactive variables.
 Specificaly in the following drug administration example, the UI component
 contains six fields: The "Drug" field specifies the amount of medication
 administered to the patient (e.g., 100 mg).
 The "VolumeOfFluid" field indicates the volume of fluid mixed with the
 drug (e.g., 300 ml).
 The "Concentration" field represents the amount of the drug per unit volume
 of fluid (e.g., 0.33 mg/ml).
 The "Rate" field specifies the flow rate of the fluid into the patient's
 body per unit of time (e.g., 30 ml per hour).
 The "Dose" field represents the dosage, which is the amount of drug administere
d to the patient's body per unit of time (e.g., 10 mg per hour).
 The "Duration" field indicates the duration of the injection, from start
 to end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 However, typically, the data dependency graphs produced by this type of
 application are more complex than the typical graphs handled in the field.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 the duration depends on the volume (and rate), which depends on the drug
 (and concentration), which in turn depends again on the duration (and dose).
 The components behavior are indepedently, so the behavior is inpredictable.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{sequencediagram}     
\end_layout

\begin_layout Plain Layout


\backslash
newthread{UI}{User Interface}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[1]{Pump}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
newinst[2]{Bag}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Duration=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{Drug=100}{Bag}{}     
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Dose=10}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}      
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{UI}{VolumeOfFluid=300}{Bag}{} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Concentration=0.33}{Bag}{}    
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Drug=99}{Bag}{}  
\end_layout

\begin_layout Plain Layout


\backslash
end{call} 
\end_layout

\begin_layout Plain Layout


\backslash
end{call}
\end_layout

\begin_layout Plain Layout


\backslash
begin{call}{Bag}{Rate=30}{Pump}{}     
\end_layout

\begin_layout Plain Layout


\backslash
end{call}        
\end_layout

\begin_layout Plain Layout


\backslash
end{call}   
\end_layout

\begin_layout Plain Layout


\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Calculation-spread-over-objects-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
A sequence diagram for the drug administration behavior.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

The drug administration behavior is represented by a sequence diagram, which
 is divided into two objects or microfrontends.
 The task of performing calculations is shared between the 
\backslash
lstinline{Pump} and 
\backslash
lstinline{Bag}.
 Initially, the user specifies a 
\backslash
lstinline{Dose} of 10 and a 
\backslash
lstinline{Duration}.
 In response, the 
\backslash
lstinline{Drug} is calculated to be 100.
 Next, the user sets the 
\backslash
lstinline{VolumeOfFluid} to 300, which causes the 
\backslash
lstinline{Concentration} to be calculated as 0.33.
 However, the subsequent calculation of 
\backslash
lstinline{Drug} unexpectedly results in 99.
 This unpredictability can be attributed to two factors.
 Firstly, during the update of 
\backslash
lstinline{Concentration}, the value of 100/300 was rounded, leading to the
 loss of information in the process.
 This caused 
\backslash
lstinline{Concentration} to be calculated as 0.33, and consequently, 
\backslash
lstinline{Drug} was calculated to be 99.
 Secondly, there was a cycle in which 
\backslash
lstinline{Concentration} was updated based on 
\backslash
lstinline{Drug}, which was in turn updated based on 
\backslash
lstinline{Concentration}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We use the simple drug administration example, ilustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-calculations-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

The example is a UI component that contains 6 fields.
 The field 
\backslash
lstinline{Drug} specifies the amount of medication administered to the patient,
 for example, 100 mg.
 The field 
\backslash
lstinline{VolumeOfFluid} indicates the volume of fluid mixed with the drug,
 for example, 300 ml.
 The field 
\backslash
lstinline{Concentration} represents the amount of the drug per unit volume
 of fluid, for example, 0.33 mg/ml.
 The field 
\backslash
lstinline{Rate} specifies the flow rate of the fluid into the patient's
 body per unit of time, for example, 30 ml per hour.
 The field 
\backslash
lstinline{Dose} represents the dosage, which is the amount of drug administered
 to the patient's body per unit of time, for example, 10 mg per hour.
 The field 
\backslash
lstinline{Duration} indicates the duration of the injection, from the start
 to the end.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The drug administration UI component need to be seperated into two UI components
: the pump and the bag.
 The bag contains the drug, volume, and concentration, while the pump contains
 an instance of the bag along with the fields for dose, rate, and duration.
 Consequently, to create a different variant of the drug administration,
 we don't need to duplicate the entire component.
 Instead, we can create two types of bags: one that includes concentration
 and one that doesn't.
 By duplicating only the bag, we reduce code redundancy and make future
 changes easier.
 If we had duplicated the entire component, any updates to the pump would
 require making changes in two places.
\end_layout

\begin_layout Plain Layout
The fields need to behaves similar to reactive variables.
 For example, consider the field "Concentration" which represents the amount
 of a drug per unit volume.
 Similar to reactive variables, this field should be recalculated in response
 to updates in the "Amount" and "Volume" values.
 In order, to keep on the specified design, we need that each component
 implement its internal coherence behavior.
 For instance, in the pump component, it should be specified, that the Amount
 of the bag, should be recalculated according to the Dose and Duration.
 In the same time, other specifications that is related intenaly to bag
 remain hodden.
 For instance, that the concentration is recalculated in response to updates
 in the "Amount" and "Volume".
\end_layout

\begin_layout Plain Layout
By spedifiing behavior similar to reactive variables, we initiate a depedancy
 graph.
 For example, in specifiing Concentration to update based on "Amount" and
 "Volume" values, we iniate a dependency, that concentration depends on
 amount and volume.
 As the components specified such behavuier privetly, each contains privately
 a depedency graph, according to its specified behavior.
 while the runtime, the epedency graph is composed from the two components.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Seperation
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The fields in the example need to be similar to reactive variables.
 For example, consider the field "Concentration" which represents the amount
 of a drug per unit volume.
 Similar to reactive variables, this field should be recalculated in response
 to updates in the "Amount" and "Volume" values.
 One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, the visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Redandantancy
\end_layout

\begin_layout Plain Layout
in the code->need to mainain it, when we need to add or update code, that
 have
\end_layout

\begin_layout Plain Layout
in variables/calculations, it might be heavy executions
\end_layout

\end_inset


\end_layout

\begin_layout Section
Redandant Code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The fields in the example need to be similar to reactive variables.
 For example, consider the field "Concentration" which represents the amount
 of a drug per unit volume.
 Similar to reactive variables, this field should be recalculated in response
 to updates in the "Amount" and "Volume" values.
 In various programming environments, including JavaScript, a similar behavior
 can be achieved by associating code with a change event for a specific
 field.
 This code will be triggered and executed whenever there is a modification
 to the field's value 
\begin_inset CommandInset citation
LatexCommand cite
key "mdn-change-event"
literal "false"

\end_inset

.
 For example, to recalculate the Concentration when the "Amount" and "Volume"
 values are updated, we can register the code responsible for updating the
 Concentration within the change events associated with the "Amount" and
 "Volume" fields.
\end_layout

\begin_layout Plain Layout
The example need to be seperated into two UI components: the pump and the
 bag.
 The bag contains the drug, volume, and concentration, while the pump contains
 an instance of the bag along with the fields for dose, rate, and duration.
 Consequently, to create a different variant of the drug administration,
 we don't need to duplicate the entire component.
 Instead, we can create two types of bags: one that includes concentration
 and one that doesn't.
 By duplicating only the bag, we reduce code redundancy and make future
 changes easier.
 If we had duplicated the entire component, any updates to the pump would
 require making changes in two places.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The fields in the example need to be similar to reactive variables.
 For example, consider the field "Concentration" which represents the amount
 of a drug per unit volume.
 Similar to reactive variables, this field should be recalculated in response
 to updates in the "Amount" and "Volume" values.
 One common tool for implementing this functionality is a spreadsheet.
 In spreadsheets, a cell represents a field and can contain a formula that
 defines its dependency on other cells.
 Alternatively, the visual fields can be connected to reactive variables.
 For instance, MobX provides a framework to implement reactive variables
 as a state management solution to integrate with React.
 React provide a framework that continuously update the view, containing
 the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In implementing the example by reactive variables, each reactive variable
 is classified into either 
\emph on
input
\emph default
 or 
\emph on
output
\emph default
 categories, often resulting in duplications.
 For instance, in spreadsheets, a cell can contain either a formula or a
 value.
 This leads to implement several modes to the drug administration.
 In the first mode, users set the concentration, volume, and duration, and
 the other fields are calculated.
 In the second mode, users set the dose, rate, and duration, and once again,
 the other fields are calculated.
 This pattern can continue for additional modes, but has redundancy across
 the different modes.
\end_layout

\begin_layout Plain Layout
In implementing the example without reactive variables, we can customize
 the updates by using visual field change events.
 For instance, as illustrated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Centerlized-Calculation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, if the dose, duration, and volume of fluid have changed, then the drug,
 concentration, and rate are calculated.
 If the drug, dose, and rate have changed, then the duration, volume, and
 concentration are calculated, and so on.
 However, this method also introduces redundancy, as seen in 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume1}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:concentrationByDrugAndVolume2}
\end_layout

\end_inset

 where the same statement is repeated.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
