#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Related-Work"

\end_inset

Related Work
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
what about distributed FRP, that we have decntralized algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Section
FRP
\end_layout

\begin_layout Paragraph
Cycles
\end_layout

\begin_layout Standard
It should be mention (in addition to all other mentions over this thesis)
 that two opposing methods have been previously presented regarding cycles.
 In the first method, cycles are avoided, because the paradigm derived from
 the functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 In the second method, forbidding cycles makes FRP unacceptably weak, because
 many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We mentioned traditional method used to address cycles.
\end_layout

\begin_layout Plain Layout
In such applications, we can plan the dependencies following each input
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
FRP runtimes that support cycles uses various techniques to stop arisen
 loops.
 Terminating when it closes a cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, adding to the language a special operator to inform the runtime when to
 break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

, stop after a number of iterations, stop if the value has not changed,
 or changed only less than a threshold (available in 
\family typewriter
Microsoft Excel
\family default
)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
 The various methods are needed due to the inability to identify wether
 a repeating update is caused by previous update was a glitch, or that it
 is unneeded because the repeating update is caused from a cycle.
\end_layout

\begin_layout Plain Layout
Another example for the challenging is in 
\family typewriter
FrTime
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 In the design of 
\family typewriter
FrTime
\family default
, a special 
\family typewriter
delay
\family default
 operator is implemented in order to handle cycles.
 Similarly, 
\family typewriter
Sodium
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special constructs named 
\family typewriter
CellLoops
\family default
 and 
\family typewriter
StreamLoops
\family default
 for handling cycles.
 Another example is in a feature called 
\family typewriter
reactive variables
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 to imperative languages.
 The feature limits the dependents to the lexical scope of its declaration
 for being acyclic.
 
\family typewriter
Sodium
\family default
 also hold a concept transaction for handling cycles created from integrating
 FRP with event handling code.
 A change propagated through an FRP variable can trigger an event handler,
 which in turn might create another update.
 This update could then feed back into the original FRP variable, creating
 a cycle.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Referential Transparency
\end_layout

\begin_layout Plain Layout
FRP is inspired from the functional paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to 
\emph on
referential transparency
\emph default
, meaning the input consistently produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
However, in our approach it is enabled to associate several expressions
 to the same variable, so saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 can be added with 
\begin_inset Formula $\LSTINLINE{A:=C+1}$
\end_inset

.
 Which means that we cannot derive the predictability property as it has
 traditionaly achieved in the field.
 Insead, the predictability property is achieved from introducing the pure
 functions over streams, as each variable consists of a streams of values
 that produced from the merge function described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-New-Variant"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Glitch Freedom
\end_layout

\begin_layout Standard
Glitch means that certain nodes are visited multiple times, while some of
 these visits involve outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a spanning tree, resulting from the DFS traversal, contains nodes with
 more than one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values.
 The multiple incoming edges of a node represent 
\emph on
simultaneous events
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, which are related to the same time, that originaly caused by a single
 event.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{next(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{next(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D=B+C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
An example for the glitch issue with the default behavior with observable
 streams
\end_layout

\end_inset

An example for the glitch issue with the default behavior with observable
 streams.
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents a sequence diagram of observable streams
 used for fields calculations, started from a change event to 
\backslash
lstinline{A}.
 The calls order in the sequence diagram is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}) (
\backslash
subref{fig:graph}) presentes the spanning tree resulted from the  traversal
 order, leading that the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Previous approaches managed the values correctly at runtime by holding an
 acyclic graph in memory and updating each variable only after all its dependenc
ies have been updated 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This is against our approach to support cycles.
 Other algorithms also do not fit our settings, because they depend on a
 central algorithm that holds in memory the data structure that represent
 the data dependencies
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,drechsler2014distributed"
literal "false"

\end_inset

.
 We find exceptions
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "shibanai2018distributed,drechsler2014distributed"
literal "false"

\end_inset

, but they do not support cycles, so we left them irrelevant.
\end_layout

\begin_layout Standard
Actualy, different applications need different handling, depending on needed
 consistency level
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
 According to this thesis, loops caused from cycles in dependencies, is
 another type of glitch.
 Our algorithm handles glitches
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We provide a unit test upon the classic case of glitch.
 Available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/blob/main/test/RIvarsBasics.js
\end_layout

\end_inset


\end_layout

\end_inset

 by enforcing an order over the values.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We take the prescpective that glitches are simultaneous events or values
 from the same time that arrive at a variable to be updated at different
 times 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 We noticed that this is like unexpected feedback loops, when also values
 arrive at a variable to be updated at different times.
 we expanded it to an overall order over the values, so that each values
 will be passed (i.e., propogated) only if it is freshed, i.e, its time is
 greater from the previous values that has been passed.
\end_layout

\begin_layout Plain Layout
We also inspired from that glitches has the mean of consistency.
 Each application can have different consistency level 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
 In the current approach, that the variables manage their values as streams,
 we are more open to customize the consistency level.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Each node in a dependancy graph can be represented as an observable stream.
 Each Item represents a visit in that node.
\end_layout

\begin_layout Plain Layout
We use an higher order functions
\end_layout

\begin_layout Plain Layout
This traversal order has the known issue named 
\emph on
glitch
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset


\emph on
.

\emph default
 Certain nodes may be visited multiple times, while some of these visits
 involving outdated values.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Glitch-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the spanning tree, resulting from the DFS traversal, contains nodes with
 more than one incoming edge.
 This implies that certain variables were updated multiple times in response
 to the change, but some of these updates relied on outdated values.
 The multiple incoming edges of a node represent simultaneous events, which
 are related to the same time, that originaly caused by a single event.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.75
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{sequencediagram}
\end_layout

\begin_layout Plain Layout

      
\backslash
newthread{A}{A}{}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[1]{B}{B}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[2]{C}{C}
\end_layout

\begin_layout Plain Layout

      
\backslash
newinst[3]{D}{D}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{B}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{B}{next(1)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
begin{call}{A}{next(1)}{C}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
begin{call}{C}{next(2)}{D}{}
\end_layout

\begin_layout Plain Layout

        
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

      
\backslash
end{call}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{sequencediagram}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:sequence}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.25
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (A) at (3,7) {A};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (B) at (2,5) {B};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (C) at (4,5) {C};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[shape=circle,draw=black] (D) at (3,3) {D};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(B) + (0,1)$) {B=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(C) + (0,1)$) {C=A+1};
\end_layout

\begin_layout Plain Layout

      
\backslash
node[scale=0.6] at ($(D) + (0,1)$) {D=B+C};
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (B);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (A) edge (C);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (B) edge (D);
\end_layout

\begin_layout Plain Layout

      
\backslash
path[-{Triangle[scale=1]}] (C) edge (D);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{}
\end_layout

\begin_layout Plain Layout

    
\backslash
label{fig:graph}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

 
\backslash
phantomcaption % Invisible caption
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:cycle-to-multiple-assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Glitch-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
An example for the glitch issue with the default behavior with observable
 streams
\end_layout

\end_inset

An example for the glitch issue with the default behavior with observable
 streams.
\begin_inset ERT
status open

\begin_layout Plain Layout

(
\backslash
subref{fig:sequence}) presents a sequence diagram of observable streams
 used for fields calculations, started from a change event to 
\backslash
lstinline{A}.
 The calls order in the sequence diagram is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{D},
\backslash
lstinline{C},
\backslash
lstinline{D}) (
\backslash
subref{fig:graph}) presentes the spanning tree resulted from the  traversal
 order, leading that the expected order is (
\backslash
lstinline{A},
\backslash
lstinline{B},
\backslash
lstinline{C},
\backslash
lstinline{D}).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Each variable abstracts a stream, where each item represents a visit.
 An item's location in the stream represent when was the visit.
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation should not create an item, in case that another item on the same
 or a more recent time is already present.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For feedback, we refer as redundant updates similar to 
\emph on
glitches
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 Glitches has been considered as two updates that refers to a single time,
 but accured in distinct times.
 Consequently, all updates caused from a single event means as of its time.
 Accordingly, feedback is of stimuouls events.
 For this reason, it is clear that a feedback refers again to updates that
 refers to a single time.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Merge
\end_layout

\begin_layout Standard
Merge operations have been considered in software engineering before, similar
 to the merge operation introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In working with streams, the merge operation has the the same general problem
 as in the events paradigm, on how to handle the time 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the two paradigms, there is the difficulty to how to merge values from
 several sources.
\end_layout

\begin_layout Standard
In the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation from 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

 (
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 in 
\begin_inset Formula $\ReactiveX$
\end_inset

), whenever there is a value from any of the sources, it is passed to the
 output stream.
 This is unpredictable, as it does not handle correctly the simultaneous
 values.
 This leads (as implemented in 
\begin_inset Formula $\NAME{sodium}$
\end_inset

) that the developers need to provide the method on how to determine the
 order of the values
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
However, due to the cycles issue, the previous implementations have exceptions
 that break this abstraction level.
 
\begin_inset Formula $\NAME{sodium}$
\end_inset

, in addition to its high-level language, has the concept of transactions
 to customize how to handle cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\begin_inset Formula $\NAME{FrTime}$
\end_inset

 has the reserved word 
\begin_inset Formula $\NAME{\LSTINLINE{delay}}$
\end_inset

 to customize how to handle cycles 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 Additionally, streams and/or events are still part of these frameworks
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming,blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—–
\end_layout

\begin_layout Plain Layout
Cycles are often challenged applications' developers and library designers.
 A remarkable example is a birth of 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As described in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.clariontech.com/blog/mvc-vs-flux-vs-redux-the-real-differences
\end_layout

\end_inset


\end_layout

\end_inset

 In previous libraries that use MVC, models are updated according to the
 view and vice versa, sometimes mentioned as 
\emph on
multidirectional
\emph default
 dataflow, which means that data flows among components in multiple directions.
 
\family typewriter
React
\family default
 and 
\family typewriter
Redux
\family default
 provides an alternative approach that proposes a design that data flow
 in one direction, such that data flows from each component to its child
 components.
 
\end_layout

\begin_layout Plain Layout
The design choice of avoiding cycles has its cost.
 For example, the lack of a feature named 
\family typewriter
binding
\family default
, by which variables are decleratively bound, so that a change in one variable
 update the other variable and vise verca.
 A similar feature is named multidirectionality
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

 (equivalent to multi-way constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

) that means that when neccesary, changes in derived values are propagated
 back to the values from which they were derived.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Cycles are traditionaly considered has causing negative effects.
 They are sometimes considered as 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, i.e., complexity that is not inherent in the problem that the software solves
 (as seen by the users) but arises only from the implementation.
 For example, the birth of React is to solve cycles created in MVC.
\end_layout

\begin_layout Plain Layout
Also in declerative frameworks like Angular, cycles has a mining as something
 to handle, rather than a more absrract meaning.
 Indeed, cycles are sometimes considered as 
\emph on
accidental
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

, i.e., complexity that is not inherent in the problem that the software solves
 (as seen by the users) but arises only from the implementation.
\end_layout

\begin_layout Plain Layout
An effort
\end_layout

\begin_layout Plain Layout
This opposed appraoches exist in frameworks provided for fornt end programming.
 Frameworks like Angular support a feature named binding.
 This feature enables view and model to interacts, so that models are updated
 according to the view and vice versa.
 This is mentioned sometimes as multidirectional dataflow, as data flows
 among components in mutipal directions.
 An alternative approach propsed a design data flow in one direction.
 This approach is used in React, when data flows from each component to
 its child components.
 This aims to provide predictability.
 It should be noted, that user events are produced from the view into a
 state managemnt manager, that is consumed by the components, and this integrati
on might create accidental cycles.
\end_layout

\begin_layout Plain Layout
The oppsed approaches affects also a feature named multidirectionality 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This feature means that when neccesary changes in derived values are propagated
 back to the values from which they were derived.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

implies that whenever a new value of either A or B is available the other
 value is updated.
 In the constraints programming paradigm, there are local propagation solvers,
 that are similar to FRP with and without multidirectionality.
 Solvers with multidirectionality are sometimes mentioned as more challenged
 to implement than solvers without multidirectionality, while solvers with
 multidirectionality may provide a more frienly framework 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Opinions among researchers are divided regarding whether to support cycles.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to a second approach, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Cycles are matter.
 This is obvious as it is frequesntly discussed explicity and implcity in
 resraches and tools documentations.
 In FRP
\end_layout

\begin_layout Plain Layout
For example, FrTime 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

 has special 
\family typewriter
delay
\family default
 operator to handle cycles.
\end_layout

\begin_layout Plain Layout
Another example, Sodium 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special constructs named 
\family typewriter
CellLoops
\family default
 and 
\family typewriter
StreamLoops
\family default
 to allow cycles, that should be declared under an explicit transaction.
\end_layout

\begin_layout Plain Layout
Actualy, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Sodium has special constructs to handle cycles.
\end_layout

\begin_layout Plain Layout
Stephen Blackheath at al 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 adds to
\end_layout

\begin_layout Plain Layout
In many frameworks and resraches, there is considerstion of cycles.
 Forbidding cycles makes FRP unacceptably weak, because many applications
 have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
 However,
\end_layout

\begin_layout Plain Layout
Opinions among researchers are divided regarding whether to support cycles.
 In FRP, One approach is to avoid 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 FRP is derived from Functional Programming (FP).
 For example, Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 In FP we achive
\emph on
 referential transparency
\emph default
, which means that input consistently produces the same output.
 If cycles do exist, it produces
\end_layout

\begin_layout Plain Layout
The paradigm is derived from the functional paradigm, with the referential
 transparency property.
 Saying 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 is like stating that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is a function with a body of 
\begin_inset Formula $\LSTINLINE{B+1}$
\end_inset

, so that each value of 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 is derived from the value of 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 This produces a 
\emph on
predictability 
\emph default
property due to referential transparency, meaning the input consistently
 produces the same output 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 According to a second approach, forbidding cycles makes FRP unacceptably
 weak, because many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
This opposed appraoches exist in frameworks provided for fornt end programming.
 Frameworks like Angular support a feature named binding.
 This feature enables view and model to interacts, so that models are updated
 according to the view and vice versa.
 This is mentioned sometimes as multidirectional dataflow, as data flows
 among components in mutipal directions.
 An alternative approach propsed a design data flow in one direction.
 This approach is used in React, when data flows from each component to
 its child components.
 This aims to provide predictability.
 It should be noted, that user events are produced from the view into a
 state managemnt manager, that is consumed by the components, and this integrati
on might create accidental cycles.
\end_layout

\begin_layout Plain Layout
The oppsed approaches affects also a feature named multidirectionality 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This feature means that when neccesary changes in derived values are propagated
 back to the values from which they were derived.
 For example, 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

implies that whenever a new value of either A or B is available the other
 value is updated.
 In the constraints programming paradigm, there are local propagation solvers,
 that are similar to FRP with and without multidirectionality.
 Solvers with multidirectionality are sometimes mentioned as more challenged
 to implement than solvers without multidirectionality, while solvers with
 multidirectionality may provide a more frienly framework 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The new variant of FRP possesses the characteristic of referential transparency,
 which is a fundamental property of FRP.
 This ensures predictability because the behavior remains consistent based
 on the input.
 Unless several issues, the referential transparency property is almost
 achieved in the observable streams model, because the output streams are
 calculated from pure functions.
\end_layout

\begin_layout Plain Layout
Furthermore, as mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Method"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the issues related to glitches, simultaneous events, and recursions have
 already been tackled through the modeling of an order and the implementation
 of a filter mechanism.
 Additionally, we address the need for a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation and handle accidental recursion using a custom assignment operator.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The assignment operator 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\LSTINLINE{:=}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 pushes values to the target variable, similar to producing input by the
 operator 
\begin_inset Formula $\LSTINLINE =$
\end_inset

.
 As a result, each variable consists of a 
\emph on
merged
\emph default
 stream from the inputs and the stream to which the variable is assigned.
 For this reason, the assignment operator is considered as a 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator.
 In the case of mutual recursion, it is necessary for at least one of the
 variables to require the merge function.
 This is because change propagation through a cycle must have a notification
 that is produced from outside of this cycle (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:cycle-merge-produce-concurrent-events-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] (X) at (-3,3) {$input$};    
\end_layout

\begin_layout Plain Layout


\backslash
draw[dotted][->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation to handle mutual recursions.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation to handle mutual recursions.
 The graph illustrates a DFS traversal of a change propogation (described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

) through a cycle, initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The assignment operator is an 
\emph on
accumulation
\emph default
 
\emph on
merge
\emph default
 operator, in its behavior to push values to the target variable.
 This is equivilent to merging the stream on the right-hand side of the
 operator with the stream on the left-hand side of the operator, and stores
 the merged result back in the left-hand side variable.
 For example (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:merge-several-sources-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 is executed as 
\begin_inset Formula $\LSTINLINE{A=merge(A,B)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Merge};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x3) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x3) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x3) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
node[marble,circle] (4x3) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x3) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (6x3) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x3) -- (1x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x3) -- (2x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x3) -- (3x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x3) -- (4x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x3) -- (5x3|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x3) -- (6x3|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-several-sources-2"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The assignment operator as an accumulation merge operator
\end_layout

\end_inset

The streams represent the variables.
 The statement 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

 produces the illustrated 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

, such that 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 will contain the elements from the two streams.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In some cases of mutual recursion, it is possible that one of the variables
 within the cycle has a second (or more) assignment, through which the propagati
on is initiated.
 Because subsequent statements with assignments to the same variable accumulate
 and merge more streams into it.
 In the given example, a subsequent statements 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 is executed as 
\begin_inset Formula $\LSTINLINE{A=merge(A,D)}$
\end_inset

 which means that 
\begin_inset Formula $\LSTINLINE{A=merge(merge(A,B),D)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The behavior of pushing values ensures that the 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operator exhibits the properties of associativity, commutativity, and flattenin
g.
 These properties guarantee that the order of applying the statements does
 not affect the final result.
 In this particular example, executing 
\begin_inset Formula $\LSTINLINE{A:=D}$
\end_inset

 first yields the same result as executing it later, as 
\begin_inset Formula $\LSTINLINE{merge(merge(A,B),D)=merge(merge(A,D),B)=merge(A,B,D)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The mentioned merge operation brings to mind the unacceptable merge operator
 in 
\begin_inset Formula $\ReactiveX$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Consequently, we discovered that the order model and assignment operator
 resolve the issues in 
\begin_inset Formula $\ReactiveX$
\end_inset

, which prevented it from being FRP.
 In both traditional merge and recursion, there are redundant updates caused
 by the inability to check each update for freshness.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
As a result, the new variant of FRP support multiple assignments.
 A variable with multiple assignments is interpreted as a merge operator
 over the variable and assigned expressions in the various statements.
 This is like a methodology that involves the variable inferring its value
 over time from various streams of samples.
 This leads also to the functional transparency
\emph on
 
\emph default
property, characterized by FRP.
 Because it has been determined, that the output streams are calculated
 from pure functions.
\end_layout

\end_inset


\end_layout

\begin_layout Section
OOP
\end_layout

\begin_layout Standard
This thesis builds upon previous efforts in integration of FRP with OOP.
\end_layout

\begin_layout Subsection
Events and Signals
\end_layout

\begin_layout Standard
In the first stage, the previous attempts focused on converting or reconciling
 concepts between FRP and OOP.
 
\begin_inset Formula $\REScala$
\end_inset

, provides 
\emph on
signals
\emph default
 that can be converted to events to fit into the OOP paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In another library, 
\begin_inset Formula $\NAME{SignalJ}$
\end_inset

, with the pure FRP, events are triggered as 
\emph on
side effects
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 The idea we used, found in 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

, involves implementing reactive variables as the Observer and Iterator
 design patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, where values are pushed to subscribers by executing their method 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

.
 This approach harmonizes previous ideas by treating observables as streams
 of events in the OOP world and streams of effects in the functional realm
 that FRP is originally based on.
\end_layout

\begin_layout Subsection
Objects and Reactive Variables
\end_layout

\begin_layout Standard
Our new assignment operation answers a traditional issue of assigning reactive
 variables from outside objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 The traditional assignment replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The new assignment operation also answers a second traditional mechanism.
 By the use of an integration with the events mechanism, a meaning similar
 to assignment can be produced.
 For example, in 
\begin_inset Formula $\ReactiveX$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 This mechanism might lead to infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, that a change in a reactive variable executes an event handler, causing
 the reactive variable to change again.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our work builds upon of 
\begin_inset Formula $\ReactiveX$
\end_inset

 and 
\begin_inset Formula $\REScala$
\end_inset

 of having reactive variables as objects' attributes.
 This means that the object interface is added with reactive variable such
 like the operations or fields accessed by getters and setters.
 
\end_layout

\begin_layout Plain Layout
Traditionaly, there is an issue in reactive variables assigned from outside
 of the objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 This assignment operation replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In addition, by the integration with the events mechanism, a meaning similar
 to assignment can be produced, such as 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 in 
\begin_inset Formula $\ReactiveX$
\end_inset

 that produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 However, the integration with the events mechanism is associated with issues
 of infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 For example, a change in a reactive variable might execute an event handler,
 causing the reactive variable to change again.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reactive Objects
\end_layout

\begin_layout Standard
Our work builds upon 
\begin_inset Formula $\REScala$
\end_inset

 that reactive variables are part of the object interface similar to operations
 or fields accessed by getters and setters 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In the same time, we provide like 
\emph on
reactive objects 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "boix2013object"
literal "false"

\end_inset

, in using objects with reactive variables as the objects' attributes.
 This alters the traditional semantics of OOP, that entire objects become
 the unit of reactivity.
 We implemented the example.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/blob/VisualRIVar_Works_In_Example/test/Reactive
Objects.js
\end_layout

\end_inset


\end_layout

\end_inset

 In a class called 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

, there are attributes 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE y$
\end_inset

, along with a method called 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

 method takes another 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object as an argument and creates a third 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object that will be automatically updated according to the changes, describing
 the target moved coordinate.
\end_layout

\begin_layout Standard
The new semantics consist of interacted objects without the need for a mediator
 that have access to objects' encapsulated state or behavior.
 Traditional implementations that achieve predictability use a mediator
 to access all variables.
 Even 
\begin_inset Formula $\REScala$
\end_inset

, which was created to bridge object-oriented and functional programming
 styles, replaces the traditional events modules with a dedicated centralized
 algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Inheritance and Polymorphism
\end_layout

\begin_layout Standard
For programmers, it has been pointed out the 
\emph on
Liskov Substitution Principle
\emph default
 (LSP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that a sub class will not change the behavior of its parent.
 For this reason, the reassignments will never override previous assignments.
 Instead, the data dependency graph will expand.
 Previously it has been mentioned: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the previous research about how to harmonize reactive variables into
 objects, it has mentioned the issue about inheritance: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
We give the answer mentioned through this thesis by that an assignment should
 be enabled everywhere with the meaning of adding the dependencies.
 This answer is provided following the consideration whether a subclass
 should be allowed to override dependencies defined in its parent.
 If a subclass changes the behavior of its super class, the resulting type
 does not inherit the entire behavior of the parent.
 Therefore, we have defined that the assignment only adds dependencies without
 overriding old ones.
 As a result, the resulting object derives its entire functionality from
 the hierarchy.
 As mentioned, the polymorphism means that the dynamic type will capture
 the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, as it is actualy done.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Constraints"

\end_inset

Constraints
\end_layout

\begin_layout Standard
The concept of
\family typewriter
 multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Although that we handle one-way constraints rather than multi-way, the
 algorithm is similar to one used for multi-way (in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Although that we handle one-way constraints rather than multi-way, our algorithm
 is similar.
\end_layout

\begin_layout Plain Layout
The concept of
\family typewriter
 multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Conflicts means a cenario that two or more constraints cannot be satisfied
 simultaneously.
 
\end_layout

\begin_layout Plain Layout
Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handle it similar to how it is handled in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Conflicts is usualy related to when consraints are multidirtional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handles it similar to how it is hadnled in Hotdrink.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library, mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 This is available in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset

.
 By our merge operation, each new sample from any of the sources are passed
 to the target variable, which recursively pass new values to targets variables.
 Consequently, in fields calculations, once the user puts a new input for
 a field, the fields that rely on a previous input, specifically the oldest
 input, are overwritten.
 Similary in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the input adds constraints to be in the top priority, causing to override
 values derived from old inputs.
 As a result, it seems like that our change propogation is like in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Plain Layout
A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts
\end_layout

\begin_layout Plain Layout
Constraints typically refered as multidirectional constraints
\end_layout

\begin_layout Plain Layout
Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Maintaining constraints is required sometimes to handle 
\emph on
conflicts
\emph default
.
 Conflicts arise in declarative constraints when two or more constraints
 cannot be satisfied simultaneously.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for empirical comparison
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

.
 In the two, whenever the user put new input for a field, the fields that
 relied on a previous input, specifically the oldest input, are overwritten.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Similar to how we handle cycles, constraints systems do by handling two-way
 constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

 (more details later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Comparing to Constraints Systems
\end_layout

\begin_layout Plain Layout
This thesis is like constraints systems, providing consistency between variables.
 However in constraints systems, developer are forced to one block of code
 that run on a single machine, while this thesis provides modular architecture.
 
\end_layout

\begin_layout Subsection
Multi-way Constraints
\end_layout

\begin_layout Plain Layout
In constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 With the proposed Rivars, it is implemented by declaring three formulas:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 However, the long verbosity exists also in constraints systems, when developers
 need specifying methods to satisfy the constraints.
 In addition, building blocks can easily built on top of our thesis.
 This means more extensions can be implemented by combining several formulas
 into a single constraint.
\end_layout

\begin_layout Subsection
Handle Consistency
\end_layout

\begin_layout Plain Layout
As mentioned, in constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 However, it is not clear what variable's value should be changed, especially
 when both other variables are not empty.
\end_layout

\begin_layout Plain Layout
The same question is arisen when declaring RIvar' formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 Our merge method produce variable's values according to the total order
 over the propogated values, that is derived from a total order over the
 external input events.
 In other words, values produced from old events are overidden by new ones.
\end_layout

\begin_layout Plain Layout
As in 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, first, constraints systems handle consistency according 
\emph on
hierarchical
\emph default
 consraints, that is to ignore constraints if they belong to the low levels
 of hierarchy.
 Second, they consider external inputs as constraints, for example the constrain
t 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=1
\end_layout

\end_inset

 is added when the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

.
 Third, external inputs' constraints are set in the hierarchy, according
 to the events' order.
\end_layout

\begin_layout Plain Layout
Consequently, the decision what variables to update in the automatic updates
 seems the same.
 
\end_layout

\begin_layout Subsection
Decentralized Calculation
\end_layout

\begin_layout Plain Layout
Constraints systems (and most reactive programming implementations
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) manage the constraints and handle them by a one centralized procedure.
 Similary is the approach in the code, the applications' code are of one
 block, because: 
\begin_inset Quotes eld
\end_inset

If the one-way constraints are defined in separate places, co-ordinating
 these constraints can be a major software engineering problem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Consequently, the market which needs modular solutions, does not adopt
 such centerlized solutions 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-2"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
