#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{algorithm,algpseudocode}
\usepackage{pgf-umlsd}
\usepackage{listings}
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, numberfirstline=true, firstnumber=1, stepnumber=1}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Related Work 
\end_layout

\begin_layout Standard
FRP shares with the paradigm of constraints systems the idea, that developers
 declare equations, and the runtime automates variables updates according
 to the equations and input.
 However, they are different: FRP is about defining variables as functions
 over other variables, while constraints systems are about to satisfy constraint
s.
\end_layout

\begin_layout Standard
There are constraints systems similar to FRP that handle one-way constraints.
 There are other constraints systems that handle two-way constraints.
 Constraints systems that handle two-way constraints, by their nature, handle
 cycles correctly, and allows defining multiple constraints that output
 to the same variable 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 This means that we are not the first to discover reassigment as a way to
 solve cycles.
 However, our finding contributes to area of the constraints systems.
\end_layout

\begin_layout Standard
The traditional constraints systems does not have the nature to work with
 components based architecture and distributed systems.
 Because the runtime is handled by constraints solvers, that are algorithms
 developed for constraints systems to satisfy the constraints.
 The solvers are centeral components that need access to all the variables
 and constraints.
 At this point our new model may help, because it does have the nature to
 work with OOP, which may be extended to work with more architectural patterns.
 
\end_layout

\begin_layout Standard
Our new variant of FRP can be refered as a constraints system.
 In the traditional constraints systems, any two-way constraint are declared
 with the methods to satisfy it, e.g., as implemented by Hotdrink in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 is attached with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B+C}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B:=A-C}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{C:=A-B}
\end_layout

\end_inset

.
 In order to use our model, only the methods should be specified.
 If one prefers providing the code in terms of two-way constraints, we can
 think about implementing a wrapper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 class as a future work.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint"

\end_inset

two-way constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B+C}
\end_layout

\end_inset

 implemented by Hotdrink
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
—————-
\end_layout

\begin_layout Subsubsection
Integrate with Objects
\end_layout

\begin_layout Standard
ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 and REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 provide reactive variables as part of the object's interface.
 Existing implementations provide two methods for assigning reactive variables
 externally, both have difficulties in compatibility with FRP.
 ReactiveX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://reactivex.io
\end_layout

\end_inset

 and REScala 
\begin_inset CommandInset citation
LatexCommand citep
key "Salvaneschi2014"
literal "false"

\end_inset

 provide reactive variables as standard data types, causing reactive variables
 being able to be assigned through an interface (by setters).
 However, this strategy is contrasted with the concept of reactive variables.
 The concept of reactive variables originates from the field of 
\emph on
Functional Reactive Programming
\emph default
 (FRP), that is based on 
\emph on
Functional Programming
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "elliott2009push"
literal "false"

\end_inset

.
 According to FRP, the programs should “describe things that exist, rather
 than actions that have happened or are to happen (i.e., what is, not what
 does)” 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
 In contrast, in ReactiveX and REScala, an assigment causes to stop the
 old source, and then start to respond to new source.
 In general, seperating the variables and expressions between interfaces
 and consumers seems incompatible with FRP, because reactive variables are
 defined by their functions over other reactive variables, or by their values
 over time 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In the second method, reactive variables are accessed externally by injecting
 events handlers.
 In events handlers, we can set inputs to reactive variables in response
 other reactive variables' updates.
 For example, in ReactiveX the statement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A.Subscribe(val=>B.OnNext(val))}
\end_layout

\end_inset

 produces the meaning of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A:=B}
\end_layout

\end_inset

.
 This method 
\emph on
adds
\emph default
 the formula in addition to the existing formulas handled by the runtime
 of the FRP solution.
 But in the current implementation, the formula is activated externally,
 without the advantages that the paradigm of FRP should provide.
 FRP aims to provide predictability and composability.
 In contrast, adding formulas externally, by integration between FRP and
 imperative programming, might cause infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive,blackheath2016functional"
literal "false"

\end_inset

.
 For example, a change in a reactive variable, might execute an event handler,
 causing the reactive variable to change.
\end_layout

\begin_layout Standard
(REScala is a library in Scala programming languauge, that supports reactive
 variables under the name 
\emph on
signals
\emph default
, being part of the object interface.
 Instead of declaring events and invoking them when variables change, the
 library enables the developers to declare the data dependencies.
 The signals interact with the inputs of the user interfaces, because signals
 changes and events can be converted between each other.
 REScala is the result of an active research in FRP, and adopts recent updates
 in the field.
\end_layout

\begin_layout Standard
ReactiveX is another library, developed first in C# programming langaue
 and adopted in many others programming langugaes.
 This library implements an observable that updates its subscribers in a
 form of an iterator.
\end_layout

\begin_layout Standard
The values that it updates the subscribers are values that it 
\end_layout

\begin_layout Standard
also supports reactive variables diffrently, but they are also a part of
 the objects interface.
\end_layout

\begin_layout Standard
ReactiveX important concept is the observable which is similar to events
 stream.
 )
\end_layout

\begin_layout Standard
————————–
\end_layout

\begin_layout Standard
The idea of combining reactive variables from FRP to being instance variables
 in OOP is not new.
 REScala and ReactiveX has also reactive variable being an instance variable.
 Anyway, the new model has several additional properties:
\end_layout

\begin_layout Itemize
The model depends only on the basic objects, as a tidy interface to clients,
 consisting of instance variables and methods.
 ReactiveX is also based on the basic objects, however it does not have
 the referential transparency (as in the next property), therefore produces
 non predictable results in case of cycles and merges 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
The model has the referential transparency property, such that each of the
 variables has a function declaring its stream of values according to the
 input provided.
 This property is basic in FRP, however according to REScala, it requires
 a mediator to observe and update the variables, not just the objects model,
 as the previous property.
\end_layout

\begin_layout Itemize
The model corresponds to the concept of inheritance with subtyping.
 Because assigning a variable that belongs to a base class, 
\emph on
adds
\emph default
 a dependency.
 This is in contrast to REScala and ReactiveX, there the same action 
\emph on
replaces
\emph default
 a dependency.
\end_layout

\begin_layout Section
distributed
\end_layout

\begin_layout Standard
In the FRP paradigm with the distributed settings, variables can be located
 in different processes or hosts 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,shibanai2018distributed,drechsler2014distributed"
literal "false"

\end_inset

.
 Using solutions like XFRP
\emph on
 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "shibanai2018distributed"
literal "false"

\end_inset

, developers declare functions over reactive variables, and the compiler
 generates a distributed application, that handles the updates according
 to the specified formulas.
\end_layout

\begin_layout Standard
——
\end_layout

\begin_layout Standard
quarp
\end_layout

\begin_layout Section
glitch/simulanous events/merge
\end_layout

\begin_layout Section
constraints?
\end_layout

\end_body
\end_document
