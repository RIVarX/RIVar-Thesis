#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Related-Work"

\end_inset

Related Work
\end_layout

\begin_layout Standard
This work focuses on preserving data consistency and currency through the
 concept of reactive instance variables and an approach that combines FRP
 with OOP.
 However, it is important to address other works in the field and distinguish
 them from the current work.
\end_layout

\begin_layout Standard
The foundation of this work is FRP, a paradigm in which programming languages
 enable the definition of dependencies between variables, ensuring that
 data consistency and currency are maintained automatically.
 The uniqueness of this work lies in its handling of cycles, its combination
 with OOP, and in its strategy in working with streams.
\end_layout

\begin_layout Section
Managing Cycles
\end_layout

\begin_layout Standard
In many FRP implementations, cycles are not supported.
 This can be observed when examining the handling of glitches (a well-known
 issue mentioned in the body of the work).
 To avoid glitches (updates based on outdated values), a variable is updated
 only after all the variables it depends on have been updated.
 For this reason, a topological sort is performed, and consequently, the
 graph must be acyclic 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
However, there are implementations that handle cycles, but this usually
 requires a dedicated abstraction.
 For example, in 
\family typewriter
FrTime
\family default
, there is a special operator called 
\begin_inset Formula $\LSTINLINE{delay}$
\end_inset

, whose purpose is to break a cycle of computations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

.
 This introduces the need not only to define 
\emph on
what
\emph default
 to compute (as intended by the paradigm) but also 
\emph on
how
\emph default
 to compute it.
 Another example is 
\family typewriter
Sodium
\family default
, where the 
\begin_inset Formula $\LSTINLINE{CellLoops}$
\end_inset

 data structure can be used to create a dependency cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
We will address two specific works, 
\family typewriter
Hotdrink
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 and 
\family typewriter
Keera
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

, that do support cycles.
\end_layout

\begin_layout Subsection

\family typewriter
Hotdrink
\end_layout

\begin_layout Standard
In constraint programming, there is research regarding the handling of cycles
 and how to resolve them
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 One constraints programming implementation is called 
\family typewriter
Hotdrink
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
 This implementation combines constraint programming with FRP.
\end_layout

\begin_layout Standard
In constraint programming, there are 
\emph on
unidirectional constraints
\emph default
 that are similar to formulas used in FRP, as well as 
\emph on
bidirectional constraints
\emph default
 that enforces equations in all directions.
 Bidirectional constraints are defined along with method definitions.
 Each method is a function and a definition of dependencies (e.g., 
\begin_inset Formula $A\rightarrow B$
\end_inset

).
 Each method in its data is similar to a unidirectional constraint.
 As a result, bidirectional constraints define cycles by their nature, created
 from the combined methods collection.
\end_layout

\begin_layout Standard
Another concept in constraint programming regarding creating constraints
 that represent 
\emph on
conflicts
\emph default
, that resemble the idea of multiple reactive assignments for the same variable.
 In constraint programming, it is possible to define two unidirectional
 constraints where the left-hand side of each constraint is the same variable.
 In this case, the system cannot provide a solution that satisfies both
 constraints.
\end_layout

\begin_layout Standard
In constraint programming, there is a model called 
\emph on
constraints hierarchy
\emph default
, in which each constraint has a priority definition.
 Thus, when solving the constraint system, the solution is based on maximizing
 the constraints that are highest in the hierarchy.
\end_layout

\begin_layout Standard
In 
\family typewriter
Hotdrink
\family default
, in response to each input 
\begin_inset Formula $\text{x}$
\end_inset

 for the variable 
\begin_inset Formula $X$
\end_inset

, a constraint 
\begin_inset Formula $\LSTINLINE{X:=x}$
\end_inset

 with maximum priority in the hierarchy is added.
 Then, an algorithm is executed to find a dependency graph without cycles
 for computing the variable values, ensuring the maximum number of constraints
 are satisfied, in accordance with the defined hierarchy.
 Based on this dependency graph, the variables are updated depending on
 other variables.
\end_layout

\begin_layout Standard
In a comparison between the strategy implemented in 
\family typewriter
HotDrink
\family default
 and the strategy presented in this work, it can be observed that for any
 given input sequence, both strategies consistently generate the same output
 sequence.
 In both cases, a new input causes the overwriting of values that were generated
 as a result of the oldest input.
 This identity can even be empirically verified by comparing the implementations
 of 
\family typewriter
Drug Administration
\family default
 in 
\family typewriter
rivarjs
\family default
 and 
\family typewriter
HotDrink
\family default
 (available on the comparison page in the source code repository).
\end_layout

\begin_layout Standard
While there is no difference between the thesis approach and 
\family typewriter
HotDrink
\family default
 in the output produced for each input, there are differences in the implementat
ion strategy, with the main difference being the level of alignment with
 modular programming and OOP.
\end_layout

\begin_layout Subsection

\family typewriter
Keera
\end_layout

\begin_layout Standard
In 
\family typewriter
Keera
\family default
, there is an abstraction of 
\emph on
reactive value
\emph default
, which corresponds to the reactive instance variable, and 
\emph on
reactive relation
\emph default
, which corresponds to reactive assignment.
 In 
\family typewriter
Keera
\family default
, similar to this work, it is possible to define reactive relations for
 a reactive value, even if it is an output variable, such that a cycle can
 be formed.
 Additionally, it is allowed to define other reactive relations for the
 same reactive value (i.e., the same reactive value appears on the left-hand
 side of the relation).
 The goal of this approach, which resembles the goal of this work, is to
 promote Separation of Concerns (SoC) and support modularity.
\end_layout

\begin_layout Standard
The differences between the current work and 
\family typewriter
Keera
\family default
 are:
\end_layout

\begin_layout Itemize
The approach and implementation in 
\family typewriter
Keera
\family default
 are carried out exclusively in 
\family typewriter
Haske
\begin_inset ERT
status open

\begin_layout Plain Layout

\family typewriter

\backslash
-
\end_layout

\end_inset

ll
\family default
.
 
\end_layout

\begin_layout Itemize
In 
\family typewriter
Keera
\family default
, it is possible to define relations that include the same reactive value
 in separate modules, whereas in the current work, these are integrated
 with OOP and its principles.
 
\end_layout

\begin_layout Itemize
In 
\family typewriter
Keera
\family default
, change propagation is carried out through 
\emph on
choreographies
\emph default
, which are reusable libraries that describe specific change propagations
 between system components.
 In contrast, the current work presents a more general approach to maintaining
 data consistency and currency.
\end_layout

\begin_layout Section
Connection with OOP 
\end_layout

\begin_layout Standard
This work is unique in its approach to OOP with reactive variables.
 While the combination of reactive variables with OOP is not new, notable
 work in this area includes 
\family typewriter
REScala
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014,salvaneschi2014towards,drechsler2014distributed"
literal "false"

\end_inset

.
 Additionally, there is work on 
\family typewriter
Reactive Objects 
\family default
in
\family typewriter
 AmbientTalk
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "boix2013object"
literal "false"

\end_inset

, as well as code libraries such as 
\family typewriter
React
\family default
, which integrate ideas from both paradigms.
 Of course, 
\family typewriter
ReactiveX
\family default
 forms the basis for the implementation strategy of this work.
\end_layout

\begin_layout Standard

\family typewriter
REScala
\family default
 shares similarities with this work in that objects can contain reactive
 variables (in the current work, reactive instance variables).
 Additionally, in 
\family typewriter
REScala
\family default
, a change in the value of a reactive variable is translated into an event,
 and an event can trigger a change in the value of a reactive variable.
\end_layout

\begin_layout Standard
However, in 
\family typewriter
REScala
\family default
, the implementation is classical: it manages a central dependency tree
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 This approach is in direct contrast to the modular approach presented in
 this work.
 While there is a distributed implementation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

 (for distributed systems, where variables are spread across different hardware
 components) of 
\family typewriter
REScala
\family default
, in which the propagation of changes is not dependent on a central component
 but rather relies on communication between nodes, even in this implementation,
 the dependencies must still take the form of a tree.
\end_layout

\begin_layout Standard
This work offers suggestions or ideas regarding questions raised in two
 papers on 
\family typewriter
REScala
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014,Kamina2018"
literal "false"

\end_inset

.
 One such question discussed in both papers is whether to support re-assignment,
 as there are advantages and disadvantages on both sides.
 An extension of this question pertains to inheritance: should it be allowed
 to override a reactive variable, such that the dependency is based on a
 new definition rather than the one in the base class?
\end_layout

\begin_layout Standard
The answer to this question, along with the answer to another question regarding
 polymorphism, is addressed in this work through the concept of multiple
 assignments.
 This is, re-assignment is possible, but this reassignment does not sever
 existing dependencies, as seen in reassignment or override; it only adds
 dependencies.
 Thus, inheritance is always an extension of existing behavior, preventing
 unexpected changes between instances of different classes that are descendants
 of the same class in the inheritance hierarchy.
\end_layout

\begin_layout Section
Working with Streams
\end_layout

\begin_layout Standard
This work is unique in that it uses a reactive stream as an abstraction
 layer for a reactive variable, and in the reactive assignment operator
 that serves as a merging operation for streams.
\end_layout

\begin_layout Standard
Nonetheless, using a reactive stream as an abstraction layer for a reactive
 variable is not fundamentally different from some of the references in
 the literature.
 A stream of events is sometimes considered a reactive variable or equivalent
 to a reactive variable
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 (or at least, conversions between the two are possible
\begin_inset Note Note
status open

\begin_layout Plain Layout
TBD: Citation? implicit...? REScala Bridge? Another? No One?
\end_layout

\end_inset

).
 Programming with streams represents a programming model akin to regular
 imperative programming with variables
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

, and therefore, the approach of this thesis to use streams for implementing
 the approach may appear trivial.
\end_layout

\begin_layout Standard
Regarding the merging of streams, it is important to distinguish between
 the approach of this thesis and previous approaches to the merging operation.
 Merging streams represents a central problem in the field
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

, referring to the combination of multiple data streams into a single stream.
 The problem of merging streams is analogous to the problem of managing
 the state of variables.
\end_layout

\begin_layout Standard
The problem can be broken down into two types: merging similar to the 
\begin_inset Formula $\LSTINLINE{CombineL}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset


\begin_inset Formula $\LSTINLINE{atest}$
\end_inset

 operator in 
\family typewriter
ReactiveX
\family default
, where each item in the output stream is computed from the items in the
 input streams; and merging similar to the 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 operator in 
\family typewriter
ReactiveX
\family default
.
\end_layout

\begin_layout Standard
In the 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 operator in 
\family typewriter
ReactiveX
\family default
, there is the issue of glitches, where certain items may still be outdated
 because each new item in one of the input streams leads to the creation
 of a new item in the output stream.
\end_layout

\begin_layout Standard
The second type is similar to the 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 operator in 
\family typewriter
ReactiveX
\family default
, an operator that creates a stream where each item from any of the input
 streams "flows" as is to the output stream.
 The merge operation in this work is similar to this definition, with the
 difference that while the standard merge operation does not guarantee a
 consistent order between the items, the merge operation here ensures such
 consistency.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
This work combines elements that have precedents in previous works alongside
 innovative contributions that expand existing knowledge.
 For example, the approach for supporting built-in cycles in the language
 is also present in 
\family typewriter
Keera
\family default
 and 
\family typewriter
HotDrink
\family default
.
 The goal of promoting modularity, which drives this work, is similar to
 the one emphasized in 
\family typewriter
Keera
\family default
.
 The method for handling cycles in 
\family typewriter
HotDrink
\family default
 also produces a consistent output for each given input, similar to the
 result obtained in this work.
\end_layout

\begin_layout Standard
The uniqueness of this work stands out compared to previous works, mainly
 in two areas:
\end_layout

\begin_layout Itemize
In the domain of streams: This work presents a new strategy for merging
 streams, providing consistent order, which differs from existing merging
 strategies.
\end_layout

\begin_layout Itemize
In the domain of integrating FRP with OOP: This work addresses open questions
 in the field, such as supporting reassignment and inheritance, and offers
 a potential solution in the form of the multiple assignments concept.
\end_layout

\begin_layout Standard
This work adds a layer to the research in the field of FRP, reinforcing
 the approach of supporting circular dependencies.
 Additionally, it proposes an innovative strategy for stream integration
 and a unique approach to combining FRP with OOP.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This work presents a different approach from the conventional methods in
 reactive programming concerning cycles in defining dependencies between
 variables.
 In this work, a reactive instance variable is implemented with a reactive
 assignment operator that merges streams, thereby supporting multiple reactive
 assignments to the same variable, and as a result, cycles.
 Consequently, a modular approach is established, aligning well with OOP
 principles.
\end_layout

\begin_layout Plain Layout
In this chapter, we will review the treatment of cycles and examine previous
 works related to elements of this study: (1) merging streams, (2) multiple
 reactive assignments to the same variable and the resulting cycles, (3)
 modularity enabled by this approach, and (4) integration with OOP.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In FRP, it is used to manage the values correctly at runtime by holding
 an 
\emph on
acyclic
\emph default
 graph in memory and updating each variable only after all its dependencies
 have been updated 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In previous research, two opposing methods have been previously presented
 regarding cycles.
 In the first method, cycles are avoided, because the paradigm derived from
 the functional paradigm, with the referential transparency property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 In addition, avoiding cycles is a necessary condition to algorithms to
 handle glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,bainomugisha2013survey"
literal "false"

\end_inset

.
 At this direction it has been presented in previous work, creating feature
 that limits data dependencies to the lexical scope of their declarations
 for being acyclic
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

 .
 In the second method, forbidding cycles makes FRP unacceptably weak, because
 many applications have cycles by their nature 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding,perez2015bridging"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Handling Cycles in Reactive Programming
\end_layout

\begin_layout Plain Layout
The support for automatic change propagation must strike a balance between
 customizable and the abstraction level.
 For example, event-driven programming frameworks give developers complete
 control over the propagation order, therefore highly customizable but lower
 abstraction level.
 Another example, 
\family typewriter
ReactiveX
\family default
 that promotes abstractions from handling events to function over streams
 of events, giving some control over propagation by choosing a 
\emph on
scheduler
\emph default
 to indicate the order of updates.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://rxjs.dev/guide/scheduler
\end_layout

\end_inset

 Finally, tools or products' features that aims to abstracting away most
 details like the ones with like reactive variables.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Variable that is re-assigned over time can be modelled as stream, that in
 each update there is a new item, of the new value representing the updated
 value at that instant.
 reactive variable means that update of that variable raises indirectly
 a continuation action based on the new value.
 Such an update may be called as
\emph on
 update with a push notification
\emph default
.
 In other words, 
\emph on
update with a push notification
\emph default
 means that not only the variable contained the new value instead of the
 previous value, but also that it raises interested parties about the change.
 We refer to variables as an object in the world, that exposes operation
 
\emph on
assign
\emph default
 (with :=) for an update, and 
\emph on
subscribe 
\emph default
for registration for push notifications.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
We provide a brief, comprehensive overview of state management, gradually
 covering its various aspects:
\end_layout

\begin_layout Itemize
Initially, code assigns values to variables, allowing other code to read
 them.
 For instance, A = 1 assigns a value to variable A, and another code segment
 B = A reads from variable A.
\end_layout

\begin_layout Itemize
Next, additional code is introduced to notify potential readers about changes.
 For example, A = 1; OnChangeA(A) notifies other parts of the system about
 changes to variable A.
 Subsequently, another piece of code, RegisterToChangeA(value => ...) registers
 to receive notifications about changes to variable A.
\end_layout

\begin_layout Itemize
Finally, these components are intertwined, enabling writing into a variable
 to automatically trigger other code to read the new values.
 For instance, declaring B := A establishes a continuous relationship between
 variables, so that when the code A = 1 is executed, variable B is updated
 automatically to reflect this new value.
\end_layout

\begin_layout Plain Layout
Each step in the above represent a valid approach.
 In the first approach, there is no mechanism to inform potential readers
 of changes.
 Consequently, readers must periodically read the values, leading to high
 resource consumption costs.
 Additionally, the first approach tends to involve making changes directly
 within the code rather than extending it.
 When updating variables based on changes to other variables, all code locations
 where the latter variables are updated must also be updated to reflect
 the changes in the variables.
\end_layout

\begin_layout Plain Layout
The second approach provide reactivity, by informing potential readers of
 changes.
 However, it requires to control when to inform readers, and for readers
 to inform to what changes to subscribe.
 This approach is difficult in high scale applications.
 Because, it is not only clear when to inform readers about changes, or
 for the readers when to subscribe or unsubscribe.
\end_layout

\begin_layout Plain Layout
The last approach unifies reading and writing such that writing into variables
 triggers potential readers to read the changes.
 This provides a cleaner specification, except for the problem of cycles,
 where a variable change might indirectly result from itself.
 In such a case, the itended understanding is not clear.
\end_layout

\begin_layout Plain Layout
As a result, the previous approach has a better tools to express requirement
\end_layout

\begin_layout Plain Layout
The previous approach is better
\end_layout

\begin_layout Plain Layout
In this context, in the previous approach requirements can be expressed
 directly, while here the itended understanding is not clear.
\end_layout

\begin_layout Plain Layout
The strategy, how cycles are controled are not explicit in the code.
\end_layout

\begin_layout Plain Layout
In such cycles,the way how changes are handled loops are stopped without
 to express the explicit strategy in the code.
\end_layout

\begin_layout Plain Layout
It is required to decide how to stop the loop.
\end_layout

\begin_layout Plain Layout
The decision how to stop such a loop is not explicit in the code
\end_layout

\begin_layout Plain Layout
In such a case, the second approach, in its full control over the changes
 might convey better in desgning how to stop the loop
\end_layout

\begin_layout Plain Layout
the decision how to stop the loop is not explicit in the code.
 Therefore, the second approach, in its full control over the changes,
\end_layout

\begin_layout Plain Layout
the second approach provides a cleaner specification in its full control
 over the changes.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Handling 
\emph on
state
\emph default
 is an important aspect in programming.
 State refers to what software remembers from past used to its future behavior.
 State is represented as changeable data, stored anywere, used to determine
 output.
 Basicly, it is variables that contain values.
\end_layout

\begin_layout Plain Layout
Software components that contained variables or any datastore, by which
 its behavior is determined, is named 
\emph on
stateful components
\emph default
.
 Our objective is to redesign an existing application to compose highly
 reusable stateful components.
\end_layout

\begin_layout Plain Layout
—-
\end_layout

\begin_layout Plain Layout
In software programming, developers sometimes encounter 
\emph on
cycles 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, 
\emph on
circular dependencies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "perez2015bridging"
literal "false"

\end_inset

 or similar.
 For variables, it means that a change in one variable causes transitively,
 through a chain of changes, this same variable to again change its value.
 Typically, the flow continues, such that the second change produces a third
 change, etc.
 In the worst case, this chain continues endlessly, breaking programs unexpected
ly.
\end_layout

\begin_layout Plain Layout
This might be accidently produced in event driven programming.
 Each event handler can trigger more events, in-awaring of the events from
 which they have been triggered.
 Therefore it is likely that an event handler transitively triggers an event
 from which it was originally triggered.
 If a variable is updated by an event handler, and this event handler triggers
 more events which lead to execute again this event handler, the variable
 is re-updated.
\end_layout

\begin_layout Plain Layout
In Functional Reactive Programming (FRP), it might be even more explicit.
\begin_inset Foot
status open

\begin_layout Plain Layout
Our presentation is based on Tetsuo Kaminaa at al 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
\end_layout

\end_inset

 In FRP, variables can be specified in terms of each other, thus initiating
 dependencies to automatically update each other.
 For instance, A := f(B) indicates that A depends on B, meaning that when
 B’s value changes, A’s value is adjusted accordingly.
 Using this abstraction, B := g(A) establishes a dependency in a reversed
 direction, resulting in a cycle
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This thesis discusse against an argument, that hirarchial data is a nececray
 condition for achiving predictability.
 This argument is inspired from several
\end_layout

\begin_layout Plain Layout
This argument are inferred
\end_layout

\begin_layout Plain Layout
Many couple predictability with the acylciity for graphs that abstract the
 depedancies.
 This represent an argument that hirarchial data is a nececray condition
 for achiving predictability.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
——–
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
Data Synchronization is a ubiquitous feature across various domains, including
 front-end interfaces, databases and inter-system communication.
 In the various forms, data is transformed or computed to be consistent
 with other data.
 In database management, synchronization involves updating fields.
 Systems such as CRM or e-commerce platforms utilize synchronization to
 align one system with another.
 Similarly, in graphical user interfaces (GUI) or front-end applications,
 it entails updating fields based on changes in other fields.
 In the realm of state management, synchronization involves adjusting variables
 in response to changes in other variables.
 Procedural programming allows developers to write explicit, step-by-step
 procedures for handling data synchronization tasks.
 Each procedure has a set of arguments and update data according to values
 contained by the arguments.
\end_layout

\begin_layout Plain Layout
Procedural programming is an outdated paradigm compared to current modern
 paradigms.
 Procedural programming consists of procedures, that execute a set of instructio
nes for a given set of arguments.
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Plain Layout
In the procedural programming, developers model proceduraes,
\end_layout

\begin_layout Paragraph
Push Model
\end_layout

\begin_layout Plain Layout
In data synchronization, two prominent strategies are employed: the 
\emph on
pull
\emph default
 and 
\emph on
push
\emph default
 models.
 In the pull mode, data consumers need to proactively request updates by
 executing a procedure or calling for a service.
 In the push model, changes are pushed forward without the consumer proactively
 requesting updates.
 The pull model might lead to redandant requests, if there are no changes
 since the last request.
 This thesis' focus is on the push model, which is apt for scenarios characteriz
ed by: first, a continuous demand for up-to-date data; second, infrequent
 changes; and finally, the absence of prolonged and resource-intensive computati
ons, as new changes may arise before the completion of such processes.
\end_layout

\begin_layout Paragraph
Explicit Data Dependencies
\end_layout

\begin_layout Plain Layout
In Reactive Programming, there is a focus on explicity define the dependencies,
 rather than relying on Event-driven paradigm where developers manually
 manage variable values.
 For example, in the event-driven paradigm, variables 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
 each have a 
\family typewriter
change
\family default
 event to which event handlers are registered.
 Within these event handlers, code calculates the sum of the values contained
 in 
\family typewriter
B
\family default
 and 
\family typewriter
C
\family default
, and then updates a variable, 
\family typewriter
A
\family default
, with that value.
 From an FRP perspective, this should be declared simply as 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or other similar syntax options.
 This specific syntax is used by Guido Salvaneschi at al 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014programming"
literal "false"

\end_inset


\end_layout

\end_inset

 making the data dependencies explicit directly in the code.
\end_layout

\begin_layout Paragraph
Control
\end_layout

\begin_layout Plain Layout
When relying on third-party control over updates, software developers may
 experience a sense of unpredictability and lack of control.
 This concern has been articulated in the experience of REScala, where developer
s expressed frustration with tracking the flow of code: “I can’t follow
 the Codeflow in RP.
 I want to know, what method is called when
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
Traditional procedural programming remains highly prevalent for Data Synchroniza
tion.
 Our initial focus lies on a specific GUI application in the healthcare
 sector, which utilizes procedural programming.
 Healthcare, an area notorious for low user satisfaction 
\begin_inset CommandInset citation
LatexCommand cite
key "gawande2018doctors"
literal "false"

\end_inset

, presents an opportunity to enhance the codebase, thereby improving the
 customer feedback loop through rapid releases and innovative programming
 methodologies.
 Surprisingly, procedural-driven programs are not limited to GUI applications
 in the healthcare sector alone.
 REST APIs and command-line interfaces (CLIs) are also often built on procedural
 principles.
 Similarly, any tool that accepts various arguments and must accommodate
 numerous scenarios may suffer from limitations inherent in the outdated
 procedural paradigm.
\end_layout

\begin_layout Plain Layout
————————–
\end_layout

\begin_layout Plain Layout
In this section, we discuss the state of the art of field calculation features.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
However, for the sake of specific use cases, more concepts are added.
\end_layout

\begin_layout Paragraph
Example:
\end_layout

\begin_layout Itemize
In the design of 
\family typewriter
FrTime
\family default
, a special 
\family typewriter
delay
\family default
 operator is implemented in order to handle cycles.
\end_layout

\begin_layout Itemize

\family typewriter
Sodium
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

 provides a special constructs named 
\family typewriter
CellLoops
\family default
 and 
\family typewriter
StreamLoops
\family default
 for handling cycles.
 
\end_layout

\begin_layout Itemize

\family typewriter
Sodium
\family default
 also hold a 
\emph on
transaction
\emph default
 concept for handling cycles created from integrating FRP with event handling
 code.
 A change propagated through an FRP variable can trigger an event handler,
 which in turn might create another update.
 This update could then feed back into the original FRP variable, creating
 a cycle.
\end_layout

\begin_layout Itemize

\family typewriter
Microsoft Excel
\family default
 manages settings 
\emph on
remove or allow a circular reference
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
allow cycles
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.Terminating when it closes a cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, adding to the language a special operator to inform the runtime when to
 break the cycle 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2006embedding"
literal "false"

\end_inset

, stop after a number of iterations, stop if the value has not changed,
 or changed only less than a threshold (available in 
\family typewriter
Microsoft Excel
\family default
)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://support.microsoft.com/en-us/office/remove-or-allow-a-circular-reference-85
40bd0f-6e97-4483-bcf7-1b49cd50d123
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In addition to reactive variables in FRP, events abstraction might also
 be needed 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2017positive"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Glitch Freedom
\end_layout

\begin_layout Plain Layout
It is used to manage the values correctly at runtime by holding an acyclic
 graph in memory and updating each variable only after all its dependencies
 have been updated 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 This is against our approach to support cycles.
 Other algorithms also do not fit our settings, because they depend on a
 central algorithm that holds in memory the data structure that represent
 the data dependencies
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics,drechsler2014distributed"
literal "false"

\end_inset

.
 We find exceptions
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "shibanai2018distributed,drechsler2014distributed"
literal "false"

\end_inset

, but they do not support cycles, so we left them irrelevant.
\end_layout

\begin_layout Plain Layout
—
\end_layout

\begin_layout Plain Layout
The goal of this section is to present works related to this thesis.
 In reactive programming, there are works on streams, works that combine
 streams with reactive variables, as well as works addressing issues such
 as glitches, integration between components, and the combination of reactive
 variables or reactive programming with OOP.
 
\end_layout

\begin_layout Section
Streams and Combination with Reactive Variables
\end_layout

\begin_layout Plain Layout
This work is unique in its idea of abstracting reactive instance variables
 and reactive assignments, such that multiple assignments create automatic
 merging between streams.
 In previous approaches, it was necessary to use streams and dedicated stream
 operators.
 There is also the issue of inconsistency in stream merging, known as a
 glitch.
 A solution exists, requiring programmers to provide a tailored algorithm
 for merging the streams to ensure consistency
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Combining FRP with OOP
\end_layout

\begin_layout Plain Layout
Additional works exploring the integration of FRP and OOP are presented
 below.
\end_layout

\begin_layout Subsection
Events and Signals
\end_layout

\begin_layout Plain Layout
In the first stage, the previous attempts focused on converting or reconciling
 concepts between FRP and OOP.
 
\begin_inset Formula $\REScala$
\end_inset

, provides 
\emph on
signals
\emph default
 that can be converted to events to fit into the OOP paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In another library, 
\begin_inset Formula $\NAME{SignalJ}$
\end_inset

, with the pure FRP, events are triggered as 
\emph on
side effects
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 The idea we used, found in 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

, involves implementing reactive variables as the Observer and Iterator
 design patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, where values are pushed to subscribers by executing their method 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

.
 This approach harmonizes previous ideas by treating observables as streams
 of events in the OOP world and streams of effects in the functional realm
 that FRP is originally based on.
\end_layout

\begin_layout Subsection
Objects and Reactive Variables
\end_layout

\begin_layout Plain Layout
Our new assignment operation answers a traditional issue of assigning reactive
 variables from outside objects
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 The traditional assignment replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The new assignment operation also answers a second traditional mechanism.
 By the use of an integration with the events mechanism, a meaning similar
 to assignment can be produced.
 For example, in 
\begin_inset Formula $\ReactiveX$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 This mechanism might lead to infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, that a change in a reactive variable executes an event handler, causing
 the reactive variable to change again.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our work builds upon of 
\begin_inset Formula $\ReactiveX$
\end_inset

 and 
\begin_inset Formula $\REScala$
\end_inset

 of having reactive variables as objects' attributes.
 This means that the object interface is added with reactive variable such
 like the operations or fields accessed by getters and setters.
\end_layout

\begin_layout Plain Layout
Traditionaly, there is an issue in reactive variables assigned from outside
 of the objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 This assignment operation replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
In addition, by the integration with the events mechanism, a meaning similar
 to assignment can be produced, such as 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 in 
\begin_inset Formula $\ReactiveX$
\end_inset

 that produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 However, the integration with the events mechanism is associated with issues
 of infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 For example, a change in a reactive variable might execute an event handler,
 causing the reactive variable to change again.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reactive Objects
\end_layout

\begin_layout Plain Layout
Our work builds upon 
\begin_inset Formula $\REScala$
\end_inset

 that reactive variables are part of the object interface similar to operations
 or fields accessed by getters and setters 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In the same time, we provide like 
\emph on
reactive objects 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "boix2013object"
literal "false"

\end_inset

, in using objects with reactive variables as the objects' attributes.
 This alters the traditional semantics of OOP, that entire objects become
 the unit of reactivity.
 We implemented the example.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/blob/VisualRIVar_Works_In_Example/test/Reactive
Objects.js
\end_layout

\end_inset


\end_layout

\end_inset

 In a class called 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

, there are attributes 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE y$
\end_inset

, along with a method called 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

 method takes another 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object as an argument and creates a third 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object that will be automatically updated according to the changes, describing
 the target moved coordinate.
\end_layout

\begin_layout Plain Layout
The new semantics consist of interacted objects without the need for a mediator
 that have access to objects' encapsulated state or behavior.
 Traditional implementations that achieve predictability use a mediator
 to access all variables.
 Even 
\begin_inset Formula $\REScala$
\end_inset

, which was created to bridge object-oriented and functional programming
 styles, replaces the traditional events modules with a dedicated centralized
 algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Inheritance and Polymorphism
\end_layout

\begin_layout Plain Layout
For programmers, it has been pointed out the 
\emph on
Liskov Substitution Principle
\emph default
 (LSP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that a sub class will not change the behavior of its parent.
 For this reason, the reassignments will never override previous assignments.
 Instead, the data dependency graph will expand.
 Previously it has been mentioned: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the previous research about how to harmonize reactive variables into
 objects, it has mentioned the issue about inheritance: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
We give the answer mentioned through this thesis by that an assignment should
 be enabled everywhere with the meaning of adding the dependencies.
 This answer is provided following the consideration whether a subclass
 should be allowed to override dependencies defined in its parent.
 If a subclass changes the behavior of its super class, the resulting type
 does not inherit the entire behavior of the parent.
 Therefore, we have defined that the assignment only adds dependencies without
 overriding old ones.
 As a result, the resulting object derives its entire functionality from
 the hierarchy.
 As mentioned, the polymorphism means that the dynamic type will capture
 the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, as it is actualy done.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Change Propagation Algorithms
\end_layout

\begin_layout Plain Layout
The idea to bring the developers user friendly mechanism to fields calculations
 brings also the 
\emph on
constraints systems
\emph default
.
 In constraints systems, developers declare equations, and the runtime automates
 variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 They reminds reactive variables and FRP.
 Many implementations in FRP consists of a centralized manager 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Actualy, as in the state management solution 
\begin_inset Formula $\NAME{MobX}$
\end_inset

 with the 
\begin_inset Formula $\NAME{React}$
\end_inset

 framework, fields calculations can consist of reactive variables implemented
 by a state management solution connected to the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Hotdrink
\end_layout

\begin_layout Plain Layout

\family typewriter
Hotdrink
\family default
 is a library implemented with a thesis-driven approach, similar to this
 thesis, to address the lack of support for cycles in data dependencies.
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
The concept of
\family typewriter
 
\family default
multiple assignment has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Although that we handle one-way constraints rather than multi-way, the
 algorithm is similar to one used for multi-way in 
\family typewriter
Hotdrink.
\end_layout

\begin_layout Plain Layout
On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\family typewriter
Hotdrink
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

 which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the methods 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 The systems utilize algorithms, named 
\emph on
constraints solvers
\emph default
, to maintain consistency in variable values.
 As in 
\family typewriter
Hotdrink
\family default
, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints.
 For each variable 
\family typewriter
X
\family default
 containing a value 
\family typewriter
x
\family default
, the runtime maintains a constraint 
\begin_inset Formula $\LSTINLINE{X=x}$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, the more prioritized
 constraints, according to the hirarchy, are satsified.
 As a result, once the user put new input for a field, the fields that relied
 on a previous input, specifically the oldest input, are overwritten.
\end_layout

\begin_layout Section
The Cycles Problem
\end_layout

\begin_layout Section
Merge
\end_layout

\begin_layout Plain Layout
Actualy, different applications need different handling, depending on needed
 consistency level
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
 According to this thesis, loops caused from cycles in dependencies, is
 another type of glitch.
 Our algorithm handles glitches
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We provide a unit test upon the classic case of glitch.
 Available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/blob/main/test/RIvarsBasics.js
\end_layout

\end_inset


\end_layout

\end_inset

 by enforcing an order over the values.
\end_layout

\begin_layout Plain Layout
Provided operators 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 are related to a concept named 
\emph on
lifting
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 They enable functions to be used like 
\emph on
higher order functions.

\emph default
 An unary function can be used by the operator 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 (that maps each item according to the function), and a binary function
 can be used by an operator 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, that works for two observable streams, mapping based on items from the
 two.
 For example, The code 
\begin_inset Formula $\LSTINLINE{A=B.Select(x=>x+1)}$
\end_inset

 is similar to 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and the code 
\begin_inset Formula $\LSTINLINE{A=B.CombineLatest(C,(b,c)=>b+c)}$
\end_inset

 is similar to 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The Rx library exposes a comprehensive set of 
\emph on
operators
\emph default
 that implement various manipulations.
 For example, 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 operator performs a mapping manipulation according to a mapping function
 received as a parameter.
 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 operator performs a merging of streams, and so on.
 An operator is a function over streams.
 This function takes streams as its arguments and returns a stream according
 to the required manipulation.
 For example, in the execution of 
\begin_inset Formula $\LSTINLINE{B=A.Select(x=>x+1)}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 operation generates a new stream and, for each 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 in stream 
\begin_inset Formula $\LSTINLINE A$
\end_inset

, streams 
\begin_inset Formula $\LSTINLINE{x+1}$
\end_inset

 to it.
 Similarly, in the execution of 
\begin_inset Formula $\LSTINLINE{C=A.Merge(B)}$
\end_inset

, the 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 operation generates a new stream that is a combination of streams 
\begin_inset Formula $\LSTINLINE A$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
\end_layout

\begin_layout Subsection
(Benefits and )Limitations
\end_layout

\begin_layout Plain Layout
An observable can be presented as a reactive variable 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it can be that each item represents a change in the value 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Observables can be used to represent GUI control change events 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, and also a reactive variable
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, by this representation, each item represents a change in the value.
 
\end_layout

\begin_layout Plain Layout
Provided operators 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

 are related to a concept named 
\emph on
lifting
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

.
 They enable functions to be used like 
\emph on
higher order functions.

\emph default
 An unary function can be used by the operator 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 (that maps each item according to the function), and a binary function
 can be used by an operator 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, that works for two observable streams, mapping based on items from the
 two.
 For example, The code 
\begin_inset Formula $\LSTINLINE{A=B.Select(x=>x+1)}$
\end_inset

 is similar to 
\begin_inset Formula $\LSTINLINE{A:=B+1}$
\end_inset

 and the code 
\begin_inset Formula $\LSTINLINE{A=B.CombineLatest(C,(b,c)=>b+c)}$
\end_inset

 is similar to 
\begin_inset Formula $\LSTINLINE{A:=B+C}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
...
\end_layout

\begin_layout Subsection
Rx as FRP (Reactive Variables)
\end_layout

\begin_layout Plain Layout
Rx works with 
\emph on
observable streams
\emph default
 (known also as 
\emph on
reactive streams
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://cycle.js.org/
\end_layout

\end_inset


\end_layout

\end_inset

, or just 
\emph on
observable
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

)
\emph on
.
 
\emph default
Observable stream refers to an object that delivers items for other objects
 through a method 
\emph on
next
\emph default
.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Streams-of-values-1-1-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, observable streams can be used to represent GUI control change events
 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, and also a reactive variable
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 By this representation, each item represents a change in the value.
 
\end_layout

\begin_layout Plain Layout
Since observable stream acts similar to reactive variables 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, provided operators are very similar to the concept of 
\emph on
lifting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bainomugisha2013survey"
literal "false"

\end_inset

, because they convert a function to be a 
\emph on
higher order function.
 
\emph default
An unary function can be lifted by the operator 
\begin_inset Formula $\LSTINLINE{Select}$
\end_inset

 that maps each item according to the function.
 For example, the expression 
\begin_inset Formula $\LSTINLINE{B=D.Select(x=>x+1)}$
\end_inset

 means that each value in 
\begin_inset Formula $\LSTINLINE D$
\end_inset

 is passed through the function 
\begin_inset Formula $\LSTINLINE{x=>x+1}$
\end_inset

, resulting in a new value for 
\begin_inset Formula $\LSTINLINE B$
\end_inset

.
 A binary function can be lifted by an operator 
\begin_inset Formula $\LSTINLINE{CombineLatest}$
\end_inset

, that works for two observable streams, mapping based on items from the
 two.
\end_layout

\begin_layout Plain Layout
The observable streams is similar to 
\emph on
stream
\emph default
 that represents a programming approach 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,red] (0x0) at (1,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,yellow] (1x0) at (2,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,green] (2x0) at (3,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,cyan] (3x0) at (4,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,blue] (4x0) at (5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle,magenta] (5x0) at (6,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x0) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=7cm] (op) {Select
\backslash
{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tikzpicture}[baseline=-1mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,circle] (x) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[marble,diamond,right=5mm of x] (y) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
draw [fdash] (x) -- (y);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

  
\backslash
}};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (7,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,red] (0x2) at (1,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,yellow] (1x2) at (2,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,green] (2x2) at (3,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,cyan] (3x2) at (4,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,blue] (4x2) at (5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,diamond,magenta] (5x2) at (6,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[complete] (6x2) at (6.5,0) {};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x0) -- (0x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (4x0) -- (4x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (5x0) -- (5x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (6x0) -- (6x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (0x2) -- (0x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x2) -- (1x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x2) -- (2x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x2) -- (3x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x2) -- (4x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x2) -- (5x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (6x2) -- (6x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Merge Streams
\end_layout

\begin_layout Plain Layout
In Rx, the 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 operator combines multiple source observables into a single output stream.
 However, 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 can exhibit unpredictable behavior when handling simultaneous emissions
 from its source observables.
 The order in which simultaneous values appear in the output stream is not
 defined and may depend on hidden factors such as thread scheduling and
 internal implementation details.
 This leads to considering Rx as not 
\emph on
true FRP
\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 (In 
\begin_inset Formula $\NAME{sodium}$
\end_inset

 that the developers need to provide the method on how to determine the
 order of the values.)
\end_layout

\begin_layout Subsection
Streams In General
\end_layout

\begin_layout Plain Layout
The observable in Rx is similar to a general concept stream 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

 presented as an alternative to using variables.
 Streams has a question of how to merge streams correctly.
 It is a dual question of how to manage the variables state correctly.
\end_layout

\begin_layout Plain Layout
The approach used in Rx is similar to a general programming approach of
 programming with streams
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 The question of the 
\begin_inset Formula $\LSTINLINE{Merge}$
\end_inset

 is similar to a general merge 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In stream-based programming, merging streams presents a challenge analogous
 to managing state in traditional programming.
 This is because, similar to how the assignment operator allows multiple
 parts of the code to modify a variable unpredictably, merging streams without
 a defined strategy can lead to unpredictable outcomes when handling simultaneou
s emissions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Although that we handle one-way constraints rather than multi-way, our algorithm
 is similar.
\end_layout

\begin_layout Plain Layout
The concept of
\family typewriter
 multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Conflicts means a cenario that two or more constraints cannot be satisfied
 simultaneously.
 
\end_layout

\begin_layout Plain Layout
Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handle it similar to how it is handled in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Conflicts is usualy related to when consraints are multidirtional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handles it similar to how it is hadnled in Hotdrink.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library, mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 This is available in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset

.
 By our merge operation, each new sample from any of the sources are passed
 to the target variable, which recursively pass new values to targets variables.
 Consequently, in fields calculations, once the user puts a new input for
 a field, the fields that rely on a previous input, specifically the oldest
 input, are overwritten.
 Similary in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the input adds constraints to be in the top priority, causing to override
 values derived from old inputs.
 As a result, it seems like that our change propogation is like in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Plain Layout
A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts
\end_layout

\begin_layout Plain Layout
Constraints typically refered as multidirectional constraints
\end_layout

\begin_layout Plain Layout
Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Maintaining constraints is required sometimes to handle 
\emph on
conflicts
\emph default
.
 Conflicts arise in declarative constraints when two or more constraints
 cannot be satisfied simultaneously.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for empirical comparison
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

.
 In the two, whenever the user put new input for a field, the fields that
 relied on a previous input, specifically the oldest input, are overwritten.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Similar to how we handle cycles, constraints systems do by handling two-way
 constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

 (more details later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Comparing to Constraints Systems
\end_layout

\begin_layout Plain Layout
This thesis is like constraints systems, providing consistency between variables.
 However in constraints systems, developer are forced to one block of code
 that run on a single machine, while this thesis provides modular architecture.
 
\end_layout

\begin_layout Subsection
Multi-way Constraints
\end_layout

\begin_layout Plain Layout
In constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 With the proposed Rivars, it is implemented by declaring three formulas:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 However, the long verbosity exists also in constraints systems, when developers
 need specifying methods to satisfy the constraints.
 In addition, building blocks can easily built on top of our thesis.
 This means more extensions can be implemented by combining several formulas
 into a single constraint.
\end_layout

\begin_layout Subsection
Handle Consistency
\end_layout

\begin_layout Plain Layout
As mentioned, in constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 However, it is not clear what variable's value should be changed, especially
 when both other variables are not empty.
\end_layout

\begin_layout Plain Layout
The same question is arisen when declaring RIvar' formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 Our merge method produce variable's values according to the total order
 over the propogated values, that is derived from a total order over the
 external input events.
 In other words, values produced from old events are overidden by new ones.
\end_layout

\begin_layout Plain Layout
As in 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, first, constraints systems handle consistency according 
\emph on
hierarchical
\emph default
 consraints, that is to ignore constraints if they belong to the low levels
 of hierarchy.
 Second, they consider external inputs as constraints, for example the constrain
t 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=1
\end_layout

\end_inset

 is added when the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

.
 Third, external inputs' constraints are set in the hierarchy, according
 to the events' order.
\end_layout

\begin_layout Plain Layout
Consequently, the decision what variables to update in the automatic updates
 seems the same.
 
\end_layout

\begin_layout Subsection
Decentralized Calculation
\end_layout

\begin_layout Plain Layout
Constraints systems (and most reactive programming implementations
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) manage the constraints and handle them by a one centralized procedure.
 Similary is the approach in the code, the applications' code are of one
 block, because: 
\begin_inset Quotes eld
\end_inset

If the one-way constraints are defined in separate places, co-ordinating
 these constraints can be a major software engineering problem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Consequently, the market which needs modular solutions, does not adopt
 such centerlized solutions 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-2"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
