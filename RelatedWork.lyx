#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Related-Work"

\end_inset

Related Work
\end_layout

\begin_layout Section
Combining FRP with OOP
\end_layout

\begin_layout Standard
Additional works exploring the integration of FRP and OOP are presented
 below.
\end_layout

\begin_layout Subsection
Events and Signals
\end_layout

\begin_layout Standard
In the first stage, the previous attempts focused on converting or reconciling
 concepts between FRP and OOP.
 
\begin_inset Formula $\REScala$
\end_inset

, provides 
\emph on
signals
\emph default
 that can be converted to events to fit into the OOP paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In another library, 
\begin_inset Formula $\NAME{SignalJ}$
\end_inset

, with the pure FRP, events are triggered as 
\emph on
side effects
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kamina2018"
literal "false"

\end_inset

.
 The idea we used, found in 
\begin_inset Formula $\NAME{RxJS}$
\end_inset

, involves implementing reactive variables as the Observer and Iterator
 design patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

, where values are pushed to subscribers by executing their method 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

.
 This approach harmonizes previous ideas by treating observables as streams
 of events in the OOP world and streams of effects in the functional realm
 that FRP is originally based on.
\end_layout

\begin_layout Subsection
Objects and Reactive Variables
\end_layout

\begin_layout Standard
Our new assignment operation answers a traditional issue of assigning reactive
 variables from outside objects
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 The traditional assignment replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The new assignment operation also answers a second traditional mechanism.
 By the use of an integration with the events mechanism, a meaning similar
 to assignment can be produced.
 For example, in 
\begin_inset Formula $\ReactiveX$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 This mechanism might lead to infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

, that a change in a reactive variable executes an event handler, causing
 the reactive variable to change again.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our work builds upon of 
\begin_inset Formula $\ReactiveX$
\end_inset

 and 
\begin_inset Formula $\REScala$
\end_inset

 of having reactive variables as objects' attributes.
 This means that the object interface is added with reactive variable such
 like the operations or fields accessed by getters and setters.
 
\end_layout

\begin_layout Plain Layout
Traditionaly, there is an issue in reactive variables assigned from outside
 of the objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 This assignment operation replaces the calculation, stopping the old source
 in order to start responding to the new source.
 This is in contrast to the declarative and functional approach originating
 in FRP, where programs should "describe things that exist, rather than
 actions that have happened or are to happen (i.e., what is, not what does)"
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In addition, by the integration with the events mechanism, a meaning similar
 to assignment can be produced, such as 
\begin_inset Formula $\LSTINLINE{A.subscribe(val=>B.next(val))}$
\end_inset

 in 
\begin_inset Formula $\ReactiveX$
\end_inset

 that produces meaning similar to 
\begin_inset Formula $\LSTINLINE{A:=B}$
\end_inset

.
 However, the integration with the events mechanism is associated with issues
 of infinite loops 
\begin_inset CommandInset citation
LatexCommand cite
key "schuster2016reactive"
literal "false"

\end_inset

.
 For example, a change in a reactive variable might execute an event handler,
 causing the reactive variable to change again.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reactive Objects
\end_layout

\begin_layout Standard
Our work builds upon 
\begin_inset Formula $\REScala$
\end_inset

 that reactive variables are part of the object interface similar to operations
 or fields accessed by getters and setters 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
 In the same time, we provide like 
\emph on
reactive objects 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "boix2013object"
literal "false"

\end_inset

, in using objects with reactive variables as the objects' attributes.
 This alters the traditional semantics of OOP, that entire objects become
 the unit of reactivity.
 We implemented the example.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/RIVarX/rivarjs/blob/VisualRIVar_Works_In_Example/test/Reactive
Objects.js
\end_layout

\end_inset


\end_layout

\end_inset

 In a class called 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

, there are attributes 
\begin_inset Formula $\LSTINLINE x$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE y$
\end_inset

, along with a method called 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{Move}$
\end_inset

 method takes another 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object as an argument and creates a third 
\begin_inset Formula $\LSTINLINE{Coordinate}$
\end_inset

 object that will be automatically updated according to the changes, describing
 the target moved coordinate.
\end_layout

\begin_layout Standard
The new semantics consist of interacted objects without the need for a mediator
 that have access to objects' encapsulated state or behavior.
 Traditional implementations that achieve predictability use a mediator
 to access all variables.
 Even 
\begin_inset Formula $\REScala$
\end_inset

, which was created to bridge object-oriented and functional programming
 styles, replaces the traditional events modules with a dedicated centralized
 algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "Salvaneschi2014"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Inheritance and Polymorphism
\end_layout

\begin_layout Standard
For programmers, it has been pointed out the 
\emph on
Liskov Substitution Principle
\emph default
 (LSP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, such that a sub class will not change the behavior of its parent.
 For this reason, the reassignments will never override previous assignments.
 Instead, the data dependency graph will expand.
 Previously it has been mentioned: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the previous research about how to harmonize reactive variables into
 objects, it has mentioned the issue about inheritance: 
\begin_inset Quotes eld
\end_inset

Should it be possible to override a reactive value with a new dependency
 expression or refer to the overridden one via super?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
 Inheritance has also being long been recognized as a challenge in managing
 data dependencies between parent and child classes 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 with the 
\emph on
object re-entrance 
\emph default
issue 
\begin_inset CommandInset citation
LatexCommand cite
key "duncan2003component"
literal "false"

\end_inset

 mentioned in
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Also, the polymorphism has been mentioned, that it is desirable that the
 dynamic type will capture the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
We give the answer mentioned through this thesis by that an assignment should
 be enabled everywhere with the meaning of adding the dependencies.
 This answer is provided following the consideration whether a subclass
 should be allowed to override dependencies defined in its parent.
 If a subclass changes the behavior of its super class, the resulting type
 does not inherit the entire behavior of the parent.
 Therefore, we have defined that the assignment only adds dependencies without
 overriding old ones.
 As a result, the resulting object derives its entire functionality from
 the hierarchy.
 As mentioned, the polymorphism means that the dynamic type will capture
 the dependencies 
\begin_inset CommandInset citation
LatexCommand cite
key "salvaneschi2014towards"
literal "false"

\end_inset

, as it is actualy done.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Change Propagation Algorithms
\end_layout

\begin_layout Standard
In modern frameworks like 
\family typewriter
React
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://react.dev/
\end_layout

\end_inset


\end_layout

\end_inset


\family default
 and also 
\family typewriter
Flutter
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://docs.flutter.dev
\end_layout

\end_inset

 applications utilize dedicated state management solutions to handle variables.
 Among these state management solutions, 
\family typewriter
Redux
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caspers2017react"
literal "false"

\end_inset

 stands out as a highly popular choice.
 It adopts a model inspired by 
\emph on
statechart
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "harel1995statement"
literal "false"

\end_inset

.
 As depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Statechart"
plural "false"
caps "true"
noprefix "false"

\end_inset

, events are modeled as state transitions between logical states, which
 are determined based on variable values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[   round/.style={rounded corners=1.5mm,minimum width=1cm,inner sep=2mm,above
 right,draw,align=center,text width=4mm}
\end_layout

\begin_layout Plain Layout

]
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S1) at (2.5,2) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S2) at (0,0) {};
\end_layout

\begin_layout Plain Layout

    
\backslash
node[round] (S3) at (5,0) {};
\end_layout

\begin_layout Plain Layout

     
\backslash
node[round] (S4) at (2.5, -3) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[-latex] (3.5, 3.5) coordinate (init) to[out=180, in=90] (S1);
\end_layout

\begin_layout Plain Layout

    
\backslash
fill (init) circle (0.05);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=180, in=90]  node[scale=0.8] {y changed} (S2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S1) edge[out=0, in=90]  node[scale=0.8] {z changed} (S3);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S2) edge[out=270, in=180]  node[scale=0.8] {z changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path[-latex] (S3) edge[out=270, in=0]  node[scale=0.8] {y changed/calculate
 x} (S4);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

     
\backslash
draw[-latex] (S4) to [loop below, looseness=8, out=-60, in=-120, min distance=10
mm] node[scale=0.8]  { y changed/calculate x;
\end_layout

\begin_layout Plain Layout

z changed/calculate x} (S4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
draw (3.5, -4) coordinate (empty);
\end_layout

\begin_layout Plain Layout

      
\backslash
node[round,fit=(S1)(S2)(S3)(S4)(init)(empty)] (System) {};
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Statechart"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset


\end_layout

\end_inset

Modeling the statechart for the formula 
\begin_inset Formula $\LSTINLINE{x:=y+z}$
\end_inset

.
 The rectangular shapes represent different states or modes of the application.
 The arrows represent transitions between the states, triggered by specific
 events.
 The labels contain the events and also actions, if needed, to perform in
 response to events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The idea to bring the developers user friendly mechanism to fields calculations
 brings also the 
\emph on
constraints systems
\emph default
.
 In constraints systems, developers declare equations, and the runtime automates
 variable updates based on these equations and input.
 There exist systems that support 
\emph on
one-way constraints
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

, where the system updates only the left-hand variable in response to changes
 in the right-hand expression.
 They reminds reactive variables and FRP.
 Many implementations in FRP consists of a centralized manager 
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Actualy, as in the state management solution 
\begin_inset Formula $\NAME{MobX}$
\end_inset

 with the 
\begin_inset Formula $\NAME{React}$
\end_inset

 framework, fields calculations can consist of reactive variables implemented
 by a state management solution connected to the visual fields.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Hotdrink
\end_layout

\begin_layout Standard

\family typewriter
Hotdrink
\family default
 is a library implemented with a thesis-driven approach, similar to this
 thesis, to address the lack of support for cycles in data dependencies.
 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The concept of
\family typewriter
 
\family default
multiple assignment has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Although that we handle one-way constraints rather than multi-way, the
 algorithm is similar to one used for multi-way in 
\family typewriter
Hotdrink.
\end_layout

\begin_layout Standard
On the other hand, there are systems that support 
\emph on
two-way constraints
\emph default

\begin_inset space \thinspace{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "haveraaen2021semantics,foust2015generating,sannella1993multi"
literal "false"

\end_inset

, such as 
\family typewriter
Hotdrink
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hotdrink.github.io/hotdrink/
\end_layout

\end_inset

 which are declared using methods to satisfy the constraints.
 For instance, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:two-way-constraint-1-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the equation 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 is attached with the methods 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

, 
\begin_inset Formula $\LSTINLINE{B=A-C}$
\end_inset

 and 
\begin_inset Formula $\LSTINLINE{C=A-B}$
\end_inset

.
 The systems utilize algorithms, named 
\emph on
constraints solvers
\emph default
, to maintain consistency in variable values.
 As in 
\family typewriter
Hotdrink
\family default
, the constraints solver uses a model named 
\emph on
constraint hierarchies
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 In order to maintain the variables according to the constraints, as in
 the example in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:constraints-hirarchy-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the runtime maintains additional constraints.
 For each variable 
\family typewriter
X
\family default
 containing a value 
\family typewriter
x
\family default
, the runtime maintains a constraint 
\begin_inset Formula $\LSTINLINE{X=x}$
\end_inset

, with hierarchy according to the order of the input.
 If there is no solution that satisfy all the constraints, the more prioritized
 constraints, according to the hirarchy, are satsified.
 As a result, once the user put new input for a field, the fields that relied
 on a previous input, specifically the oldest input, are overwritten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

function  sum( a, b ) { return a + b; }
\end_layout

\begin_layout Plain Layout

function diff( a, b ) { return a - b; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var model = new hd.ModelBuilder()
\end_layout

\begin_layout Plain Layout

    .variables( {A: 0, B: 0, C: 0} )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .constraint( A, B, C )
\end_layout

\begin_layout Plain Layout

      .method( 'B, C -> A', sum  ) // A:=B+C
\end_layout

\begin_layout Plain Layout

      .method( 'A, C -> B', diff ) // B:=A-C
\end_layout

\begin_layout Plain Layout

      .method( 'A, B -> C', diff ) // C:=A-B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .end();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-way-constraint-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset


\end_layout

\end_inset

Two-way constraint 
\begin_inset Formula $\LSTINLINE{A=B+C}$
\end_inset

 implemented by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The 
\begin_inset Formula $\LSTINLINE{constraint}$
\end_inset

 method is used to create the constraint by specifying the variables as
 arguments and chaining the necessary methods.
 Each method has two parameters: the data flow direction and the function
 to execute when that method is chosen to satisfy the constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Constraints hierarchical in descending order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=1, B=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, B=2, A=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=2, B=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=B, A=3, B=2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A=3, B=3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:constraints-hirarchy-1"

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Maintaining 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{B}
\end_layout

\end_inset

 according to the constraint 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{A=B}
\end_layout

\end_inset

, using constraint hierarchies.
\end_layout

\end_inset

Maintaining 
\begin_inset Formula $\NAME A$
\end_inset

 and 
\begin_inset Formula $\NAME B$
\end_inset

 according to the constraint 
\begin_inset Formula $\NAME{A=B}$
\end_inset

, using constraint hierarchies.
 Each row represents a step in the interaction.
 The first column mentions the input provided.
 The second column mentions the exiting constraints following the input
 provided.
 The third column displays the values of the variables, as determined by
 the constraint solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Although that we handle one-way constraints rather than multi-way, our algorithm
 is similar.
\end_layout

\begin_layout Plain Layout
The concept of
\family typewriter
 multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Conflicts means a cenario that two or more constraints cannot be satisfied
 simultaneously.
 
\end_layout

\begin_layout Plain Layout
Conflicts are usually related to when constraints are multidirectional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handle it similar to how it is handled in 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Conflicts is usualy related to when consraints are multidirtional.
 A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 We handles it similar to how it is hadnled in Hotdrink.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library, mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

.
 This is available in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset

.
 By our merge operation, each new sample from any of the sources are passed
 to the target variable, which recursively pass new values to targets variables.
 Consequently, in fields calculations, once the user puts a new input for
 a field, the fields that rely on a previous input, specifically the oldest
 input, are overwritten.
 Similary in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

, the input adds constraints to be in the top priority, causing to override
 values derived from old inputs.
 As a result, it seems like that our change propogation is like in the 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 library.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Plain Layout
A system is over-constrained when you have too many constraints for the
 number of variables.
 These constraints might be conflicting, making it impossible to find an
 assignment of values to the variables that satisfies all of them 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 has a meaning of 
\emph on
conflicts
\emph default
 of several 
\emph on
one-way constraints
\emph default
.
 Conflicts
\end_layout

\begin_layout Plain Layout
Constraints typically refered as multidirectional constraints
\end_layout

\begin_layout Plain Layout
Constraints describe relations that must be maintained 
\begin_inset CommandInset citation
LatexCommand cite
key "borning1987constraint"
literal "false"

\end_inset

.
 Maintaining constraints is required sometimes to handle 
\emph on
conflicts
\emph default
.
 Conflicts arise in declarative constraints when two or more constraints
 cannot be satisfied simultaneously.
\end_layout

\begin_layout Plain Layout
has a meaning similar to constraints.
 In constraints systems, a constraint means a relation over a set of variables
 that the runtime enforces by updating variables.
\end_layout

\begin_layout Plain Layout
The concept of 
\family typewriter
multiple assignment
\family default
 is basicly very similar to 
\family typewriter
one-way dataflow constraints
\begin_inset space ~
\end_inset


\family default

\begin_inset CommandInset citation
LatexCommand cite
key "demetrescu2011reactive"
literal "false"

\end_inset

.
 However, since our motivation is for enabling cycles, we approach this
 problem differently.
 Whereas in constraints systems, the discussion is about conflicts, we introduce
 an approach of 
\emph on
merging streams
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced propogation algorithm behaves similar to 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

.
 The Drug Administration example is implemented side by side by 
\begin_inset Formula $\NAME{Hotdrink}$
\end_inset

 and 
\begin_inset Formula $\NAME{rivarjs}$
\end_inset

 for empirical comparison
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
available in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

.
 In the two, whenever the user put new input for a field, the fields that
 relied on a previous input, specifically the oldest input, are overwritten.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Similar to how we handle cycles, constraints systems do by handling two-way
 constraints 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

 (more details later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
...
\end_layout

\begin_layout Section
Comparing to Constraints Systems
\end_layout

\begin_layout Plain Layout
This thesis is like constraints systems, providing consistency between variables.
 However in constraints systems, developer are forced to one block of code
 that run on a single machine, while this thesis provides modular architecture.
 
\end_layout

\begin_layout Subsection
Multi-way Constraints
\end_layout

\begin_layout Plain Layout
In constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 With the proposed Rivars, it is implemented by declaring three formulas:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 However, the long verbosity exists also in constraints systems, when developers
 need specifying methods to satisfy the constraints.
 In addition, building blocks can easily built on top of our thesis.
 This means more extensions can be implemented by combining several formulas
 into a single constraint.
\end_layout

\begin_layout Subsection
Handle Consistency
\end_layout

\begin_layout Plain Layout
As mentioned, in constraints systems, we can declare 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=B+C
\end_layout

\end_inset

, and each user update, to any of the variables, follows an automatic update
 to the left variables.
 However, it is not clear what variable's value should be changed, especially
 when both other variables are not empty.
\end_layout

\begin_layout Plain Layout
The same question is arisen when declaring RIvar' formulas 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

B:=A-C
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

C:=A-B
\end_layout

\end_inset

.
 Our merge method produce variable's values according to the total order
 over the propogated values, that is derived from a total order over the
 external input events.
 In other words, values produced from old events are overidden by new ones.
\end_layout

\begin_layout Plain Layout
As in 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

, first, constraints systems handle consistency according 
\emph on
hierarchical
\emph default
 consraints, that is to ignore constraints if they belong to the low levels
 of hierarchy.
 Second, they consider external inputs as constraints, for example the constrain
t 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=1
\end_layout

\end_inset

 is added when the user set 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with 
\begin_inset ERT
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

.
 Third, external inputs' constraints are set in the hierarchy, according
 to the events' order.
\end_layout

\begin_layout Plain Layout
Consequently, the decision what variables to update in the automatic updates
 seems the same.
 
\end_layout

\begin_layout Subsection
Decentralized Calculation
\end_layout

\begin_layout Plain Layout
Constraints systems (and most reactive programming implementations
\begin_inset CommandInset citation
LatexCommand cite
key "drechsler2014distributed"
literal "false"

\end_inset

) manage the constraints and handle them by a one centralized procedure.
 Similary is the approach in the code, the applications' code are of one
 block, because: 
\begin_inset Quotes eld
\end_inset

If the one-way constraints are defined in separate places, co-ordinating
 these constraints can be a major software engineering problem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 Consequently, the market which needs modular solutions, does not adopt
 such centerlized solutions 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By the introduced assignment the implemented new variant 
\end_layout

\begin_layout Plain Layout
In 
\end_layout

\begin_layout Plain Layout
The superposition property is achived since any added formula does extend
 the application.
 In previous implementations, the assignmemt did replace to the calcu 
\end_layout

\begin_layout Plain Layout
Since the implementation is based on observables extensions, unpredictability
 might only coming from merges, glitches and recursions.
\end_layout

\begin_layout Plain Layout
our issue blocking from having the desired predictability, is the merge
 operations and recursions.
 
\end_layout

\begin_layout Plain Layout
derive some features predictability several operations.
 However, we should complete our proof for predictability, because in using
 streams, there is has the same general time problem we have in the events
 driven 
\begin_inset CommandInset citation
LatexCommand cite
key "abelson1996structure"
literal "false"

\end_inset

.
 In the industry libraries, as can be seen in ReactiveX and Sodium, there
 is either an inpredictable merge function or that the developer need to
 specify the method to merge 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
almost all operations produced the refern
\end_layout

\begin_layout Plain Layout
we need only the inpreditabiity reursions and merges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The introduced operators provide functions over streams achieving properties
 characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\begin_layout Plain Layout
The merge property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
We introduced the merge operator as a function over streams, with the property
 known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
\end_layout

\begin_layout Plain Layout
Furthermore, we guarantee that the same sequence of events consistently
 produces the same results, achieving properties characterized by FRP.
 FRP is originally described as functions over reactive variables, with
 the property known as
\emph on
 functional transparency
\emph default
, meaning that the input consistently produces the same output.
 We have achieved this property by functions over streams of events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
n {5} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
radius {3cm} 
\end_layout

\begin_layout Plain Layout


\backslash
def 
\backslash
margin {8} % margin in angles, depends on the radius
\end_layout

\begin_layout Plain Layout


\backslash
foreach [count=
\backslash
s] 
\backslash
j in {A,B,...,E} 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, circle] (
\backslash
j) at ({360/
\backslash
n * (
\backslash
s - 1)}:
\backslash
radius) {
\backslash
j};   
\backslash
draw[->, >=latex] ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:
\backslash
radius)      arc ({360/
\backslash
n * (
\backslash
s - 1)+
\backslash
margin}:{360/
\backslash
n * (
\backslash
s)-
\backslash
margin}:
\backslash
radius);          
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[above] 
\backslash
node[draw, circle] (X) at (-3,3) {X};    
\end_layout

\begin_layout Plain Layout


\backslash
draw [->, >=latex] (X) -- (C) node[midway, right=-0.1cm] {merge};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cycle-merge-produce-concurrent-events-1-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
\end_layout

\end_inset

The 
\begin_inset Formula $\LSTINLINE{merge}$
\end_inset

 operation as the location to handle the unexpected feedback loop.
 The graph illustrates an example produced from a DFS traversal of a change
 propogation (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Observable-Streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), initiated from an external input to the variable 
\begin_inset Formula $\LSTINLINE C$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Illustrating the spanning graph in the case of a cycle in the dependencies,
 when node C receives an input, it propagates it to node D, then to node
 E, and so on, until node B forwards it back to node C through the merge
 operator.
 However, this update is stale and should not be propagated again to node
 D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2-1"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this thesis, we aimed to strike a balance between abstraction and control
 in value propagation.
 Our framework provides a high-level language based on FRP, accompanied
 by a general propagation algorithm that ensures a defined update sequence.
 While the drug administration example demonstrates clear business logic,
 encompassing defined objects, variables, and calculations, the propagation
 algorithms may not fulfill business requirements for other applications.
 Moreover, performance considerations (non-functional requirements) may
 necessitate modifying the update order, such as lowering consistency levels
 for resource-intensive computations.
\end_layout

\begin_layout Section
The Propogation Algorithm
\end_layout

\begin_layout Plain Layout
We have implemented and made publicly available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rivarx.github.io/Evaluation
\end_layout

\end_inset


\end_layout

\end_inset

 two drug administration examples: one using rivarjs and the other using
 hotdrink.
 Upon observation, both implementations exhibit similar behavior.
 Once a field is updated, the fields that relied on the previous input,
 specifically the oldest input, are overwritten.
 In the case of Hotdrink, the addition of new input triggers the creation
 of an equation constraint at the highest level of the hierarchy, involving
 the variable and the input.
 Plans are then generated, with each plan recursively searching for equations
 where the left variables are determined by preceding equations.
 The plan that satisfies the most constraints in the hierarchy is selected
 and executed.
 This aligns with our propagation approach, as we continue propagating values
 derived from the highest priority values.
 Consequently, the update sequence for both methods—our framework and the
 constraint hierarchy model for GUI—is identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To evaluate the approach, we first implemented (https://rivarx.github.io/UsageExam
ples/) the drug administration presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Background"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As ilustarted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration-UML-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we have splited the drug administration form into two distinct objects.
 Each object is responsible for managing only the variables and relationships
 that are directly relevant to it.
 For instance, the concentration of the bag is hidden from the pump because
 the pump object only interacts directly with the bag's drug and volume.
 Conversely, the concentration is only indirectly communicated with the
 pump since it is updated from changes in the amount or volume.
 According to this example, if the propogation algorithm is sufficient,
 we achived our goal.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.8]%[show  background  grid]
\end_layout

\begin_layout Plain Layout


\backslash
begin{interface}{IBag}{0,-5}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Drug}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{VolumeOfFluid}
\end_layout

\begin_layout Plain Layout


\backslash
end{interface}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}[text width=8 cm]{Pump}{0,0}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Duration}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Dose}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Rate}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
composition{Pump}{TheBag}{}{IBag}
\end_layout

\begin_layout Plain Layout


\backslash
begin{class}{Bag}{0,-10}
\end_layout

\begin_layout Plain Layout


\backslash
implement {IBag}
\end_layout

\begin_layout Plain Layout


\backslash
attribute{Concentration}
\end_layout

\begin_layout Plain Layout


\backslash
end{class}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Drug-Administration-UML-2"

\end_inset

A UML diagram showing a composition relationship between a Pump class and
 an IBag interface.
 The Pump class has three attributes: Duration, Dose, and Rate.
 The Bag class implements the IBag interface and has two attributes: Drug
 and VolumeOfFluid, as well as an additional attribute called Concentration.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The Case Study
\end_layout

\begin_layout Plain Layout
We implemented the motivating example by using RIVarX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/RivkaAltshuler/RIVar/tree/main/CaseStudies/DrugAdministration
\end_layout

\end_inset

.
 As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Class-Pump-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is a class depending on the interface 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

, containing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Drug}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{VolumeOfFluid}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 depends on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

 by containing the class variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{TheBag}
\end_layout

\end_inset

 typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
 Based on the existing bag, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 contains 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Rate}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Dose}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Duration}
\end_layout

\end_inset

 also typed as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{RIVar}
\end_layout

\end_inset

.
 In the constructor of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 we define formulas to calculate the accessible variables.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 class is independently implemented deriving from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{IBag}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 does not depend on each other, according to the 
\emph on
Dependency Inversion Principle
\emph default
 (DIP): 
\begin_inset Quotes eld
\end_inset

high level modules should not depend on low level modules; both should depend
 on abstractions
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

.
 Also in runtime, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 has a consistent behavior when connected or unconnected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

.
 Unless 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has input, the connected 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 has no effect on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

.
 This is simulated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bag-In-Runtime-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout

line~
\backslash
ref{line:pump}
\end_layout

\end_inset

 has no effect on the outcome.
 Similary, if we had an inheritance instead of the composition, such that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 is the base class and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 is the subclass.
 Then, according to the
\emph on
 Liskov Substitution Principle
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "martin2018clean"
literal "false"

\end_inset

, objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 can be replaced by objects of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 without any effect.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

public class Pump
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Rate = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Dose = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

    public RIVar<decimal> Duration = new RIVar<decimal>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IBag TheBag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Pump(IBag bag)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        TheBag = bag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Dose.Set(TheBag.Amount.Div(Duration));
\end_layout

\begin_layout Plain Layout

        Rate.Set(TheBag.Volume.Div(Duration));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Amount.Div(Dose));
\end_layout

\begin_layout Plain Layout

        Duration.Set(TheBag.Volume.Div(Rate));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        TheBag.Amount.Set(Duration.Mul(Dose));
\end_layout

\begin_layout Plain Layout

        TheBag.Volume.Set(Duration.Mul(Rate));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-Pump-1"

\end_inset

Class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

decimal result = 0;
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

bag.Concentration.Subscribe(new observer(o => result = o));
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);|
\backslash
label{line:pump}| // this line has no effect
\end_layout

\begin_layout Plain Layout

bag.Amount.OnNext(100);
\end_layout

\begin_layout Plain Layout

bag.Volume.OnNext(200);
\end_layout

\begin_layout Plain Layout

Assert.AreEqual(0.5, result);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bag-In-Runtime-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag} in runtime
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:The-design-of"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we introduced a micro-frontend design.
 Accordingly, we developed loosly coupled components that can be developed,
 built and deployed indepedently.
 The bootsrap is introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Bootstrap-of-the-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 is like the bag micro frontend, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 is like the pump micro frontend.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{UserControl_Pump}
\end_layout

\end_inset

 implements the UI and are connected to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

 respectively.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting} 
\end_layout

\begin_layout Plain Layout

var bag = new Bag();
\end_layout

\begin_layout Plain Layout

var pump = new Pump(bag);
\end_layout

\begin_layout Plain Layout

var bagUserControl = new UserControl_Bag(bag);
\end_layout

\begin_layout Plain Layout

var pumpUserControl = new UserControl_Pump(pump);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bootstrap-of-the-2"

\end_inset

Bootstrap of the drug administration components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The UI components are connected to the model objects (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Bag}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Pump}
\end_layout

\end_inset

) in such that whenever a user changes a field's value, it produces an input
 to the related variable, causing other variables to be calculated, producing
 updates in their related fields.
 The UI components also provide the functionality to indicate calculated
 values, just like in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Drug-Administration"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In addition, The UI components append to a log file any value change.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Log-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we introduce the log output of the cenario introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except the unexpected update.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Dose_Control:10
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <1>
\end_layout

\begin_layout Plain Layout
Duration_Control:10
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,1>
\end_layout

\begin_layout Plain Layout
Drug_Control:100
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <2,3>
\end_layout

\begin_layout Plain Layout
Dose_Control: 10 <3,2>
\end_layout

\begin_layout Plain Layout
Drug_Control: 100 <3>
\end_layout

\begin_layout Plain Layout
Duration_Control: 10 <2>
\end_layout

\begin_layout Plain Layout
Volume_Control:300
\end_layout

\begin_layout Plain Layout
Drug_Control: 100.00 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,3,4>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <3,4,2>
\end_layout

\begin_layout Plain Layout
Rate_Control:30.00
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <2,5>
\end_layout

\begin_layout Plain Layout
Rate_Control: 30.00 <5>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300.00 <3,4>
\end_layout

\begin_layout Plain Layout
Concentration_Control: 0.33 <3,4>
\end_layout

\begin_layout Plain Layout
Volume_Control: 300 <4>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Log-1"

\end_inset

Log for the cenario of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unpredictable-Calculation"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Algorithm
\end_layout

\begin_layout Plain Layout
first, front end need syncronization updates.
\end_layout

\begin_layout Plain Layout
second, our resulted libraries actualy produces a framework for decenterlized
 constraints systems.
 We provide the ability to declare one-way dataflow constraints targeting
 to variables that we do not own.
 While the entire system maintain the whole constraints as in hirarchial
 constraints systems.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this section, we compare our method to Hotdrink mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "par:Constraints"
plural "false"
caps "true"
noprefix "false"

\end_inset

, FRP and so our method are similar to Hotdrink in that they share declare
 equations, providing runtime automates to automate variables' updates,
 they support cycles and several assignments, and that they handle the variables
' values according to the order of the input.
 Our method is diffrent from Hotdrink in that it is a 
\emph on
decenterlized
\emph default
 constraints system, and that it handles one-way constraints.
\end_layout

\begin_layout Paragraph*
decenterlized constraints system
\end_layout

\begin_layout Plain Layout
Hotdrink needs for each input, to run against the entire constraints and
 existing values, to generate a new dependancy graph according to the variables'
 existing values.
 This algorithm is executed by a madiator coupling the entire variables
 and dependencies.
 As mentioned in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Repeating-Solutions"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this design causes applications to not being reused.
 In other words, Hotdrink can be used only to building monolith applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "marheim2017domain"
literal "false"

\end_inset

.
 In contrast, our method provides a decentrelized constraints system, the
 variables observe their sources and update their values by regular objects'
 messages.
 Consequently, by nature, relations between variables can be specified,
 even when variables are located in diffrent components.
\end_layout

\begin_layout Paragraph*
one-way constraints
\end_layout

\begin_layout Plain Layout
Hotdrink handles two-way constraints while our method handle one-way constraints.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ConstraintsInBackground"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the two-way constraints need attached one-way constraints, that are the
 
\emph on
methods 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

 to satisfy the two-way constraints.
 Consequently, with the two methods, the developer needs to specify one-way
 constraints.
 However, it has been augmented that it is more correct to specify two-way
 constraints, because several one-way constraints defined separately might
 define inconsistent requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "sannella1993multi"
literal "false"

\end_inset

.
 We leave this for future work.
 For this stage we provide two arguments to the claim.
 First, according to the motivating example, we need the option to write
 the one-way constraints separately.
 Second, the method should be used in a programming language that supports
 OOP.
 Consequently, it should not be hard to implement a wrapper class 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{Constraint}
\end_layout

\end_inset

 containing one-way constraints given as arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future Enhancments
\end_layout

\begin_layout Plain Layout
We provided a new abstraction with an elsticity.
 The fact that we provided an actual end to end solution, does not strict
 it.
 The merge function can be replaced depending on the feasibilty and requiremtns.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
