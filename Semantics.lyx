#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reactive Variables Semantics
\end_layout

\begin_layout Standard
We formulate semantics to reactive variables to conform also to RIVars.
 Two constraints are added to the implementation of reactive variables:
 First, any dependancy graph should be supported; not just DAG.
 Second, no centerlized management are alowed.
\end_layout

\begin_layout Standard
By the mean to support any dependancy graph, reactive variables are assigned
 without to avoid reassigments, recursions, glitches or being an input variable.
 The reason to the decentralized approach is because objects shoud interact
 directly by messages and events.
 Creating a centerlized engine causes the objects the need to share variables,
 to not encapsulate their state, and to depend on a third party to manage
 their state.
 
\end_layout

\begin_layout Standard
In addition to the first two constraints, we would satisfy the 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

.
 Referential transparency means that the same input will produce consistently
 the same output.
 The referential transparency property is what causes FRP to be predictable
 and composable.
 However, we use a formulation of the guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

: 
\begin_inset Quotes eld
\end_inset

the same sequence of events produces the same results, regardless of the
 timing of those events
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Essentiality the semantics includes two principals.
 First, variable's low level abstraction is an observable stream of values
 represeting its varying value.
 Second, a single variable can have several sources (from being an input
 variable while having one or more assigments, or just from having several
 assigments).
\end_layout

\begin_layout Standard
Taking the two principals, a variable with more than one source means having
 several streams of samples contributing to inferre its values.
 This is similar to situations when several devices sample a single real-world
 variable.
 Actualy by the mean of an assigment, another stream is added to the variable's
 sources.
\end_layout

\begin_layout Standard
We depend on the feasibility of having a 
\emph on
merge
\emph default
 function, such that an assigment will be handled as applying the merge
 function recursivle, e.g., 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B
\end_layout

\end_inset

 is handled as 
\begin_inset ERT
status open

\begin_layout Plain Layout

A=merge(A,B)
\end_layout

\end_inset

.
 The merge function should contain the logic, how to inffer the variable's
 values from its several sources.
 The merge function should be a pure function over streams.
 
\end_layout

\begin_layout Standard
The merge function suggests to inffer values according to the time: whenever
 a new value exists in any of the sources, the value would be propogated
 to the target variable.
 In the merge the time is reflected by ordering the items.
\end_layout

\begin_layout Section
Reactive Variables
\end_layout

\begin_layout Standard
A reactive variable, under the hood, is an 
\emph on
events stream
\emph default
, an observable emitting values to subscribers 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, based on the 
\emph on
observer
\emph default
 and 
\emph on
iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 This makes the management decenterlized and defines the reactive variable
 abstraction in the low level.
 In the high level, reactive variables are the typical 
\emph on
continuous
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

; they are used to define variables dependencies in the problem domain,
 independant of time.
\end_layout

\begin_layout Standard
The lower level abstraction 
\emph on
does
\emph default
 exist, because even when a reactive variable represents a real world variable
 in high level, in computers reactive variable's actual values cannot continuous
ly given.
 For example, temperature might be represented by a reactive variable depending
 on an actualy stream of discrete events, being sampled by a thermometer.
\end_layout

\begin_layout Standard
Similary in UI applications, the logic may be in terms of continuously update
 fields according to other fields; objects constructed from classes from
 the previous chapter, aim to be the logic layer to certain UI applications.
 Many times, UI application observe fieldsâ€™ change events, once a value
 is changed, dependant fields are calculated and presented.
 The fields change events feed reactive variables (as observable variables),
 and the fields updates are from subscribing to reactive variables (as latent
 variables).
 
\end_layout

\begin_layout Section
Operators and Assigments
\end_layout

\begin_layout Standard
Operators and assigments are two elements type connecting reactive variables
 between each other.
 For example (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Formula"
plural "false"
caps "false"
noprefix "false"

\end_inset

), in the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

 over the reactive variables A, B and C, + is an operator connecting B and
 C, and := is an assigment connecting 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+C
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (1,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (3,7) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus) at (2,5) {+}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (2,3) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,1) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Equal) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matrix[row sep=0.5cm]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

  
\backslash
node at (0.2,0.2) {B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x0) at (0.8,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x0) at (2,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x0) at (3,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x0) at (4.5,0) {2};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

   
\backslash
node at (0.2,0.2) {C};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x1) at (1.25,0) {2};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (1x1) at (3.75,0) {1};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x1) at (5.5,0) {6};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[box,minimum width=6.5cm] (op) {Plus};
\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
draw [time] (0,0) -- (6.5,0);
\end_layout

\begin_layout Plain Layout

    
\backslash
node at (0.2,0.2) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (0x2) at (1.25,0) {3};
\end_layout

\begin_layout Plain Layout

   
\backslash
node[marble,circle] (1x2) at (2,0) {7};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (2x2) at (3,0) {5};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (3x2) at (3.75,0) {4};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (4x2) at (4.5,0) {3};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[marble,circle] (5x2) at (5.5,0) {8};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x0) -- (0x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x0) -- (1x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x0) -- (2x0|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (3x0) -- (3x0|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (0x1) -- (0x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (1x1) -- (1x1|-op.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw [fdash] (2x1) -- (2x1|-op.north);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (0x2) -- (0x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (1x2) -- (1x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (2x2) -- (2x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (3x2) -- (3x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (4x2) -- (4x2|-op.south);
\end_layout

\begin_layout Plain Layout


\backslash
draw [rdash] (5x2) -- (5x2|-op.south);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Formula"

\end_inset

Formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

 over reactive variables A, B and C
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Operator is a lifted function, such that a function over values are lifted
 to being over reactive variables: the constructed expression continously
 reflects the varying value calculated from the reactive variables.
 Similary, an assigment over reactive variables would be a lifted assigment,
 such that an assigned reactive variable should reflect the assigned expression
 continuously.
 
\end_layout

\begin_layout Standard
An operator, under the hood, tracks its input values from the inputs streams
 it is subscribed to, calculating and 
\emph on
deciding
\emph default
 what values to notify its subscribers; some inputs might be redundant updates
 or with an incorrect order due to glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Reactive variables can be assigned (and also get input) ignoring already
 existed assigments.
 Furthermore, there might recursions leading to cycles in the dependancy
 graph.
 Consequently under the hood, an assigment is a bit like operators: it provides
 to its subscribers 
\emph on
a single values stream based on several values streams
\emph default
 which it is subscribed to, while
\emph on
 ignoring redundant updates
\emph default
.
\end_layout

\begin_layout Standard
The assigment can be formulated as a 
\emph on
merge
\emph default
 operation over streams.
 Conceptually it reminds situations when several devices sample a single
 real-world variable; and the whole streams of samples would contribute
 to inferre one single stream.
 Similary, several assigments produce several streams of samples, claiming
 what the variable's value is over time.
 The reactive variable is subscribed to each of them, and merge the input
 values into one stream representing its value over time.
\end_layout

\end_body
\end_document
