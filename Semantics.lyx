#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass openu-thesis
\begin_preamble
%\usepackage[usenames,dvipsnames]{color}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tocloft}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{pgf-umlsd}
\usepackage{algorithm,algpseudocode}
\usepackage{listings}
\lstset{numbers=left, numberfirstline=true, firstnumber=1, stepnumber=1}
\usepackage[section]{placeins}
\usetikzlibrary{positioning,arrows,arrows.meta}
\lstset{%
  breaklines=true,
  breakatwhitespace=true,
   moredelim=[is][\underbar]{_}{_}
}
\usepackage{tikz,rxmarbles}
\usetikzlibrary[arrows,shapes,positioning,matrix]
\tikzset{pair/.style={draw,rectangle,minimum height=1.5cm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reactive Variables Semantics
\end_layout

\begin_layout Standard
We formulate semantics to reactive variables to conform also to RIVars.
 RIVars add constraints to the implementation of reactive variables: First,
 no centerlized management are alowed, because objects interact directly
 by messages and events.
 Second, as previously presented, reactive variables should support any
 dependancy graph, including constructions such as cycles.
\end_layout

\begin_layout Section
Reactive Variables
\end_layout

\begin_layout Standard
A reactive variable, under the hood, is an 
\emph on
events stream
\emph default
, an observable emitting values to subscribers 
\begin_inset CommandInset citation
LatexCommand cite
key "meijer2012your"
literal "false"

\end_inset

, based on the 
\emph on
observer
\emph default
 and 
\emph on
iterator
\emph default
 patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "gamma1995design"
literal "false"

\end_inset

.
 This makes the management decenterlized and defines the reactive variable
 abstraction in the low level.
 In the high level, reactive variables are the typical 
\emph on
continuous
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elliott2009push"
literal "false"

\end_inset

; they are used to define variables dependencies in the problem domain,
 independant of time.
\end_layout

\begin_layout Standard
The lower level abstraction does exist, because even when a reactive variable
 represent a real world variable in high level, in computers reactive variable's
 actual values cannot continuously given.
 For example, temperature might be represented by a reactive variable depending
 on an actualy stream of discrete events, being sampled by a thermometer.
\end_layout

\begin_layout Standard
Similary in UI applications, the logic may be in terms of continuously update
 fields according to other fields; objects constructed from classes from
 the previous chapter, aim to be the logic layer to certain UI applications.
 Many times, UI application observe fieldsâ€™ change events, once a value
 is changed, dependant fields are calculated and presented.
 The fields change events feed reactive variables (as observable variables),
 and the fields updates are from subscribing to reactive variables (as latent
 variables).
 
\end_layout

\begin_layout Section
Operators and Assigments
\end_layout

\begin_layout Standard
Operators and assigments are two elements type connecting reactive variables
 between each other.
 For example, in the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

A:=B+C
\end_layout

\end_inset

 over the reactive variables A, B and C, + is an operator connecting B and
 C, and := is an assigment connecting 
\begin_inset ERT
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to the expression 
\begin_inset ERT
status open

\begin_layout Plain Layout

B+C
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}  
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (B) at (1,7) {B};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (C) at (3,7) {C};
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=rectangle,draw=black] (Plus) at (2,5) {+}; 
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=diamond,draw=black] (Equal) at (2,3) {=};     
\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (A) at (2,1) {A};     
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (B) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (C) edge  (Plus);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Plus) edge  (Equal);
\end_layout

\begin_layout Plain Layout


\backslash
path[-{Triangle[scale=1]}] (Equal) edge  (A);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Operator is a lifted function, such that a function over values are lifted
 to being over reactive variables: the constructed expression continously
 reflects the varying value calculated from the reactive variables.
 Similary, an assigment over reactive variables would be 
\emph on
lifted
\emph default
 assigment, such that an assigned reactive variable should reflect the assigned
 expression continuously.
 
\end_layout

\begin_layout Standard
An operator, under the hood, tracks its input values from the inputs streams
 it is subscribed to, calculating and 
\emph on
deciding
\emph default
 what values to notify its subscribers; some inputs might be redundant updates
 or with an incorrect order due to glitches 
\begin_inset CommandInset citation
LatexCommand cite
key "margara2018semantics"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Reactive variables can be assigned (and also get input) ignoring already
 existed assigments.
 Furthermore, there might recursions leading to cycles in the dependancy
 graph.
 Consequently under the hood, an assigment is a bit like operators: it provides
 to its subscribers 
\emph on
a single values stream based on several values streams
\emph default
 which it is subscribed to, while
\emph on
 ignoring redundant updates
\emph default
.
\end_layout

\begin_layout Standard
The assigment can be formulated as a 
\emph on
merge
\emph default
 operation over streams.
 Conceptually it reminds situations when several devices sample a single
 real-world variable ; and the whole streams of samples would contribute
 to inferre one single stream.
 Similary, several assigments produce several streams of samples, claiming
 what the variable's value is over time.
 The reactive variable is subscribed to each of them, and merge the input
 values into one stream representing its value over time.
\end_layout

\begin_layout Section
Change Propogation
\end_layout

\begin_layout Standard
It might be that an external input conflicts with the variables' values.
 However, in the proposed semantics the new values are adopted.
 It is expected that they would propogate changes overriding old values,
 then following the propogation process the variables' values become consistent
 again.
\end_layout

\begin_layout Standard
Specificaly, an assigment trigger changes from either of the assigned expression
s ignoring non-
\emph on
new
\emph default
 values.
 This strategy has in common with glitch handling: any value calculated
 from both 
\emph on
new
\emph default
 values with an 
\emph on
old
\emph default
 values are ignored.
 However, with the stream model, time is modeled 
\emph on
implicity
\emph default
 be 
\emph on
ordering
\emph default
 the items.
 The merge operation should do the merge by providing the values over time
 according to the
\emph on
 time
\emph default
; also the glitch handling: the values must have an order.
 
\end_layout

\begin_layout Standard
The order would derive from the sequence of events.
 It would conform the guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "foust2015generating"
literal "false"

\end_inset

: 
\emph on
the same sequence of events produces the same results, regardless of the
 timing of those events
\emph default
.
 This is a proposed option to satisfy the significant FRP 
\emph on
referential transparency
\emph default
 property 
\begin_inset CommandInset citation
LatexCommand cite
key "blackheath2016functional"
literal "false"

\end_inset

: 
\emph on
the same input will produce consistently the same output
\emph default
.
\end_layout

\end_body
\end_document
